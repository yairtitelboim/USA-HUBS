{"ast":null,"code":"// index.ts\nimport { bbox as turfBBox } from \"@turf/bbox\";\nimport { getCoords, getGeom } from \"@turf/invariant\";\nimport { polygon, multiPolygon, lineString } from \"@turf/helpers\";\nimport { clone } from \"@turf/clone\";\nfunction lineToPolygon(lines, options = {}) {\n  var _a, _b, _c;\n  var properties = options.properties;\n  var autoComplete = (_a = options.autoComplete) != null ? _a : true;\n  var orderCoords = (_b = options.orderCoords) != null ? _b : true;\n  var mutate = (_c = options.mutate) != null ? _c : false;\n  if (!mutate) {\n    lines = clone(lines);\n  }\n  switch (lines.type) {\n    case \"FeatureCollection\":\n      var coords = [];\n      lines.features.forEach(function (line) {\n        coords.push(getCoords(lineStringToPolygon(line, {}, autoComplete, orderCoords)));\n      });\n      return multiPolygon(coords, properties);\n    default:\n      return lineStringToPolygon(lines, properties, autoComplete, orderCoords);\n  }\n}\nfunction lineStringToPolygon(line, properties, autoComplete, orderCoords) {\n  properties = properties ? properties : line.type === \"Feature\" ? line.properties : {};\n  var geom = getGeom(line);\n  var coords = geom.coordinates;\n  var type = geom.type;\n  if (!coords.length) throw new Error(\"line must contain coordinates\");\n  switch (type) {\n    case \"LineString\":\n      if (autoComplete) coords = autoCompleteCoords(coords);\n      return polygon([coords], properties);\n    case \"MultiLineString\":\n      var multiCoords = [];\n      var largestArea = 0;\n      coords.forEach(function (coord) {\n        if (autoComplete) coord = autoCompleteCoords(coord);\n        if (orderCoords) {\n          var area = calculateArea(turfBBox(lineString(coord)));\n          if (area > largestArea) {\n            multiCoords.unshift(coord);\n            largestArea = area;\n          } else multiCoords.push(coord);\n        } else {\n          multiCoords.push(coord);\n        }\n      });\n      return polygon(multiCoords, properties);\n    default:\n      throw new Error(\"geometry type \" + type + \" is not supported\");\n  }\n}\nfunction autoCompleteCoords(coords) {\n  var first = coords[0];\n  var x1 = first[0];\n  var y1 = first[1];\n  var last = coords[coords.length - 1];\n  var x2 = last[0];\n  var y2 = last[1];\n  if (x1 !== x2 || y1 !== y2) {\n    coords.push(first);\n  }\n  return coords;\n}\nfunction calculateArea(bbox) {\n  var west = bbox[0];\n  var south = bbox[1];\n  var east = bbox[2];\n  var north = bbox[3];\n  return Math.abs(west - east) * Math.abs(south - north);\n}\nvar turf_line_to_polygon_default = lineToPolygon;\nexport { turf_line_to_polygon_default as default, lineToPolygon };","map":{"version":3,"names":["bbox","turfBBox","getCoords","getGeom","polygon","multiPolygon","lineString","clone","lineToPolygon","lines","options","_a","_b","_c","properties","autoComplete","orderCoords","mutate","type","coords","features","forEach","line","push","lineStringToPolygon","geom","coordinates","length","Error","autoCompleteCoords","multiCoords","largestArea","coord","area","calculateArea","unshift","first","x1","y1","last","x2","y2","west","south","east","north","Math","abs","turf_line_to_polygon_default"],"sources":["/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/line-to-polygon/index.ts"],"sourcesContent":["import {\n  Feature,\n  FeatureCollection,\n  MultiLineString,\n  LineString,\n  GeoJsonProperties,\n  BBox,\n  Position,\n} from \"geojson\";\nimport { bbox as turfBBox } from \"@turf/bbox\";\nimport { getCoords, getGeom } from \"@turf/invariant\";\nimport { polygon, multiPolygon, lineString } from \"@turf/helpers\";\nimport { clone } from \"@turf/clone\";\n\n/**\n * Converts (Multi)LineString(s) to Polygon(s).\n *\n * @function\n * @param {FeatureCollection|Feature<LineString|MultiLineString>} lines Features to convert\n * @param {Object} [options={}] Optional parameters\n * @param {Object} [options.properties={}] translates GeoJSON properties to Feature\n * @param {boolean} [options.autoComplete=true] auto complete linestrings (matches first & last coordinates)\n * @param {boolean} [options.orderCoords=true] sorts linestrings to place outer ring at the first position of the coordinates\n * @param {boolean} [options.mutate=false] mutate the original linestring using autoComplete (matches first & last coordinates)\n * @returns {Feature<Polygon|MultiPolygon>} converted to Polygons\n * @example\n * var line = turf.lineString([[125, -30], [145, -30], [145, -20], [125, -20], [125, -30]]);\n *\n * var polygon = turf.lineToPolygon(line);\n *\n * //addToMap\n * var addToMap = [polygon];\n */\nfunction lineToPolygon<G extends LineString | MultiLineString>(\n  lines: Feature<G> | FeatureCollection<G> | G,\n  options: {\n    properties?: GeoJsonProperties;\n    autoComplete?: boolean;\n    orderCoords?: boolean;\n    mutate?: boolean;\n  } = {}\n) {\n  // Optional parameters\n  var properties = options.properties;\n  var autoComplete = options.autoComplete ?? true;\n  var orderCoords = options.orderCoords ?? true;\n  var mutate = options.mutate ?? false;\n\n  if (!mutate) {\n    lines = clone(lines);\n  }\n\n  switch (lines.type) {\n    case \"FeatureCollection\":\n      var coords: number[][][][] = [];\n      lines.features.forEach(function (line) {\n        coords.push(\n          getCoords(lineStringToPolygon(line, {}, autoComplete, orderCoords))\n        );\n      });\n      return multiPolygon(coords, properties);\n    default:\n      return lineStringToPolygon(lines, properties, autoComplete, orderCoords);\n  }\n}\n\n/**\n * LineString to Polygon\n *\n * @private\n * @param {Feature<LineString|MultiLineString>} line line\n * @param {Object} [properties] translates GeoJSON properties to Feature\n * @param {boolean} [autoComplete=true] auto complete linestrings\n * @param {boolean} [orderCoords=true] sorts linestrings to place outer ring at the first position of the coordinates\n * @returns {Feature<Polygon>} line converted to Polygon\n */\nfunction lineStringToPolygon<G extends LineString | MultiLineString>(\n  line: Feature<G> | G,\n  properties: GeoJsonProperties | undefined,\n  autoComplete: boolean,\n  orderCoords: boolean\n) {\n  properties = properties\n    ? properties\n    : line.type === \"Feature\"\n      ? line.properties\n      : {};\n  var geom = getGeom(line);\n  var coords: Position[] | Position[][] = geom.coordinates;\n  var type = geom.type;\n\n  if (!coords.length) throw new Error(\"line must contain coordinates\");\n\n  switch (type) {\n    case \"LineString\":\n      if (autoComplete) coords = autoCompleteCoords(coords as Position[]);\n      return polygon([coords as Position[]], properties);\n    case \"MultiLineString\":\n      var multiCoords: number[][][] = [];\n      var largestArea = 0;\n\n      (coords as Position[][]).forEach(function (coord) {\n        if (autoComplete) coord = autoCompleteCoords(coord);\n\n        // Largest LineString to be placed in the first position of the coordinates array\n        if (orderCoords) {\n          var area = calculateArea(turfBBox(lineString(coord)));\n          if (area > largestArea) {\n            multiCoords.unshift(coord);\n            largestArea = area;\n          } else multiCoords.push(coord);\n        } else {\n          multiCoords.push(coord);\n        }\n      });\n      return polygon(multiCoords, properties);\n    default:\n      throw new Error(\"geometry type \" + type + \" is not supported\");\n  }\n}\n\n/**\n * Auto Complete Coords - matches first & last coordinates\n *\n * @private\n * @param {Array<Array<number>>} coords Coordinates\n * @returns {Array<Array<number>>} auto completed coordinates\n */\nfunction autoCompleteCoords(coords: Position[]) {\n  var first = coords[0];\n  var x1 = first[0];\n  var y1 = first[1];\n  var last = coords[coords.length - 1];\n  var x2 = last[0];\n  var y2 = last[1];\n  if (x1 !== x2 || y1 !== y2) {\n    coords.push(first);\n  }\n  return coords;\n}\n\n/**\n * area - quick approximate area calculation (used to sort)\n *\n * @private\n * @param {Array<number>} bbox BBox [west, south, east, north]\n * @returns {number} very quick area calculation\n */\nfunction calculateArea(bbox: BBox) {\n  var west = bbox[0];\n  var south = bbox[1];\n  var east = bbox[2];\n  var north = bbox[3];\n  return Math.abs(west - east) * Math.abs(south - north);\n}\n\nexport { lineToPolygon };\nexport default lineToPolygon;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}