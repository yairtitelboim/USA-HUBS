{"ast":null,"code":"// index.ts\nimport { booleanPointInPolygon } from \"@turf/boolean-point-in-polygon\";\nimport { lineIntersect } from \"@turf/line-intersect\";\nimport { flattenEach } from \"@turf/meta\";\nimport { polygonToLine } from \"@turf/polygon-to-line\";\nfunction booleanDisjoint(feature1, feature2, {\n  ignoreSelfIntersections = true\n} = {\n  ignoreSelfIntersections: true\n}) {\n  let bool = true;\n  flattenEach(feature1, flatten1 => {\n    flattenEach(feature2, flatten2 => {\n      if (bool === false) {\n        return false;\n      }\n      bool = disjoint(flatten1.geometry, flatten2.geometry, ignoreSelfIntersections);\n    });\n  });\n  return bool;\n}\nfunction disjoint(geom1, geom2, ignoreSelfIntersections) {\n  switch (geom1.type) {\n    case \"Point\":\n      switch (geom2.type) {\n        case \"Point\":\n          return !compareCoords(geom1.coordinates, geom2.coordinates);\n        case \"LineString\":\n          return !isPointOnLine(geom2, geom1);\n        case \"Polygon\":\n          return !booleanPointInPolygon(geom1, geom2);\n      }\n      break;\n    case \"LineString\":\n      switch (geom2.type) {\n        case \"Point\":\n          return !isPointOnLine(geom1, geom2);\n        case \"LineString\":\n          return !isLineOnLine(geom1, geom2, ignoreSelfIntersections);\n        case \"Polygon\":\n          return !isLineInPoly(geom2, geom1, ignoreSelfIntersections);\n      }\n      break;\n    case \"Polygon\":\n      switch (geom2.type) {\n        case \"Point\":\n          return !booleanPointInPolygon(geom2, geom1);\n        case \"LineString\":\n          return !isLineInPoly(geom1, geom2, ignoreSelfIntersections);\n        case \"Polygon\":\n          return !isPolyInPoly(geom2, geom1, ignoreSelfIntersections);\n      }\n  }\n  return false;\n}\nfunction isPointOnLine(lineString, pt) {\n  for (let i = 0; i < lineString.coordinates.length - 1; i++) {\n    if (isPointOnLineSegment(lineString.coordinates[i], lineString.coordinates[i + 1], pt.coordinates)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction isLineOnLine(lineString1, lineString2, ignoreSelfIntersections) {\n  const doLinesIntersect = lineIntersect(lineString1, lineString2, {\n    ignoreSelfIntersections\n  });\n  if (doLinesIntersect.features.length > 0) {\n    return true;\n  }\n  return false;\n}\nfunction isLineInPoly(polygon, lineString, ignoreSelfIntersections) {\n  for (const coord of lineString.coordinates) {\n    if (booleanPointInPolygon(coord, polygon)) {\n      return true;\n    }\n  }\n  const doLinesIntersect = lineIntersect(lineString, polygonToLine(polygon), {\n    ignoreSelfIntersections\n  });\n  if (doLinesIntersect.features.length > 0) {\n    return true;\n  }\n  return false;\n}\nfunction isPolyInPoly(feature1, feature2, ignoreSelfIntersections) {\n  for (const coord1 of feature1.coordinates[0]) {\n    if (booleanPointInPolygon(coord1, feature2)) {\n      return true;\n    }\n  }\n  for (const coord2 of feature2.coordinates[0]) {\n    if (booleanPointInPolygon(coord2, feature1)) {\n      return true;\n    }\n  }\n  const doLinesIntersect = lineIntersect(polygonToLine(feature1), polygonToLine(feature2), {\n    ignoreSelfIntersections\n  });\n  if (doLinesIntersect.features.length > 0) {\n    return true;\n  }\n  return false;\n}\nfunction isPointOnLineSegment(lineSegmentStart, lineSegmentEnd, pt) {\n  const dxc = pt[0] - lineSegmentStart[0];\n  const dyc = pt[1] - lineSegmentStart[1];\n  const dxl = lineSegmentEnd[0] - lineSegmentStart[0];\n  const dyl = lineSegmentEnd[1] - lineSegmentStart[1];\n  const cross = dxc * dyl - dyc * dxl;\n  if (cross !== 0) {\n    return false;\n  }\n  if (Math.abs(dxl) >= Math.abs(dyl)) {\n    if (dxl > 0) {\n      return lineSegmentStart[0] <= pt[0] && pt[0] <= lineSegmentEnd[0];\n    } else {\n      return lineSegmentEnd[0] <= pt[0] && pt[0] <= lineSegmentStart[0];\n    }\n  } else if (dyl > 0) {\n    return lineSegmentStart[1] <= pt[1] && pt[1] <= lineSegmentEnd[1];\n  } else {\n    return lineSegmentEnd[1] <= pt[1] && pt[1] <= lineSegmentStart[1];\n  }\n}\nfunction compareCoords(pair1, pair2) {\n  return pair1[0] === pair2[0] && pair1[1] === pair2[1];\n}\nvar turf_boolean_disjoint_default = booleanDisjoint;\nexport { booleanDisjoint, turf_boolean_disjoint_default as default };","map":{"version":3,"names":["booleanPointInPolygon","lineIntersect","flattenEach","polygonToLine","booleanDisjoint","feature1","feature2","ignoreSelfIntersections","bool","flatten1","flatten2","disjoint","geometry","geom1","geom2","type","compareCoords","coordinates","isPointOnLine","isLineOnLine","isLineInPoly","isPolyInPoly","lineString","pt","i","length","isPointOnLineSegment","lineString1","lineString2","doLinesIntersect","features","polygon","coord","coord1","coord2","lineSegmentStart","lineSegmentEnd","dxc","dyc","dxl","dyl","cross","Math","abs","pair1","pair2","turf_boolean_disjoint_default"],"sources":["/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/boolean-disjoint/index.ts"],"sourcesContent":["import {\n  Feature,\n  Geometry,\n  LineString,\n  Point,\n  Polygon,\n  Position,\n} from \"geojson\";\nimport { booleanPointInPolygon } from \"@turf/boolean-point-in-polygon\";\nimport { lineIntersect } from \"@turf/line-intersect\";\nimport { flattenEach } from \"@turf/meta\";\nimport { polygonToLine } from \"@turf/polygon-to-line\";\n\n/**\n * Boolean-disjoint returns (TRUE) if the intersection of the two geometries is an empty set.\n *\n * @function\n * @param {Geometry|Feature<any>} feature1 GeoJSON Feature or Geometry\n * @param {Geometry|Feature<any>} feature2 GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.ignoreSelfIntersections=true] ignore self-intersections on input features\n * @returns {boolean} true if the intersection is an empty set, false otherwise\n * @example\n * var point = turf.point([2, 2]);\n * var line = turf.lineString([[1, 1], [1, 2], [1, 3], [1, 4]]);\n *\n * turf.booleanDisjoint(line, point);\n * //=true\n */\nfunction booleanDisjoint(\n  feature1: Feature<any> | Geometry,\n  feature2: Feature<any> | Geometry,\n  {\n    ignoreSelfIntersections = true,\n  }: {\n    ignoreSelfIntersections?: boolean;\n  } = { ignoreSelfIntersections: true }\n): boolean {\n  let bool = true;\n  flattenEach(feature1, (flatten1) => {\n    flattenEach(feature2, (flatten2) => {\n      if (bool === false) {\n        return false;\n      }\n      bool = disjoint(\n        flatten1.geometry,\n        flatten2.geometry,\n        ignoreSelfIntersections\n      );\n    });\n  });\n  return bool;\n}\n\n/**\n * Disjoint operation for simple Geometries (Point/LineString/Polygon)\n *\n * @private\n * @param {Geometry<any>} geom1 GeoJSON Geometry\n * @param {Geometry<any>} geom2 GeoJSON Geometry\n * @param {boolean} ignoreSelfIntersections ignore self-intersections on input features\n * @returns {boolean} true if disjoint, false otherwise\n */\nfunction disjoint(geom1: any, geom2: any, ignoreSelfIntersections: boolean) {\n  switch (geom1.type) {\n    case \"Point\":\n      switch (geom2.type) {\n        case \"Point\":\n          return !compareCoords(geom1.coordinates, geom2.coordinates);\n        case \"LineString\":\n          return !isPointOnLine(geom2, geom1);\n        case \"Polygon\":\n          return !booleanPointInPolygon(geom1, geom2);\n      }\n      /* istanbul ignore next */\n      break;\n    case \"LineString\":\n      switch (geom2.type) {\n        case \"Point\":\n          return !isPointOnLine(geom1, geom2);\n        case \"LineString\":\n          return !isLineOnLine(geom1, geom2, ignoreSelfIntersections);\n        case \"Polygon\":\n          return !isLineInPoly(geom2, geom1, ignoreSelfIntersections);\n      }\n      /* istanbul ignore next */\n      break;\n    case \"Polygon\":\n      switch (geom2.type) {\n        case \"Point\":\n          return !booleanPointInPolygon(geom2, geom1);\n        case \"LineString\":\n          return !isLineInPoly(geom1, geom2, ignoreSelfIntersections);\n        case \"Polygon\":\n          return !isPolyInPoly(geom2, geom1, ignoreSelfIntersections);\n      }\n  }\n  return false;\n}\n\n// http://stackoverflow.com/a/11908158/1979085\nfunction isPointOnLine(lineString: LineString, pt: Point) {\n  for (let i = 0; i < lineString.coordinates.length - 1; i++) {\n    if (\n      isPointOnLineSegment(\n        lineString.coordinates[i],\n        lineString.coordinates[i + 1],\n        pt.coordinates\n      )\n    ) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction isLineOnLine(\n  lineString1: LineString,\n  lineString2: LineString,\n  ignoreSelfIntersections: boolean\n) {\n  const doLinesIntersect = lineIntersect(lineString1, lineString2, {\n    ignoreSelfIntersections,\n  });\n  if (doLinesIntersect.features.length > 0) {\n    return true;\n  }\n  return false;\n}\n\nfunction isLineInPoly(\n  polygon: Polygon,\n  lineString: LineString,\n  ignoreSelfIntersections: boolean\n) {\n  for (const coord of lineString.coordinates) {\n    if (booleanPointInPolygon(coord, polygon)) {\n      return true;\n    }\n  }\n  const doLinesIntersect = lineIntersect(lineString, polygonToLine(polygon), {\n    ignoreSelfIntersections,\n  });\n  if (doLinesIntersect.features.length > 0) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Is Polygon (geom1) in Polygon (geom2)\n * Only takes into account outer rings\n * See http://stackoverflow.com/a/4833823/1979085\n *\n * @private\n * @param {Geometry|Feature<Polygon>} feature1 Polygon1\n * @param {Geometry|Feature<Polygon>} feature2 Polygon2\n * @param {boolean} ignoreSelfIntersections ignore self-intersections on input features\n * @returns {boolean} true if geom1 is in geom2, false otherwise\n */\nfunction isPolyInPoly(\n  feature1: Polygon,\n  feature2: Polygon,\n  ignoreSelfIntersections: boolean\n) {\n  for (const coord1 of feature1.coordinates[0]) {\n    if (booleanPointInPolygon(coord1, feature2)) {\n      return true;\n    }\n  }\n  for (const coord2 of feature2.coordinates[0]) {\n    if (booleanPointInPolygon(coord2, feature1)) {\n      return true;\n    }\n  }\n  const doLinesIntersect = lineIntersect(\n    polygonToLine(feature1),\n    polygonToLine(feature2),\n    { ignoreSelfIntersections }\n  );\n  if (doLinesIntersect.features.length > 0) {\n    return true;\n  }\n  return false;\n}\n\nfunction isPointOnLineSegment(\n  lineSegmentStart: Position,\n  lineSegmentEnd: Position,\n  pt: Position\n) {\n  const dxc = pt[0] - lineSegmentStart[0];\n  const dyc = pt[1] - lineSegmentStart[1];\n  const dxl = lineSegmentEnd[0] - lineSegmentStart[0];\n  const dyl = lineSegmentEnd[1] - lineSegmentStart[1];\n  const cross = dxc * dyl - dyc * dxl;\n  if (cross !== 0) {\n    return false;\n  }\n  if (Math.abs(dxl) >= Math.abs(dyl)) {\n    if (dxl > 0) {\n      return lineSegmentStart[0] <= pt[0] && pt[0] <= lineSegmentEnd[0];\n    } else {\n      return lineSegmentEnd[0] <= pt[0] && pt[0] <= lineSegmentStart[0];\n    }\n  } else if (dyl > 0) {\n    return lineSegmentStart[1] <= pt[1] && pt[1] <= lineSegmentEnd[1];\n  } else {\n    return lineSegmentEnd[1] <= pt[1] && pt[1] <= lineSegmentStart[1];\n  }\n}\n\n/**\n * compareCoords\n *\n * @private\n * @param {Position} pair1 point [x,y]\n * @param {Position} pair2 point [x,y]\n * @returns {boolean} true if coord pairs match, false otherwise\n */\nfunction compareCoords(pair1: Position, pair2: Position) {\n  return pair1[0] === pair2[0] && pair1[1] === pair2[1];\n}\n\nexport { booleanDisjoint };\nexport default booleanDisjoint;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}