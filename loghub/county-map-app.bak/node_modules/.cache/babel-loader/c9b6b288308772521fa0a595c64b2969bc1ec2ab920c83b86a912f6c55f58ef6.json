{"ast":null,"code":"// index.js\nimport { center } from \"@turf/center\";\nimport jsts from \"@turf/jsts\";\nimport { geomEach, featureEach } from \"@turf/meta\";\nimport { geoAzimuthalEquidistant } from \"d3-geo\";\nimport { feature, featureCollection, radiansToLength, lengthToRadians, earthRadius } from \"@turf/helpers\";\nvar {\n  BufferOp,\n  GeoJSONReader,\n  GeoJSONWriter\n} = jsts;\nfunction buffer(geojson, radius, options) {\n  options = options || {};\n  var units = options.units || \"kilometers\";\n  var steps = options.steps || 8;\n  if (!geojson) throw new Error(\"geojson is required\");\n  if (typeof options !== \"object\") throw new Error(\"options must be an object\");\n  if (typeof steps !== \"number\") throw new Error(\"steps must be an number\");\n  if (radius === void 0) throw new Error(\"radius is required\");\n  if (steps <= 0) throw new Error(\"steps must be greater than 0\");\n  var results = [];\n  switch (geojson.type) {\n    case \"GeometryCollection\":\n      geomEach(geojson, function (geometry) {\n        var buffered = bufferFeature(geometry, radius, units, steps);\n        if (buffered) results.push(buffered);\n      });\n      return featureCollection(results);\n    case \"FeatureCollection\":\n      featureEach(geojson, function (feature2) {\n        var multiBuffered = bufferFeature(feature2, radius, units, steps);\n        if (multiBuffered) {\n          featureEach(multiBuffered, function (buffered) {\n            if (buffered) results.push(buffered);\n          });\n        }\n      });\n      return featureCollection(results);\n  }\n  return bufferFeature(geojson, radius, units, steps);\n}\nfunction bufferFeature(geojson, radius, units, steps) {\n  var properties = geojson.properties || {};\n  var geometry = geojson.type === \"Feature\" ? geojson.geometry : geojson;\n  if (geometry.type === \"GeometryCollection\") {\n    var results = [];\n    geomEach(geojson, function (geometry2) {\n      var buffered2 = bufferFeature(geometry2, radius, units, steps);\n      if (buffered2) results.push(buffered2);\n    });\n    return featureCollection(results);\n  }\n  var projection = defineProjection(geometry);\n  var projected = {\n    type: geometry.type,\n    coordinates: projectCoords(geometry.coordinates, projection)\n  };\n  var reader = new GeoJSONReader();\n  var geom = reader.read(projected);\n  var distance = radiansToLength(lengthToRadians(radius, units), \"meters\");\n  var buffered = BufferOp.bufferOp(geom, distance, steps);\n  var writer = new GeoJSONWriter();\n  buffered = writer.write(buffered);\n  if (coordsIsNaN(buffered.coordinates)) return void 0;\n  var result = {\n    type: buffered.type,\n    coordinates: unprojectCoords(buffered.coordinates, projection)\n  };\n  return feature(result, properties);\n}\nfunction coordsIsNaN(coords) {\n  if (Array.isArray(coords[0])) return coordsIsNaN(coords[0]);\n  return isNaN(coords[0]);\n}\nfunction projectCoords(coords, proj) {\n  if (typeof coords[0] !== \"object\") return proj(coords);\n  return coords.map(function (coord) {\n    return projectCoords(coord, proj);\n  });\n}\nfunction unprojectCoords(coords, proj) {\n  if (typeof coords[0] !== \"object\") return proj.invert(coords);\n  return coords.map(function (coord) {\n    return unprojectCoords(coord, proj);\n  });\n}\nfunction defineProjection(geojson) {\n  var coords = center(geojson).geometry.coordinates;\n  var rotation = [-coords[0], -coords[1]];\n  return geoAzimuthalEquidistant().rotate(rotation).scale(earthRadius);\n}\nvar turf_buffer_default = buffer;\nexport { buffer, turf_buffer_default as default };","map":{"version":3,"names":["center","jsts","geomEach","featureEach","geoAzimuthalEquidistant","feature","featureCollection","radiansToLength","lengthToRadians","earthRadius","BufferOp","GeoJSONReader","GeoJSONWriter","buffer","geojson","radius","options","units","steps","Error","results","type","geometry","buffered","bufferFeature","push","feature2","multiBuffered","properties","geometry2","buffered2","projection","defineProjection","projected","coordinates","projectCoords","reader","geom","read","distance","bufferOp","writer","write","coordsIsNaN","result","unprojectCoords","coords","Array","isArray","isNaN","proj","map","coord","invert","rotation","rotate","scale","turf_buffer_default"],"sources":["/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/buffer/index.js"],"sourcesContent":["import { center } from \"@turf/center\";\nimport jsts from \"@turf/jsts\";\nimport { geomEach, featureEach } from \"@turf/meta\";\nimport { geoAzimuthalEquidistant } from \"d3-geo\";\nimport {\n  feature,\n  featureCollection,\n  radiansToLength,\n  lengthToRadians,\n  earthRadius,\n} from \"@turf/helpers\";\n\nconst { BufferOp, GeoJSONReader, GeoJSONWriter } = jsts;\n\n/**\n * Calculates a buffer for input features for a given radius. Units supported are miles, kilometers, and degrees.\n *\n * When using a negative radius, the resulting geometry may be invalid if\n * it's too small compared to the radius magnitude. If the input is a\n * FeatureCollection, only valid members will be returned in the output\n * FeatureCollection - i.e., the output collection may have fewer members than\n * the input, or even be empty.\n *\n * @function\n * @param {FeatureCollection|Geometry|Feature<any>} geojson input to be buffered\n * @param {number} radius distance to draw the buffer (negative values are allowed)\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units=\"kilometers\"] any of the options supported by turf units\n * @param {number} [options.steps=8] number of steps\n * @returns {FeatureCollection|Feature<Polygon|MultiPolygon>|undefined} buffered features\n * @example\n * var point = turf.point([-90.548630, 14.616599]);\n * var buffered = turf.buffer(point, 500, {units: 'miles'});\n *\n * //addToMap\n * var addToMap = [point, buffered]\n */\nfunction buffer(geojson, radius, options) {\n  // Optional params\n  options = options || {};\n\n  // use user supplied options or default values\n  var units = options.units || \"kilometers\";\n  var steps = options.steps || 8;\n\n  // validation\n  if (!geojson) throw new Error(\"geojson is required\");\n  if (typeof options !== \"object\") throw new Error(\"options must be an object\");\n  if (typeof steps !== \"number\") throw new Error(\"steps must be an number\");\n\n  // Allow negative buffers (\"erosion\") or zero-sized buffers (\"repair geometry\")\n  if (radius === undefined) throw new Error(\"radius is required\");\n  if (steps <= 0) throw new Error(\"steps must be greater than 0\");\n\n  var results = [];\n  switch (geojson.type) {\n    case \"GeometryCollection\":\n      geomEach(geojson, function (geometry) {\n        var buffered = bufferFeature(geometry, radius, units, steps);\n        if (buffered) results.push(buffered);\n      });\n      return featureCollection(results);\n    case \"FeatureCollection\":\n      featureEach(geojson, function (feature) {\n        var multiBuffered = bufferFeature(feature, radius, units, steps);\n        if (multiBuffered) {\n          featureEach(multiBuffered, function (buffered) {\n            if (buffered) results.push(buffered);\n          });\n        }\n      });\n      return featureCollection(results);\n  }\n  return bufferFeature(geojson, radius, units, steps);\n}\n\n/**\n * Buffer single Feature/Geometry\n *\n * @private\n * @param {Feature<any>} geojson input to be buffered\n * @param {number} radius distance to draw the buffer\n * @param {string} [units='kilometers'] any of the options supported by turf units\n * @param {number} [steps=8] number of steps\n * @returns {Feature<Polygon|MultiPolygon>} buffered feature\n */\nfunction bufferFeature(geojson, radius, units, steps) {\n  var properties = geojson.properties || {};\n  var geometry = geojson.type === \"Feature\" ? geojson.geometry : geojson;\n\n  // Geometry Types faster than jsts\n  if (geometry.type === \"GeometryCollection\") {\n    var results = [];\n    geomEach(geojson, function (geometry) {\n      var buffered = bufferFeature(geometry, radius, units, steps);\n      if (buffered) results.push(buffered);\n    });\n    return featureCollection(results);\n  }\n\n  // Project GeoJSON to Azimuthal Equidistant projection (convert to Meters)\n  var projection = defineProjection(geometry);\n  var projected = {\n    type: geometry.type,\n    coordinates: projectCoords(geometry.coordinates, projection),\n  };\n\n  // JSTS buffer operation\n  var reader = new GeoJSONReader();\n  var geom = reader.read(projected);\n  var distance = radiansToLength(lengthToRadians(radius, units), \"meters\");\n  var buffered = BufferOp.bufferOp(geom, distance, steps);\n  var writer = new GeoJSONWriter();\n  buffered = writer.write(buffered);\n\n  // Detect if empty geometries\n  if (coordsIsNaN(buffered.coordinates)) return undefined;\n\n  // Unproject coordinates (convert to Degrees)\n  var result = {\n    type: buffered.type,\n    coordinates: unprojectCoords(buffered.coordinates, projection),\n  };\n\n  return feature(result, properties);\n}\n\n/**\n * Coordinates isNaN\n *\n * @private\n * @param {Array<any>} coords GeoJSON Coordinates\n * @returns {boolean} if NaN exists\n */\nfunction coordsIsNaN(coords) {\n  if (Array.isArray(coords[0])) return coordsIsNaN(coords[0]);\n  return isNaN(coords[0]);\n}\n\n/**\n * Project coordinates to projection\n *\n * @private\n * @param {Array<any>} coords to project\n * @param {GeoProjection} proj D3 Geo Projection\n * @returns {Array<any>} projected coordinates\n */\nfunction projectCoords(coords, proj) {\n  if (typeof coords[0] !== \"object\") return proj(coords);\n  return coords.map(function (coord) {\n    return projectCoords(coord, proj);\n  });\n}\n\n/**\n * Un-Project coordinates to projection\n *\n * @private\n * @param {Array<any>} coords to un-project\n * @param {GeoProjection} proj D3 Geo Projection\n * @returns {Array<any>} un-projected coordinates\n */\nfunction unprojectCoords(coords, proj) {\n  if (typeof coords[0] !== \"object\") return proj.invert(coords);\n  return coords.map(function (coord) {\n    return unprojectCoords(coord, proj);\n  });\n}\n\n/**\n * Define Azimuthal Equidistant projection\n *\n * @private\n * @param {Geometry|Feature<any>} geojson Base projection on center of GeoJSON\n * @returns {GeoProjection} D3 Geo Azimuthal Equidistant Projection\n */\nfunction defineProjection(geojson) {\n  var coords = center(geojson).geometry.coordinates;\n  var rotation = [-coords[0], -coords[1]];\n  return geoAzimuthalEquidistant().rotate(rotation).scale(earthRadius);\n}\n\nexport { buffer };\nexport default buffer;\n"],"mappings":";AAAA,SAASA,MAAA,QAAc;AACvB,OAAOC,IAAA,MAAU;AACjB,SAASC,QAAA,EAAUC,WAAA,QAAmB;AACtC,SAASC,uBAAA,QAA+B;AACxC,SACEC,OAAA,EACAC,iBAAA,EACAC,eAAA,EACAC,eAAA,EACAC,WAAA,QACK;AAEP,IAAM;EAAEC,QAAA;EAAUC,aAAA;EAAeC;AAAc,IAAIX,IAAA;AAyBnD,SAASY,OAAOC,OAAA,EAASC,MAAA,EAAQC,OAAA,EAAS;EAExCA,OAAA,GAAUA,OAAA,IAAW,CAAC;EAGtB,IAAIC,KAAA,GAAQD,OAAA,CAAQC,KAAA,IAAS;EAC7B,IAAIC,KAAA,GAAQF,OAAA,CAAQE,KAAA,IAAS;EAG7B,IAAI,CAACJ,OAAA,EAAS,MAAM,IAAIK,KAAA,CAAM,qBAAqB;EACnD,IAAI,OAAOH,OAAA,KAAY,UAAU,MAAM,IAAIG,KAAA,CAAM,2BAA2B;EAC5E,IAAI,OAAOD,KAAA,KAAU,UAAU,MAAM,IAAIC,KAAA,CAAM,yBAAyB;EAGxE,IAAIJ,MAAA,KAAW,QAAW,MAAM,IAAII,KAAA,CAAM,oBAAoB;EAC9D,IAAID,KAAA,IAAS,GAAG,MAAM,IAAIC,KAAA,CAAM,8BAA8B;EAE9D,IAAIC,OAAA,GAAU,EAAC;EACf,QAAQN,OAAA,CAAQO,IAAA;IACd,KAAK;MACHnB,QAAA,CAASY,OAAA,EAAS,UAAUQ,QAAA,EAAU;QACpC,IAAIC,QAAA,GAAWC,aAAA,CAAcF,QAAA,EAAUP,MAAA,EAAQE,KAAA,EAAOC,KAAK;QAC3D,IAAIK,QAAA,EAAUH,OAAA,CAAQK,IAAA,CAAKF,QAAQ;MACrC,CAAC;MACD,OAAOjB,iBAAA,CAAkBc,OAAO;IAClC,KAAK;MACHjB,WAAA,CAAYW,OAAA,EAAS,UAAUY,QAAA,EAAS;QACtC,IAAIC,aAAA,GAAgBH,aAAA,CAAcE,QAAA,EAASX,MAAA,EAAQE,KAAA,EAAOC,KAAK;QAC/D,IAAIS,aAAA,EAAe;UACjBxB,WAAA,CAAYwB,aAAA,EAAe,UAAUJ,QAAA,EAAU;YAC7C,IAAIA,QAAA,EAAUH,OAAA,CAAQK,IAAA,CAAKF,QAAQ;UACrC,CAAC;QACH;MACF,CAAC;MACD,OAAOjB,iBAAA,CAAkBc,OAAO;EACpC;EACA,OAAOI,aAAA,CAAcV,OAAA,EAASC,MAAA,EAAQE,KAAA,EAAOC,KAAK;AACpD;AAYA,SAASM,cAAcV,OAAA,EAASC,MAAA,EAAQE,KAAA,EAAOC,KAAA,EAAO;EACpD,IAAIU,UAAA,GAAad,OAAA,CAAQc,UAAA,IAAc,CAAC;EACxC,IAAIN,QAAA,GAAWR,OAAA,CAAQO,IAAA,KAAS,YAAYP,OAAA,CAAQQ,QAAA,GAAWR,OAAA;EAG/D,IAAIQ,QAAA,CAASD,IAAA,KAAS,sBAAsB;IAC1C,IAAID,OAAA,GAAU,EAAC;IACflB,QAAA,CAASY,OAAA,EAAS,UAAUe,SAAA,EAAU;MACpC,IAAIC,SAAA,GAAWN,aAAA,CAAcK,SAAA,EAAUd,MAAA,EAAQE,KAAA,EAAOC,KAAK;MAC3D,IAAIY,SAAA,EAAUV,OAAA,CAAQK,IAAA,CAAKK,SAAQ;IACrC,CAAC;IACD,OAAOxB,iBAAA,CAAkBc,OAAO;EAClC;EAGA,IAAIW,UAAA,GAAaC,gBAAA,CAAiBV,QAAQ;EAC1C,IAAIW,SAAA,GAAY;IACdZ,IAAA,EAAMC,QAAA,CAASD,IAAA;IACfa,WAAA,EAAaC,aAAA,CAAcb,QAAA,CAASY,WAAA,EAAaH,UAAU;EAC7D;EAGA,IAAIK,MAAA,GAAS,IAAIzB,aAAA,CAAc;EAC/B,IAAI0B,IAAA,GAAOD,MAAA,CAAOE,IAAA,CAAKL,SAAS;EAChC,IAAIM,QAAA,GAAWhC,eAAA,CAAgBC,eAAA,CAAgBO,MAAA,EAAQE,KAAK,GAAG,QAAQ;EACvE,IAAIM,QAAA,GAAWb,QAAA,CAAS8B,QAAA,CAASH,IAAA,EAAME,QAAA,EAAUrB,KAAK;EACtD,IAAIuB,MAAA,GAAS,IAAI7B,aAAA,CAAc;EAC/BW,QAAA,GAAWkB,MAAA,CAAOC,KAAA,CAAMnB,QAAQ;EAGhC,IAAIoB,WAAA,CAAYpB,QAAA,CAASW,WAAW,GAAG,OAAO;EAG9C,IAAIU,MAAA,GAAS;IACXvB,IAAA,EAAME,QAAA,CAASF,IAAA;IACfa,WAAA,EAAaW,eAAA,CAAgBtB,QAAA,CAASW,WAAA,EAAaH,UAAU;EAC/D;EAEA,OAAO1B,OAAA,CAAQuC,MAAA,EAAQhB,UAAU;AACnC;AASA,SAASe,YAAYG,MAAA,EAAQ;EAC3B,IAAIC,KAAA,CAAMC,OAAA,CAAQF,MAAA,CAAO,CAAC,CAAC,GAAG,OAAOH,WAAA,CAAYG,MAAA,CAAO,CAAC,CAAC;EAC1D,OAAOG,KAAA,CAAMH,MAAA,CAAO,CAAC,CAAC;AACxB;AAUA,SAASX,cAAcW,MAAA,EAAQI,IAAA,EAAM;EACnC,IAAI,OAAOJ,MAAA,CAAO,CAAC,MAAM,UAAU,OAAOI,IAAA,CAAKJ,MAAM;EACrD,OAAOA,MAAA,CAAOK,GAAA,CAAI,UAAUC,KAAA,EAAO;IACjC,OAAOjB,aAAA,CAAciB,KAAA,EAAOF,IAAI;EAClC,CAAC;AACH;AAUA,SAASL,gBAAgBC,MAAA,EAAQI,IAAA,EAAM;EACrC,IAAI,OAAOJ,MAAA,CAAO,CAAC,MAAM,UAAU,OAAOI,IAAA,CAAKG,MAAA,CAAOP,MAAM;EAC5D,OAAOA,MAAA,CAAOK,GAAA,CAAI,UAAUC,KAAA,EAAO;IACjC,OAAOP,eAAA,CAAgBO,KAAA,EAAOF,IAAI;EACpC,CAAC;AACH;AASA,SAASlB,iBAAiBlB,OAAA,EAAS;EACjC,IAAIgC,MAAA,GAAS9C,MAAA,CAAOc,OAAO,EAAEQ,QAAA,CAASY,WAAA;EACtC,IAAIoB,QAAA,GAAW,CAAC,CAACR,MAAA,CAAO,CAAC,GAAG,CAACA,MAAA,CAAO,CAAC,CAAC;EACtC,OAAO1C,uBAAA,CAAwB,EAAEmD,MAAA,CAAOD,QAAQ,EAAEE,KAAA,CAAM/C,WAAW;AACrE;AAGA,IAAOgD,mBAAA,GAAQ5C,MAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}