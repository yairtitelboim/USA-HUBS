{"ast":null,"code":"// index.ts\nimport { distanceWeight as spatialWeight } from \"@turf/distance-weight\";\nimport { featureEach } from \"@turf/meta\";\nfunction moranIndex(fc, options) {\n  var _a, _b;\n  const inputField = options.inputField;\n  const threshold = options.threshold || 1e5;\n  const p = options.p || 2;\n  const binary = (_a = options.binary) != null ? _a : false;\n  const alpha = options.alpha || -1;\n  const standardization = (_b = options.standardization) != null ? _b : true;\n  const weight = spatialWeight(fc, {\n    alpha,\n    binary,\n    p,\n    standardization,\n    threshold\n  });\n  const y = [];\n  featureEach(fc, feature => {\n    const feaProperties = feature.properties || {};\n    y.push(feaProperties[inputField]);\n  });\n  const yMean = mean(y);\n  const yVar = variance(y);\n  let weightSum = 0;\n  let s0 = 0;\n  let s1 = 0;\n  let s2 = 0;\n  const n = weight.length;\n  for (let i = 0; i < n; i++) {\n    let subS2 = 0;\n    for (let j = 0; j < n; j++) {\n      weightSum += weight[i][j] * (y[i] - yMean) * (y[j] - yMean);\n      s0 += weight[i][j];\n      s1 += Math.pow(weight[i][j] + weight[j][i], 2);\n      subS2 += weight[i][j] + weight[j][i];\n    }\n    s2 += Math.pow(subS2, 2);\n  }\n  s1 = 0.5 * s1;\n  const moranIndex2 = weightSum / s0 / yVar;\n  const expectedMoranIndex = -1 / (n - 1);\n  const vNum = n * n * s1 - n * s2 + 3 * (s0 * s0);\n  const vDen = (n - 1) * (n + 1) * (s0 * s0);\n  const vNorm = vNum / vDen - expectedMoranIndex * expectedMoranIndex;\n  const stdNorm = Math.sqrt(vNorm);\n  const zNorm = (moranIndex2 - expectedMoranIndex) / stdNorm;\n  return {\n    expectedMoranIndex,\n    moranIndex: moranIndex2,\n    stdNorm,\n    zNorm\n  };\n}\nfunction mean(y) {\n  let sum = 0;\n  for (const item of y) {\n    sum += item;\n  }\n  return sum / y.length;\n}\nfunction variance(y) {\n  const yMean = mean(y);\n  let sum = 0;\n  for (const item of y) {\n    sum += Math.pow(item - yMean, 2);\n  }\n  return sum / y.length;\n}\nvar turf_moran_index_default = moranIndex;\nexport { turf_moran_index_default as default, moranIndex };","map":{"version":3,"names":["distanceWeight","spatialWeight","featureEach","moranIndex","fc","options","_a","_b","inputField","threshold","p","binary","alpha","standardization","weight","y","feature","feaProperties","properties","push","yMean","mean","yVar","variance","weightSum","s0","s1","s2","n","length","i","subS2","j","Math","pow","moranIndex2","expectedMoranIndex","vNum","vDen","vNorm","stdNorm","sqrt","zNorm","sum","item","turf_moran_index_default"],"sources":["/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/moran-index/index.ts"],"sourcesContent":["import { FeatureCollection } from \"geojson\";\nimport { distanceWeight as spatialWeight } from \"@turf/distance-weight\";\nimport { featureEach } from \"@turf/meta\";\n\n/**\n * @typedef {object} MoranIndex\n * @property {number} moranIndex the moran's Index of the observed feature set\n * @property {number} expectedMoranIndex the moran's Index of the random distribution\n * @property {number} stdNorm the standard devitaion of the random distribution\n * @property {number} zNorm the z-score of the observe samples with regard to the random distribution\n */\ntype MoranIndex = {\n  moranIndex: number;\n  expectedMoranIndex: number;\n  stdNorm: number;\n  zNorm: number;\n};\n\n/**\n * Moran's I measures patterns of attribute values associated with features.\n * The method reveal whether similar values tend to occur near each other,\n * or whether high or low values are interspersed.\n *\n * Moran's I > 0 means a clusterd pattern.\n * Moran's I < 0 means a dispersed pattern.\n * Moran's I = 0 means a random pattern.\n *\n * In order to test the significance of the result. The z score is calculated.\n * A positive enough z-score (ex. >1.96) indicates clustering,\n * while a negative enough z-score (ex. <-1.96) indicates a dispersed pattern.\n *\n * the z-score can be calculated based on a normal or random assumption.\n *\n * **Bibliography***\n *\n * 1. [Moran's I](https://en.wikipedia.org/wiki/Moran%27s_I)\n *\n * 2. [pysal](http://pysal.readthedocs.io/en/latest/index.html)\n *\n * 3. Andy Mitchell, The ESRI Guide to GIS Analysis Volume 2: Spatial Measurements & Statistics.\n *\n * @function\n * @param {FeatureCollection<any>} fc\n * @param {Object} options\n * @param {string} options.inputField the property name, must contain numeric values\n * @param {number} [options.threshold=100000] the distance threshold\n * @param {number} [options.p=2] the Minkowski p-norm distance parameter\n * @param {boolean} [options.binary=false] whether transfrom the distance to binary\n * @param {number} [options.alpha=-1] the distance decay parameter\n * @param {boolean} [options.standardization=true] wheter row standardization the distance\n * @returns {MoranIndex}\n * @example\n *\n * const bbox = [-65, 40, -63, 42];\n * const dataset = turf.randomPoint(100, { bbox: bbox });\n *\n * const result = turf.moranIndex(dataset, {\n *   inputField: 'CRIME',\n * });\n */\n\nfunction moranIndex(\n  fc: FeatureCollection<any>,\n  options: {\n    inputField: string;\n    threshold?: number;\n    p?: number;\n    binary?: boolean;\n    alpha?: number;\n    standardization?: boolean;\n  }\n): MoranIndex {\n  const inputField = options.inputField;\n  const threshold = options.threshold || 100000;\n  const p = options.p || 2;\n  const binary = options.binary ?? false;\n  const alpha = options.alpha || -1;\n  const standardization = options.standardization ?? true;\n\n  const weight = spatialWeight(fc, {\n    alpha,\n    binary,\n    p,\n    standardization,\n    threshold,\n  });\n\n  const y: number[] = [];\n  featureEach(fc, (feature) => {\n    const feaProperties = feature.properties || {};\n    // validate inputField exists\n    y.push(feaProperties[inputField]);\n  });\n\n  const yMean = mean(y);\n  const yVar = variance(y);\n  let weightSum = 0;\n  let s0 = 0;\n  let s1 = 0;\n  let s2 = 0;\n  const n = weight.length;\n  // validate y.length is the same as weight.length\n  for (let i = 0; i < n; i++) {\n    let subS2 = 0;\n    for (let j = 0; j < n; j++) {\n      weightSum += weight[i][j] * (y[i] - yMean) * (y[j] - yMean);\n      s0 += weight[i][j];\n      s1 += Math.pow(weight[i][j] + weight[j][i], 2);\n      subS2 += weight[i][j] + weight[j][i];\n    }\n    s2 += Math.pow(subS2, 2);\n  }\n  s1 = 0.5 * s1;\n\n  const moranIndex = weightSum / s0 / yVar;\n  const expectedMoranIndex = -1 / (n - 1);\n  const vNum = n * n * s1 - n * s2 + 3 * (s0 * s0);\n  const vDen = (n - 1) * (n + 1) * (s0 * s0);\n  const vNorm = vNum / vDen - expectedMoranIndex * expectedMoranIndex;\n  const stdNorm = Math.sqrt(vNorm);\n  const zNorm = (moranIndex - expectedMoranIndex) / stdNorm;\n\n  return {\n    expectedMoranIndex,\n    moranIndex,\n    stdNorm,\n    zNorm,\n  };\n}\n\n/**\n * get mean of a list\n *\n * @private\n * @param {number[]} y\n * @returns {number}\n *\n */\nfunction mean(y: number[]): number {\n  let sum = 0;\n  for (const item of y) {\n    sum += item;\n  }\n  return sum / y.length;\n}\n/**\n * get variance of a list\n *\n * @private\n * @param {number[]} y\n * @returns {number}\n *\n */\nfunction variance(y: number[]): number {\n  const yMean = mean(y);\n  let sum = 0;\n  for (const item of y) {\n    sum += Math.pow(item - yMean, 2);\n  }\n  return sum / y.length;\n}\n\nexport { moranIndex, MoranIndex };\nexport default moranIndex;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}