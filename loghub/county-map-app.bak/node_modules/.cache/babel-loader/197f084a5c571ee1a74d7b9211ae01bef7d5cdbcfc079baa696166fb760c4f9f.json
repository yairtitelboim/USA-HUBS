{"ast":null,"code":"// index.ts\nimport { earthRadius } from \"@turf/helpers\";\nimport { geomReduce } from \"@turf/meta\";\nfunction area(geojson) {\n  return geomReduce(geojson, (value, geom) => {\n    return value + calculateArea(geom);\n  }, 0);\n}\nfunction calculateArea(geom) {\n  let total = 0;\n  let i;\n  switch (geom.type) {\n    case \"Polygon\":\n      return polygonArea(geom.coordinates);\n    case \"MultiPolygon\":\n      for (i = 0; i < geom.coordinates.length; i++) {\n        total += polygonArea(geom.coordinates[i]);\n      }\n      return total;\n    case \"Point\":\n    case \"MultiPoint\":\n    case \"LineString\":\n    case \"MultiLineString\":\n      return 0;\n  }\n  return 0;\n}\nfunction polygonArea(coords) {\n  let total = 0;\n  if (coords && coords.length > 0) {\n    total += Math.abs(ringArea(coords[0]));\n    for (let i = 1; i < coords.length; i++) {\n      total -= Math.abs(ringArea(coords[i]));\n    }\n  }\n  return total;\n}\nvar FACTOR = earthRadius * earthRadius / 2;\nvar PI_OVER_180 = Math.PI / 180;\nfunction ringArea(coords) {\n  const coordsLength = coords.length - 1;\n  if (coordsLength <= 2) return 0;\n  let total = 0;\n  let i = 0;\n  while (i < coordsLength) {\n    const lower = coords[i];\n    const middle = coords[i + 1 === coordsLength ? 0 : i + 1];\n    const upper = coords[i + 2 >= coordsLength ? (i + 2) % coordsLength : i + 2];\n    const lowerX = lower[0] * PI_OVER_180;\n    const middleY = middle[1] * PI_OVER_180;\n    const upperX = upper[0] * PI_OVER_180;\n    total += (upperX - lowerX) * Math.sin(middleY);\n    i++;\n  }\n  return total * FACTOR;\n}\nvar turf_area_default = area;\nexport { area, turf_area_default as default };","map":{"version":3,"names":["earthRadius","geomReduce","area","geojson","value","geom","calculateArea","total","i","type","polygonArea","coordinates","length","coords","Math","abs","ringArea","FACTOR","PI_OVER_180","PI","coordsLength","lower","middle","upper","lowerX","middleY","upperX","sin","turf_area_default"],"sources":["/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/area/index.ts"],"sourcesContent":["import { Feature, FeatureCollection, Geometry } from \"geojson\";\nimport { earthRadius } from \"@turf/helpers\";\nimport { geomReduce } from \"@turf/meta\";\n\n/**\n * Calculates the geodesic area in square meters of one or more polygons.\n *\n * @function\n * @param {GeoJSON} geojson input polygon(s) as {@link Geometry}, {@link Feature}, or {@link FeatureCollection}\n * @returns {number} area in square meters\n * @example\n * var polygon = turf.polygon([[[125, -15], [113, -22], [154, -27], [144, -15], [125, -15]]]);\n *\n * var area = turf.area(polygon);\n *\n * //addToMap\n * var addToMap = [polygon]\n * polygon.properties.area = area\n */\nfunction area(geojson: Feature<any> | FeatureCollection<any> | Geometry) {\n  return geomReduce(\n    geojson,\n    (value, geom) => {\n      return value + calculateArea(geom);\n    },\n    0\n  );\n}\n\n/**\n * Calculate Area\n *\n * @private\n * @param {Geometry} geom GeoJSON Geometries\n * @returns {number} area\n */\nfunction calculateArea(geom: Geometry): number {\n  let total = 0;\n  let i;\n  switch (geom.type) {\n    case \"Polygon\":\n      return polygonArea(geom.coordinates);\n    case \"MultiPolygon\":\n      for (i = 0; i < geom.coordinates.length; i++) {\n        total += polygonArea(geom.coordinates[i]);\n      }\n      return total;\n    case \"Point\":\n    case \"MultiPoint\":\n    case \"LineString\":\n    case \"MultiLineString\":\n      return 0;\n  }\n  return 0;\n}\n\nfunction polygonArea(coords: any) {\n  let total = 0;\n  if (coords && coords.length > 0) {\n    total += Math.abs(ringArea(coords[0]));\n    for (let i = 1; i < coords.length; i++) {\n      total -= Math.abs(ringArea(coords[i]));\n    }\n  }\n  return total;\n}\n\n/**\n * @private\n * A constant factor used to compute the area of a polygon.\n * It's derived from the square of the Earth's radius divided by 2.\n *\n * @type {number}\n */\nconst FACTOR = (earthRadius * earthRadius) / 2;\n\n/**\n * @private\n * A constant used for converting degrees to radians.\n * Represents the ratio of PI to 180.\n *\n * @type {number}\n */\nconst PI_OVER_180 = Math.PI / 180;\n\n/**\n * @private\n * Calculate the approximate area of the polygon were it projected onto the earth.\n * Note that this area will be positive if ring is oriented clockwise, otherwise it will be negative.\n *\n * Reference:\n * Robert. G. Chamberlain and William H. Duquette, \"Some Algorithms for Polygons on a Sphere\",\n * JPL Publication 07-03, Jet Propulsion\n * Laboratory, Pasadena, CA, June 2007 https://trs.jpl.nasa.gov/handle/2014/40409\n *\n * @param {Array<Array<number>>} coords Ring Coordinates\n * @returns {number} The approximate signed geodesic area of the polygon in square meters.\n */\nfunction ringArea(coords: number[][]): number {\n  const coordsLength = coords.length - 1;\n\n  if (coordsLength <= 2) return 0;\n  let total = 0;\n\n  let i = 0;\n  while (i < coordsLength) {\n    const lower = coords[i];\n    const middle = coords[i + 1 === coordsLength ? 0 : i + 1];\n    const upper =\n      coords[i + 2 >= coordsLength ? (i + 2) % coordsLength : i + 2];\n\n    const lowerX = lower[0] * PI_OVER_180;\n    const middleY = middle[1] * PI_OVER_180;\n    const upperX = upper[0] * PI_OVER_180;\n\n    total += (upperX - lowerX) * Math.sin(middleY);\n\n    i++;\n  }\n\n  return total * FACTOR;\n}\n\nexport { area };\nexport default area;\n"],"mappings":";AACA,SAASA,WAAA,QAAmB;AAC5B,SAASC,UAAA,QAAkB;AAiB3B,SAASC,KAAKC,OAAA,EAA2D;EACvE,OAAOF,UAAA,CACLE,OAAA,EACA,CAACC,KAAA,EAAOC,IAAA,KAAS;IACf,OAAOD,KAAA,GAAQE,aAAA,CAAcD,IAAI;EACnC,GACA,CACF;AACF;AASA,SAASC,cAAcD,IAAA,EAAwB;EAC7C,IAAIE,KAAA,GAAQ;EACZ,IAAIC,CAAA;EACJ,QAAQH,IAAA,CAAKI,IAAA;IACX,KAAK;MACH,OAAOC,WAAA,CAAYL,IAAA,CAAKM,WAAW;IACrC,KAAK;MACH,KAAKH,CAAA,GAAI,GAAGA,CAAA,GAAIH,IAAA,CAAKM,WAAA,CAAYC,MAAA,EAAQJ,CAAA,IAAK;QAC5CD,KAAA,IAASG,WAAA,CAAYL,IAAA,CAAKM,WAAA,CAAYH,CAAC,CAAC;MAC1C;MACA,OAAOD,KAAA;IACT,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;MACH,OAAO;EACX;EACA,OAAO;AACT;AAEA,SAASG,YAAYG,MAAA,EAAa;EAChC,IAAIN,KAAA,GAAQ;EACZ,IAAIM,MAAA,IAAUA,MAAA,CAAOD,MAAA,GAAS,GAAG;IAC/BL,KAAA,IAASO,IAAA,CAAKC,GAAA,CAAIC,QAAA,CAASH,MAAA,CAAO,CAAC,CAAC,CAAC;IACrC,SAASL,CAAA,GAAI,GAAGA,CAAA,GAAIK,MAAA,CAAOD,MAAA,EAAQJ,CAAA,IAAK;MACtCD,KAAA,IAASO,IAAA,CAAKC,GAAA,CAAIC,QAAA,CAASH,MAAA,CAAOL,CAAC,CAAC,CAAC;IACvC;EACF;EACA,OAAOD,KAAA;AACT;AASA,IAAMU,MAAA,GAAUjB,WAAA,GAAcA,WAAA,GAAe;AAS7C,IAAMkB,WAAA,GAAcJ,IAAA,CAAKK,EAAA,GAAK;AAe9B,SAASH,SAASH,MAAA,EAA4B;EAC5C,MAAMO,YAAA,GAAeP,MAAA,CAAOD,MAAA,GAAS;EAErC,IAAIQ,YAAA,IAAgB,GAAG,OAAO;EAC9B,IAAIb,KAAA,GAAQ;EAEZ,IAAIC,CAAA,GAAI;EACR,OAAOA,CAAA,GAAIY,YAAA,EAAc;IACvB,MAAMC,KAAA,GAAQR,MAAA,CAAOL,CAAC;IACtB,MAAMc,MAAA,GAAST,MAAA,CAAOL,CAAA,GAAI,MAAMY,YAAA,GAAe,IAAIZ,CAAA,GAAI,CAAC;IACxD,MAAMe,KAAA,GACJV,MAAA,CAAOL,CAAA,GAAI,KAAKY,YAAA,IAAgBZ,CAAA,GAAI,KAAKY,YAAA,GAAeZ,CAAA,GAAI,CAAC;IAE/D,MAAMgB,MAAA,GAASH,KAAA,CAAM,CAAC,IAAIH,WAAA;IAC1B,MAAMO,OAAA,GAAUH,MAAA,CAAO,CAAC,IAAIJ,WAAA;IAC5B,MAAMQ,MAAA,GAASH,KAAA,CAAM,CAAC,IAAIL,WAAA;IAE1BX,KAAA,KAAUmB,MAAA,GAASF,MAAA,IAAUV,IAAA,CAAKa,GAAA,CAAIF,OAAO;IAE7CjB,CAAA;EACF;EAEA,OAAOD,KAAA,GAAQU,MAAA;AACjB;AAGA,IAAOW,iBAAA,GAAQ1B,IAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}