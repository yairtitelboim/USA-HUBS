{"ast":null,"code":"// index.ts\nimport { getCoord, getCoords } from \"@turf/invariant\";\nfunction booleanPointOnLine(pt, line, options = {}) {\n  const ptCoords = getCoord(pt);\n  const lineCoords = getCoords(line);\n  for (let i = 0; i < lineCoords.length - 1; i++) {\n    let ignoreBoundary = false;\n    if (options.ignoreEndVertices) {\n      if (i === 0) {\n        ignoreBoundary = \"start\";\n      }\n      if (i === lineCoords.length - 2) {\n        ignoreBoundary = \"end\";\n      }\n      if (i === 0 && i + 1 === lineCoords.length - 1) {\n        ignoreBoundary = \"both\";\n      }\n    }\n    if (isPointOnLineSegment(lineCoords[i], lineCoords[i + 1], ptCoords, ignoreBoundary, typeof options.epsilon === \"undefined\" ? null : options.epsilon)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction isPointOnLineSegment(lineSegmentStart, lineSegmentEnd, pt, excludeBoundary, epsilon) {\n  const x = pt[0];\n  const y = pt[1];\n  const x1 = lineSegmentStart[0];\n  const y1 = lineSegmentStart[1];\n  const x2 = lineSegmentEnd[0];\n  const y2 = lineSegmentEnd[1];\n  const dxc = pt[0] - x1;\n  const dyc = pt[1] - y1;\n  const dxl = x2 - x1;\n  const dyl = y2 - y1;\n  const cross = dxc * dyl - dyc * dxl;\n  if (epsilon !== null) {\n    if (Math.abs(cross) > epsilon) {\n      return false;\n    }\n  } else if (cross !== 0) {\n    return false;\n  }\n  if (Math.abs(dxl) === Math.abs(dyl) && Math.abs(dxl) === 0) {\n    if (excludeBoundary) {\n      return false;\n    }\n    if (pt[0] === lineSegmentStart[0] && pt[1] === lineSegmentStart[1]) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n  if (!excludeBoundary) {\n    if (Math.abs(dxl) >= Math.abs(dyl)) {\n      return dxl > 0 ? x1 <= x && x <= x2 : x2 <= x && x <= x1;\n    }\n    return dyl > 0 ? y1 <= y && y <= y2 : y2 <= y && y <= y1;\n  } else if (excludeBoundary === \"start\") {\n    if (Math.abs(dxl) >= Math.abs(dyl)) {\n      return dxl > 0 ? x1 < x && x <= x2 : x2 <= x && x < x1;\n    }\n    return dyl > 0 ? y1 < y && y <= y2 : y2 <= y && y < y1;\n  } else if (excludeBoundary === \"end\") {\n    if (Math.abs(dxl) >= Math.abs(dyl)) {\n      return dxl > 0 ? x1 <= x && x < x2 : x2 < x && x <= x1;\n    }\n    return dyl > 0 ? y1 <= y && y < y2 : y2 < y && y <= y1;\n  } else if (excludeBoundary === \"both\") {\n    if (Math.abs(dxl) >= Math.abs(dyl)) {\n      return dxl > 0 ? x1 < x && x < x2 : x2 < x && x < x1;\n    }\n    return dyl > 0 ? y1 < y && y < y2 : y2 < y && y < y1;\n  }\n  return false;\n}\nvar turf_boolean_point_on_line_default = booleanPointOnLine;\nexport { booleanPointOnLine, turf_boolean_point_on_line_default as default };","map":{"version":3,"names":["getCoord","getCoords","booleanPointOnLine","pt","line","options","ptCoords","lineCoords","i","length","ignoreBoundary","ignoreEndVertices","isPointOnLineSegment","epsilon","lineSegmentStart","lineSegmentEnd","excludeBoundary","x","y","x1","y1","x2","y2","dxc","dyc","dxl","dyl","cross","Math","abs","turf_boolean_point_on_line_default"],"sources":["/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/boolean-point-on-line/index.ts"],"sourcesContent":["import { Feature, LineString } from \"geojson\";\nimport { Coord } from \"@turf/helpers\";\nimport { getCoord, getCoords } from \"@turf/invariant\";\n\n/**\n * Returns true if a point is on a line. Accepts a optional parameter to ignore the\n * start and end vertices of the linestring.\n *\n * @function\n * @param {Coord} pt GeoJSON Point\n * @param {Feature<LineString>} line GeoJSON LineString\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.ignoreEndVertices=false] whether to ignore the start and end vertices.\n * @param {number} [options.epsilon] Fractional number to compare with the cross product result. Useful for dealing with floating points such as lng/lat points\n * @returns {boolean} true/false\n * @example\n * var pt = turf.point([0, 0]);\n * var line = turf.lineString([[-1, -1],[1, 1],[1.5, 2.2]]);\n * var isPointOnLine = turf.booleanPointOnLine(pt, line);\n * //=true\n */\nfunction booleanPointOnLine(\n  pt: Coord,\n  line: Feature<LineString> | LineString,\n  options: {\n    ignoreEndVertices?: boolean;\n    epsilon?: number;\n  } = {}\n): boolean {\n  // Normalize inputs\n  const ptCoords = getCoord(pt);\n  const lineCoords = getCoords(line);\n\n  // Main\n  for (let i = 0; i < lineCoords.length - 1; i++) {\n    let ignoreBoundary: boolean | string = false;\n    if (options.ignoreEndVertices) {\n      if (i === 0) {\n        ignoreBoundary = \"start\";\n      }\n      if (i === lineCoords.length - 2) {\n        ignoreBoundary = \"end\";\n      }\n      if (i === 0 && i + 1 === lineCoords.length - 1) {\n        ignoreBoundary = \"both\";\n      }\n    }\n    if (\n      isPointOnLineSegment(\n        lineCoords[i],\n        lineCoords[i + 1],\n        ptCoords,\n        ignoreBoundary,\n        typeof options.epsilon === \"undefined\" ? null : options.epsilon\n      )\n    ) {\n      return true;\n    }\n  }\n  return false;\n}\n\n// See http://stackoverflow.com/a/4833823/1979085\n// See https://stackoverflow.com/a/328122/1048847\n/**\n * @private\n * @param {Position} lineSegmentStart coord pair of start of line\n * @param {Position} lineSegmentEnd coord pair of end of line\n * @param {Position} pt coord pair of point to check\n * @param {boolean|string} excludeBoundary whether the point is allowed to fall on the line ends.\n * @param {number} epsilon Fractional number to compare with the cross product result. Useful for dealing with floating points such as lng/lat points\n * If true which end to ignore.\n * @returns {boolean} true/false\n */\nfunction isPointOnLineSegment(\n  lineSegmentStart: number[],\n  lineSegmentEnd: number[],\n  pt: number[],\n  excludeBoundary: string | boolean,\n  epsilon: number | null\n): boolean {\n  const x = pt[0];\n  const y = pt[1];\n  const x1 = lineSegmentStart[0];\n  const y1 = lineSegmentStart[1];\n  const x2 = lineSegmentEnd[0];\n  const y2 = lineSegmentEnd[1];\n  const dxc = pt[0] - x1;\n  const dyc = pt[1] - y1;\n  const dxl = x2 - x1;\n  const dyl = y2 - y1;\n  const cross = dxc * dyl - dyc * dxl;\n  if (epsilon !== null) {\n    if (Math.abs(cross) > epsilon) {\n      return false;\n    }\n  } else if (cross !== 0) {\n    return false;\n  }\n\n  // Special cases for zero length lines\n  // https://github.com/Turfjs/turf/issues/2750\n  if (Math.abs(dxl) === Math.abs(dyl) && Math.abs(dxl) === 0) {\n    // Zero length line.\n    if (excludeBoundary) {\n      // To be on a zero length line pt has to be on the start (and end), BUT we\n      // are excluding start and end from possible matches.\n      return false;\n    }\n    if (pt[0] === lineSegmentStart[0] && pt[1] === lineSegmentStart[1]) {\n      // If point is same as start (and end) it's on the line segment\n      return true;\n    } else {\n      // Otherwise point is somewhere else\n      return false;\n    }\n  }\n\n  if (!excludeBoundary) {\n    if (Math.abs(dxl) >= Math.abs(dyl)) {\n      return dxl > 0 ? x1 <= x && x <= x2 : x2 <= x && x <= x1;\n    }\n    return dyl > 0 ? y1 <= y && y <= y2 : y2 <= y && y <= y1;\n  } else if (excludeBoundary === \"start\") {\n    if (Math.abs(dxl) >= Math.abs(dyl)) {\n      return dxl > 0 ? x1 < x && x <= x2 : x2 <= x && x < x1;\n    }\n    return dyl > 0 ? y1 < y && y <= y2 : y2 <= y && y < y1;\n  } else if (excludeBoundary === \"end\") {\n    if (Math.abs(dxl) >= Math.abs(dyl)) {\n      return dxl > 0 ? x1 <= x && x < x2 : x2 < x && x <= x1;\n    }\n    return dyl > 0 ? y1 <= y && y < y2 : y2 < y && y <= y1;\n  } else if (excludeBoundary === \"both\") {\n    if (Math.abs(dxl) >= Math.abs(dyl)) {\n      return dxl > 0 ? x1 < x && x < x2 : x2 < x && x < x1;\n    }\n    return dyl > 0 ? y1 < y && y < y2 : y2 < y && y < y1;\n  }\n  return false;\n}\n\nexport { booleanPointOnLine };\nexport default booleanPointOnLine;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}