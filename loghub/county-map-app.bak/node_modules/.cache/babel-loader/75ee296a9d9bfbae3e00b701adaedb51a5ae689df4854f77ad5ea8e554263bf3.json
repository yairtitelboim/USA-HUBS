{"ast":null,"code":"import { orient2d } from 'robust-predicates';\nfunction pointInPolygon(p, polygon) {\n  var i;\n  var ii;\n  var k = 0;\n  var f;\n  var u1;\n  var v1;\n  var u2;\n  var v2;\n  var currentP;\n  var nextP;\n  var x = p[0];\n  var y = p[1];\n  var numContours = polygon.length;\n  for (i = 0; i < numContours; i++) {\n    ii = 0;\n    var contour = polygon[i];\n    var contourLen = contour.length - 1;\n    currentP = contour[0];\n    if (currentP[0] !== contour[contourLen][0] && currentP[1] !== contour[contourLen][1]) {\n      throw new Error('First and last coordinates in a ring must be the same');\n    }\n    u1 = currentP[0] - x;\n    v1 = currentP[1] - y;\n    for (ii; ii < contourLen; ii++) {\n      nextP = contour[ii + 1];\n      u2 = nextP[0] - x;\n      v2 = nextP[1] - y;\n      if (v1 === 0 && v2 === 0) {\n        if (u2 <= 0 && u1 >= 0 || u1 <= 0 && u2 >= 0) {\n          return 0;\n        }\n      } else if (v2 >= 0 && v1 <= 0 || v2 <= 0 && v1 >= 0) {\n        f = orient2d(u1, u2, v1, v2, 0, 0);\n        if (f === 0) {\n          return 0;\n        }\n        if (f > 0 && v2 > 0 && v1 <= 0 || f < 0 && v2 <= 0 && v1 > 0) {\n          k++;\n        }\n      }\n      currentP = nextP;\n      v1 = v2;\n      u1 = u2;\n    }\n  }\n  if (k % 2 === 0) {\n    return false;\n  }\n  return true;\n}\nexport { pointInPolygon as default };","map":{"version":3,"names":["orient2d","pointInPolygon","p","polygon","i","ii","k","f","u1","v1","u2","v2","currentP","nextP","x","y","numContours","length","contour","contourLen","Error","default"],"sources":["/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/point-in-polygon-hao/dist/esm/index.js"],"sourcesContent":["import { orient2d } from 'robust-predicates';\n\nfunction pointInPolygon(p, polygon) {\n    var i;\n    var ii;\n    var k = 0;\n    var f;\n    var u1;\n    var v1;\n    var u2;\n    var v2;\n    var currentP;\n    var nextP;\n\n    var x = p[0];\n    var y = p[1];\n\n    var numContours = polygon.length;\n    for (i = 0; i < numContours; i++) {\n        ii = 0;\n        var contour = polygon[i];\n        var contourLen = contour.length - 1;\n\n        currentP = contour[0];\n        if (currentP[0] !== contour[contourLen][0] &&\n            currentP[1] !== contour[contourLen][1]) {\n            throw new Error('First and last coordinates in a ring must be the same')\n        }\n\n        u1 = currentP[0] - x;\n        v1 = currentP[1] - y;\n\n        for (ii; ii < contourLen; ii++) {\n            nextP = contour[ii + 1];\n\n            u2 = nextP[0] - x;\n            v2 = nextP[1] - y;\n\n            if (v1 === 0 && v2 === 0) {\n                if ((u2 <= 0 && u1 >= 0) || (u1 <= 0 && u2 >= 0)) { return 0 }\n            } else if ((v2 >= 0 && v1 <= 0) || (v2 <= 0 && v1 >= 0)) {\n                f = orient2d(u1, u2, v1, v2, 0, 0);\n                if (f === 0) { return 0 }\n                if ((f > 0 && v2 > 0 && v1 <= 0) || (f < 0 && v2 <= 0 && v1 > 0)) { k++; }\n            }\n            currentP = nextP;\n            v1 = v2;\n            u1 = u2;\n        }\n    }\n\n    if (k % 2 === 0) { return false }\n    return true\n}\n\nexport { pointInPolygon as default };\n"],"mappings":"AAAA,SAASA,QAAQ,QAAQ,mBAAmB;AAE5C,SAASC,cAAcA,CAACC,CAAC,EAAEC,OAAO,EAAE;EAChC,IAAIC,CAAC;EACL,IAAIC,EAAE;EACN,IAAIC,CAAC,GAAG,CAAC;EACT,IAAIC,CAAC;EACL,IAAIC,EAAE;EACN,IAAIC,EAAE;EACN,IAAIC,EAAE;EACN,IAAIC,EAAE;EACN,IAAIC,QAAQ;EACZ,IAAIC,KAAK;EAET,IAAIC,CAAC,GAAGZ,CAAC,CAAC,CAAC,CAAC;EACZ,IAAIa,CAAC,GAAGb,CAAC,CAAC,CAAC,CAAC;EAEZ,IAAIc,WAAW,GAAGb,OAAO,CAACc,MAAM;EAChC,KAAKb,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGY,WAAW,EAAEZ,CAAC,EAAE,EAAE;IAC9BC,EAAE,GAAG,CAAC;IACN,IAAIa,OAAO,GAAGf,OAAO,CAACC,CAAC,CAAC;IACxB,IAAIe,UAAU,GAAGD,OAAO,CAACD,MAAM,GAAG,CAAC;IAEnCL,QAAQ,GAAGM,OAAO,CAAC,CAAC,CAAC;IACrB,IAAIN,QAAQ,CAAC,CAAC,CAAC,KAAKM,OAAO,CAACC,UAAU,CAAC,CAAC,CAAC,CAAC,IACtCP,QAAQ,CAAC,CAAC,CAAC,KAAKM,OAAO,CAACC,UAAU,CAAC,CAAC,CAAC,CAAC,EAAE;MACxC,MAAM,IAAIC,KAAK,CAAC,uDAAuD,CAAC;IAC5E;IAEAZ,EAAE,GAAGI,QAAQ,CAAC,CAAC,CAAC,GAAGE,CAAC;IACpBL,EAAE,GAAGG,QAAQ,CAAC,CAAC,CAAC,GAAGG,CAAC;IAEpB,KAAKV,EAAE,EAAEA,EAAE,GAAGc,UAAU,EAAEd,EAAE,EAAE,EAAE;MAC5BQ,KAAK,GAAGK,OAAO,CAACb,EAAE,GAAG,CAAC,CAAC;MAEvBK,EAAE,GAAGG,KAAK,CAAC,CAAC,CAAC,GAAGC,CAAC;MACjBH,EAAE,GAAGE,KAAK,CAAC,CAAC,CAAC,GAAGE,CAAC;MAEjB,IAAIN,EAAE,KAAK,CAAC,IAAIE,EAAE,KAAK,CAAC,EAAE;QACtB,IAAKD,EAAE,IAAI,CAAC,IAAIF,EAAE,IAAI,CAAC,IAAMA,EAAE,IAAI,CAAC,IAAIE,EAAE,IAAI,CAAE,EAAE;UAAE,OAAO,CAAC;QAAC;MACjE,CAAC,MAAM,IAAKC,EAAE,IAAI,CAAC,IAAIF,EAAE,IAAI,CAAC,IAAME,EAAE,IAAI,CAAC,IAAIF,EAAE,IAAI,CAAE,EAAE;QACrDF,CAAC,GAAGP,QAAQ,CAACQ,EAAE,EAAEE,EAAE,EAAED,EAAE,EAAEE,EAAE,EAAE,CAAC,EAAE,CAAC,CAAC;QAClC,IAAIJ,CAAC,KAAK,CAAC,EAAE;UAAE,OAAO,CAAC;QAAC;QACxB,IAAKA,CAAC,GAAG,CAAC,IAAII,EAAE,GAAG,CAAC,IAAIF,EAAE,IAAI,CAAC,IAAMF,CAAC,GAAG,CAAC,IAAII,EAAE,IAAI,CAAC,IAAIF,EAAE,GAAG,CAAE,EAAE;UAAEH,CAAC,EAAE;QAAE;MAC7E;MACAM,QAAQ,GAAGC,KAAK;MAChBJ,EAAE,GAAGE,EAAE;MACPH,EAAE,GAAGE,EAAE;IACX;EACJ;EAEA,IAAIJ,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE;IAAE,OAAO,KAAK;EAAC;EAChC,OAAO,IAAI;AACf;AAEA,SAASL,cAAc,IAAIoB,OAAO","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}