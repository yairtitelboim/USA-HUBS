{"ast":null,"code":"// index.ts\nimport { degreesToRadians, lengthToRadians, point, radiansToDegrees } from \"@turf/helpers\";\nimport { getCoord } from \"@turf/invariant\";\nfunction destination(origin, distance, bearing, options = {}) {\n  const coordinates1 = getCoord(origin);\n  const longitude1 = degreesToRadians(coordinates1[0]);\n  const latitude1 = degreesToRadians(coordinates1[1]);\n  const bearingRad = degreesToRadians(bearing);\n  const radians = lengthToRadians(distance, options.units);\n  const latitude2 = Math.asin(Math.sin(latitude1) * Math.cos(radians) + Math.cos(latitude1) * Math.sin(radians) * Math.cos(bearingRad));\n  const longitude2 = longitude1 + Math.atan2(Math.sin(bearingRad) * Math.sin(radians) * Math.cos(latitude1), Math.cos(radians) - Math.sin(latitude1) * Math.sin(latitude2));\n  const lng = radiansToDegrees(longitude2);\n  const lat = radiansToDegrees(latitude2);\n  return point([lng, lat], options.properties);\n}\nvar turf_destination_default = destination;\nexport { turf_destination_default as default, destination };","map":{"version":3,"names":["degreesToRadians","lengthToRadians","point","radiansToDegrees","getCoord","destination","origin","distance","bearing","options","coordinates1","longitude1","latitude1","bearingRad","radians","units","latitude2","Math","asin","sin","cos","longitude2","atan2","lng","lat","properties","turf_destination_default"],"sources":["/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/destination/index.ts"],"sourcesContent":["// http://en.wikipedia.org/wiki/Haversine_formula\n// http://www.movable-type.co.uk/scripts/latlong.html\nimport { Feature, Point, GeoJsonProperties } from \"geojson\";\nimport {\n  Coord,\n  degreesToRadians,\n  lengthToRadians,\n  point,\n  radiansToDegrees,\n  Units,\n} from \"@turf/helpers\";\nimport { getCoord } from \"@turf/invariant\";\n\n/**\n * Takes a {@link Point} and calculates the location of a destination point given a distance in\n * degrees, radians, miles, or kilometers; and bearing in degrees.\n * This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.\n *\n * @function\n * @param {Coord} origin starting point\n * @param {number} distance distance from the origin point\n * @param {number} bearing ranging from -180 to 180\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] miles, kilometers, degrees, or radians\n * @param {Object} [options.properties={}] Translate properties to Point\n * @returns {Feature<Point>} destination point\n * @example\n * var point = turf.point([-75.343, 39.984]);\n * var distance = 50;\n * var bearing = 90;\n * var options = {units: 'miles'};\n *\n * var destination = turf.destination(point, distance, bearing, options);\n *\n * //addToMap\n * var addToMap = [point, destination]\n * destination.properties['marker-color'] = '#f00';\n * point.properties['marker-color'] = '#0f0';\n */\nfunction destination<P extends GeoJsonProperties = GeoJsonProperties>(\n  origin: Coord,\n  distance: number,\n  bearing: number,\n  options: {\n    units?: Units;\n    properties?: P;\n  } = {}\n): Feature<Point, P> {\n  // Handle input\n  const coordinates1 = getCoord(origin);\n  const longitude1 = degreesToRadians(coordinates1[0]);\n  const latitude1 = degreesToRadians(coordinates1[1]);\n  const bearingRad = degreesToRadians(bearing);\n  const radians = lengthToRadians(distance, options.units);\n\n  // Main\n  const latitude2 = Math.asin(\n    Math.sin(latitude1) * Math.cos(radians) +\n      Math.cos(latitude1) * Math.sin(radians) * Math.cos(bearingRad)\n  );\n  const longitude2 =\n    longitude1 +\n    Math.atan2(\n      Math.sin(bearingRad) * Math.sin(radians) * Math.cos(latitude1),\n      Math.cos(radians) - Math.sin(latitude1) * Math.sin(latitude2)\n    );\n  const lng = radiansToDegrees(longitude2);\n  const lat = radiansToDegrees(latitude2);\n\n  return point([lng, lat], options.properties);\n}\n\nexport { destination };\nexport default destination;\n"],"mappings":";AAGA,SAEEA,gBAAA,EACAC,eAAA,EACAC,KAAA,EACAC,gBAAA,QAEK;AACP,SAASC,QAAA,QAAgB;AA4BzB,SAASC,YACPC,MAAA,EACAC,QAAA,EACAC,OAAA,EACAC,OAAA,GAGI,CAAC,GACc;EAEnB,MAAMC,YAAA,GAAeN,QAAA,CAASE,MAAM;EACpC,MAAMK,UAAA,GAAaX,gBAAA,CAAiBU,YAAA,CAAa,CAAC,CAAC;EACnD,MAAME,SAAA,GAAYZ,gBAAA,CAAiBU,YAAA,CAAa,CAAC,CAAC;EAClD,MAAMG,UAAA,GAAab,gBAAA,CAAiBQ,OAAO;EAC3C,MAAMM,OAAA,GAAUb,eAAA,CAAgBM,QAAA,EAAUE,OAAA,CAAQM,KAAK;EAGvD,MAAMC,SAAA,GAAYC,IAAA,CAAKC,IAAA,CACrBD,IAAA,CAAKE,GAAA,CAAIP,SAAS,IAAIK,IAAA,CAAKG,GAAA,CAAIN,OAAO,IACpCG,IAAA,CAAKG,GAAA,CAAIR,SAAS,IAAIK,IAAA,CAAKE,GAAA,CAAIL,OAAO,IAAIG,IAAA,CAAKG,GAAA,CAAIP,UAAU,CACjE;EACA,MAAMQ,UAAA,GACJV,UAAA,GACAM,IAAA,CAAKK,KAAA,CACHL,IAAA,CAAKE,GAAA,CAAIN,UAAU,IAAII,IAAA,CAAKE,GAAA,CAAIL,OAAO,IAAIG,IAAA,CAAKG,GAAA,CAAIR,SAAS,GAC7DK,IAAA,CAAKG,GAAA,CAAIN,OAAO,IAAIG,IAAA,CAAKE,GAAA,CAAIP,SAAS,IAAIK,IAAA,CAAKE,GAAA,CAAIH,SAAS,CAC9D;EACF,MAAMO,GAAA,GAAMpB,gBAAA,CAAiBkB,UAAU;EACvC,MAAMG,GAAA,GAAMrB,gBAAA,CAAiBa,SAAS;EAEtC,OAAOd,KAAA,CAAM,CAACqB,GAAA,EAAKC,GAAG,GAAGf,OAAA,CAAQgB,UAAU;AAC7C;AAGA,IAAOC,wBAAA,GAAQrB,WAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}