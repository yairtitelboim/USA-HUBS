{"ast":null,"code":"// index.ts\nimport { segmentEach } from \"@turf/meta\";\nimport { getGeom } from \"@turf/invariant\";\nimport { lineOverlap } from \"@turf/line-overlap\";\nimport { lineIntersect } from \"@turf/line-intersect\";\nimport { geojsonEquality } from \"geojson-equality-ts\";\nfunction booleanOverlap(feature1, feature2) {\n  const geom1 = getGeom(feature1);\n  const geom2 = getGeom(feature2);\n  const type1 = geom1.type;\n  const type2 = geom2.type;\n  if (type1 === \"MultiPoint\" && type2 !== \"MultiPoint\" || (type1 === \"LineString\" || type1 === \"MultiLineString\") && type2 !== \"LineString\" && type2 !== \"MultiLineString\" || (type1 === \"Polygon\" || type1 === \"MultiPolygon\") && type2 !== \"Polygon\" && type2 !== \"MultiPolygon\") {\n    throw new Error(\"features must be of the same type\");\n  }\n  if (type1 === \"Point\") throw new Error(\"Point geometry not supported\");\n  if (geojsonEquality(feature1, feature2, {\n    precision: 6\n  })) return false;\n  let overlap = 0;\n  switch (type1) {\n    case \"MultiPoint\":\n      for (var i = 0; i < geom1.coordinates.length; i++) {\n        for (var j = 0; j < geom2.coordinates.length; j++) {\n          var coord1 = geom1.coordinates[i];\n          var coord2 = geom2.coordinates[j];\n          if (coord1[0] === coord2[0] && coord1[1] === coord2[1]) {\n            return true;\n          }\n        }\n      }\n      return false;\n    case \"LineString\":\n    case \"MultiLineString\":\n      segmentEach(feature1, segment1 => {\n        segmentEach(feature2, segment2 => {\n          if (lineOverlap(segment1, segment2).features.length) overlap++;\n        });\n      });\n      break;\n    case \"Polygon\":\n    case \"MultiPolygon\":\n      segmentEach(feature1, segment1 => {\n        segmentEach(feature2, segment2 => {\n          if (lineIntersect(segment1, segment2).features.length) overlap++;\n        });\n      });\n      break;\n  }\n  return overlap > 0;\n}\nvar turf_boolean_overlap_default = booleanOverlap;\nexport { booleanOverlap, turf_boolean_overlap_default as default };","map":{"version":3,"names":["segmentEach","getGeom","lineOverlap","lineIntersect","geojsonEquality","booleanOverlap","feature1","feature2","geom1","geom2","type1","type","type2","Error","precision","overlap","i","coordinates","length","j","coord1","coord2","segment1","segment2","features","turf_boolean_overlap_default"],"sources":["/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/boolean-overlap/index.ts"],"sourcesContent":["import { Feature, Geometry, MultiPoint } from \"geojson\";\nimport { segmentEach } from \"@turf/meta\";\nimport { getGeom } from \"@turf/invariant\";\nimport { lineOverlap } from \"@turf/line-overlap\";\nimport { lineIntersect } from \"@turf/line-intersect\";\nimport { geojsonEquality } from \"geojson-equality-ts\";\n\n/**\n * Compares two geometries of the same dimension and returns true if their intersection set results in a geometry\n * different from both but of the same dimension. It applies to Polygon/Polygon, LineString/LineString,\n * Multipoint/Multipoint, MultiLineString/MultiLineString and MultiPolygon/MultiPolygon.\n *\n * In other words, it returns true if the two geometries overlap, provided that neither completely contains the other.\n *\n * @function\n * @param  {Geometry|Feature<LineString|MultiLineString|Polygon|MultiPolygon>} feature1 input\n * @param  {Geometry|Feature<LineString|MultiLineString|Polygon|MultiPolygon>} feature2 input\n * @returns {boolean} true/false\n * @example\n * var poly1 = turf.polygon([[[0,0],[0,5],[5,5],[5,0],[0,0]]]);\n * var poly2 = turf.polygon([[[1,1],[1,6],[6,6],[6,1],[1,1]]]);\n * var poly3 = turf.polygon([[[10,10],[10,15],[15,15],[15,10],[10,10]]]);\n *\n * turf.booleanOverlap(poly1, poly2)\n * //=true\n * turf.booleanOverlap(poly2, poly3)\n * //=false\n */\nfunction booleanOverlap(\n  feature1: Feature<any> | Geometry,\n  feature2: Feature<any> | Geometry\n): boolean {\n  const geom1 = getGeom(feature1);\n  const geom2 = getGeom(feature2);\n  const type1 = geom1.type;\n  const type2 = geom2.type;\n\n  if (\n    (type1 === \"MultiPoint\" && type2 !== \"MultiPoint\") ||\n    ((type1 === \"LineString\" || type1 === \"MultiLineString\") &&\n      type2 !== \"LineString\" &&\n      type2 !== \"MultiLineString\") ||\n    ((type1 === \"Polygon\" || type1 === \"MultiPolygon\") &&\n      type2 !== \"Polygon\" &&\n      type2 !== \"MultiPolygon\")\n  ) {\n    throw new Error(\"features must be of the same type\");\n  }\n  if (type1 === \"Point\") throw new Error(\"Point geometry not supported\");\n\n  // features must be not equal\n  if (geojsonEquality(feature1 as any, feature2 as any, { precision: 6 }))\n    return false;\n\n  let overlap = 0;\n\n  switch (type1) {\n    case \"MultiPoint\":\n      for (var i = 0; i < (geom1 as MultiPoint).coordinates.length; i++) {\n        for (var j = 0; j < (geom2 as MultiPoint).coordinates.length; j++) {\n          var coord1 = geom1.coordinates[i];\n          var coord2 = geom2.coordinates[j];\n          if (coord1[0] === coord2[0] && coord1[1] === coord2[1]) {\n            return true;\n          }\n        }\n      }\n      return false;\n\n    case \"LineString\":\n    case \"MultiLineString\":\n      segmentEach(feature1, (segment1) => {\n        segmentEach(feature2, (segment2) => {\n          if (lineOverlap(segment1!, segment2!).features.length) overlap++;\n        });\n      });\n      break;\n\n    case \"Polygon\":\n    case \"MultiPolygon\":\n      segmentEach(feature1, (segment1) => {\n        segmentEach(feature2, (segment2) => {\n          if (lineIntersect(segment1!, segment2!).features.length) overlap++;\n        });\n      });\n      break;\n  }\n\n  return overlap > 0;\n}\n\nexport { booleanOverlap };\nexport default booleanOverlap;\n"],"mappings":";AACA,SAASA,WAAA,QAAmB;AAC5B,SAASC,OAAA,QAAe;AACxB,SAASC,WAAA,QAAmB;AAC5B,SAASC,aAAA,QAAqB;AAC9B,SAASC,eAAA,QAAuB;AAuBhC,SAASC,eACPC,QAAA,EACAC,QAAA,EACS;EACT,MAAMC,KAAA,GAAQP,OAAA,CAAQK,QAAQ;EAC9B,MAAMG,KAAA,GAAQR,OAAA,CAAQM,QAAQ;EAC9B,MAAMG,KAAA,GAAQF,KAAA,CAAMG,IAAA;EACpB,MAAMC,KAAA,GAAQH,KAAA,CAAME,IAAA;EAEpB,IACGD,KAAA,KAAU,gBAAgBE,KAAA,KAAU,iBACnCF,KAAA,KAAU,gBAAgBA,KAAA,KAAU,sBACpCE,KAAA,KAAU,gBACVA,KAAA,KAAU,sBACVF,KAAA,KAAU,aAAaA,KAAA,KAAU,mBACjCE,KAAA,KAAU,aACVA,KAAA,KAAU,gBACZ;IACA,MAAM,IAAIC,KAAA,CAAM,mCAAmC;EACrD;EACA,IAAIH,KAAA,KAAU,SAAS,MAAM,IAAIG,KAAA,CAAM,8BAA8B;EAGrE,IAAIT,eAAA,CAAgBE,QAAA,EAAiBC,QAAA,EAAiB;IAAEO,SAAA,EAAW;EAAE,CAAC,GACpE,OAAO;EAET,IAAIC,OAAA,GAAU;EAEd,QAAQL,KAAA;IACN,KAAK;MACH,SAASM,CAAA,GAAI,GAAGA,CAAA,GAAKR,KAAA,CAAqBS,WAAA,CAAYC,MAAA,EAAQF,CAAA,IAAK;QACjE,SAASG,CAAA,GAAI,GAAGA,CAAA,GAAKV,KAAA,CAAqBQ,WAAA,CAAYC,MAAA,EAAQC,CAAA,IAAK;UACjE,IAAIC,MAAA,GAASZ,KAAA,CAAMS,WAAA,CAAYD,CAAC;UAChC,IAAIK,MAAA,GAASZ,KAAA,CAAMQ,WAAA,CAAYE,CAAC;UAChC,IAAIC,MAAA,CAAO,CAAC,MAAMC,MAAA,CAAO,CAAC,KAAKD,MAAA,CAAO,CAAC,MAAMC,MAAA,CAAO,CAAC,GAAG;YACtD,OAAO;UACT;QACF;MACF;MACA,OAAO;IAET,KAAK;IACL,KAAK;MACHrB,WAAA,CAAYM,QAAA,EAAWgB,QAAA,IAAa;QAClCtB,WAAA,CAAYO,QAAA,EAAWgB,QAAA,IAAa;UAClC,IAAIrB,WAAA,CAAYoB,QAAA,EAAWC,QAAS,EAAEC,QAAA,CAASN,MAAA,EAAQH,OAAA;QACzD,CAAC;MACH,CAAC;MACD;IAEF,KAAK;IACL,KAAK;MACHf,WAAA,CAAYM,QAAA,EAAWgB,QAAA,IAAa;QAClCtB,WAAA,CAAYO,QAAA,EAAWgB,QAAA,IAAa;UAClC,IAAIpB,aAAA,CAAcmB,QAAA,EAAWC,QAAS,EAAEC,QAAA,CAASN,MAAA,EAAQH,OAAA;QAC3D,CAAC;MACH,CAAC;MACD;EACJ;EAEA,OAAOA,OAAA,GAAU;AACnB;AAGA,IAAOU,4BAAA,GAAQpB,cAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}