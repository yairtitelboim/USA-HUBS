{"ast":null,"code":"// index.js\nimport { length } from \"@turf/length\";\nimport { lineSliceAlong } from \"@turf/line-slice-along\";\nimport { flattenEach } from \"@turf/meta\";\nimport { featureCollection, isObject } from \"@turf/helpers\";\nfunction lineChunk(geojson, segmentLength, options) {\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var units = options.units;\n  var reverse = options.reverse;\n  if (!geojson) throw new Error(\"geojson is required\");\n  if (segmentLength <= 0) throw new Error(\"segmentLength must be greater than 0\");\n  var results = [];\n  flattenEach(geojson, function (feature) {\n    if (reverse) feature.geometry.coordinates = feature.geometry.coordinates.reverse();\n    sliceLineSegments(feature, segmentLength, units, function (segment) {\n      results.push(segment);\n    });\n  });\n  return featureCollection(results);\n}\nfunction sliceLineSegments(line, segmentLength, units, callback) {\n  var lineLength = length(line, {\n    units\n  });\n  if (lineLength <= segmentLength) return callback(line);\n  var numberOfSegments = lineLength / segmentLength;\n  if (!Number.isInteger(numberOfSegments)) {\n    numberOfSegments = Math.floor(numberOfSegments) + 1;\n  }\n  for (var i = 0; i < numberOfSegments; i++) {\n    var outline = lineSliceAlong(line, segmentLength * i, segmentLength * (i + 1), {\n      units\n    });\n    callback(outline, i);\n  }\n}\nvar turf_line_chunk_default = lineChunk;\nexport { turf_line_chunk_default as default, lineChunk };","map":{"version":3,"names":["length","lineSliceAlong","flattenEach","featureCollection","isObject","lineChunk","geojson","segmentLength","options","Error","units","reverse","results","feature","geometry","coordinates","sliceLineSegments","segment","push","line","callback","lineLength","numberOfSegments","Number","isInteger","Math","floor","i","outline","turf_line_chunk_default"],"sources":["/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/line-chunk/index.js"],"sourcesContent":["import { length } from \"@turf/length\";\nimport { lineSliceAlong } from \"@turf/line-slice-along\";\nimport { flattenEach } from \"@turf/meta\";\nimport { featureCollection, isObject } from \"@turf/helpers\";\n\n/**\n * Divides a {@link LineString} into chunks of a specified length.\n * If the line is shorter than the segment length then the original line is returned.\n *\n * @function\n * @param {FeatureCollection|Geometry|Feature<LineString|MultiLineString>} geojson the lines to split\n * @param {number} segmentLength how long to make each segment\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] units can be degrees, radians, miles, or kilometers\n * @param {boolean} [options.reverse=false] reverses coordinates to start the first chunked segment at the end\n * @returns {FeatureCollection<LineString>} collection of line segments\n * @example\n * var line = turf.lineString([[-95, 40], [-93, 45], [-85, 50]]);\n *\n * var chunk = turf.lineChunk(line, 15, {units: 'miles'});\n *\n * //addToMap\n * var addToMap = [chunk];\n */\nfunction lineChunk(geojson, segmentLength, options) {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var units = options.units;\n  var reverse = options.reverse;\n\n  // Validation\n  if (!geojson) throw new Error(\"geojson is required\");\n  if (segmentLength <= 0)\n    throw new Error(\"segmentLength must be greater than 0\");\n\n  // Container\n  var results = [];\n\n  // Flatten each feature to simple LineString\n  flattenEach(geojson, function (feature) {\n    // reverses coordinates to start the first chunked segment at the end\n    if (reverse)\n      feature.geometry.coordinates = feature.geometry.coordinates.reverse();\n\n    sliceLineSegments(feature, segmentLength, units, function (segment) {\n      results.push(segment);\n    });\n  });\n  return featureCollection(results);\n}\n\n/**\n * Slice Line Segments\n *\n * @private\n * @param {Feature<LineString>} line GeoJSON LineString\n * @param {number} segmentLength how long to make each segment\n * @param {string}[units='kilometers'] units can be degrees, radians, miles, or kilometers\n * @param {Function} callback iterate over sliced line segments\n * @returns {void}\n */\nfunction sliceLineSegments(line, segmentLength, units, callback) {\n  var lineLength = length(line, { units: units });\n\n  // If the line is shorter than the segment length then the orginal line is returned.\n  if (lineLength <= segmentLength) return callback(line);\n\n  var numberOfSegments = lineLength / segmentLength;\n\n  // If numberOfSegments is integer, no need to plus 1\n  if (!Number.isInteger(numberOfSegments)) {\n    numberOfSegments = Math.floor(numberOfSegments) + 1;\n  }\n\n  for (var i = 0; i < numberOfSegments; i++) {\n    var outline = lineSliceAlong(\n      line,\n      segmentLength * i,\n      segmentLength * (i + 1),\n      { units: units }\n    );\n    callback(outline, i);\n  }\n}\n\nexport { lineChunk };\nexport default lineChunk;\n"],"mappings":";AAAA,SAASA,MAAA,QAAc;AACvB,SAASC,cAAA,QAAsB;AAC/B,SAASC,WAAA,QAAmB;AAC5B,SAASC,iBAAA,EAAmBC,QAAA,QAAgB;AAqB5C,SAASC,UAAUC,OAAA,EAASC,aAAA,EAAeC,OAAA,EAAS;EAElDA,OAAA,GAAUA,OAAA,IAAW,CAAC;EACtB,IAAI,CAACJ,QAAA,CAASI,OAAO,GAAG,MAAM,IAAIC,KAAA,CAAM,oBAAoB;EAC5D,IAAIC,KAAA,GAAQF,OAAA,CAAQE,KAAA;EACpB,IAAIC,OAAA,GAAUH,OAAA,CAAQG,OAAA;EAGtB,IAAI,CAACL,OAAA,EAAS,MAAM,IAAIG,KAAA,CAAM,qBAAqB;EACnD,IAAIF,aAAA,IAAiB,GACnB,MAAM,IAAIE,KAAA,CAAM,sCAAsC;EAGxD,IAAIG,OAAA,GAAU,EAAC;EAGfV,WAAA,CAAYI,OAAA,EAAS,UAAUO,OAAA,EAAS;IAEtC,IAAIF,OAAA,EACFE,OAAA,CAAQC,QAAA,CAASC,WAAA,GAAcF,OAAA,CAAQC,QAAA,CAASC,WAAA,CAAYJ,OAAA,CAAQ;IAEtEK,iBAAA,CAAkBH,OAAA,EAASN,aAAA,EAAeG,KAAA,EAAO,UAAUO,OAAA,EAAS;MAClEL,OAAA,CAAQM,IAAA,CAAKD,OAAO;IACtB,CAAC;EACH,CAAC;EACD,OAAOd,iBAAA,CAAkBS,OAAO;AAClC;AAYA,SAASI,kBAAkBG,IAAA,EAAMZ,aAAA,EAAeG,KAAA,EAAOU,QAAA,EAAU;EAC/D,IAAIC,UAAA,GAAarB,MAAA,CAAOmB,IAAA,EAAM;IAAET;EAAa,CAAC;EAG9C,IAAIW,UAAA,IAAcd,aAAA,EAAe,OAAOa,QAAA,CAASD,IAAI;EAErD,IAAIG,gBAAA,GAAmBD,UAAA,GAAad,aAAA;EAGpC,IAAI,CAACgB,MAAA,CAAOC,SAAA,CAAUF,gBAAgB,GAAG;IACvCA,gBAAA,GAAmBG,IAAA,CAAKC,KAAA,CAAMJ,gBAAgB,IAAI;EACpD;EAEA,SAASK,CAAA,GAAI,GAAGA,CAAA,GAAIL,gBAAA,EAAkBK,CAAA,IAAK;IACzC,IAAIC,OAAA,GAAU3B,cAAA,CACZkB,IAAA,EACAZ,aAAA,GAAgBoB,CAAA,EAChBpB,aAAA,IAAiBoB,CAAA,GAAI,IACrB;MAAEjB;IAAa,CACjB;IACAU,QAAA,CAASQ,OAAA,EAASD,CAAC;EACrB;AACF;AAGA,IAAOE,uBAAA,GAAQxB,SAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}