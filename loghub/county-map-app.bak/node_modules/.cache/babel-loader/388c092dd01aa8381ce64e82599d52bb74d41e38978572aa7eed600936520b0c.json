{"ast":null,"code":"// index.ts\nimport { lineString, multiLineString, multiPolygon, polygon } from \"@turf/helpers\";\nimport { getGeom } from \"@turf/invariant\";\n\n// lib/lineclip.ts\nfunction lineclip(points, bbox, result) {\n  var len = points.length,\n    codeA = bitCode(points[0], bbox),\n    part = [],\n    i,\n    codeB,\n    lastCode;\n  let a;\n  let b;\n  if (!result) result = [];\n  for (i = 1; i < len; i++) {\n    a = points[i - 1];\n    b = points[i];\n    codeB = lastCode = bitCode(b, bbox);\n    while (true) {\n      if (!(codeA | codeB)) {\n        part.push(a);\n        if (codeB !== lastCode) {\n          part.push(b);\n          if (i < len - 1) {\n            result.push(part);\n            part = [];\n          }\n        } else if (i === len - 1) {\n          part.push(b);\n        }\n        break;\n      } else if (codeA & codeB) {\n        break;\n      } else if (codeA) {\n        a = intersect(a, b, codeA, bbox);\n        codeA = bitCode(a, bbox);\n      } else {\n        b = intersect(a, b, codeB, bbox);\n        codeB = bitCode(b, bbox);\n      }\n    }\n    codeA = lastCode;\n  }\n  if (part.length) result.push(part);\n  return result;\n}\nfunction polygonclip(points, bbox) {\n  var result, edge, prev, prevInside, i, p, inside;\n  for (edge = 1; edge <= 8; edge *= 2) {\n    result = [];\n    prev = points[points.length - 1];\n    prevInside = !(bitCode(prev, bbox) & edge);\n    for (i = 0; i < points.length; i++) {\n      p = points[i];\n      inside = !(bitCode(p, bbox) & edge);\n      if (inside !== prevInside) result.push(intersect(prev, p, edge, bbox));\n      if (inside) result.push(p);\n      prev = p;\n      prevInside = inside;\n    }\n    points = result;\n    if (!points.length) break;\n  }\n  return result;\n}\nfunction intersect(a, b, edge, bbox) {\n  return edge & 8 ? [a[0] + (b[0] - a[0]) * (bbox[3] - a[1]) / (b[1] - a[1]), bbox[3]] : edge & 4 ? [a[0] + (b[0] - a[0]) * (bbox[1] - a[1]) / (b[1] - a[1]), bbox[1]] : edge & 2 ? [bbox[2], a[1] + (b[1] - a[1]) * (bbox[2] - a[0]) / (b[0] - a[0])] : edge & 1 ? [bbox[0], a[1] + (b[1] - a[1]) * (bbox[0] - a[0]) / (b[0] - a[0])] : null;\n}\nfunction bitCode(p, bbox) {\n  var code = 0;\n  if (p[0] < bbox[0]) code |= 1;else if (p[0] > bbox[2]) code |= 2;\n  if (p[1] < bbox[1]) code |= 4;else if (p[1] > bbox[3]) code |= 8;\n  return code;\n}\n\n// index.ts\nfunction bboxClip(feature, bbox) {\n  const geom = getGeom(feature);\n  const type = geom.type;\n  const properties = feature.type === \"Feature\" ? feature.properties : {};\n  let coords = geom.coordinates;\n  switch (type) {\n    case \"LineString\":\n    case \"MultiLineString\":\n      {\n        const lines = [];\n        if (type === \"LineString\") {\n          coords = [coords];\n        }\n        coords.forEach(line => {\n          lineclip(line, bbox, lines);\n        });\n        if (lines.length === 1) {\n          return lineString(lines[0], properties);\n        }\n        return multiLineString(lines, properties);\n      }\n    case \"Polygon\":\n      return polygon(clipPolygon(coords, bbox), properties);\n    case \"MultiPolygon\":\n      return multiPolygon(coords.map(poly => {\n        return clipPolygon(poly, bbox);\n      }), properties);\n    default:\n      throw new Error(\"geometry \" + type + \" not supported\");\n  }\n}\nfunction clipPolygon(rings, bbox) {\n  const outRings = [];\n  for (const ring of rings) {\n    const clipped = polygonclip(ring, bbox);\n    if (clipped.length > 0) {\n      if (clipped[0][0] !== clipped[clipped.length - 1][0] || clipped[0][1] !== clipped[clipped.length - 1][1]) {\n        clipped.push(clipped[0]);\n      }\n      if (clipped.length >= 4) {\n        outRings.push(clipped);\n      }\n    }\n  }\n  return outRings;\n}\nvar turf_bbox_clip_default = bboxClip;\nexport { bboxClip, turf_bbox_clip_default as default };","map":{"version":3,"names":["lineString","multiLineString","multiPolygon","polygon","getGeom","lineclip","points","bbox","result","len","length","codeA","bitCode","part","i","codeB","lastCode","a","b","push","intersect","polygonclip","edge","prev","prevInside","p","inside","code","bboxClip","feature","geom","type","properties","coords","coordinates","lines","forEach","line","clipPolygon","map","poly","Error","rings","outRings","ring","clipped","turf_bbox_clip_default"],"sources":["/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/bbox-clip/index.ts","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/bbox-clip/lib/lineclip.ts"],"sourcesContent":["import {\n  BBox,\n  Feature,\n  LineString,\n  MultiLineString,\n  MultiPolygon,\n  GeoJsonProperties,\n  Polygon,\n} from \"geojson\";\n\nimport {\n  lineString,\n  multiLineString,\n  multiPolygon,\n  polygon,\n} from \"@turf/helpers\";\nimport { getGeom } from \"@turf/invariant\";\nimport { lineclip, polygonclip } from \"./lib/lineclip.js\";\n\n/**\n * Takes a {@link Feature} and a bbox and clips the feature to the bbox using\n * [lineclip](https://github.com/mapbox/lineclip).\n * May result in degenerate edges when clipping Polygons.\n *\n * @function\n * @param {Feature<LineString|MultiLineString|Polygon|MultiPolygon>} feature feature to clip to the bbox\n * @param {BBox} bbox extent in [minX, minY, maxX, maxY] order\n * @returns {Feature<LineString|MultiLineString|Polygon|MultiPolygon>} clipped Feature\n * @example\n * var bbox = [0, 0, 10, 10];\n * var poly = turf.polygon([[[2, 2], [8, 4], [12, 8], [3, 7], [2, 2]]]);\n *\n * var clipped = turf.bboxClip(poly, bbox);\n *\n * //addToMap\n * var addToMap = [bbox, poly, clipped]\n */\nfunction bboxClip<\n  G extends Polygon | MultiPolygon | LineString | MultiLineString,\n  P extends GeoJsonProperties = GeoJsonProperties,\n>(feature: Feature<G, P> | G, bbox: BBox) {\n  const geom = getGeom(feature);\n  const type = geom.type;\n  const properties = feature.type === \"Feature\" ? feature.properties : {};\n  let coords: any[] = geom.coordinates;\n\n  switch (type) {\n    case \"LineString\":\n    case \"MultiLineString\": {\n      const lines: any[] = [];\n      if (type === \"LineString\") {\n        coords = [coords];\n      }\n      coords.forEach((line) => {\n        lineclip(line, bbox, lines);\n      });\n      if (lines.length === 1) {\n        return lineString(lines[0], properties);\n      }\n      return multiLineString(lines, properties);\n    }\n    case \"Polygon\":\n      return polygon(clipPolygon(coords, bbox), properties);\n    case \"MultiPolygon\":\n      return multiPolygon(\n        coords.map((poly) => {\n          return clipPolygon(poly, bbox);\n        }),\n        properties\n      );\n    default:\n      throw new Error(\"geometry \" + type + \" not supported\");\n  }\n}\n\nfunction clipPolygon(rings: number[][][], bbox: BBox) {\n  const outRings = [];\n  for (const ring of rings) {\n    const clipped = polygonclip(ring, bbox);\n    if (clipped.length > 0) {\n      if (\n        clipped[0][0] !== clipped[clipped.length - 1][0] ||\n        clipped[0][1] !== clipped[clipped.length - 1][1]\n      ) {\n        clipped.push(clipped[0]);\n      }\n      if (clipped.length >= 4) {\n        outRings.push(clipped);\n      }\n    }\n  }\n  return outRings;\n}\n\nexport { bboxClip };\nexport default bboxClip;\n","// Cohen-Sutherland line clipping algorithm, adapted to efficiently\n// handle polylines rather than just segments\nimport { BBox } from \"geojson\";\n\nexport function lineclip(\n  points: number[][],\n  bbox: BBox,\n  result?: number[][][]\n): number[][][] {\n  var len = points.length,\n    codeA = bitCode(points[0], bbox),\n    part = [] as number[][],\n    i,\n    codeB,\n    lastCode;\n  let a: number[];\n  let b: number[];\n\n  if (!result) result = [];\n\n  for (i = 1; i < len; i++) {\n    a = points[i - 1];\n    b = points[i];\n    codeB = lastCode = bitCode(b, bbox);\n\n    while (true) {\n      if (!(codeA | codeB)) {\n        // accept\n        part.push(a);\n\n        if (codeB !== lastCode) {\n          // segment went outside\n          part.push(b);\n\n          if (i < len - 1) {\n            // start a new line\n            result.push(part);\n            part = [];\n          }\n        } else if (i === len - 1) {\n          part.push(b);\n        }\n        break;\n      } else if (codeA & codeB) {\n        // trivial reject\n        break;\n      } else if (codeA) {\n        // a outside, intersect with clip edge\n        a = intersect(a, b, codeA, bbox)!;\n        codeA = bitCode(a, bbox);\n      } else {\n        // b outside\n        b = intersect(a, b, codeB, bbox)!;\n        codeB = bitCode(b, bbox);\n      }\n    }\n\n    codeA = lastCode;\n  }\n\n  if (part.length) result.push(part);\n\n  return result;\n}\n\n// Sutherland-Hodgeman polygon clipping algorithm\n\nexport function polygonclip(points: number[][], bbox: BBox): number[][] {\n  var result: number[][], edge, prev, prevInside, i, p, inside;\n\n  // clip against each side of the clip rectangle\n  for (edge = 1; edge <= 8; edge *= 2) {\n    result = [];\n    prev = points[points.length - 1];\n    prevInside = !(bitCode(prev, bbox) & edge);\n\n    for (i = 0; i < points.length; i++) {\n      p = points[i];\n      inside = !(bitCode(p, bbox) & edge);\n\n      // if segment goes through the clip window, add an intersection\n      if (inside !== prevInside) result.push(intersect(prev, p, edge, bbox)!);\n\n      if (inside) result.push(p); // add a point if it's inside\n\n      prev = p;\n      prevInside = inside;\n    }\n\n    points = result;\n\n    if (!points.length) break;\n  }\n\n  return result!;\n}\n\n// intersect a segment against one of the 4 lines that make up the bbox\n\nfunction intersect(\n  a: number[],\n  b: number[],\n  edge: number,\n  bbox: BBox\n): number[] | null {\n  return edge & 8\n    ? [a[0] + ((b[0] - a[0]) * (bbox[3] - a[1])) / (b[1] - a[1]), bbox[3]] // top\n    : edge & 4\n      ? [a[0] + ((b[0] - a[0]) * (bbox[1] - a[1])) / (b[1] - a[1]), bbox[1]] // bottom\n      : edge & 2\n        ? [bbox[2], a[1] + ((b[1] - a[1]) * (bbox[2] - a[0])) / (b[0] - a[0])] // right\n        : edge & 1\n          ? [bbox[0], a[1] + ((b[1] - a[1]) * (bbox[0] - a[0])) / (b[0] - a[0])] // left\n          : null;\n}\n\n// bit code reflects the point position relative to the bbox:\n\n//         left  mid  right\n//    top  1001  1000  1010\n//    mid  0001  0000  0010\n// bottom  0101  0100  0110\n\nfunction bitCode(p: number[], bbox: BBox) {\n  var code = 0;\n\n  if (p[0] < bbox[0]) code |= 1;\n  // left\n  else if (p[0] > bbox[2]) code |= 2; // right\n\n  if (p[1] < bbox[1]) code |= 4;\n  // bottom\n  else if (p[1] > bbox[3]) code |= 8; // top\n\n  return code;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}