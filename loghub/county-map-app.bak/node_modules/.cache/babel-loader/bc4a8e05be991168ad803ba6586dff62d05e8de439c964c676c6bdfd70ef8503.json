{"ast":null,"code":"// index.ts\nimport { bbox } from \"@turf/bbox\";\nimport { booleanPointInPolygon } from \"@turf/boolean-point-in-polygon\";\nimport { distance } from \"@turf/distance\";\nimport { transformScale as scale } from \"@turf/transform-scale\";\nimport { cleanCoords } from \"@turf/clean-coords\";\nimport { bboxPolygon } from \"@turf/bbox-polygon\";\nimport { getCoord, getGeom } from \"@turf/invariant\";\nimport { point, isNumber, lineString, isObject, featureCollection, feature } from \"@turf/helpers\";\n\n// lib/javascript-astar.js\nfunction pathTo(node) {\n  var curr = node,\n    path = [];\n  while (curr.parent) {\n    path.unshift(curr);\n    curr = curr.parent;\n  }\n  return path;\n}\nfunction getHeap() {\n  return new BinaryHeap(function (node) {\n    return node.f;\n  });\n}\nvar astar = {\n  /**\n   * Perform an A* Search on a graph given a start and end node.\n   *\n   * @private\n   * @memberof astar\n   * @param {Graph} graph Graph\n   * @param {GridNode} start Start\n   * @param {GridNode} end End\n   * @param {Object} [options] Options\n   * @param {bool} [options.closest] Specifies whether to return the path to the closest node if the target is unreachable.\n   * @param {Function} [options.heuristic] Heuristic function (see astar.heuristics).\n   * @returns {Object} Search\n   */\n  search: function (graph, start, end, options) {\n    var _a;\n    graph.cleanDirty();\n    options = options || {};\n    var heuristic = options.heuristic || astar.heuristics.manhattan,\n      closest = (_a = options.closest) != null ? _a : false;\n    var openHeap = getHeap(),\n      closestNode = start;\n    start.h = heuristic(start, end);\n    openHeap.push(start);\n    while (openHeap.size() > 0) {\n      var currentNode = openHeap.pop();\n      if (currentNode === end) {\n        return pathTo(currentNode);\n      }\n      currentNode.closed = true;\n      var neighbors = graph.neighbors(currentNode);\n      for (var i = 0, il = neighbors.length; i < il; ++i) {\n        var neighbor = neighbors[i];\n        if (neighbor.closed || neighbor.isWall()) {\n          continue;\n        }\n        var gScore = currentNode.g + neighbor.getCost(currentNode),\n          beenVisited = neighbor.visited;\n        if (!beenVisited || gScore < neighbor.g) {\n          neighbor.visited = true;\n          neighbor.parent = currentNode;\n          neighbor.h = neighbor.h || heuristic(neighbor, end);\n          neighbor.g = gScore;\n          neighbor.f = neighbor.g + neighbor.h;\n          graph.markDirty(neighbor);\n          if (closest) {\n            if (neighbor.h < closestNode.h || neighbor.h === closestNode.h && neighbor.g < closestNode.g) {\n              closestNode = neighbor;\n            }\n          }\n          if (!beenVisited) {\n            openHeap.push(neighbor);\n          } else {\n            openHeap.rescoreElement(neighbor);\n          }\n        }\n      }\n    }\n    if (closest) {\n      return pathTo(closestNode);\n    }\n    return [];\n  },\n  // See list of heuristics: http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html\n  heuristics: {\n    manhattan: function (pos0, pos1) {\n      var d1 = Math.abs(pos1.x - pos0.x);\n      var d2 = Math.abs(pos1.y - pos0.y);\n      return d1 + d2;\n    },\n    diagonal: function (pos0, pos1) {\n      var D = 1;\n      var D2 = Math.sqrt(2);\n      var d1 = Math.abs(pos1.x - pos0.x);\n      var d2 = Math.abs(pos1.y - pos0.y);\n      return D * (d1 + d2) + (D2 - 2 * D) * Math.min(d1, d2);\n    }\n  },\n  cleanNode: function (node) {\n    node.f = 0;\n    node.g = 0;\n    node.h = 0;\n    node.visited = false;\n    node.closed = false;\n    node.parent = null;\n  }\n};\nfunction Graph(gridIn, options) {\n  options = options || {};\n  this.nodes = [];\n  this.diagonal = !!options.diagonal;\n  this.grid = [];\n  for (var x = 0; x < gridIn.length; x++) {\n    this.grid[x] = [];\n    for (var y = 0, row = gridIn[x]; y < row.length; y++) {\n      var node = new GridNode(x, y, row[y]);\n      this.grid[x][y] = node;\n      this.nodes.push(node);\n    }\n  }\n  this.init();\n}\nGraph.prototype.init = function () {\n  this.dirtyNodes = [];\n  for (var i = 0; i < this.nodes.length; i++) {\n    astar.cleanNode(this.nodes[i]);\n  }\n};\nGraph.prototype.cleanDirty = function () {\n  for (var i = 0; i < this.dirtyNodes.length; i++) {\n    astar.cleanNode(this.dirtyNodes[i]);\n  }\n  this.dirtyNodes = [];\n};\nGraph.prototype.markDirty = function (node) {\n  this.dirtyNodes.push(node);\n};\nGraph.prototype.neighbors = function (node) {\n  var ret = [],\n    x = node.x,\n    y = node.y,\n    grid = this.grid;\n  if (grid[x - 1] && grid[x - 1][y]) {\n    ret.push(grid[x - 1][y]);\n  }\n  if (grid[x + 1] && grid[x + 1][y]) {\n    ret.push(grid[x + 1][y]);\n  }\n  if (grid[x] && grid[x][y - 1]) {\n    ret.push(grid[x][y - 1]);\n  }\n  if (grid[x] && grid[x][y + 1]) {\n    ret.push(grid[x][y + 1]);\n  }\n  if (this.diagonal) {\n    if (grid[x - 1] && grid[x - 1][y - 1]) {\n      ret.push(grid[x - 1][y - 1]);\n    }\n    if (grid[x + 1] && grid[x + 1][y - 1]) {\n      ret.push(grid[x + 1][y - 1]);\n    }\n    if (grid[x - 1] && grid[x - 1][y + 1]) {\n      ret.push(grid[x - 1][y + 1]);\n    }\n    if (grid[x + 1] && grid[x + 1][y + 1]) {\n      ret.push(grid[x + 1][y + 1]);\n    }\n  }\n  return ret;\n};\nGraph.prototype.toString = function () {\n  var graphString = [],\n    nodes = this.grid,\n    rowDebug,\n    row,\n    y,\n    l;\n  for (var x = 0, len = nodes.length; x < len; x++) {\n    rowDebug = [];\n    row = nodes[x];\n    for (y = 0, l = row.length; y < l; y++) {\n      rowDebug.push(row[y].weight);\n    }\n    graphString.push(rowDebug.join(\" \"));\n  }\n  return graphString.join(\"\\n\");\n};\nfunction GridNode(x, y, weight) {\n  this.x = x;\n  this.y = y;\n  this.weight = weight;\n}\nGridNode.prototype.toString = function () {\n  return \"[\" + this.x + \" \" + this.y + \"]\";\n};\nGridNode.prototype.getCost = function (fromNeighbor) {\n  if (fromNeighbor && fromNeighbor.x !== this.x && fromNeighbor.y !== this.y) {\n    return this.weight * 1.41421;\n  }\n  return this.weight;\n};\nGridNode.prototype.isWall = function () {\n  return this.weight === 0;\n};\nfunction BinaryHeap(scoreFunction) {\n  this.content = [];\n  this.scoreFunction = scoreFunction;\n}\nBinaryHeap.prototype = {\n  push: function (element) {\n    this.content.push(element);\n    this.sinkDown(this.content.length - 1);\n  },\n  pop: function () {\n    var result = this.content[0];\n    var end = this.content.pop();\n    if (this.content.length > 0) {\n      this.content[0] = end;\n      this.bubbleUp(0);\n    }\n    return result;\n  },\n  remove: function (node) {\n    var i = this.content.indexOf(node);\n    var end = this.content.pop();\n    if (i !== this.content.length - 1) {\n      this.content[i] = end;\n      if (this.scoreFunction(end) < this.scoreFunction(node)) {\n        this.sinkDown(i);\n      } else {\n        this.bubbleUp(i);\n      }\n    }\n  },\n  size: function () {\n    return this.content.length;\n  },\n  rescoreElement: function (node) {\n    this.sinkDown(this.content.indexOf(node));\n  },\n  sinkDown: function (n) {\n    var element = this.content[n];\n    while (n > 0) {\n      var parentN = (n + 1 >> 1) - 1,\n        parent = this.content[parentN];\n      if (this.scoreFunction(element) < this.scoreFunction(parent)) {\n        this.content[parentN] = element;\n        this.content[n] = parent;\n        n = parentN;\n      } else {\n        break;\n      }\n    }\n  },\n  bubbleUp: function (n) {\n    var length = this.content.length,\n      element = this.content[n],\n      elemScore = this.scoreFunction(element);\n    while (true) {\n      var child2N = n + 1 << 1,\n        child1N = child2N - 1;\n      var swap = null,\n        child1Score;\n      if (child1N < length) {\n        var child1 = this.content[child1N];\n        child1Score = this.scoreFunction(child1);\n        if (child1Score < elemScore) {\n          swap = child1N;\n        }\n      }\n      if (child2N < length) {\n        var child2 = this.content[child2N],\n          child2Score = this.scoreFunction(child2);\n        if (child2Score < (swap === null ? elemScore : child1Score)) {\n          swap = child2N;\n        }\n      }\n      if (swap !== null) {\n        this.content[n] = this.content[swap];\n        this.content[swap] = element;\n        n = swap;\n      } else {\n        break;\n      }\n    }\n  }\n};\n\n// index.ts\nfunction shortestPath(start, end, options = {}) {\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  let obstacles = options.obstacles || featureCollection([]);\n  let resolution = options.resolution || 100;\n  if (!start) throw new Error(\"start is required\");\n  if (!end) throw new Error(\"end is required\");\n  if (resolution && (!isNumber(resolution) || resolution <= 0)) throw new Error(\"options.resolution must be a number, greater than 0\");\n  const startCoord = getCoord(start);\n  const endCoord = getCoord(end);\n  start = point(startCoord);\n  end = point(endCoord);\n  if (obstacles.type === \"FeatureCollection\") {\n    if (obstacles.features.length === 0) {\n      return lineString([startCoord, endCoord]);\n    }\n  } else if (obstacles.type === \"Polygon\") {\n    obstacles = featureCollection([feature(getGeom(obstacles))]);\n  } else {\n    throw new Error(\"invalid obstacles\");\n  }\n  const collection = obstacles;\n  collection.features.push(start);\n  collection.features.push(end);\n  const box = bbox(scale(bboxPolygon(bbox(collection)), 1.15));\n  const [west, south, east, north] = box;\n  const width = distance([west, south], [east, south], options);\n  const division = width / resolution;\n  collection.features.pop();\n  collection.features.pop();\n  const xFraction = division / distance([west, south], [east, south], options);\n  const cellWidth = xFraction * (east - west);\n  const yFraction = division / distance([west, south], [west, north], options);\n  const cellHeight = yFraction * (north - south);\n  const bboxHorizontalSide = east - west;\n  const bboxVerticalSide = north - south;\n  const columns = Math.floor(bboxHorizontalSide / cellWidth);\n  const rows = Math.floor(bboxVerticalSide / cellHeight);\n  const deltaX = (bboxHorizontalSide - columns * cellWidth) / 2;\n  const deltaY = (bboxVerticalSide - rows * cellHeight) / 2;\n  const pointMatrix = [];\n  const matrix = [];\n  let closestToStart;\n  let closestToEnd;\n  let minDistStart = Infinity;\n  let minDistEnd = Infinity;\n  let currentY = north - deltaY;\n  let r = 0;\n  while (currentY >= south) {\n    const matrixRow = [];\n    const pointMatrixRow = [];\n    let currentX = west + deltaX;\n    let c = 0;\n    while (currentX <= east) {\n      const pt = point([currentX, currentY]);\n      const isInsideObstacle = isInside(pt, obstacles);\n      matrixRow.push(isInsideObstacle ? 0 : 1);\n      pointMatrixRow.push(currentX + \"|\" + currentY);\n      const distStart = distance(pt, start);\n      if (!isInsideObstacle && distStart < minDistStart) {\n        minDistStart = distStart;\n        closestToStart = {\n          x: c,\n          y: r\n        };\n      }\n      const distEnd = distance(pt, end);\n      if (!isInsideObstacle && distEnd < minDistEnd) {\n        minDistEnd = distEnd;\n        closestToEnd = {\n          x: c,\n          y: r\n        };\n      }\n      currentX += cellWidth;\n      c++;\n    }\n    matrix.push(matrixRow);\n    pointMatrix.push(pointMatrixRow);\n    currentY -= cellHeight;\n    r++;\n  }\n  const graph = new Graph(matrix, {\n    diagonal: true\n  });\n  const startOnMatrix = graph.grid[closestToStart.y][closestToStart.x];\n  const endOnMatrix = graph.grid[closestToEnd.y][closestToEnd.x];\n  const result = astar.search(graph, startOnMatrix, endOnMatrix);\n  const path = [startCoord];\n  result.forEach(function (coord) {\n    const coords = pointMatrix[coord.x][coord.y].split(\"|\");\n    path.push([+coords[0], +coords[1]]);\n  });\n  path.push(endCoord);\n  return cleanCoords(lineString(path));\n}\nfunction isInside(pt, polygons) {\n  for (let i = 0; i < polygons.features.length; i++) {\n    if (booleanPointInPolygon(pt, polygons.features[i])) {\n      return true;\n    }\n  }\n  return false;\n}\nvar turf_shortest_path_default = shortestPath;\nexport { turf_shortest_path_default as default, shortestPath };","map":{"version":3,"names":["bbox","booleanPointInPolygon","distance","transformScale","scale","cleanCoords","bboxPolygon","getCoord","getGeom","point","isNumber","lineString","isObject","featureCollection","feature","pathTo","node","curr","path","parent","unshift","getHeap","BinaryHeap","f","astar","search","graph","start","end","options","_a","cleanDirty","heuristic","heuristics","manhattan","closest","openHeap","closestNode","h","push","size","currentNode","pop","closed","neighbors","i","il","length","neighbor","isWall","gScore","g","getCost","beenVisited","visited","markDirty","rescoreElement","pos0","pos1","d1","Math","abs","x","d2","y","diagonal","D","D2","sqrt","min","cleanNode","Graph","gridIn","nodes","grid","row","GridNode","init","prototype","dirtyNodes","ret","toString","graphString","rowDebug","l","len","weight","join","fromNeighbor","scoreFunction","content","element","sinkDown","result","bubbleUp","remove","indexOf","n","parentN","elemScore","child2N","child1N","swap","child1Score","child1","child2","child2Score","shortestPath","Error","obstacles","resolution","startCoord","endCoord","type","features","collection","box","west","south","east","north","width","division","xFraction","cellWidth","yFraction","cellHeight","bboxHorizontalSide","bboxVerticalSide","columns","floor","rows","deltaX","deltaY","pointMatrix","matrix","closestToStart","closestToEnd","minDistStart","Infinity","minDistEnd","currentY","r","matrixRow","pointMatrixRow","currentX","c","pt","isInsideObstacle","isInside","distStart","distEnd","startOnMatrix","endOnMatrix","forEach","coord","coords","split","polygons","turf_shortest_path_default"],"sources":["/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/shortest-path/index.ts","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/shortest-path/lib/javascript-astar.js"],"sourcesContent":["import {\n  Polygon,\n  Feature,\n  FeatureCollection,\n  LineString,\n  Geometry,\n  Point,\n} from \"geojson\";\nimport { bbox } from \"@turf/bbox\";\nimport { booleanPointInPolygon } from \"@turf/boolean-point-in-polygon\";\nimport { distance } from \"@turf/distance\";\nimport { transformScale as scale } from \"@turf/transform-scale\";\nimport { cleanCoords } from \"@turf/clean-coords\";\nimport { bboxPolygon } from \"@turf/bbox-polygon\";\nimport { getCoord, getGeom } from \"@turf/invariant\";\nimport {\n  Coord,\n  Units,\n  point,\n  isNumber,\n  lineString,\n  isObject,\n  featureCollection,\n  feature,\n} from \"@turf/helpers\";\nimport { Graph, GridNode, astar } from \"./lib/javascript-astar.js\";\n\n/**\n * Returns the shortest {@link LineString|path} from {@link Point|start} to {@link Point|end} without colliding with\n * any {@link Feature} in obstacles {@link FeatureCollection}<{@link Polygon}>\n *\n * @function\n * @param {Coord} start point\n * @param {Coord} end point\n * @param {Object} [options={}] optional parameters\n * @param {Polygon|Feature<Polygon>|FeatureCollection<Polygon>} [options.obstacles] areas which path cannot travel\n * @param {Units} [options.units='kilometers'] unit in which resolution & minimum distance will be expressed in; it can be degrees, radians, miles, kilometers, ...\n * @param {number} [options.resolution=100] distance between matrix points on which the path will be calculated\n * @returns {Feature<LineString>} shortest path between start and end\n * @example\n * var start = [-5, -6];\n * var end = [9, -6];\n * var options = {\n *   obstacles: turf.polygon([[[0, -7], [5, -7], [5, -3], [0, -3], [0, -7]]]).geometry\n * };\n *\n * var path = turf.shortestPath(start, end, options);\n *\n * //addToMap\n * var addToMap = [start, end, options.obstacles, path];\n */\nfunction shortestPath(\n  start: Coord,\n  end: Coord,\n  options: {\n    obstacles?: Polygon | Feature<Polygon> | FeatureCollection<Polygon>;\n    units?: Units;\n    resolution?: number;\n  } = {}\n): Feature<LineString> {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  let obstacles = options.obstacles || featureCollection([]);\n  let resolution = options.resolution || 100;\n\n  // validation\n  if (!start) throw new Error(\"start is required\");\n  if (!end) throw new Error(\"end is required\");\n  if (resolution && (!isNumber(resolution) || resolution <= 0))\n    throw new Error(\"options.resolution must be a number, greater than 0\");\n\n  // Normalize Inputs\n  const startCoord = getCoord(start);\n  const endCoord = getCoord(end);\n  start = point(startCoord);\n  end = point(endCoord);\n\n  // Handle obstacles\n  if (obstacles.type === \"FeatureCollection\") {\n    if (obstacles.features.length === 0) {\n      return lineString([startCoord, endCoord]);\n    }\n  } else if (obstacles.type === \"Polygon\") {\n    obstacles = featureCollection([feature(getGeom(obstacles))]);\n  } else {\n    throw new Error(\"invalid obstacles\");\n  }\n\n  // define path grid area\n  const collection: FeatureCollection<Geometry> = obstacles;\n  collection.features.push(start);\n  collection.features.push(end);\n  const box = bbox(scale(bboxPolygon(bbox(collection)), 1.15)); // extend 15%\n  const [west, south, east, north] = box;\n\n  const width = distance([west, south], [east, south], options);\n  const division = width / resolution;\n\n  collection.features.pop();\n  collection.features.pop();\n\n  const xFraction = division / distance([west, south], [east, south], options);\n  const cellWidth = xFraction * (east - west);\n  const yFraction = division / distance([west, south], [west, north], options);\n  const cellHeight = yFraction * (north - south);\n\n  const bboxHorizontalSide = east - west;\n  const bboxVerticalSide = north - south;\n  const columns = Math.floor(bboxHorizontalSide / cellWidth);\n  const rows = Math.floor(bboxVerticalSide / cellHeight);\n  // adjust origin of the grid\n  const deltaX = (bboxHorizontalSide - columns * cellWidth) / 2;\n  const deltaY = (bboxVerticalSide - rows * cellHeight) / 2;\n\n  // loop through points only once to speed up process\n  // define matrix grid for A-star algorithm\n  const pointMatrix: string[][] = [];\n  const matrix: number[][] = [];\n\n  let closestToStart: GridNode;\n  let closestToEnd: GridNode;\n  let minDistStart = Infinity;\n  let minDistEnd = Infinity;\n  let currentY = north - deltaY;\n  let r = 0;\n  while (currentY >= south) {\n    // var currentY = south + deltaY;\n    const matrixRow = [];\n    const pointMatrixRow = [];\n    let currentX = west + deltaX;\n    let c = 0;\n    while (currentX <= east) {\n      const pt = point([currentX, currentY]);\n      const isInsideObstacle = isInside(pt, obstacles);\n      // feed obstacles matrix\n      matrixRow.push(isInsideObstacle ? 0 : 1); // with javascript-astar\n      // matrixRow.push(isInsideObstacle ? 1 : 0); // with astar-andrea\n      // map point's coords\n      pointMatrixRow.push(currentX + \"|\" + currentY);\n      // set closest points\n      const distStart = distance(pt, start);\n      // if (distStart < minDistStart) {\n      if (!isInsideObstacle && distStart < minDistStart) {\n        minDistStart = distStart;\n        closestToStart = { x: c, y: r };\n      }\n      const distEnd = distance(pt, end);\n      // if (distEnd < minDistEnd) {\n      if (!isInsideObstacle && distEnd < minDistEnd) {\n        minDistEnd = distEnd;\n        closestToEnd = { x: c, y: r };\n      }\n      currentX += cellWidth;\n      c++;\n    }\n    matrix.push(matrixRow);\n    pointMatrix.push(pointMatrixRow);\n    currentY -= cellHeight;\n    r++;\n  }\n\n  // find path on matrix grid\n\n  // javascript-astar ----------------------\n  const graph = new Graph(matrix, { diagonal: true });\n  const startOnMatrix = graph.grid[closestToStart!.y][closestToStart!.x];\n  const endOnMatrix = graph.grid[closestToEnd!.y][closestToEnd!.x];\n  const result: GridNode[] = astar.search(graph, startOnMatrix, endOnMatrix);\n\n  const path = [startCoord];\n  result.forEach(function (coord) {\n    const coords = pointMatrix[coord.x][coord.y].split(\"|\");\n    path.push([+coords[0], +coords[1]]); // make sure coords are numbers\n  });\n  path.push(endCoord);\n  // ---------------------------------------\n\n  // astar-andrea ------------------------\n  // var result = aStar(matrix, [closestToStart.x, closestToStart.y], [closestToEnd.x, closestToEnd.y], 'DiagonalFree');\n  // var path = [start.geometry.coordinates];\n  // result.forEach(function (coord) {\n  //     var coords = pointMatrix[coord[1]][coord[0]].split('|');\n  //     path.push([+coords[0], +coords[1]]); // make sure coords are numbers\n  // });\n  // path.push(end.geometry.coordinates);\n  // ---------------------------------------\n\n  return cleanCoords(lineString(path));\n}\n\n/**\n * Checks if Point is inside any of the Polygons\n *\n * @private\n * @param {Feature<Point>} pt to check\n * @param {FeatureCollection<Polygon>} polygons features\n * @returns {boolean} if inside or not\n */\nfunction isInside(pt: Feature<Point>, polygons: FeatureCollection<Polygon>) {\n  for (let i = 0; i < polygons.features.length; i++) {\n    if (booleanPointInPolygon(pt, polygons.features[i])) {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport { shortestPath };\nexport default shortestPath;\n","// javascript-astar 0.4.1\n// http://github.com/bgrins/javascript-astar\n// Freely distributable under the MIT License.\n// Implements the astar search algorithm in javascript using a Binary Heap.\n// Includes Binary Heap (with modifications) from Marijn Haverbeke.\n// http://eloquentjavascript.net/appendix2.html\n\nfunction pathTo(node) {\n  var curr = node,\n    path = [];\n  while (curr.parent) {\n    path.unshift(curr);\n    curr = curr.parent;\n  }\n  return path;\n}\n\nfunction getHeap() {\n  return new BinaryHeap(function (node) {\n    return node.f;\n  });\n}\n\n/**\n * Astar\n * @private\n */\nexport var astar = {\n  /**\n   * Perform an A* Search on a graph given a start and end node.\n   *\n   * @private\n   * @memberof astar\n   * @param {Graph} graph Graph\n   * @param {GridNode} start Start\n   * @param {GridNode} end End\n   * @param {Object} [options] Options\n   * @param {bool} [options.closest] Specifies whether to return the path to the closest node if the target is unreachable.\n   * @param {Function} [options.heuristic] Heuristic function (see astar.heuristics).\n   * @returns {Object} Search\n   */\n  search: function (graph, start, end, options) {\n    graph.cleanDirty();\n    options = options || {};\n    var heuristic = options.heuristic || astar.heuristics.manhattan,\n      closest = options.closest ?? false;\n\n    var openHeap = getHeap(),\n      closestNode = start; // set the start node to be the closest if required\n\n    start.h = heuristic(start, end);\n\n    openHeap.push(start);\n\n    while (openHeap.size() > 0) {\n      // Grab the lowest f(x) to process next.  Heap keeps this sorted for us.\n      var currentNode = openHeap.pop();\n\n      // End case -- result has been found, return the traced path.\n      if (currentNode === end) {\n        return pathTo(currentNode);\n      }\n\n      // Normal case -- move currentNode from open to closed, process each of its neighbors.\n      currentNode.closed = true;\n\n      // Find all neighbors for the current node.\n      var neighbors = graph.neighbors(currentNode);\n\n      for (var i = 0, il = neighbors.length; i < il; ++i) {\n        var neighbor = neighbors[i];\n\n        if (neighbor.closed || neighbor.isWall()) {\n          // Not a valid node to process, skip to next neighbor.\n          continue;\n        }\n\n        // The g score is the shortest distance from start to current node.\n        // We need to check if the path we have arrived at this neighbor is the shortest one we have seen yet.\n        var gScore = currentNode.g + neighbor.getCost(currentNode),\n          beenVisited = neighbor.visited;\n\n        if (!beenVisited || gScore < neighbor.g) {\n          // Found an optimal (so far) path to this node.  Take score for node to see how good it is.\n          neighbor.visited = true;\n          neighbor.parent = currentNode;\n          neighbor.h = neighbor.h || heuristic(neighbor, end);\n          neighbor.g = gScore;\n          neighbor.f = neighbor.g + neighbor.h;\n          graph.markDirty(neighbor);\n          if (closest) {\n            // If the neighbour is closer than the current closestNode or if it's equally close but has\n            // a cheaper path than the current closest node then it becomes the closest node\n            if (\n              neighbor.h < closestNode.h ||\n              (neighbor.h === closestNode.h && neighbor.g < closestNode.g)\n            ) {\n              closestNode = neighbor;\n            }\n          }\n\n          if (!beenVisited) {\n            // Pushing to heap will put it in proper place based on the 'f' value.\n            openHeap.push(neighbor);\n          } else {\n            // Already seen the node, but since it has been rescored we need to reorder it in the heap\n            openHeap.rescoreElement(neighbor);\n          }\n        }\n      }\n    }\n\n    if (closest) {\n      return pathTo(closestNode);\n    }\n\n    // No result was found - empty array signifies failure to find path.\n    return [];\n  },\n  // See list of heuristics: http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html\n  heuristics: {\n    manhattan: function (pos0, pos1) {\n      var d1 = Math.abs(pos1.x - pos0.x);\n      var d2 = Math.abs(pos1.y - pos0.y);\n      return d1 + d2;\n    },\n    diagonal: function (pos0, pos1) {\n      var D = 1;\n      var D2 = Math.sqrt(2);\n      var d1 = Math.abs(pos1.x - pos0.x);\n      var d2 = Math.abs(pos1.y - pos0.y);\n      return D * (d1 + d2) + (D2 - 2 * D) * Math.min(d1, d2);\n    },\n  },\n  cleanNode: function (node) {\n    node.f = 0;\n    node.g = 0;\n    node.h = 0;\n    node.visited = false;\n    node.closed = false;\n    node.parent = null;\n  },\n};\n\n/**\n * A graph memory structure\n *\n * @private\n * @param {Array} gridIn 2D array of input weights\n * @param {Object} [options] Options\n * @param {boolean} [options.diagonal] Specifies whether diagonal moves are allowed\n * @returns {void} Graph\n */\nexport function Graph(gridIn, options) {\n  options = options || {};\n  this.nodes = [];\n  this.diagonal = !!options.diagonal;\n  this.grid = [];\n  for (var x = 0; x < gridIn.length; x++) {\n    this.grid[x] = [];\n\n    for (var y = 0, row = gridIn[x]; y < row.length; y++) {\n      var node = new GridNode(x, y, row[y]);\n      this.grid[x][y] = node;\n      this.nodes.push(node);\n    }\n  }\n  this.init();\n}\n\nGraph.prototype.init = function () {\n  this.dirtyNodes = [];\n  for (var i = 0; i < this.nodes.length; i++) {\n    astar.cleanNode(this.nodes[i]);\n  }\n};\n\nGraph.prototype.cleanDirty = function () {\n  for (var i = 0; i < this.dirtyNodes.length; i++) {\n    astar.cleanNode(this.dirtyNodes[i]);\n  }\n  this.dirtyNodes = [];\n};\n\nGraph.prototype.markDirty = function (node) {\n  this.dirtyNodes.push(node);\n};\n\nGraph.prototype.neighbors = function (node) {\n  var ret = [],\n    x = node.x,\n    y = node.y,\n    grid = this.grid;\n\n  // West\n  if (grid[x - 1] && grid[x - 1][y]) {\n    ret.push(grid[x - 1][y]);\n  }\n\n  // East\n  if (grid[x + 1] && grid[x + 1][y]) {\n    ret.push(grid[x + 1][y]);\n  }\n\n  // South\n  if (grid[x] && grid[x][y - 1]) {\n    ret.push(grid[x][y - 1]);\n  }\n\n  // North\n  if (grid[x] && grid[x][y + 1]) {\n    ret.push(grid[x][y + 1]);\n  }\n\n  if (this.diagonal) {\n    // Southwest\n    if (grid[x - 1] && grid[x - 1][y - 1]) {\n      ret.push(grid[x - 1][y - 1]);\n    }\n\n    // Southeast\n    if (grid[x + 1] && grid[x + 1][y - 1]) {\n      ret.push(grid[x + 1][y - 1]);\n    }\n\n    // Northwest\n    if (grid[x - 1] && grid[x - 1][y + 1]) {\n      ret.push(grid[x - 1][y + 1]);\n    }\n\n    // Northeast\n    if (grid[x + 1] && grid[x + 1][y + 1]) {\n      ret.push(grid[x + 1][y + 1]);\n    }\n  }\n\n  return ret;\n};\n\nGraph.prototype.toString = function () {\n  var graphString = [],\n    nodes = this.grid, // when using grid\n    rowDebug,\n    row,\n    y,\n    l;\n  for (var x = 0, len = nodes.length; x < len; x++) {\n    rowDebug = [];\n    row = nodes[x];\n    for (y = 0, l = row.length; y < l; y++) {\n      rowDebug.push(row[y].weight);\n    }\n    graphString.push(rowDebug.join(\" \"));\n  }\n  return graphString.join(\"\\n\");\n};\n\nfunction GridNode(x, y, weight) {\n  this.x = x;\n  this.y = y;\n  this.weight = weight;\n}\n\nGridNode.prototype.toString = function () {\n  return \"[\" + this.x + \" \" + this.y + \"]\";\n};\n\nGridNode.prototype.getCost = function (fromNeighbor) {\n  // Take diagonal weight into consideration.\n  if (fromNeighbor && fromNeighbor.x !== this.x && fromNeighbor.y !== this.y) {\n    return this.weight * 1.41421;\n  }\n  return this.weight;\n};\n\nGridNode.prototype.isWall = function () {\n  return this.weight === 0;\n};\n\nfunction BinaryHeap(scoreFunction) {\n  this.content = [];\n  this.scoreFunction = scoreFunction;\n}\n\nBinaryHeap.prototype = {\n  push: function (element) {\n    // Add the new element to the end of the array.\n    this.content.push(element);\n\n    // Allow it to sink down.\n    this.sinkDown(this.content.length - 1);\n  },\n  pop: function () {\n    // Store the first element so we can return it later.\n    var result = this.content[0];\n    // Get the element at the end of the array.\n    var end = this.content.pop();\n    // If there are any elements left, put the end element at the\n    // start, and let it bubble up.\n    if (this.content.length > 0) {\n      this.content[0] = end;\n      this.bubbleUp(0);\n    }\n    return result;\n  },\n  remove: function (node) {\n    var i = this.content.indexOf(node);\n\n    // When it is found, the process seen in 'pop' is repeated\n    // to fill up the hole.\n    var end = this.content.pop();\n\n    if (i !== this.content.length - 1) {\n      this.content[i] = end;\n\n      if (this.scoreFunction(end) < this.scoreFunction(node)) {\n        this.sinkDown(i);\n      } else {\n        this.bubbleUp(i);\n      }\n    }\n  },\n  size: function () {\n    return this.content.length;\n  },\n  rescoreElement: function (node) {\n    this.sinkDown(this.content.indexOf(node));\n  },\n  sinkDown: function (n) {\n    // Fetch the element that has to be sunk.\n    var element = this.content[n];\n\n    // When at 0, an element can not sink any further.\n    while (n > 0) {\n      // Compute the parent element's index, and fetch it.\n      var parentN = ((n + 1) >> 1) - 1,\n        parent = this.content[parentN];\n      // Swap the elements if the parent is greater.\n      if (this.scoreFunction(element) < this.scoreFunction(parent)) {\n        this.content[parentN] = element;\n        this.content[n] = parent;\n        // Update 'n' to continue at the new position.\n        n = parentN;\n        // Found a parent that is less, no need to sink any further.\n      } else {\n        break;\n      }\n    }\n  },\n  bubbleUp: function (n) {\n    // Look up the target element and its score.\n    var length = this.content.length,\n      element = this.content[n],\n      elemScore = this.scoreFunction(element);\n\n    while (true) {\n      // Compute the indices of the child elements.\n      var child2N = (n + 1) << 1,\n        child1N = child2N - 1;\n      // This is used to store the new position of the element, if any.\n      var swap = null,\n        child1Score;\n      // If the first child exists (is inside the array)...\n      if (child1N < length) {\n        // Look it up and compute its score.\n        var child1 = this.content[child1N];\n        child1Score = this.scoreFunction(child1);\n\n        // If the score is less than our element's, we need to swap.\n        if (child1Score < elemScore) {\n          swap = child1N;\n        }\n      }\n\n      // Do the same checks for the other child.\n      if (child2N < length) {\n        var child2 = this.content[child2N],\n          child2Score = this.scoreFunction(child2);\n        if (child2Score < (swap === null ? elemScore : child1Score)) {\n          swap = child2N;\n        }\n      }\n\n      // If the element needs to be moved, swap it, and continue.\n      if (swap !== null) {\n        this.content[n] = this.content[swap];\n        this.content[swap] = element;\n        n = swap;\n        // Otherwise, we are done.\n      } else {\n        break;\n      }\n    }\n  },\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}