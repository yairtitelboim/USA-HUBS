{"ast":null,"code":"// index.ts\nimport { lineIntersect } from \"@turf/line-intersect\";\nimport { polygonToLine } from \"@turf/polygon-to-line\";\nimport { booleanPointInPolygon } from \"@turf/boolean-point-in-polygon\";\nimport { getGeom } from \"@turf/invariant\";\nimport { point } from \"@turf/helpers\";\nfunction booleanCrosses(feature1, feature2) {\n  var geom1 = getGeom(feature1);\n  var geom2 = getGeom(feature2);\n  var type1 = geom1.type;\n  var type2 = geom2.type;\n  switch (type1) {\n    case \"MultiPoint\":\n      switch (type2) {\n        case \"LineString\":\n          return doMultiPointAndLineStringCross(geom1, geom2);\n        case \"Polygon\":\n          return doesMultiPointCrossPoly(geom1, geom2);\n        default:\n          throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\n      }\n    case \"LineString\":\n      switch (type2) {\n        case \"MultiPoint\":\n          return doMultiPointAndLineStringCross(geom2, geom1);\n        case \"LineString\":\n          return doLineStringsCross(geom1, geom2);\n        case \"Polygon\":\n          return doLineStringAndPolygonCross(geom1, geom2);\n        default:\n          throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\n      }\n    case \"Polygon\":\n      switch (type2) {\n        case \"MultiPoint\":\n          return doesMultiPointCrossPoly(geom2, geom1);\n        case \"LineString\":\n          return doLineStringAndPolygonCross(geom2, geom1);\n        default:\n          throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\n      }\n    default:\n      throw new Error(\"feature1 \" + type1 + \" geometry not supported\");\n  }\n}\nfunction doMultiPointAndLineStringCross(multiPoint, lineString) {\n  var foundIntPoint = false;\n  var foundExtPoint = false;\n  var pointLength = multiPoint.coordinates.length;\n  var i = 0;\n  while (i < pointLength && !foundIntPoint && !foundExtPoint) {\n    for (var i2 = 0; i2 < lineString.coordinates.length - 1; i2++) {\n      var incEndVertices = true;\n      if (i2 === 0 || i2 === lineString.coordinates.length - 2) {\n        incEndVertices = false;\n      }\n      if (isPointOnLineSegment(lineString.coordinates[i2], lineString.coordinates[i2 + 1], multiPoint.coordinates[i], incEndVertices)) {\n        foundIntPoint = true;\n      } else {\n        foundExtPoint = true;\n      }\n    }\n    i++;\n  }\n  return foundIntPoint && foundExtPoint;\n}\nfunction doLineStringsCross(lineString1, lineString2) {\n  var doLinesIntersect = lineIntersect(lineString1, lineString2);\n  if (doLinesIntersect.features.length > 0) {\n    for (var i = 0; i < lineString1.coordinates.length - 1; i++) {\n      for (var i2 = 0; i2 < lineString2.coordinates.length - 1; i2++) {\n        var incEndVertices = true;\n        if (i2 === 0 || i2 === lineString2.coordinates.length - 2) {\n          incEndVertices = false;\n        }\n        if (isPointOnLineSegment(lineString1.coordinates[i], lineString1.coordinates[i + 1], lineString2.coordinates[i2], incEndVertices)) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\nfunction doLineStringAndPolygonCross(lineString, polygon) {\n  const line = polygonToLine(polygon);\n  const doLinesIntersect = lineIntersect(lineString, line);\n  if (doLinesIntersect.features.length > 0) {\n    return true;\n  }\n  return false;\n}\nfunction doesMultiPointCrossPoly(multiPoint, polygon) {\n  var foundIntPoint = false;\n  var foundExtPoint = false;\n  var pointLength = multiPoint.coordinates.length;\n  for (let i = 0; i < pointLength && (!foundIntPoint || !foundExtPoint); i++) {\n    if (booleanPointInPolygon(point(multiPoint.coordinates[i]), polygon)) {\n      foundIntPoint = true;\n    } else {\n      foundExtPoint = true;\n    }\n  }\n  return foundExtPoint && foundIntPoint;\n}\nfunction isPointOnLineSegment(lineSegmentStart, lineSegmentEnd, pt, incEnd) {\n  var dxc = pt[0] - lineSegmentStart[0];\n  var dyc = pt[1] - lineSegmentStart[1];\n  var dxl = lineSegmentEnd[0] - lineSegmentStart[0];\n  var dyl = lineSegmentEnd[1] - lineSegmentStart[1];\n  var cross = dxc * dyl - dyc * dxl;\n  if (cross !== 0) {\n    return false;\n  }\n  if (incEnd) {\n    if (Math.abs(dxl) >= Math.abs(dyl)) {\n      return dxl > 0 ? lineSegmentStart[0] <= pt[0] && pt[0] <= lineSegmentEnd[0] : lineSegmentEnd[0] <= pt[0] && pt[0] <= lineSegmentStart[0];\n    }\n    return dyl > 0 ? lineSegmentStart[1] <= pt[1] && pt[1] <= lineSegmentEnd[1] : lineSegmentEnd[1] <= pt[1] && pt[1] <= lineSegmentStart[1];\n  } else {\n    if (Math.abs(dxl) >= Math.abs(dyl)) {\n      return dxl > 0 ? lineSegmentStart[0] < pt[0] && pt[0] < lineSegmentEnd[0] : lineSegmentEnd[0] < pt[0] && pt[0] < lineSegmentStart[0];\n    }\n    return dyl > 0 ? lineSegmentStart[1] < pt[1] && pt[1] < lineSegmentEnd[1] : lineSegmentEnd[1] < pt[1] && pt[1] < lineSegmentStart[1];\n  }\n}\nvar turf_boolean_crosses_default = booleanCrosses;\nexport { booleanCrosses, turf_boolean_crosses_default as default };","map":{"version":3,"names":["lineIntersect","polygonToLine","booleanPointInPolygon","getGeom","point","booleanCrosses","feature1","feature2","geom1","geom2","type1","type","type2","doMultiPointAndLineStringCross","doesMultiPointCrossPoly","Error","doLineStringsCross","doLineStringAndPolygonCross","multiPoint","lineString","foundIntPoint","foundExtPoint","pointLength","coordinates","length","i","i2","incEndVertices","isPointOnLineSegment","lineString1","lineString2","doLinesIntersect","features","polygon","line","lineSegmentStart","lineSegmentEnd","pt","incEnd","dxc","dyc","dxl","dyl","cross","Math","abs","turf_boolean_crosses_default"],"sources":["/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/boolean-crosses/index.ts"],"sourcesContent":["import { Feature, Geometry, Polygon, LineString, MultiPoint } from \"geojson\";\nimport { lineIntersect } from \"@turf/line-intersect\";\nimport { polygonToLine } from \"@turf/polygon-to-line\";\nimport { booleanPointInPolygon } from \"@turf/boolean-point-in-polygon\";\nimport { getGeom } from \"@turf/invariant\";\nimport { point } from \"@turf/helpers\";\n\n/**\n * Boolean-Crosses returns True if the intersection results in a geometry whose dimension is one less than\n * the maximum dimension of the two source geometries and the intersection set is interior to\n * both source geometries.\n *\n * Boolean-Crosses returns t (TRUE) for only multipoint/polygon, multipoint/linestring, linestring/linestring, linestring/polygon, and linestring/multipolygon comparisons.\n * Other comparisons are not supported as they are outside the OpenGIS Simple Features spec and may give unexpected results.\n *\n * @function\n * @param {Geometry|Feature<any>} feature1 GeoJSON Feature or Geometry\n * @param {Geometry|Feature<any>} feature2 GeoJSON Feature or Geometry\n * @returns {boolean} true/false\n * @example\n * var line1 = turf.lineString([[-2, 2], [4, 2]]);\n * var line2 = turf.lineString([[1, 1], [1, 2], [1, 3], [1, 4]]);\n *\n * var cross = turf.booleanCrosses(line1, line2);\n * //=true\n */\nfunction booleanCrosses(\n  feature1: Feature<any> | Geometry,\n  feature2: Feature<any> | Geometry\n): boolean {\n  var geom1 = getGeom(feature1);\n  var geom2 = getGeom(feature2);\n  var type1 = geom1.type;\n  var type2 = geom2.type;\n\n  switch (type1) {\n    case \"MultiPoint\":\n      switch (type2) {\n        case \"LineString\":\n          return doMultiPointAndLineStringCross(geom1, geom2);\n        case \"Polygon\":\n          return doesMultiPointCrossPoly(geom1, geom2);\n        default:\n          throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\n      }\n    case \"LineString\":\n      switch (type2) {\n        case \"MultiPoint\": // An inverse operation\n          return doMultiPointAndLineStringCross(geom2, geom1);\n        case \"LineString\":\n          return doLineStringsCross(geom1, geom2);\n        case \"Polygon\":\n          return doLineStringAndPolygonCross(geom1, geom2);\n        default:\n          throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\n      }\n    case \"Polygon\":\n      switch (type2) {\n        case \"MultiPoint\": // An inverse operation\n          return doesMultiPointCrossPoly(geom2, geom1);\n        case \"LineString\": // An inverse operation\n          return doLineStringAndPolygonCross(geom2, geom1);\n        default:\n          throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\n      }\n    default:\n      throw new Error(\"feature1 \" + type1 + \" geometry not supported\");\n  }\n}\n\nfunction doMultiPointAndLineStringCross(\n  multiPoint: MultiPoint,\n  lineString: LineString\n) {\n  var foundIntPoint = false;\n  var foundExtPoint = false;\n  var pointLength = multiPoint.coordinates.length;\n  var i = 0;\n  while (i < pointLength && !foundIntPoint && !foundExtPoint) {\n    for (var i2 = 0; i2 < lineString.coordinates.length - 1; i2++) {\n      var incEndVertices = true;\n      if (i2 === 0 || i2 === lineString.coordinates.length - 2) {\n        incEndVertices = false;\n      }\n      if (\n        isPointOnLineSegment(\n          lineString.coordinates[i2],\n          lineString.coordinates[i2 + 1],\n          multiPoint.coordinates[i],\n          incEndVertices\n        )\n      ) {\n        foundIntPoint = true;\n      } else {\n        foundExtPoint = true;\n      }\n    }\n    i++;\n  }\n  return foundIntPoint && foundExtPoint;\n}\n\nfunction doLineStringsCross(lineString1: LineString, lineString2: LineString) {\n  var doLinesIntersect = lineIntersect(lineString1, lineString2);\n  if (doLinesIntersect.features.length > 0) {\n    for (var i = 0; i < lineString1.coordinates.length - 1; i++) {\n      for (var i2 = 0; i2 < lineString2.coordinates.length - 1; i2++) {\n        var incEndVertices = true;\n        if (i2 === 0 || i2 === lineString2.coordinates.length - 2) {\n          incEndVertices = false;\n        }\n        if (\n          isPointOnLineSegment(\n            lineString1.coordinates[i],\n            lineString1.coordinates[i + 1],\n            lineString2.coordinates[i2],\n            incEndVertices\n          )\n        ) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\nfunction doLineStringAndPolygonCross(lineString: LineString, polygon: Polygon) {\n  const line: any = polygonToLine(polygon);\n  const doLinesIntersect = lineIntersect(lineString, line);\n  if (doLinesIntersect.features.length > 0) {\n    return true;\n  }\n  return false;\n}\n\nfunction doesMultiPointCrossPoly(multiPoint: MultiPoint, polygon: Polygon) {\n  var foundIntPoint = false;\n  var foundExtPoint = false;\n  var pointLength = multiPoint.coordinates.length;\n  for (let i = 0; i < pointLength && (!foundIntPoint || !foundExtPoint); i++) {\n    if (booleanPointInPolygon(point(multiPoint.coordinates[i]), polygon)) {\n      foundIntPoint = true;\n    } else {\n      foundExtPoint = true;\n    }\n  }\n\n  return foundExtPoint && foundIntPoint;\n}\n\n/**\n * Is a point on a line segment\n * Only takes into account outer rings\n * See http://stackoverflow.com/a/4833823/1979085\n *\n * @private\n * @param {number[]} lineSegmentStart coord pair of start of line\n * @param {number[]} lineSegmentEnd coord pair of end of line\n * @param {number[]} pt coord pair of point to check\n * @param {boolean} incEnd whether the point is allowed to fall on the line ends\n * @returns {boolean} true/false\n */\nfunction isPointOnLineSegment(\n  lineSegmentStart: number[],\n  lineSegmentEnd: number[],\n  pt: number[],\n  incEnd: boolean\n) {\n  var dxc = pt[0] - lineSegmentStart[0];\n  var dyc = pt[1] - lineSegmentStart[1];\n  var dxl = lineSegmentEnd[0] - lineSegmentStart[0];\n  var dyl = lineSegmentEnd[1] - lineSegmentStart[1];\n  var cross = dxc * dyl - dyc * dxl;\n  if (cross !== 0) {\n    return false;\n  }\n  if (incEnd) {\n    if (Math.abs(dxl) >= Math.abs(dyl)) {\n      return dxl > 0\n        ? lineSegmentStart[0] <= pt[0] && pt[0] <= lineSegmentEnd[0]\n        : lineSegmentEnd[0] <= pt[0] && pt[0] <= lineSegmentStart[0];\n    }\n    return dyl > 0\n      ? lineSegmentStart[1] <= pt[1] && pt[1] <= lineSegmentEnd[1]\n      : lineSegmentEnd[1] <= pt[1] && pt[1] <= lineSegmentStart[1];\n  } else {\n    if (Math.abs(dxl) >= Math.abs(dyl)) {\n      return dxl > 0\n        ? lineSegmentStart[0] < pt[0] && pt[0] < lineSegmentEnd[0]\n        : lineSegmentEnd[0] < pt[0] && pt[0] < lineSegmentStart[0];\n    }\n    return dyl > 0\n      ? lineSegmentStart[1] < pt[1] && pt[1] < lineSegmentEnd[1]\n      : lineSegmentEnd[1] < pt[1] && pt[1] < lineSegmentStart[1];\n  }\n}\n\nexport { booleanCrosses };\nexport default booleanCrosses;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}