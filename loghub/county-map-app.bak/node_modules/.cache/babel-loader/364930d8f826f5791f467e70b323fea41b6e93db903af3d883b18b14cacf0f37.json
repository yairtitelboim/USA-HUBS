{"ast":null,"code":"// index.ts\nimport { featureCollection, multiPolygon, polygon } from \"@turf/helpers\";\nimport { coordEach, geomEach } from \"@turf/meta\";\nfunction polygonSmooth(inputPolys, options) {\n  options = options || {};\n  options.iterations = options.iterations || 1;\n  const {\n    iterations\n  } = options;\n  const outPolys = [];\n  if (!inputPolys) throw new Error(\"inputPolys is required\");\n  geomEach(inputPolys, function (geom, geomIndex, properties) {\n    if (geom.type === \"Polygon\") {\n      let outCoords = [[]];\n      for (let i = 0; i < iterations; i++) {\n        let tempOutput = [];\n        let poly = geom;\n        if (i > 0) {\n          poly = polygon(outCoords).geometry;\n        }\n        processPolygon(poly, tempOutput);\n        outCoords = tempOutput.slice(0);\n      }\n      outPolys.push(polygon(outCoords, properties));\n    } else if (geom.type === \"MultiPolygon\") {\n      let outCoords = [[[]]];\n      for (let y = 0; y < iterations; y++) {\n        let tempOutput = [];\n        let poly = geom;\n        if (y > 0) {\n          poly = multiPolygon(outCoords).geometry;\n        }\n        processMultiPolygon(poly, tempOutput);\n        outCoords = tempOutput.slice(0);\n      }\n      outPolys.push(multiPolygon(outCoords, properties));\n    } else {\n      throw new Error(\"geometry is invalid, must be Polygon or MultiPolygon\");\n    }\n  });\n  return featureCollection(outPolys);\n}\nfunction processPolygon(poly, tempOutput) {\n  var previousCoord;\n  var previousGeometryIndex;\n  coordEach(poly, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n    if (previousGeometryIndex !== geometryIndex) {\n      tempOutput.push([]);\n    } else {\n      var p0x = previousCoord[0];\n      var p0y = previousCoord[1];\n      var p1x = currentCoord[0];\n      var p1y = currentCoord[1];\n      tempOutput[geometryIndex].push([0.75 * p0x + 0.25 * p1x, 0.75 * p0y + 0.25 * p1y]);\n      tempOutput[geometryIndex].push([0.25 * p0x + 0.75 * p1x, 0.25 * p0y + 0.75 * p1y]);\n    }\n    previousCoord = currentCoord;\n    previousGeometryIndex = geometryIndex;\n  }, false);\n  tempOutput.forEach(function (ring) {\n    ring.push(ring[0]);\n  });\n}\nfunction processMultiPolygon(poly, tempOutput) {\n  let previousCoord;\n  let previousMultiFeatureIndex;\n  let previousGeometryIndex;\n  coordEach(poly, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n    if (previousMultiFeatureIndex !== multiFeatureIndex) {\n      tempOutput.push([[]]);\n    } else if (previousGeometryIndex !== geometryIndex) {\n      tempOutput[multiFeatureIndex].push([]);\n    } else {\n      var p0x = previousCoord[0];\n      var p0y = previousCoord[1];\n      var p1x = currentCoord[0];\n      var p1y = currentCoord[1];\n      tempOutput[multiFeatureIndex][geometryIndex].push([0.75 * p0x + 0.25 * p1x, 0.75 * p0y + 0.25 * p1y]);\n      tempOutput[multiFeatureIndex][geometryIndex].push([0.25 * p0x + 0.75 * p1x, 0.25 * p0y + 0.75 * p1y]);\n    }\n    previousCoord = currentCoord;\n    previousMultiFeatureIndex = multiFeatureIndex;\n    previousGeometryIndex = geometryIndex;\n  }, false);\n  tempOutput.forEach(function (poly2) {\n    poly2.forEach(function (ring) {\n      ring.push(ring[0]);\n    });\n  });\n}\nvar turf_polygon_smooth_default = polygonSmooth;\nexport { turf_polygon_smooth_default as default, polygonSmooth };","map":{"version":3,"names":["featureCollection","multiPolygon","polygon","coordEach","geomEach","polygonSmooth","inputPolys","options","iterations","outPolys","Error","geom","geomIndex","properties","type","outCoords","i","tempOutput","poly","geometry","processPolygon","slice","push","y","processMultiPolygon","previousCoord","previousGeometryIndex","currentCoord","coordIndex","featureIndex","multiFeatureIndex","geometryIndex","p0x","p0y","p1x","p1y","forEach","ring","previousMultiFeatureIndex","poly2","turf_polygon_smooth_default"],"sources":["/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/polygon-smooth/index.ts"],"sourcesContent":["import type {\n  Feature,\n  FeatureCollection,\n  Polygon,\n  Position,\n  MultiPolygon,\n} from \"geojson\";\nimport { featureCollection, multiPolygon, polygon } from \"@turf/helpers\";\nimport { coordEach, geomEach } from \"@turf/meta\";\n\n/**\n * Smooths a {@link Polygon} or {@link MultiPolygon}. Based on [Chaikin's algorithm](http://graphics.cs.ucdavis.edu/education/CAGDNotes/Chaikins-Algorithm/Chaikins-Algorithm.html).\n * Warning: may create degenerate polygons.\n *\n * @function\n * @param {FeatureCollection<Polygon|MultiPolygon>|Feature<Polygon|MultiPolygon>|Polygon|MultiPolygon} inputPolys (Multi)Polygon(s) to smooth\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.iterations=1] The number of times to smooth the polygon. A higher value means a smoother polygon.\n * @returns {FeatureCollection<Polygon|MultiPolygon>} FeatureCollection containing the smoothed polygon/multipoylgons\n * @example\n * var polygon = turf.polygon([[[11, 0], [22, 4], [31, 0], [31, 11], [21, 15], [11, 11], [11, 0]]]);\n *\n * var smoothed = turf.polygonSmooth(polygon, {iterations: 3})\n *\n * //addToMap\n * var addToMap = [smoothed, polygon];\n */\nfunction polygonSmooth(\n  inputPolys:\n    | FeatureCollection<Polygon | MultiPolygon>\n    | Feature<Polygon | MultiPolygon>\n    | Polygon\n    | MultiPolygon,\n  options?: {\n    iterations?: number;\n  }\n): FeatureCollection<Polygon | MultiPolygon> {\n  // Optional parameters\n  options = options || {};\n  options.iterations = options.iterations || 1;\n\n  const { iterations } = options;\n\n  const outPolys: Feature<Polygon | MultiPolygon>[] = [];\n  if (!inputPolys) throw new Error(\"inputPolys is required\");\n\n  geomEach(inputPolys, function (geom, geomIndex, properties) {\n    if (geom.type === \"Polygon\") {\n      let outCoords: Position[][] = [[]];\n      for (let i = 0; i < iterations; i++) {\n        let tempOutput: Position[][] = [];\n        let poly = geom;\n        if (i > 0) {\n          poly = polygon(outCoords).geometry;\n        }\n        processPolygon(poly, tempOutput);\n        outCoords = tempOutput.slice(0);\n      }\n      outPolys.push(polygon(outCoords, properties));\n    } else if (geom.type === \"MultiPolygon\") {\n      let outCoords: Position[][][] = [[[]]];\n      for (let y = 0; y < iterations; y++) {\n        let tempOutput: Position[][][] = [];\n        let poly = geom;\n        if (y > 0) {\n          poly = multiPolygon(outCoords).geometry;\n        }\n        processMultiPolygon(poly, tempOutput);\n        outCoords = tempOutput.slice(0);\n      }\n      outPolys.push(multiPolygon(outCoords, properties));\n    } else {\n      throw new Error(\"geometry is invalid, must be Polygon or MultiPolygon\");\n    }\n  });\n\n  return featureCollection(outPolys);\n}\n\n/**\n * @param {poly} poly to process\n * @param {poly} tempOutput to place the results in\n * @private\n */\nfunction processPolygon(poly: Polygon, tempOutput: Position[][]) {\n  var previousCoord: Position;\n  var previousGeometryIndex: number;\n\n  coordEach(\n    poly,\n    function (\n      currentCoord,\n      coordIndex,\n      featureIndex,\n      multiFeatureIndex,\n      geometryIndex\n    ) {\n      if (previousGeometryIndex !== geometryIndex) {\n        tempOutput.push([]);\n      } else {\n        var p0x = previousCoord[0];\n        var p0y = previousCoord[1];\n        var p1x = currentCoord[0];\n        var p1y = currentCoord[1];\n        tempOutput[geometryIndex].push([\n          0.75 * p0x + 0.25 * p1x,\n          0.75 * p0y + 0.25 * p1y,\n        ]);\n        tempOutput[geometryIndex].push([\n          0.25 * p0x + 0.75 * p1x,\n          0.25 * p0y + 0.75 * p1y,\n        ]);\n      }\n      previousCoord = currentCoord;\n      previousGeometryIndex = geometryIndex;\n    },\n    false\n  );\n  tempOutput.forEach(function (ring) {\n    ring.push(ring[0]);\n  });\n}\n\n/**\n * @param {poly} poly to process\n * @param {poly} tempOutput to place the results in\n * @private\n */\nfunction processMultiPolygon(poly: MultiPolygon, tempOutput: Position[][][]) {\n  let previousCoord: Position;\n  let previousMultiFeatureIndex: number;\n  let previousGeometryIndex: number;\n\n  coordEach(\n    poly,\n    function (\n      currentCoord,\n      coordIndex,\n      featureIndex,\n      multiFeatureIndex,\n      geometryIndex\n    ) {\n      if (previousMultiFeatureIndex !== multiFeatureIndex) {\n        tempOutput.push([[]]);\n      } else if (previousGeometryIndex !== geometryIndex) {\n        tempOutput[multiFeatureIndex].push([]);\n      } else {\n        var p0x = previousCoord[0];\n        var p0y = previousCoord[1];\n        var p1x = currentCoord[0];\n        var p1y = currentCoord[1];\n        tempOutput[multiFeatureIndex][geometryIndex].push([\n          0.75 * p0x + 0.25 * p1x,\n          0.75 * p0y + 0.25 * p1y,\n        ]);\n        tempOutput[multiFeatureIndex][geometryIndex].push([\n          0.25 * p0x + 0.75 * p1x,\n          0.25 * p0y + 0.75 * p1y,\n        ]);\n      }\n      previousCoord = currentCoord;\n      previousMultiFeatureIndex = multiFeatureIndex;\n      previousGeometryIndex = geometryIndex;\n    },\n    false\n  );\n  tempOutput.forEach(function (poly) {\n    poly.forEach(function (ring) {\n      ring.push(ring[0]);\n    });\n  });\n}\n\nexport { polygonSmooth };\nexport default polygonSmooth;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}