{"ast":null,"code":"// index.ts\nfunction clone(geojson) {\n  if (!geojson) {\n    throw new Error(\"geojson is required\");\n  }\n  switch (geojson.type) {\n    case \"Feature\":\n      return cloneFeature(geojson);\n    case \"FeatureCollection\":\n      return cloneFeatureCollection(geojson);\n    case \"Point\":\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiPoint\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n    case \"GeometryCollection\":\n      return cloneGeometry(geojson);\n    default:\n      throw new Error(\"unknown GeoJSON type\");\n  }\n}\nfunction cloneFeature(geojson) {\n  const cloned = {\n    type: \"Feature\"\n  };\n  Object.keys(geojson).forEach(key => {\n    switch (key) {\n      case \"type\":\n      case \"properties\":\n      case \"geometry\":\n        return;\n      default:\n        cloned[key] = geojson[key];\n    }\n  });\n  cloned.properties = cloneProperties(geojson.properties);\n  if (geojson.geometry == null) {\n    cloned.geometry = null;\n  } else {\n    cloned.geometry = cloneGeometry(geojson.geometry);\n  }\n  return cloned;\n}\nfunction cloneProperties(properties) {\n  const cloned = {};\n  if (!properties) {\n    return cloned;\n  }\n  Object.keys(properties).forEach(key => {\n    const value = properties[key];\n    if (typeof value === \"object\") {\n      if (value === null) {\n        cloned[key] = null;\n      } else if (Array.isArray(value)) {\n        cloned[key] = value.map(item => {\n          return item;\n        });\n      } else {\n        cloned[key] = cloneProperties(value);\n      }\n    } else {\n      cloned[key] = value;\n    }\n  });\n  return cloned;\n}\nfunction cloneFeatureCollection(geojson) {\n  const cloned = {\n    type: \"FeatureCollection\"\n  };\n  Object.keys(geojson).forEach(key => {\n    switch (key) {\n      case \"type\":\n      case \"features\":\n        return;\n      default:\n        cloned[key] = geojson[key];\n    }\n  });\n  cloned.features = geojson.features.map(feature => {\n    return cloneFeature(feature);\n  });\n  return cloned;\n}\nfunction cloneGeometry(geometry) {\n  const geom = {\n    type: geometry.type\n  };\n  if (geometry.bbox) {\n    geom.bbox = geometry.bbox;\n  }\n  if (geometry.type === \"GeometryCollection\") {\n    geom.geometries = geometry.geometries.map(g => {\n      return cloneGeometry(g);\n    });\n    return geom;\n  }\n  geom.coordinates = deepSlice(geometry.coordinates);\n  return geom;\n}\nfunction deepSlice(coords) {\n  const cloned = coords;\n  if (typeof cloned[0] !== \"object\") {\n    return cloned.slice();\n  }\n  return cloned.map(coord => {\n    return deepSlice(coord);\n  });\n}\nvar turf_clone_default = clone;\nexport { clone, cloneProperties, turf_clone_default as default };","map":{"version":3,"names":["clone","geojson","Error","type","cloneFeature","cloneFeatureCollection","cloneGeometry","cloned","Object","keys","forEach","key","properties","cloneProperties","geometry","value","Array","isArray","map","item","features","feature","geom","bbox","geometries","g","coordinates","deepSlice","coords","slice","coord","turf_clone_default"],"sources":["/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/clone/index.ts"],"sourcesContent":["import { Feature, GeoJsonProperties } from \"geojson\";\nimport { AllGeoJSON } from \"@turf/helpers\";\n\n/**\n * Returns a cloned copy of the passed GeoJSON Object, including possible 'Foreign Members'.\n * ~3-5x faster than the common JSON.parse + JSON.stringify combo method.\n *\n * @function\n * @param {GeoJSON} geojson GeoJSON Object\n * @returns {GeoJSON} cloned GeoJSON Object\n * @example\n * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]], {color: 'red'});\n *\n * var lineCloned = turf.clone(line);\n */\nfunction clone<T extends AllGeoJSON>(geojson: T): T {\n  if (!geojson) {\n    throw new Error(\"geojson is required\");\n  }\n\n  switch (geojson.type) {\n    case \"Feature\":\n      return cloneFeature(geojson);\n    case \"FeatureCollection\":\n      return cloneFeatureCollection(geojson);\n    case \"Point\":\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiPoint\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n    case \"GeometryCollection\":\n      return cloneGeometry(geojson);\n    default:\n      throw new Error(\"unknown GeoJSON type\");\n  }\n}\n\n/**\n * Clone Feature\n *\n * @private\n * @param {Feature<any>} geojson GeoJSON Feature\n * @returns {Feature<any>} cloned Feature\n */\nfunction cloneFeature(geojson: any) {\n  const cloned: any = { type: \"Feature\" };\n  // Preserve Foreign Members\n  Object.keys(geojson).forEach((key) => {\n    switch (key) {\n      case \"type\":\n      case \"properties\":\n      case \"geometry\":\n        return;\n      default:\n        cloned[key] = geojson[key];\n    }\n  });\n  // Add properties & geometry last\n  cloned.properties = cloneProperties(geojson.properties);\n  if (geojson.geometry == null) {\n    cloned.geometry = null;\n  } else {\n    cloned.geometry = cloneGeometry(geojson.geometry);\n  }\n  return cloned;\n}\n\n/**\n * Clone Properties\n *\n * @private\n * @param {Object} properties GeoJSON Properties\n * @returns {Object} cloned Properties\n */\nfunction cloneProperties(properties: GeoJsonProperties) {\n  const cloned: { [key: string]: any } = {};\n  if (!properties) {\n    return cloned;\n  }\n  Object.keys(properties).forEach((key) => {\n    const value = properties[key];\n    if (typeof value === \"object\") {\n      if (value === null) {\n        // handle null\n        cloned[key] = null;\n      } else if (Array.isArray(value)) {\n        // handle Array\n        cloned[key] = value.map((item) => {\n          return item;\n        });\n      } else {\n        // handle generic Object\n        cloned[key] = cloneProperties(value);\n      }\n    } else {\n      cloned[key] = value;\n    }\n  });\n  return cloned;\n}\n\n/**\n * Clone Feature Collection\n *\n * @private\n * @param {FeatureCollection<any>} geojson GeoJSON Feature Collection\n * @returns {FeatureCollection<any>} cloned Feature Collection\n */\nfunction cloneFeatureCollection(geojson: any) {\n  const cloned: any = { type: \"FeatureCollection\" };\n\n  // Preserve Foreign Members\n  Object.keys(geojson).forEach((key) => {\n    switch (key) {\n      case \"type\":\n      case \"features\":\n        return;\n      default:\n        cloned[key] = geojson[key];\n    }\n  });\n  // Add features\n  cloned.features = geojson.features.map((feature: Feature<any>) => {\n    return cloneFeature(feature);\n  });\n  return cloned;\n}\n\n/**\n * Clone Geometry\n *\n * @private\n * @param {Geometry<any>} geometry GeoJSON Geometry\n * @returns {Geometry<any>} cloned Geometry\n */\nfunction cloneGeometry(geometry: any) {\n  const geom: any = { type: geometry.type };\n  if (geometry.bbox) {\n    geom.bbox = geometry.bbox;\n  }\n\n  if (geometry.type === \"GeometryCollection\") {\n    geom.geometries = geometry.geometries.map((g: any) => {\n      return cloneGeometry(g);\n    });\n    return geom;\n  }\n  geom.coordinates = deepSlice(geometry.coordinates);\n  return geom;\n}\n\n/**\n * Deep Slice coordinates\n *\n * @private\n * @param {Coordinates} coords Coordinates\n * @returns {Coordinates} all coordinates sliced\n */\nfunction deepSlice<C = any[]>(coords: C): C {\n  const cloned: any = coords;\n  if (typeof cloned[0] !== \"object\") {\n    return cloned.slice();\n  }\n  return cloned.map((coord: any) => {\n    return deepSlice(coord);\n  });\n}\n\nexport { clone, cloneProperties };\nexport default clone;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}