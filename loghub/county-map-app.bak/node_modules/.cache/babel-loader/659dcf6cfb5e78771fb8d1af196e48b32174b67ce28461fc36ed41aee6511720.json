{"ast":null,"code":"// index.ts\nimport { isNumber } from \"@turf/helpers\";\nfunction getCoord(coord) {\n  if (!coord) {\n    throw new Error(\"coord is required\");\n  }\n  if (!Array.isArray(coord)) {\n    if (coord.type === \"Feature\" && coord.geometry !== null && coord.geometry.type === \"Point\") {\n      return [...coord.geometry.coordinates];\n    }\n    if (coord.type === \"Point\") {\n      return [...coord.coordinates];\n    }\n  }\n  if (Array.isArray(coord) && coord.length >= 2 && !Array.isArray(coord[0]) && !Array.isArray(coord[1])) {\n    return [...coord];\n  }\n  throw new Error(\"coord must be GeoJSON Point or an Array of numbers\");\n}\nfunction getCoords(coords) {\n  if (Array.isArray(coords)) {\n    return coords;\n  }\n  if (coords.type === \"Feature\") {\n    if (coords.geometry !== null) {\n      return coords.geometry.coordinates;\n    }\n  } else {\n    if (coords.coordinates) {\n      return coords.coordinates;\n    }\n  }\n  throw new Error(\"coords must be GeoJSON Feature, Geometry Object or an Array\");\n}\nfunction containsNumber(coordinates) {\n  if (coordinates.length > 1 && isNumber(coordinates[0]) && isNumber(coordinates[1])) {\n    return true;\n  }\n  if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n    return containsNumber(coordinates[0]);\n  }\n  throw new Error(\"coordinates must only contain numbers\");\n}\nfunction geojsonType(value, type, name) {\n  if (!type || !name) {\n    throw new Error(\"type and name required\");\n  }\n  if (!value || value.type !== type) {\n    throw new Error(\"Invalid input to \" + name + \": must be a \" + type + \", given \" + value.type);\n  }\n}\nfunction featureOf(feature, type, name) {\n  if (!feature) {\n    throw new Error(\"No feature passed\");\n  }\n  if (!name) {\n    throw new Error(\".featureOf() requires a name\");\n  }\n  if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n    throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\n  }\n  if (!feature.geometry || feature.geometry.type !== type) {\n    throw new Error(\"Invalid input to \" + name + \": must be a \" + type + \", given \" + feature.geometry.type);\n  }\n}\nfunction collectionOf(featureCollection, type, name) {\n  if (!featureCollection) {\n    throw new Error(\"No featureCollection passed\");\n  }\n  if (!name) {\n    throw new Error(\".collectionOf() requires a name\");\n  }\n  if (!featureCollection || featureCollection.type !== \"FeatureCollection\") {\n    throw new Error(\"Invalid input to \" + name + \", FeatureCollection required\");\n  }\n  for (const feature of featureCollection.features) {\n    if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n      throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n      throw new Error(\"Invalid input to \" + name + \": must be a \" + type + \", given \" + feature.geometry.type);\n    }\n  }\n}\nfunction getGeom(geojson) {\n  if (geojson.type === \"Feature\") {\n    return geojson.geometry;\n  }\n  return geojson;\n}\nfunction getType(geojson, _name) {\n  if (geojson.type === \"FeatureCollection\") {\n    return \"FeatureCollection\";\n  }\n  if (geojson.type === \"GeometryCollection\") {\n    return \"GeometryCollection\";\n  }\n  if (geojson.type === \"Feature\" && geojson.geometry !== null) {\n    return geojson.geometry.type;\n  }\n  return geojson.type;\n}\nexport { collectionOf, containsNumber, featureOf, geojsonType, getCoord, getCoords, getGeom, getType };","map":{"version":3,"names":["isNumber","getCoord","coord","Error","Array","isArray","type","geometry","coordinates","length","getCoords","coords","containsNumber","geojsonType","value","name","featureOf","feature","collectionOf","featureCollection","features","getGeom","geojson","getType","_name"],"sources":["/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/invariant/index.ts"],"sourcesContent":["import {\n  Feature,\n  FeatureCollection,\n  Geometry,\n  LineString,\n  MultiPoint,\n  MultiLineString,\n  MultiPolygon,\n  Point,\n  Polygon,\n} from \"geojson\";\nimport { isNumber } from \"@turf/helpers\";\n\n/**\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\n *\n * @function\n * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers\n * @returns {Array<number>} coordinates\n * @example\n * var pt = turf.point([10, 10]);\n *\n * var coord = turf.getCoord(pt);\n * //= [10, 10]\n */\nfunction getCoord(coord: Feature<Point> | Point | number[]): number[] {\n  if (!coord) {\n    throw new Error(\"coord is required\");\n  }\n\n  if (!Array.isArray(coord)) {\n    if (\n      coord.type === \"Feature\" &&\n      coord.geometry !== null &&\n      coord.geometry.type === \"Point\"\n    ) {\n      return [...coord.geometry.coordinates];\n    }\n    if (coord.type === \"Point\") {\n      return [...coord.coordinates];\n    }\n  }\n  if (\n    Array.isArray(coord) &&\n    coord.length >= 2 &&\n    !Array.isArray(coord[0]) &&\n    !Array.isArray(coord[1])\n  ) {\n    return [...coord];\n  }\n\n  throw new Error(\"coord must be GeoJSON Point or an Array of numbers\");\n}\n\n/**\n * Unwrap coordinates from a Feature, Geometry Object or an Array\n *\n * @function\n * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array\n * @returns {Array<any>} coordinates\n * @example\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\n *\n * var coords = turf.getCoords(poly);\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\n */\nfunction getCoords<\n  G extends\n    | Point\n    | LineString\n    | Polygon\n    | MultiPoint\n    | MultiLineString\n    | MultiPolygon,\n>(coords: any[] | Feature<G> | G): any[] {\n  if (Array.isArray(coords)) {\n    return coords;\n  }\n\n  // Feature\n  if (coords.type === \"Feature\") {\n    if (coords.geometry !== null) {\n      return coords.geometry.coordinates;\n    }\n  } else {\n    // Geometry\n    if (coords.coordinates) {\n      return coords.coordinates;\n    }\n  }\n\n  throw new Error(\n    \"coords must be GeoJSON Feature, Geometry Object or an Array\"\n  );\n}\n\n/**\n * Checks if coordinates contains a number\n *\n * @function\n * @param {Array<any>} coordinates GeoJSON Coordinates\n * @returns {boolean} true if Array contains a number\n */\nfunction containsNumber(coordinates: any[]): boolean {\n  if (\n    coordinates.length > 1 &&\n    isNumber(coordinates[0]) &&\n    isNumber(coordinates[1])\n  ) {\n    return true;\n  }\n\n  if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n    return containsNumber(coordinates[0]);\n  }\n  throw new Error(\"coordinates must only contain numbers\");\n}\n\n/**\n * Enforce expectations about types of GeoJSON objects for Turf.\n *\n * @function\n * @param {GeoJSON} value any GeoJSON object\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nfunction geojsonType(value: any, type: string, name: string): void {\n  if (!type || !name) {\n    throw new Error(\"type and name required\");\n  }\n\n  if (!value || value.type !== type) {\n    throw new Error(\n      \"Invalid input to \" +\n        name +\n        \": must be a \" +\n        type +\n        \", given \" +\n        value.type\n    );\n  }\n}\n\n/**\n * Enforce expectations about types of {@link Feature} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @function\n * @param {Feature} feature a feature with an expected geometry type\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} error if value is not the expected type.\n */\nfunction featureOf(feature: Feature<any>, type: string, name: string): void {\n  if (!feature) {\n    throw new Error(\"No feature passed\");\n  }\n  if (!name) {\n    throw new Error(\".featureOf() requires a name\");\n  }\n  if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n    throw new Error(\n      \"Invalid input to \" + name + \", Feature with geometry required\"\n    );\n  }\n  if (!feature.geometry || feature.geometry.type !== type) {\n    throw new Error(\n      \"Invalid input to \" +\n        name +\n        \": must be a \" +\n        type +\n        \", given \" +\n        feature.geometry.type\n    );\n  }\n}\n\n/**\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @function\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nfunction collectionOf(\n  featureCollection: FeatureCollection<any>,\n  type: string,\n  name: string\n) {\n  if (!featureCollection) {\n    throw new Error(\"No featureCollection passed\");\n  }\n  if (!name) {\n    throw new Error(\".collectionOf() requires a name\");\n  }\n  if (!featureCollection || featureCollection.type !== \"FeatureCollection\") {\n    throw new Error(\n      \"Invalid input to \" + name + \", FeatureCollection required\"\n    );\n  }\n  for (const feature of featureCollection.features) {\n    if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n      throw new Error(\n        \"Invalid input to \" + name + \", Feature with geometry required\"\n      );\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n      throw new Error(\n        \"Invalid input to \" +\n          name +\n          \": must be a \" +\n          type +\n          \", given \" +\n          feature.geometry.type\n      );\n    }\n  }\n}\n\n/**\n * Get Geometry from Feature or Geometry Object\n *\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\n * @returns {Geometry|null} GeoJSON Geometry Object\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getGeom(point)\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\n */\nfunction getGeom<G extends Geometry>(geojson: Feature<G> | G): G {\n  if (geojson.type === \"Feature\") {\n    return geojson.geometry;\n  }\n  return geojson;\n}\n\n/**\n * Get GeoJSON object's type, Geometry type is prioritize.\n *\n * @param {GeoJSON} geojson GeoJSON object\n * @param {string} [name=\"geojson\"] name of the variable to display in error message (unused)\n * @returns {string} GeoJSON type\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getType(point)\n * //=\"Point\"\n */\nfunction getType(\n  geojson: Feature<any> | FeatureCollection<any> | Geometry,\n  _name?: string\n): string {\n  if (geojson.type === \"FeatureCollection\") {\n    return \"FeatureCollection\";\n  }\n  if (geojson.type === \"GeometryCollection\") {\n    return \"GeometryCollection\";\n  }\n  if (geojson.type === \"Feature\" && geojson.geometry !== null) {\n    return geojson.geometry.type;\n  }\n  return geojson.type;\n}\n\nexport {\n  getCoord,\n  getCoords,\n  containsNumber,\n  geojsonType,\n  featureOf,\n  collectionOf,\n  getGeom,\n  getType,\n};\n// No default export!\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}