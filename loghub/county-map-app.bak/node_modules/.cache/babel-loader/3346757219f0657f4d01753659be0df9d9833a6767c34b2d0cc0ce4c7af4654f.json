{"ast":null,"code":"// index.js\nimport { lineString } from \"@turf/helpers\";\nimport { getCoord } from \"@turf/invariant\";\n\n// lib/arc.js\nvar D2R = Math.PI / 180;\nvar R2D = 180 / Math.PI;\nvar Coord = function (lon, lat) {\n  this.lon = lon;\n  this.lat = lat;\n  this.x = D2R * lon;\n  this.y = D2R * lat;\n};\nCoord.prototype.view = function () {\n  return String(this.lon).slice(0, 4) + \",\" + String(this.lat).slice(0, 4);\n};\nCoord.prototype.antipode = function () {\n  var anti_lat = -1 * this.lat;\n  var anti_lon = this.lon < 0 ? 180 + this.lon : (180 - this.lon) * -1;\n  return new Coord(anti_lon, anti_lat);\n};\nvar LineString = function () {\n  this.coords = [];\n  this.length = 0;\n};\nLineString.prototype.move_to = function (coord) {\n  this.length++;\n  this.coords.push(coord);\n};\nvar Arc = function (properties) {\n  this.properties = properties || {};\n  this.geometries = [];\n};\nArc.prototype.json = function () {\n  if (this.geometries.length <= 0) {\n    return {\n      geometry: {\n        type: \"LineString\",\n        coordinates: null\n      },\n      type: \"Feature\",\n      properties: this.properties\n    };\n  } else if (this.geometries.length === 1) {\n    return {\n      geometry: {\n        type: \"LineString\",\n        coordinates: this.geometries[0].coords\n      },\n      type: \"Feature\",\n      properties: this.properties\n    };\n  } else {\n    var multiline = [];\n    for (var i = 0; i < this.geometries.length; i++) {\n      multiline.push(this.geometries[i].coords);\n    }\n    return {\n      geometry: {\n        type: \"MultiLineString\",\n        coordinates: multiline\n      },\n      type: \"Feature\",\n      properties: this.properties\n    };\n  }\n};\nArc.prototype.wkt = function () {\n  var wkt_string = \"\";\n  var wkt = \"LINESTRING(\";\n  var collect = function (c) {\n    wkt += c[0] + \" \" + c[1] + \",\";\n  };\n  for (var i = 0; i < this.geometries.length; i++) {\n    if (this.geometries[i].coords.length === 0) {\n      return \"LINESTRING(empty)\";\n    } else {\n      var coords = this.geometries[i].coords;\n      coords.forEach(collect);\n      wkt_string += wkt.substring(0, wkt.length - 1) + \")\";\n    }\n  }\n  return wkt_string;\n};\nvar GreatCircle = function (start, end, properties) {\n  if (!start || start.x === void 0 || start.y === void 0) {\n    throw new Error(\"GreatCircle constructor expects two args: start and end objects with x and y properties\");\n  }\n  if (!end || end.x === void 0 || end.y === void 0) {\n    throw new Error(\"GreatCircle constructor expects two args: start and end objects with x and y properties\");\n  }\n  this.start = new Coord(start.x, start.y);\n  this.end = new Coord(end.x, end.y);\n  this.properties = properties || {};\n  var w = this.start.x - this.end.x;\n  var h = this.start.y - this.end.y;\n  var z = Math.pow(Math.sin(h / 2), 2) + Math.cos(this.start.y) * Math.cos(this.end.y) * Math.pow(Math.sin(w / 2), 2);\n  this.g = 2 * Math.asin(Math.sqrt(z));\n  if (this.g === Math.PI) {\n    throw new Error(\"it appears \" + start.view() + \" and \" + end.view() + \" are 'antipodal', e.g diametrically opposite, thus there is no single route but rather infinite\");\n  } else if (isNaN(this.g)) {\n    throw new Error(\"could not calculate great circle between \" + start + \" and \" + end);\n  }\n};\nGreatCircle.prototype.interpolate = function (f) {\n  var A = Math.sin((1 - f) * this.g) / Math.sin(this.g);\n  var B = Math.sin(f * this.g) / Math.sin(this.g);\n  var x = A * Math.cos(this.start.y) * Math.cos(this.start.x) + B * Math.cos(this.end.y) * Math.cos(this.end.x);\n  var y = A * Math.cos(this.start.y) * Math.sin(this.start.x) + B * Math.cos(this.end.y) * Math.sin(this.end.x);\n  var z = A * Math.sin(this.start.y) + B * Math.sin(this.end.y);\n  var lat = R2D * Math.atan2(z, Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)));\n  var lon = R2D * Math.atan2(y, x);\n  return [lon, lat];\n};\nGreatCircle.prototype.Arc = function (npoints, options) {\n  var first_pass = [];\n  if (!npoints || npoints <= 2) {\n    first_pass.push([this.start.lon, this.start.lat]);\n    first_pass.push([this.end.lon, this.end.lat]);\n  } else {\n    var delta = 1 / (npoints - 1);\n    for (var i = 0; i < npoints; ++i) {\n      var step = delta * i;\n      var pair = this.interpolate(step);\n      first_pass.push(pair);\n    }\n  }\n  var bHasBigDiff = false;\n  var dfMaxSmallDiffLong = 0;\n  var dfDateLineOffset = options && options.offset ? options.offset : 10;\n  var dfLeftBorderX = 180 - dfDateLineOffset;\n  var dfRightBorderX = -180 + dfDateLineOffset;\n  var dfDiffSpace = 360 - dfDateLineOffset;\n  for (var j = 1; j < first_pass.length; ++j) {\n    var dfPrevX = first_pass[j - 1][0];\n    var dfX = first_pass[j][0];\n    var dfDiffLong = Math.abs(dfX - dfPrevX);\n    if (dfDiffLong > dfDiffSpace && (dfX > dfLeftBorderX && dfPrevX < dfRightBorderX || dfPrevX > dfLeftBorderX && dfX < dfRightBorderX)) {\n      bHasBigDiff = true;\n    } else if (dfDiffLong > dfMaxSmallDiffLong) {\n      dfMaxSmallDiffLong = dfDiffLong;\n    }\n  }\n  var poMulti = [];\n  if (bHasBigDiff && dfMaxSmallDiffLong < dfDateLineOffset) {\n    var poNewLS = [];\n    poMulti.push(poNewLS);\n    for (var k = 0; k < first_pass.length; ++k) {\n      var dfX0 = parseFloat(first_pass[k][0]);\n      if (k > 0 && Math.abs(dfX0 - first_pass[k - 1][0]) > dfDiffSpace) {\n        var dfX1 = parseFloat(first_pass[k - 1][0]);\n        var dfY1 = parseFloat(first_pass[k - 1][1]);\n        var dfX2 = parseFloat(first_pass[k][0]);\n        var dfY2 = parseFloat(first_pass[k][1]);\n        if (dfX1 > -180 && dfX1 < dfRightBorderX && dfX2 === 180 && k + 1 < first_pass.length && first_pass[k - 1][0] > -180 && first_pass[k - 1][0] < dfRightBorderX) {\n          poNewLS.push([-180, first_pass[k][1]]);\n          k++;\n          poNewLS.push([first_pass[k][0], first_pass[k][1]]);\n          continue;\n        } else if (dfX1 > dfLeftBorderX && dfX1 < 180 && dfX2 === -180 && k + 1 < first_pass.length && first_pass[k - 1][0] > dfLeftBorderX && first_pass[k - 1][0] < 180) {\n          poNewLS.push([180, first_pass[k][1]]);\n          k++;\n          poNewLS.push([first_pass[k][0], first_pass[k][1]]);\n          continue;\n        }\n        if (dfX1 < dfRightBorderX && dfX2 > dfLeftBorderX) {\n          var tmpX = dfX1;\n          dfX1 = dfX2;\n          dfX2 = tmpX;\n          var tmpY = dfY1;\n          dfY1 = dfY2;\n          dfY2 = tmpY;\n        }\n        if (dfX1 > dfLeftBorderX && dfX2 < dfRightBorderX) {\n          dfX2 += 360;\n        }\n        if (dfX1 <= 180 && dfX2 >= 180 && dfX1 < dfX2) {\n          var dfRatio = (180 - dfX1) / (dfX2 - dfX1);\n          var dfY = dfRatio * dfY2 + (1 - dfRatio) * dfY1;\n          poNewLS.push([first_pass[k - 1][0] > dfLeftBorderX ? 180 : -180, dfY]);\n          poNewLS = [];\n          poNewLS.push([first_pass[k - 1][0] > dfLeftBorderX ? -180 : 180, dfY]);\n          poMulti.push(poNewLS);\n        } else {\n          poNewLS = [];\n          poMulti.push(poNewLS);\n        }\n        poNewLS.push([dfX0, first_pass[k][1]]);\n      } else {\n        poNewLS.push([first_pass[k][0], first_pass[k][1]]);\n      }\n    }\n  } else {\n    var poNewLS0 = [];\n    poMulti.push(poNewLS0);\n    for (var l = 0; l < first_pass.length; ++l) {\n      poNewLS0.push([first_pass[l][0], first_pass[l][1]]);\n    }\n  }\n  var arc = new Arc(this.properties);\n  for (var m = 0; m < poMulti.length; ++m) {\n    var line = new LineString();\n    arc.geometries.push(line);\n    var points = poMulti[m];\n    for (var j0 = 0; j0 < points.length; ++j0) {\n      line.move_to(points[j0]);\n    }\n  }\n  return arc;\n};\n\n// index.js\nfunction greatCircle(start, end, options) {\n  options = options || {};\n  if (typeof options !== \"object\") throw new Error(\"options is invalid\");\n  var properties = options.properties;\n  var npoints = options.npoints;\n  var offset = options.offset;\n  start = getCoord(start);\n  end = getCoord(end);\n  properties = properties || {};\n  npoints = npoints || 100;\n  if (start[0] === end[0] && start[1] === end[1]) {\n    const arr = Array(npoints);\n    arr.fill([start[0], start[1]]);\n    return lineString(arr, properties);\n  }\n  offset = offset || 10;\n  var generator = new GreatCircle({\n    x: start[0],\n    y: start[1]\n  }, {\n    x: end[0],\n    y: end[1]\n  }, properties);\n  var line = generator.Arc(npoints, {\n    offset\n  });\n  return line.json();\n}\nvar turf_great_circle_default = greatCircle;\nexport { turf_great_circle_default as default, greatCircle };\n/*!\n * Copyright (c) 2019, Dane Springmeyer\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in\n *       the documentation and/or other materials provided with the\n *       distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */","map":{"version":3,"names":["lineString","getCoord","D2R","Math","PI","R2D","Coord","lon","lat","x","y","prototype","view","String","slice","antipode","anti_lat","anti_lon","LineString","coords","length","move_to","coord","push","Arc","properties","geometries","json","geometry","type","coordinates","multiline","i","wkt","wkt_string","collect","c","forEach","substring","GreatCircle","start","end","Error","w","h","z","pow","sin","cos","g","asin","sqrt","isNaN","interpolate","f","A","B","atan2","npoints","options","first_pass","delta","step","pair","bHasBigDiff","dfMaxSmallDiffLong","dfDateLineOffset","offset","dfLeftBorderX","dfRightBorderX","dfDiffSpace","j","dfPrevX","dfX","dfDiffLong","abs","poMulti","poNewLS","k","dfX0","parseFloat","dfX1","dfY1","dfX2","dfY2","tmpX","tmpY","dfRatio","dfY","poNewLS0","l","arc","m","line","points","j0","greatCircle","arr","Array","fill","generator","turf_great_circle_default"],"sources":["/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/great-circle/index.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/great-circle/lib/arc.js"],"sourcesContent":["import { lineString } from \"@turf/helpers\";\nimport { getCoord } from \"@turf/invariant\";\nimport { GreatCircle } from \"./lib/arc.js\";\n\n/**\n * Calculate great circles routes as {@link LineString} or {@link MultiLineString}.\n * If the `start` and `end` points span the antimeridian, the resulting feature will\n * be split into a `MultiLineString`. If the `start` and `end` positions are the same\n * then a `LineString` will be returned with duplicate coordinates the length of the `npoints` option.\n *\n * @function\n * @param {Coord} start source point feature\n * @param {Coord} end destination point feature\n * @param {Object} [options={}] Optional parameters\n * @param {Object} [options.properties={}] line feature properties\n * @param {number} [options.npoints=100] number of points\n * @param {number} [options.offset=10] offset controls the likelyhood that lines will\n * be split which cross the dateline. The higher the number the more likely.\n * @returns {Feature<LineString | MultiLineString>} great circle line feature\n * @example\n * var start = turf.point([-122, 48]);\n * var end = turf.point([-77, 39]);\n *\n * var greatCircle = turf.greatCircle(start, end, {properties: {name: 'Seattle to DC'}});\n *\n * //addToMap\n * var addToMap = [start, end, greatCircle]\n */\nfunction greatCircle(start, end, options) {\n  // Optional parameters\n  options = options || {};\n  if (typeof options !== \"object\") throw new Error(\"options is invalid\");\n  var properties = options.properties;\n  var npoints = options.npoints;\n  var offset = options.offset;\n\n  start = getCoord(start);\n  end = getCoord(end);\n\n  properties = properties || {};\n  npoints = npoints || 100;\n\n  if (start[0] === end[0] && start[1] === end[1]) {\n    const arr = Array(npoints);\n    arr.fill([start[0], start[1]]);\n    return lineString(arr, properties);\n  }\n\n  offset = offset || 10;\n\n  var generator = new GreatCircle(\n    { x: start[0], y: start[1] },\n    { x: end[0], y: end[1] },\n    properties\n  );\n\n  var line = generator.Arc(npoints, { offset: offset });\n\n  return line.json();\n}\n\nexport { greatCircle };\nexport default greatCircle;\n","/*!\n * Copyright (c) 2019, Dane Springmeyer\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in\n *       the documentation and/or other materials provided with the\n *       distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nvar D2R = Math.PI / 180;\nvar R2D = 180 / Math.PI;\n\nvar Coord = function (lon, lat) {\n  this.lon = lon;\n  this.lat = lat;\n  this.x = D2R * lon;\n  this.y = D2R * lat;\n};\n\nCoord.prototype.view = function () {\n  return String(this.lon).slice(0, 4) + \",\" + String(this.lat).slice(0, 4);\n};\n\nCoord.prototype.antipode = function () {\n  var anti_lat = -1 * this.lat;\n  var anti_lon = this.lon < 0 ? 180 + this.lon : (180 - this.lon) * -1;\n  return new Coord(anti_lon, anti_lat);\n};\n\nvar LineString = function () {\n  this.coords = [];\n  this.length = 0;\n};\n\nLineString.prototype.move_to = function (coord) {\n  this.length++;\n  this.coords.push(coord);\n};\n\nvar Arc = function (properties) {\n  this.properties = properties || {};\n  this.geometries = [];\n};\n\nArc.prototype.json = function () {\n  if (this.geometries.length <= 0) {\n    return {\n      geometry: { type: \"LineString\", coordinates: null },\n      type: \"Feature\",\n      properties: this.properties,\n    };\n  } else if (this.geometries.length === 1) {\n    return {\n      geometry: { type: \"LineString\", coordinates: this.geometries[0].coords },\n      type: \"Feature\",\n      properties: this.properties,\n    };\n  } else {\n    var multiline = [];\n    for (var i = 0; i < this.geometries.length; i++) {\n      multiline.push(this.geometries[i].coords);\n    }\n    return {\n      geometry: { type: \"MultiLineString\", coordinates: multiline },\n      type: \"Feature\",\n      properties: this.properties,\n    };\n  }\n};\n\n// TODO - output proper multilinestring\nArc.prototype.wkt = function () {\n  var wkt_string = \"\";\n  var wkt = \"LINESTRING(\";\n  var collect = function (c) {\n    wkt += c[0] + \" \" + c[1] + \",\";\n  };\n  for (var i = 0; i < this.geometries.length; i++) {\n    if (this.geometries[i].coords.length === 0) {\n      return \"LINESTRING(empty)\";\n    } else {\n      var coords = this.geometries[i].coords;\n      coords.forEach(collect);\n      wkt_string += wkt.substring(0, wkt.length - 1) + \")\";\n    }\n  }\n  return wkt_string;\n};\n\n/*\n * http://en.wikipedia.org/wiki/Great-circle_distance\n *\n */\nvar GreatCircle = function (start, end, properties) {\n  if (!start || start.x === undefined || start.y === undefined) {\n    throw new Error(\n      \"GreatCircle constructor expects two args: start and end objects with x and y properties\"\n    );\n  }\n  if (!end || end.x === undefined || end.y === undefined) {\n    throw new Error(\n      \"GreatCircle constructor expects two args: start and end objects with x and y properties\"\n    );\n  }\n  this.start = new Coord(start.x, start.y);\n  this.end = new Coord(end.x, end.y);\n  this.properties = properties || {};\n\n  var w = this.start.x - this.end.x;\n  var h = this.start.y - this.end.y;\n  var z =\n    Math.pow(Math.sin(h / 2.0), 2) +\n    Math.cos(this.start.y) *\n      Math.cos(this.end.y) *\n      Math.pow(Math.sin(w / 2.0), 2);\n  this.g = 2.0 * Math.asin(Math.sqrt(z));\n\n  if (this.g === Math.PI) {\n    throw new Error(\n      \"it appears \" +\n        start.view() +\n        \" and \" +\n        end.view() +\n        \" are 'antipodal', e.g diametrically opposite, thus there is no single route but rather infinite\"\n    );\n  } else if (isNaN(this.g)) {\n    throw new Error(\n      \"could not calculate great circle between \" + start + \" and \" + end\n    );\n  }\n};\n\n/*\n * http://williams.best.vwh.net/avform.htm#Intermediate\n */\nGreatCircle.prototype.interpolate = function (f) {\n  var A = Math.sin((1 - f) * this.g) / Math.sin(this.g);\n  var B = Math.sin(f * this.g) / Math.sin(this.g);\n  var x =\n    A * Math.cos(this.start.y) * Math.cos(this.start.x) +\n    B * Math.cos(this.end.y) * Math.cos(this.end.x);\n  var y =\n    A * Math.cos(this.start.y) * Math.sin(this.start.x) +\n    B * Math.cos(this.end.y) * Math.sin(this.end.x);\n  var z = A * Math.sin(this.start.y) + B * Math.sin(this.end.y);\n  var lat = R2D * Math.atan2(z, Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)));\n  var lon = R2D * Math.atan2(y, x);\n  return [lon, lat];\n};\n\n/*\n * Generate points along the great circle\n */\nGreatCircle.prototype.Arc = function (npoints, options) {\n  var first_pass = [];\n  if (!npoints || npoints <= 2) {\n    first_pass.push([this.start.lon, this.start.lat]);\n    first_pass.push([this.end.lon, this.end.lat]);\n  } else {\n    var delta = 1.0 / (npoints - 1);\n    for (var i = 0; i < npoints; ++i) {\n      var step = delta * i;\n      var pair = this.interpolate(step);\n      first_pass.push(pair);\n    }\n  }\n  /* partial port of dateline handling from:\n      gdal/ogr/ogrgeometryfactory.cpp\n\n      TODO - does not handle all wrapping scenarios yet\n    */\n  var bHasBigDiff = false;\n  var dfMaxSmallDiffLong = 0;\n  // from http://www.gdal.org/ogr2ogr.html\n  // -datelineoffset:\n  // (starting with GDAL 1.10) offset from dateline in degrees (default long. = +/- 10deg, geometries within 170deg to -170deg will be splited)\n  var dfDateLineOffset = options && options.offset ? options.offset : 10;\n  var dfLeftBorderX = 180 - dfDateLineOffset;\n  var dfRightBorderX = -180 + dfDateLineOffset;\n  var dfDiffSpace = 360 - dfDateLineOffset;\n\n  // https://github.com/OSGeo/gdal/blob/7bfb9c452a59aac958bff0c8386b891edf8154ca/gdal/ogr/ogrgeometryfactory.cpp#L2342\n  for (var j = 1; j < first_pass.length; ++j) {\n    var dfPrevX = first_pass[j - 1][0];\n    var dfX = first_pass[j][0];\n    var dfDiffLong = Math.abs(dfX - dfPrevX);\n    if (\n      dfDiffLong > dfDiffSpace &&\n      ((dfX > dfLeftBorderX && dfPrevX < dfRightBorderX) ||\n        (dfPrevX > dfLeftBorderX && dfX < dfRightBorderX))\n    ) {\n      bHasBigDiff = true;\n    } else if (dfDiffLong > dfMaxSmallDiffLong) {\n      dfMaxSmallDiffLong = dfDiffLong;\n    }\n  }\n\n  var poMulti = [];\n  if (bHasBigDiff && dfMaxSmallDiffLong < dfDateLineOffset) {\n    var poNewLS = [];\n    poMulti.push(poNewLS);\n    for (var k = 0; k < first_pass.length; ++k) {\n      var dfX0 = parseFloat(first_pass[k][0]);\n      if (k > 0 && Math.abs(dfX0 - first_pass[k - 1][0]) > dfDiffSpace) {\n        var dfX1 = parseFloat(first_pass[k - 1][0]);\n        var dfY1 = parseFloat(first_pass[k - 1][1]);\n        var dfX2 = parseFloat(first_pass[k][0]);\n        var dfY2 = parseFloat(first_pass[k][1]);\n        if (\n          dfX1 > -180 &&\n          dfX1 < dfRightBorderX &&\n          dfX2 === 180 &&\n          k + 1 < first_pass.length &&\n          first_pass[k - 1][0] > -180 &&\n          first_pass[k - 1][0] < dfRightBorderX\n        ) {\n          poNewLS.push([-180, first_pass[k][1]]);\n          k++;\n          poNewLS.push([first_pass[k][0], first_pass[k][1]]);\n          continue;\n        } else if (\n          dfX1 > dfLeftBorderX &&\n          dfX1 < 180 &&\n          dfX2 === -180 &&\n          k + 1 < first_pass.length &&\n          first_pass[k - 1][0] > dfLeftBorderX &&\n          first_pass[k - 1][0] < 180\n        ) {\n          poNewLS.push([180, first_pass[k][1]]);\n          k++;\n          poNewLS.push([first_pass[k][0], first_pass[k][1]]);\n          continue;\n        }\n\n        if (dfX1 < dfRightBorderX && dfX2 > dfLeftBorderX) {\n          // swap dfX1, dfX2\n          var tmpX = dfX1;\n          dfX1 = dfX2;\n          dfX2 = tmpX;\n          // swap dfY1, dfY2\n          var tmpY = dfY1;\n          dfY1 = dfY2;\n          dfY2 = tmpY;\n        }\n        if (dfX1 > dfLeftBorderX && dfX2 < dfRightBorderX) {\n          dfX2 += 360;\n        }\n\n        if (dfX1 <= 180 && dfX2 >= 180 && dfX1 < dfX2) {\n          var dfRatio = (180 - dfX1) / (dfX2 - dfX1);\n          var dfY = dfRatio * dfY2 + (1 - dfRatio) * dfY1;\n          poNewLS.push([\n            first_pass[k - 1][0] > dfLeftBorderX ? 180 : -180,\n            dfY,\n          ]);\n          poNewLS = [];\n          poNewLS.push([\n            first_pass[k - 1][0] > dfLeftBorderX ? -180 : 180,\n            dfY,\n          ]);\n          poMulti.push(poNewLS);\n        } else {\n          poNewLS = [];\n          poMulti.push(poNewLS);\n        }\n        poNewLS.push([dfX0, first_pass[k][1]]);\n      } else {\n        poNewLS.push([first_pass[k][0], first_pass[k][1]]);\n      }\n    }\n  } else {\n    // add normally\n    var poNewLS0 = [];\n    poMulti.push(poNewLS0);\n    for (var l = 0; l < first_pass.length; ++l) {\n      poNewLS0.push([first_pass[l][0], first_pass[l][1]]);\n    }\n  }\n\n  var arc = new Arc(this.properties);\n  for (var m = 0; m < poMulti.length; ++m) {\n    var line = new LineString();\n    arc.geometries.push(line);\n    var points = poMulti[m];\n    for (var j0 = 0; j0 < points.length; ++j0) {\n      line.move_to(points[j0]);\n    }\n  }\n  return arc;\n};\n\nexport { Coord, Arc, GreatCircle };\n\nexport default {\n  Coord,\n  Arc,\n  GreatCircle,\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}