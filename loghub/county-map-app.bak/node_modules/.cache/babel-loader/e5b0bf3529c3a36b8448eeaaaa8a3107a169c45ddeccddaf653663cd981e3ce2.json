{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\n\n// index.ts\nimport { getType } from \"@turf/invariant\";\nimport { featureEach, geomEach } from \"@turf/meta\";\nimport { pointToLineDistance } from \"@turf/point-to-line-distance\";\nfunction nearestPointToLine(points, line, options = {}) {\n  const units = options.units;\n  const properties = options.properties || {};\n  const pts = normalize(points);\n  if (!pts.features.length) {\n    throw new Error(\"points must contain features\");\n  }\n  if (!line) {\n    throw new Error(\"line is required\");\n  }\n  if (getType(line) !== \"LineString\") {\n    throw new Error(\"line must be a LineString\");\n  }\n  let dist = Infinity;\n  let pt = null;\n  featureEach(pts, point => {\n    const d = pointToLineDistance(point, line, {\n      units\n    });\n    if (d < dist) {\n      dist = d;\n      pt = point;\n    }\n  });\n  if (pt) {\n    pt.properties = __spreadValues(__spreadValues(__spreadValues({}, {\n      dist\n    }), pt.properties), properties);\n  }\n  return pt;\n}\nfunction normalize(points) {\n  const features = [];\n  const type = points.geometry ? points.geometry.type : points.type;\n  switch (type) {\n    case \"GeometryCollection\":\n      geomEach(points, geom => {\n        if (geom.type === \"Point\") {\n          features.push({\n            type: \"Feature\",\n            properties: {},\n            geometry: geom\n          });\n        }\n      });\n      return {\n        type: \"FeatureCollection\",\n        features\n      };\n    case \"FeatureCollection\":\n      points.features = points.features.filter(feature => {\n        return feature.geometry.type === \"Point\";\n      });\n      return points;\n    default:\n      throw new Error(\"points must be a Point Collection\");\n  }\n}\nvar turf_nearest_point_to_line_default = nearestPointToLine;\nexport { turf_nearest_point_to_line_default as default, nearestPointToLine };","map":{"version":3,"names":["getType","featureEach","geomEach","pointToLineDistance","nearestPointToLine","points","line","options","units","properties","pts","normalize","features","length","Error","dist","Infinity","pt","point","d","__spreadValues","type","geometry","geom","push","filter","feature","turf_nearest_point_to_line_default"],"sources":["/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/nearest-point-to-line/index.ts"],"sourcesContent":["import {\n  Feature,\n  FeatureCollection,\n  GeometryCollection,\n  LineString,\n  Point,\n  GeoJsonProperties,\n} from \"geojson\";\nimport { Units } from \"@turf/helpers\";\nimport { getType } from \"@turf/invariant\";\nimport { featureEach, geomEach } from \"@turf/meta\";\nimport { pointToLineDistance } from \"@turf/point-to-line-distance\";\n\n/**\n * Returns the closest {@link Point|point}, of a {@link FeatureCollection|collection} of points,\n * to a {@link LineString|line}. The returned point has a `dist` property indicating its distance to the line.\n *\n * @function\n * @param {FeatureCollection|GeometryCollection<Point>} points Point Collection\n * @param {Feature|Geometry<LineString>} line Line Feature\n * @param {Object} [options] Optional parameters\n * @param {string} [options.units='kilometers'] unit of the output distance property\n * (eg: degrees, radians, miles, or kilometers)\n * @param {Object} [options.properties={}] Translate Properties to Point\n * @returns {Feature<Point>} the closest point\n * @example\n * var pt1 = turf.point([0, 0]);\n * var pt2 = turf.point([0.5, 0.5]);\n * var points = turf.featureCollection([pt1, pt2]);\n * var line = turf.lineString([[1,1], [-1,1]]);\n *\n * var nearest = turf.nearestPointToLine(points, line);\n *\n * //addToMap\n * var addToMap = [nearest, line];\n */\nfunction nearestPointToLine<P = { dist: number; [key: string]: any }>(\n  points:\n    | FeatureCollection<Point>\n    | Feature<GeometryCollection>\n    | GeometryCollection,\n  line: Feature<LineString> | LineString,\n  options: {\n    units?: Units;\n    properties?: GeoJsonProperties;\n  } = {}\n): Feature<Point, P> {\n  const units = options.units;\n  const properties = options.properties || {};\n\n  // validation\n  const pts = normalize(points);\n  if (!pts.features.length) {\n    throw new Error(\"points must contain features\");\n  }\n\n  if (!line) {\n    throw new Error(\"line is required\");\n  }\n  if (getType(line) !== \"LineString\") {\n    throw new Error(\"line must be a LineString\");\n  }\n\n  let dist = Infinity;\n  let pt: any = null;\n\n  featureEach(pts, (point) => {\n    const d = pointToLineDistance(point, line, { units });\n    if (d < dist) {\n      dist = d;\n      pt = point;\n    }\n  });\n  /*\n   * Translate Properties to final Point, priorities:\n   * 1. options.properties\n   * 2. inherent Point properties\n   * 3. dist custom properties created by NearestPointToLine\n   */\n  if (pt) {\n    pt.properties = { ...{ dist }, ...pt.properties, ...properties };\n  }\n  return pt;\n}\n\n/**\n * Convert Collection to FeatureCollection\n *\n * @private\n * @param {FeatureCollection|GeometryCollection} points Points\n * @returns {FeatureCollection<Point>} points\n */\nfunction normalize(points: any): FeatureCollection<Point> {\n  const features: any[] = [];\n  const type = points.geometry ? points.geometry.type : points.type;\n  switch (type) {\n    case \"GeometryCollection\":\n      geomEach(points, (geom) => {\n        if (geom.type === \"Point\") {\n          features.push({ type: \"Feature\", properties: {}, geometry: geom });\n        }\n      });\n      return { type: \"FeatureCollection\", features };\n    case \"FeatureCollection\":\n      points.features = points.features.filter((feature: any) => {\n        return feature.geometry.type === \"Point\";\n      });\n      return points;\n    default:\n      throw new Error(\"points must be a Point Collection\");\n  }\n}\n\nexport { nearestPointToLine };\nexport default nearestPointToLine;\n"],"mappings":";;;;;;;;;;;;;;;;;;;AASA,SAASA,OAAA,QAAe;AACxB,SAASC,WAAA,EAAaC,QAAA,QAAgB;AACtC,SAASC,mBAAA,QAA2B;AAyBpC,SAASC,mBACPC,MAAA,EAIAC,IAAA,EACAC,OAAA,GAGI,CAAC,GACc;EACnB,MAAMC,KAAA,GAAQD,OAAA,CAAQC,KAAA;EACtB,MAAMC,UAAA,GAAaF,OAAA,CAAQE,UAAA,IAAc,CAAC;EAG1C,MAAMC,GAAA,GAAMC,SAAA,CAAUN,MAAM;EAC5B,IAAI,CAACK,GAAA,CAAIE,QAAA,CAASC,MAAA,EAAQ;IACxB,MAAM,IAAIC,KAAA,CAAM,8BAA8B;EAChD;EAEA,IAAI,CAACR,IAAA,EAAM;IACT,MAAM,IAAIQ,KAAA,CAAM,kBAAkB;EACpC;EACA,IAAId,OAAA,CAAQM,IAAI,MAAM,cAAc;IAClC,MAAM,IAAIQ,KAAA,CAAM,2BAA2B;EAC7C;EAEA,IAAIC,IAAA,GAAOC,QAAA;EACX,IAAIC,EAAA,GAAU;EAEdhB,WAAA,CAAYS,GAAA,EAAMQ,KAAA,IAAU;IAC1B,MAAMC,CAAA,GAAIhB,mBAAA,CAAoBe,KAAA,EAAOZ,IAAA,EAAM;MAAEE;IAAM,CAAC;IACpD,IAAIW,CAAA,GAAIJ,IAAA,EAAM;MACZA,IAAA,GAAOI,CAAA;MACPF,EAAA,GAAKC,KAAA;IACP;EACF,CAAC;EAOD,IAAID,EAAA,EAAI;IACNA,EAAA,CAAGR,UAAA,GAAaW,cAAA,CAAAA,cAAA,CAAAA,cAAA,KAAK;MAAEL;IAAK,IAAME,EAAA,CAAGR,UAAA,GAAeA,UAAA;EACtD;EACA,OAAOQ,EAAA;AACT;AASA,SAASN,UAAUN,MAAA,EAAuC;EACxD,MAAMO,QAAA,GAAkB,EAAC;EACzB,MAAMS,IAAA,GAAOhB,MAAA,CAAOiB,QAAA,GAAWjB,MAAA,CAAOiB,QAAA,CAASD,IAAA,GAAOhB,MAAA,CAAOgB,IAAA;EAC7D,QAAQA,IAAA;IACN,KAAK;MACHnB,QAAA,CAASG,MAAA,EAASkB,IAAA,IAAS;QACzB,IAAIA,IAAA,CAAKF,IAAA,KAAS,SAAS;UACzBT,QAAA,CAASY,IAAA,CAAK;YAAEH,IAAA,EAAM;YAAWZ,UAAA,EAAY,CAAC;YAAGa,QAAA,EAAUC;UAAK,CAAC;QACnE;MACF,CAAC;MACD,OAAO;QAAEF,IAAA,EAAM;QAAqBT;MAAS;IAC/C,KAAK;MACHP,MAAA,CAAOO,QAAA,GAAWP,MAAA,CAAOO,QAAA,CAASa,MAAA,CAAQC,OAAA,IAAiB;QACzD,OAAOA,OAAA,CAAQJ,QAAA,CAASD,IAAA,KAAS;MACnC,CAAC;MACD,OAAOhB,MAAA;IACT;MACE,MAAM,IAAIS,KAAA,CAAM,mCAAmC;EACvD;AACF;AAGA,IAAOa,kCAAA,GAAQvB,kBAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}