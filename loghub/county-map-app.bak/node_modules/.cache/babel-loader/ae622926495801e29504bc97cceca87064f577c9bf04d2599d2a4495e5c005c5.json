{"ast":null,"code":"// index.ts\nimport earcut from \"earcut\";\nimport { polygon } from \"@turf/helpers\";\nfunction tesselate(poly) {\n  if (!poly.geometry || poly.geometry.type !== \"Polygon\" && poly.geometry.type !== \"MultiPolygon\") {\n    throw new Error(\"input must be a Polygon or MultiPolygon\");\n  }\n  const fc = {\n    type: \"FeatureCollection\",\n    features: []\n  };\n  if (poly.geometry.type === \"Polygon\") {\n    fc.features = processPolygon(poly.geometry.coordinates);\n  } else {\n    poly.geometry.coordinates.forEach(function (coordinates) {\n      fc.features = fc.features.concat(processPolygon(coordinates));\n    });\n  }\n  return fc;\n}\nfunction processPolygon(coordinates) {\n  const data = flattenCoords(coordinates);\n  const dim = 2;\n  const result = earcut(data.vertices, data.holes, dim);\n  const features = [];\n  const vertices = [];\n  result.forEach(function (vert, i2) {\n    const index = result[i2];\n    vertices.push([data.vertices[index * dim], data.vertices[index * dim + 1]]);\n  });\n  for (var i = 0; i < vertices.length; i += 3) {\n    const coords = vertices.slice(i, i + 3);\n    coords.push(vertices[i]);\n    features.push(polygon([coords]));\n  }\n  return features;\n}\nfunction flattenCoords(data) {\n  const dim = data[0][0].length,\n    result = {\n      vertices: [],\n      holes: [],\n      dimensions: dim\n    };\n  let holeIndex = 0;\n  for (let i = 0; i < data.length; i++) {\n    for (let j = 0; j < data[i].length; j++) {\n      for (let d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);\n    }\n    if (i > 0) {\n      holeIndex += data[i - 1].length;\n      result.holes.push(holeIndex);\n    }\n  }\n  return result;\n}\nvar turf_tesselate_default = tesselate;\nexport { turf_tesselate_default as default, tesselate };","map":{"version":3,"names":["earcut","polygon","tesselate","poly","geometry","type","Error","fc","features","processPolygon","coordinates","forEach","concat","data","flattenCoords","dim","result","vertices","holes","vert","i2","index","push","i","length","coords","slice","dimensions","holeIndex","j","d","turf_tesselate_default"],"sources":["/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/tesselate/index.ts"],"sourcesContent":["import {\n  Feature,\n  FeatureCollection,\n  MultiPolygon,\n  Polygon,\n  Position,\n} from \"geojson\";\nimport earcut from \"earcut\";\nimport { polygon } from \"@turf/helpers\";\n\n/**\n * Tesselates a polygon or multipolygon into a collection of triangle polygons\n * using [earcut](https://github.com/mapbox/earcut).\n *\n * @function\n * @param {Feature<Polygon|MultiPolygon>} poly the polygon to tesselate\n * @returns {FeatureCollection<Polygon>} collection of polygon tesselations\n * @example\n * const poly = turf.polygon([[[11, 0], [22, 4], [31, 0], [31, 11], [21, 15], [11, 11], [11, 0]]]);\n * const triangles = turf.tesselate(poly);\n *\n * //addToMap\n * const addToMap = [poly, triangles]\n */\nfunction tesselate(\n  poly: Feature<Polygon | MultiPolygon>\n): FeatureCollection<Polygon> {\n  if (\n    !poly.geometry ||\n    (poly.geometry.type !== \"Polygon\" && poly.geometry.type !== \"MultiPolygon\")\n  ) {\n    throw new Error(\"input must be a Polygon or MultiPolygon\");\n  }\n\n  const fc: FeatureCollection<Polygon> = {\n    type: \"FeatureCollection\",\n    features: [],\n  };\n\n  if (poly.geometry.type === \"Polygon\") {\n    fc.features = processPolygon(poly.geometry.coordinates);\n  } else {\n    poly.geometry.coordinates.forEach(function (coordinates) {\n      fc.features = fc.features.concat(processPolygon(coordinates));\n    });\n  }\n\n  return fc;\n}\n\nfunction processPolygon(coordinates: Position[][]) {\n  const data = flattenCoords(coordinates);\n  const dim = 2;\n  const result = earcut(data.vertices, data.holes, dim);\n\n  const features: Feature<Polygon>[] = [];\n  const vertices: Position[] = [];\n\n  result.forEach(function (vert: any, i: number) {\n    const index = result[i];\n    vertices.push([data.vertices[index * dim], data.vertices[index * dim + 1]]);\n  });\n\n  for (var i = 0; i < vertices.length; i += 3) {\n    const coords = vertices.slice(i, i + 3);\n    coords.push(vertices[i]);\n    features.push(polygon([coords]));\n  }\n\n  return features;\n}\n\nfunction flattenCoords(data: Position[][]) {\n  const dim: number = data[0][0].length,\n    result: { vertices: number[]; holes: number[]; dimensions: number } = {\n      vertices: [],\n      holes: [],\n      dimensions: dim,\n    };\n  let holeIndex = 0;\n\n  for (let i = 0; i < data.length; i++) {\n    for (let j = 0; j < data[i].length; j++) {\n      for (let d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);\n    }\n    if (i > 0) {\n      holeIndex += data[i - 1].length;\n      result.holes.push(holeIndex);\n    }\n  }\n\n  return result;\n}\n\nexport { tesselate };\nexport default tesselate;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}