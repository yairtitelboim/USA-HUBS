{"ast":null,"code":"// src/index.ts\nvar SplayTreeNode = class {\n  key;\n  left = null;\n  right = null;\n  constructor(key) {\n    this.key = key;\n  }\n};\nvar SplayTreeSetNode = class extends SplayTreeNode {\n  constructor(key) {\n    super(key);\n  }\n};\nvar SplayTreeMapNode = class _SplayTreeMapNode extends SplayTreeNode {\n  value;\n  constructor(key, value) {\n    super(key);\n    this.value = value;\n  }\n  replaceValue(value) {\n    const node = new _SplayTreeMapNode(this.key, value);\n    node.left = this.left;\n    node.right = this.right;\n    return node;\n  }\n};\nvar SplayTree = class {\n  size = 0;\n  modificationCount = 0;\n  splayCount = 0;\n  splay(key) {\n    const root = this.root;\n    if (root == null) {\n      this.compare(key, key);\n      return -1;\n    }\n    let right = null;\n    let newTreeRight = null;\n    let left = null;\n    let newTreeLeft = null;\n    let current = root;\n    const compare = this.compare;\n    let comp;\n    while (true) {\n      comp = compare(current.key, key);\n      if (comp > 0) {\n        let currentLeft = current.left;\n        if (currentLeft == null) break;\n        comp = compare(currentLeft.key, key);\n        if (comp > 0) {\n          current.left = currentLeft.right;\n          currentLeft.right = current;\n          current = currentLeft;\n          currentLeft = current.left;\n          if (currentLeft == null) break;\n        }\n        if (right == null) {\n          newTreeRight = current;\n        } else {\n          right.left = current;\n        }\n        right = current;\n        current = currentLeft;\n      } else if (comp < 0) {\n        let currentRight = current.right;\n        if (currentRight == null) break;\n        comp = compare(currentRight.key, key);\n        if (comp < 0) {\n          current.right = currentRight.left;\n          currentRight.left = current;\n          current = currentRight;\n          currentRight = current.right;\n          if (currentRight == null) break;\n        }\n        if (left == null) {\n          newTreeLeft = current;\n        } else {\n          left.right = current;\n        }\n        left = current;\n        current = currentRight;\n      } else {\n        break;\n      }\n    }\n    if (left != null) {\n      left.right = current.left;\n      current.left = newTreeLeft;\n    }\n    if (right != null) {\n      right.left = current.right;\n      current.right = newTreeRight;\n    }\n    if (this.root !== current) {\n      this.root = current;\n      this.splayCount++;\n    }\n    return comp;\n  }\n  splayMin(node) {\n    let current = node;\n    let nextLeft = current.left;\n    while (nextLeft != null) {\n      const left = nextLeft;\n      current.left = left.right;\n      left.right = current;\n      current = left;\n      nextLeft = current.left;\n    }\n    return current;\n  }\n  splayMax(node) {\n    let current = node;\n    let nextRight = current.right;\n    while (nextRight != null) {\n      const right = nextRight;\n      current.right = right.left;\n      right.left = current;\n      current = right;\n      nextRight = current.right;\n    }\n    return current;\n  }\n  _delete(key) {\n    if (this.root == null) return null;\n    const comp = this.splay(key);\n    if (comp != 0) return null;\n    let root = this.root;\n    const result = root;\n    const left = root.left;\n    this.size--;\n    if (left == null) {\n      this.root = root.right;\n    } else {\n      const right = root.right;\n      root = this.splayMax(left);\n      root.right = right;\n      this.root = root;\n    }\n    this.modificationCount++;\n    return result;\n  }\n  addNewRoot(node, comp) {\n    this.size++;\n    this.modificationCount++;\n    const root = this.root;\n    if (root == null) {\n      this.root = node;\n      return;\n    }\n    if (comp < 0) {\n      node.left = root;\n      node.right = root.right;\n      root.right = null;\n    } else {\n      node.right = root;\n      node.left = root.left;\n      root.left = null;\n    }\n    this.root = node;\n  }\n  _first() {\n    const root = this.root;\n    if (root == null) return null;\n    this.root = this.splayMin(root);\n    return this.root;\n  }\n  _last() {\n    const root = this.root;\n    if (root == null) return null;\n    this.root = this.splayMax(root);\n    return this.root;\n  }\n  clear() {\n    this.root = null;\n    this.size = 0;\n    this.modificationCount++;\n  }\n  has(key) {\n    return this.validKey(key) && this.splay(key) == 0;\n  }\n  defaultCompare() {\n    return (a, b) => a < b ? -1 : a > b ? 1 : 0;\n  }\n  wrap() {\n    return {\n      getRoot: () => {\n        return this.root;\n      },\n      setRoot: root => {\n        this.root = root;\n      },\n      getSize: () => {\n        return this.size;\n      },\n      getModificationCount: () => {\n        return this.modificationCount;\n      },\n      getSplayCount: () => {\n        return this.splayCount;\n      },\n      setSplayCount: count => {\n        this.splayCount = count;\n      },\n      splay: key => {\n        return this.splay(key);\n      },\n      has: key => {\n        return this.has(key);\n      }\n    };\n  }\n};\nvar SplayTreeMap = class extends SplayTree {\n  root = null;\n  compare;\n  validKey;\n  constructor(compare, isValidKey) {\n    super();\n    this.compare = compare ?? this.defaultCompare();\n    this.validKey = isValidKey ?? (a => a != null && a != void 0);\n  }\n  delete(key) {\n    if (!this.validKey(key)) return false;\n    return this._delete(key) != null;\n  }\n  forEach(f) {\n    const nodes = new SplayTreeMapEntryIterableIterator(this.wrap());\n    let result;\n    while (result = nodes.next(), !result.done) {\n      f(result.value[1], result.value[0], this);\n    }\n  }\n  get(key) {\n    if (!this.validKey(key)) return void 0;\n    if (this.root != null) {\n      const comp = this.splay(key);\n      if (comp == 0) {\n        return this.root.value;\n      }\n    }\n    return void 0;\n  }\n  hasValue(value) {\n    const initialSplayCount = this.splayCount;\n    const visit = node => {\n      while (node != null) {\n        if (node.value == value) return true;\n        if (initialSplayCount != this.splayCount) {\n          throw \"Concurrent modification during iteration.\";\n        }\n        if (node.right != null && visit(node.right)) {\n          return true;\n        }\n        node = node.left;\n      }\n      return false;\n    };\n    return visit(this.root);\n  }\n  set(key, value) {\n    const comp = this.splay(key);\n    if (comp == 0) {\n      this.root = this.root.replaceValue(value);\n      this.splayCount += 1;\n      return this;\n    }\n    this.addNewRoot(new SplayTreeMapNode(key, value), comp);\n    return this;\n  }\n  setAll(other) {\n    other.forEach((value, key) => {\n      this.set(key, value);\n    });\n  }\n  setIfAbsent(key, ifAbsent) {\n    let comp = this.splay(key);\n    if (comp == 0) {\n      return this.root.value;\n    }\n    const modificationCount = this.modificationCount;\n    const splayCount = this.splayCount;\n    const value = ifAbsent();\n    if (modificationCount != this.modificationCount) {\n      throw \"Concurrent modification during iteration.\";\n    }\n    if (splayCount != this.splayCount) {\n      comp = this.splay(key);\n    }\n    this.addNewRoot(new SplayTreeMapNode(key, value), comp);\n    return value;\n  }\n  isEmpty() {\n    return this.root == null;\n  }\n  isNotEmpty() {\n    return !this.isEmpty();\n  }\n  firstKey() {\n    if (this.root == null) return null;\n    return this._first().key;\n  }\n  lastKey() {\n    if (this.root == null) return null;\n    return this._last().key;\n  }\n  lastKeyBefore(key) {\n    if (key == null) throw \"Invalid arguments(s)\";\n    if (this.root == null) return null;\n    const comp = this.splay(key);\n    if (comp < 0) return this.root.key;\n    let node = this.root.left;\n    if (node == null) return null;\n    let nodeRight = node.right;\n    while (nodeRight != null) {\n      node = nodeRight;\n      nodeRight = node.right;\n    }\n    return node.key;\n  }\n  firstKeyAfter(key) {\n    if (key == null) throw \"Invalid arguments(s)\";\n    if (this.root == null) return null;\n    const comp = this.splay(key);\n    if (comp > 0) return this.root.key;\n    let node = this.root.right;\n    if (node == null) return null;\n    let nodeLeft = node.left;\n    while (nodeLeft != null) {\n      node = nodeLeft;\n      nodeLeft = node.left;\n    }\n    return node.key;\n  }\n  update(key, update, ifAbsent) {\n    let comp = this.splay(key);\n    if (comp == 0) {\n      const modificationCount = this.modificationCount;\n      const splayCount = this.splayCount;\n      const newValue = update(this.root.value);\n      if (modificationCount != this.modificationCount) {\n        throw \"Concurrent modification during iteration.\";\n      }\n      if (splayCount != this.splayCount) {\n        this.splay(key);\n      }\n      this.root = this.root.replaceValue(newValue);\n      this.splayCount += 1;\n      return newValue;\n    }\n    if (ifAbsent != null) {\n      const modificationCount = this.modificationCount;\n      const splayCount = this.splayCount;\n      const newValue = ifAbsent();\n      if (modificationCount != this.modificationCount) {\n        throw \"Concurrent modification during iteration.\";\n      }\n      if (splayCount != this.splayCount) {\n        comp = this.splay(key);\n      }\n      this.addNewRoot(new SplayTreeMapNode(key, newValue), comp);\n      return newValue;\n    }\n    throw \"Invalid argument (key): Key not in map.\";\n  }\n  updateAll(update) {\n    const root = this.root;\n    if (root == null) return;\n    const iterator = new SplayTreeMapEntryIterableIterator(this.wrap());\n    let node;\n    while (node = iterator.next(), !node.done) {\n      const newValue = update(...node.value);\n      iterator.replaceValue(newValue);\n    }\n  }\n  keys() {\n    return new SplayTreeKeyIterableIterator(this.wrap());\n  }\n  values() {\n    return new SplayTreeValueIterableIterator(this.wrap());\n  }\n  entries() {\n    return this[Symbol.iterator]();\n  }\n  [Symbol.iterator]() {\n    return new SplayTreeMapEntryIterableIterator(this.wrap());\n  }\n  [Symbol.toStringTag] = \"[object Map]\";\n};\nvar SplayTreeSet = class _SplayTreeSet extends SplayTree {\n  root = null;\n  compare;\n  validKey;\n  constructor(compare, isValidKey) {\n    super();\n    this.compare = compare ?? this.defaultCompare();\n    this.validKey = isValidKey ?? (v => v != null && v != void 0);\n  }\n  delete(element) {\n    if (!this.validKey(element)) return false;\n    return this._delete(element) != null;\n  }\n  deleteAll(elements) {\n    for (const element of elements) {\n      this.delete(element);\n    }\n  }\n  forEach(f) {\n    const nodes = this[Symbol.iterator]();\n    let result;\n    while (result = nodes.next(), !result.done) {\n      f(result.value, result.value, this);\n    }\n  }\n  add(element) {\n    const compare = this.splay(element);\n    if (compare != 0) this.addNewRoot(new SplayTreeSetNode(element), compare);\n    return this;\n  }\n  addAndReturn(element) {\n    const compare = this.splay(element);\n    if (compare != 0) this.addNewRoot(new SplayTreeSetNode(element), compare);\n    return this.root.key;\n  }\n  addAll(elements) {\n    for (const element of elements) {\n      this.add(element);\n    }\n  }\n  isEmpty() {\n    return this.root == null;\n  }\n  isNotEmpty() {\n    return this.root != null;\n  }\n  single() {\n    if (this.size == 0) throw \"Bad state: No element\";\n    if (this.size > 1) throw \"Bad state: Too many element\";\n    return this.root.key;\n  }\n  first() {\n    if (this.size == 0) throw \"Bad state: No element\";\n    return this._first().key;\n  }\n  last() {\n    if (this.size == 0) throw \"Bad state: No element\";\n    return this._last().key;\n  }\n  lastBefore(element) {\n    if (element == null) throw \"Invalid arguments(s)\";\n    if (this.root == null) return null;\n    const comp = this.splay(element);\n    if (comp < 0) return this.root.key;\n    let node = this.root.left;\n    if (node == null) return null;\n    let nodeRight = node.right;\n    while (nodeRight != null) {\n      node = nodeRight;\n      nodeRight = node.right;\n    }\n    return node.key;\n  }\n  firstAfter(element) {\n    if (element == null) throw \"Invalid arguments(s)\";\n    if (this.root == null) return null;\n    const comp = this.splay(element);\n    if (comp > 0) return this.root.key;\n    let node = this.root.right;\n    if (node == null) return null;\n    let nodeLeft = node.left;\n    while (nodeLeft != null) {\n      node = nodeLeft;\n      nodeLeft = node.left;\n    }\n    return node.key;\n  }\n  retainAll(elements) {\n    const retainSet = new _SplayTreeSet(this.compare, this.validKey);\n    const modificationCount = this.modificationCount;\n    for (const object of elements) {\n      if (modificationCount != this.modificationCount) {\n        throw \"Concurrent modification during iteration.\";\n      }\n      if (this.validKey(object) && this.splay(object) == 0) {\n        retainSet.add(this.root.key);\n      }\n    }\n    if (retainSet.size != this.size) {\n      this.root = retainSet.root;\n      this.size = retainSet.size;\n      this.modificationCount++;\n    }\n  }\n  lookup(object) {\n    if (!this.validKey(object)) return null;\n    const comp = this.splay(object);\n    if (comp != 0) return null;\n    return this.root.key;\n  }\n  intersection(other) {\n    const result = new _SplayTreeSet(this.compare, this.validKey);\n    for (const element of this) {\n      if (other.has(element)) result.add(element);\n    }\n    return result;\n  }\n  difference(other) {\n    const result = new _SplayTreeSet(this.compare, this.validKey);\n    for (const element of this) {\n      if (!other.has(element)) result.add(element);\n    }\n    return result;\n  }\n  union(other) {\n    const u = this.clone();\n    u.addAll(other);\n    return u;\n  }\n  clone() {\n    const set = new _SplayTreeSet(this.compare, this.validKey);\n    set.size = this.size;\n    set.root = this.copyNode(this.root);\n    return set;\n  }\n  copyNode(node) {\n    if (node == null) return null;\n    function copyChildren(node2, dest) {\n      let left;\n      let right;\n      do {\n        left = node2.left;\n        right = node2.right;\n        if (left != null) {\n          const newLeft = new SplayTreeSetNode(left.key);\n          dest.left = newLeft;\n          copyChildren(left, newLeft);\n        }\n        if (right != null) {\n          const newRight = new SplayTreeSetNode(right.key);\n          dest.right = newRight;\n          node2 = right;\n          dest = newRight;\n        }\n      } while (right != null);\n    }\n    const result = new SplayTreeSetNode(node.key);\n    copyChildren(node, result);\n    return result;\n  }\n  toSet() {\n    return this.clone();\n  }\n  entries() {\n    return new SplayTreeSetEntryIterableIterator(this.wrap());\n  }\n  keys() {\n    return this[Symbol.iterator]();\n  }\n  values() {\n    return this[Symbol.iterator]();\n  }\n  [Symbol.iterator]() {\n    return new SplayTreeKeyIterableIterator(this.wrap());\n  }\n  [Symbol.toStringTag] = \"[object Set]\";\n};\nvar SplayTreeIterableIterator = class {\n  tree;\n  path = new Array();\n  modificationCount = null;\n  splayCount;\n  constructor(tree) {\n    this.tree = tree;\n    this.splayCount = tree.getSplayCount();\n  }\n  [Symbol.iterator]() {\n    return this;\n  }\n  next() {\n    if (this.moveNext()) return {\n      done: false,\n      value: this.current()\n    };\n    return {\n      done: true,\n      value: null\n    };\n  }\n  current() {\n    if (!this.path.length) return null;\n    const node = this.path[this.path.length - 1];\n    return this.getValue(node);\n  }\n  rebuildPath(key) {\n    this.path.splice(0, this.path.length);\n    this.tree.splay(key);\n    this.path.push(this.tree.getRoot());\n    this.splayCount = this.tree.getSplayCount();\n  }\n  findLeftMostDescendent(node) {\n    while (node != null) {\n      this.path.push(node);\n      node = node.left;\n    }\n  }\n  moveNext() {\n    if (this.modificationCount != this.tree.getModificationCount()) {\n      if (this.modificationCount == null) {\n        this.modificationCount = this.tree.getModificationCount();\n        let node2 = this.tree.getRoot();\n        while (node2 != null) {\n          this.path.push(node2);\n          node2 = node2.left;\n        }\n        return this.path.length > 0;\n      }\n      throw \"Concurrent modification during iteration.\";\n    }\n    if (!this.path.length) return false;\n    if (this.splayCount != this.tree.getSplayCount()) {\n      this.rebuildPath(this.path[this.path.length - 1].key);\n    }\n    let node = this.path[this.path.length - 1];\n    let next = node.right;\n    if (next != null) {\n      while (next != null) {\n        this.path.push(next);\n        next = next.left;\n      }\n      return true;\n    }\n    this.path.pop();\n    while (this.path.length && this.path[this.path.length - 1].right === node) {\n      node = this.path.pop();\n    }\n    return this.path.length > 0;\n  }\n};\nvar SplayTreeKeyIterableIterator = class extends SplayTreeIterableIterator {\n  getValue(node) {\n    return node.key;\n  }\n};\nvar SplayTreeSetEntryIterableIterator = class extends SplayTreeIterableIterator {\n  getValue(node) {\n    return [node.key, node.key];\n  }\n};\nvar SplayTreeValueIterableIterator = class extends SplayTreeIterableIterator {\n  constructor(map) {\n    super(map);\n  }\n  getValue(node) {\n    return node.value;\n  }\n};\nvar SplayTreeMapEntryIterableIterator = class extends SplayTreeIterableIterator {\n  constructor(map) {\n    super(map);\n  }\n  getValue(node) {\n    return [node.key, node.value];\n  }\n  replaceValue(value) {\n    if (this.modificationCount != this.tree.getModificationCount()) {\n      throw \"Concurrent modification during iteration.\";\n    }\n    if (this.splayCount != this.tree.getSplayCount()) {\n      this.rebuildPath(this.path[this.path.length - 1].key);\n    }\n    const last = this.path.pop();\n    const newLast = last.replaceValue(value);\n    if (!this.path.length) {\n      this.tree.setRoot(newLast);\n    } else {\n      const parent = this.path[this.path.length - 1];\n      if (last === parent.left) {\n        parent.left = newLast;\n      } else {\n        parent.right = newLast;\n      }\n    }\n    this.path.push(newLast);\n    const count = this.tree.getSplayCount() + 1;\n    this.tree.setSplayCount(count);\n    this.splayCount = count;\n  }\n};\nexport { SplayTreeMap, SplayTreeSet };","map":{"version":3,"names":["SplayTreeNode","key","left","right","constructor","SplayTreeSetNode","SplayTreeMapNode","_SplayTreeMapNode","value","replaceValue","node","SplayTree","size","modificationCount","splayCount","splay","root","compare","newTreeRight","newTreeLeft","current","comp","currentLeft","currentRight","splayMin","nextLeft","splayMax","nextRight","_delete","result","addNewRoot","_first","_last","clear","has","validKey","defaultCompare","a","b","wrap","getRoot","setRoot","getSize","getModificationCount","getSplayCount","setSplayCount","count","SplayTreeMap","isValidKey","delete","forEach","f","nodes","SplayTreeMapEntryIterableIterator","next","done","get","hasValue","initialSplayCount","visit","set","setAll","other","setIfAbsent","ifAbsent","isEmpty","isNotEmpty","firstKey","lastKey","lastKeyBefore","nodeRight","firstKeyAfter","nodeLeft","update","newValue","updateAll","iterator","keys","SplayTreeKeyIterableIterator","values","SplayTreeValueIterableIterator","entries","Symbol","toStringTag","SplayTreeSet","_SplayTreeSet","v","element","deleteAll","elements","add","addAndReturn","addAll","single","first","last","lastBefore","firstAfter","retainAll","retainSet","object","lookup","intersection","difference","union","u","clone","copyNode","copyChildren","node2","dest","newLeft","newRight","toSet","SplayTreeSetEntryIterableIterator","SplayTreeIterableIterator","tree","path","Array","moveNext","length","getValue","rebuildPath","splice","push","findLeftMostDescendent","pop","map","newLast","parent"],"sources":["/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/splaytree-ts/src/index.ts"],"sourcesContent":["type Comparator<T> = (a: T, b: T) => number;\ntype Predicate<T> = (value: T) => boolean;\n\nclass SplayTreeNode<K, Node extends SplayTreeNode<K, Node>> {\n    readonly key: K;\n\n    left: Node | null = null;\n    right: Node | null = null;\n\n    constructor(key: K) {\n        this.key = key;\n    }\n}\n\nclass SplayTreeSetNode<K> extends SplayTreeNode<K, SplayTreeSetNode<K>> {\n    constructor(key: K) {\n        super(key);\n    }\n}\n\nclass SplayTreeMapNode<K, V> extends SplayTreeNode<K, SplayTreeMapNode<K, V>> {\n    readonly value: V;\n\n    constructor(key: K, value: V) {\n        super(key);\n        this.value = value;\n    }\n\n    replaceValue(value: V) {\n        const node = new SplayTreeMapNode(this.key, value);\n        node.left = this.left;\n        node.right = this.right;\n        return node;\n    }\n}\n\nabstract class SplayTree<K, Node extends SplayTreeNode<K, Node>> {\n    protected abstract root: Node | null;\n\n    public size = 0;\n\n    protected modificationCount = 0;\n\n    protected splayCount = 0;\n\n    protected abstract compare: Comparator<K>;\n\n    protected abstract validKey: Predicate<unknown>;\n\n    protected splay(key: K) {\n        const root = this.root;\n        if (root == null) {\n            this.compare(key, key);\n            return -1;\n        }\n\n        let right: Node | null = null;\n        let newTreeRight: Node | null = null;\n        let left: Node | null = null;\n        let newTreeLeft: Node | null = null;\n        let current = root;\n        const compare = this.compare;\n        let comp: number;\n        while (true) {\n            comp = compare(current.key, key);\n            if (comp > 0) {\n                let currentLeft = current.left;\n                if (currentLeft == null) break;\n                comp = compare(currentLeft.key, key);\n                if (comp > 0) {\n                    current.left = currentLeft.right;\n                    currentLeft.right = current;\n                    current = currentLeft;\n                    currentLeft = current.left;\n                    if (currentLeft == null) break;\n                }\n                if (right == null) {\n                    newTreeRight = current;\n                } else {\n                    right.left = current;\n                }\n                right = current;\n                current = currentLeft;\n            } else if (comp < 0) {\n                let currentRight = current.right;\n                if (currentRight == null) break;\n                comp = compare(currentRight.key, key);\n                if (comp < 0) {\n                    current.right = currentRight.left;\n                    currentRight.left = current;\n                    current = currentRight;\n                    currentRight = current.right;\n                    if (currentRight == null) break;\n                }\n                if (left == null) {\n                    newTreeLeft = current;\n                } else {\n                    left.right = current;\n                }\n                left = current;\n                current = currentRight;\n            } else {\n                break;\n            }\n        }\n        if (left != null) {\n            left.right = current.left;\n            current.left = newTreeLeft;\n        }\n        if (right != null) {\n            right.left = current.right;\n            current.right = newTreeRight;\n        }\n        if (this.root !== current) {\n            this.root = current;\n            this.splayCount++;\n        }\n        return comp;\n    }\n\n    protected splayMin(node: Node) {\n        let current = node;\n        let nextLeft = current.left;\n        while (nextLeft != null) {\n            const left = nextLeft;\n            current.left = left.right;\n            left.right = current;\n            current = left;\n            nextLeft = current.left;\n        }\n        return current;\n    }\n\n    protected splayMax(node: Node) {\n        let current = node;\n        let nextRight = current.right;\n        while (nextRight != null) {\n            const right = nextRight;\n            current.right = right.left;\n            right.left = current;\n            current = right;\n            nextRight = current.right;\n        }\n        return current;\n    }\n\n    protected _delete(key: K) {\n        if (this.root == null) return null;\n        const comp = this.splay(key);\n        if (comp != 0) return null;\n        let root = this.root;\n        const result = root;\n        const left = root.left;\n        this.size--;\n        if (left == null) {\n            this.root = root.right;\n        } else {\n            const right = root.right;\n            root = this.splayMax(left);\n\n            root.right = right;\n            this.root = root;\n        }\n        this.modificationCount++;\n        return result;\n    }\n\n    protected addNewRoot(node: Node, comp: number) {\n        this.size++;\n        this.modificationCount++;\n        const root = this.root;\n        if (root == null) {\n            this.root = node;\n            return;\n        }\n        if (comp < 0) {\n            node.left = root;\n            node.right = root.right;\n            root.right = null;\n        } else {\n            node.right = root;\n            node.left = root.left;\n            root.left = null;\n        }\n        this.root = node;\n    }\n\n    protected _first() {\n        const root = this.root;\n        if (root == null) return null;\n        this.root = this.splayMin(root);\n        return this.root;\n    }\n\n    protected _last() {\n        const root = this.root;\n        if (root == null) return null;\n        this.root = this.splayMax(root);\n        return this.root;\n    }\n\n    public clear() {\n        this.root = null;\n        this.size = 0;\n        this.modificationCount++;\n    }\n\n    public has(key: unknown) {\n        return this.validKey(key) && this.splay(key as K) == 0;\n    }\n\n    protected defaultCompare(): Comparator<K> {\n        return (a: K, b: K) => a < b ? -1 : a > b ? 1 : 0;\n    }\n\n    protected wrap(): SplayTreeWrapper<K, Node> {\n        return {\n            getRoot: () => { return this.root },\n            setRoot: (root) => { this.root = root },\n            getSize: () => { return this.size },\n            getModificationCount: () => { return this.modificationCount },\n            getSplayCount: () => { return this.splayCount },\n            setSplayCount: (count) => { this.splayCount = count },\n            splay: (key) => { return this.splay(key) },\n            has: (key) => { return this.has(key) },\n        };\n    }\n}\n\nexport class SplayTreeMap<K, V> extends SplayTree<K, SplayTreeMapNode<K, V>> implements Iterable<[K, V]>, Map<K, V> {\n    protected root: SplayTreeMapNode<K, V> | null = null;\n\n    protected compare: Comparator<K>;\n    protected validKey: Predicate<unknown>;\n\n    constructor(compare?: Comparator<K>, isValidKey?: Predicate<unknown>) {\n        super();\n        this.compare = compare ?? this.defaultCompare();\n        this.validKey = isValidKey ?? ((a: unknown) => a != null && a != undefined);\n    }\n\n    delete(key: unknown) {\n        if (!this.validKey(key)) return false;\n        return this._delete(key as K) != null;\n    }\n\n    forEach(f: (value: V, key: K, map: Map<K, V>) => void) {\n        const nodes: Iterator<[K, V]> = new SplayTreeMapEntryIterableIterator<K, V>(this.wrap());\n        let result: IteratorResult<[K, V]>;\n        while (result = nodes.next(), !result.done) {\n            f(result.value[1], result.value[0], this);\n        }\n    }\n\n    get(key: unknown): V | undefined {\n        if (!this.validKey(key)) return undefined;\n        if (this.root != null) {\n            const comp = this.splay(key as K);\n            if (comp == 0) {\n                return this.root!.value;\n            }\n        }\n        return undefined;\n    }\n\n    hasValue(value: unknown) {\n        const initialSplayCount = this.splayCount;\n        const visit = (node: SplayTreeMapNode<K, V> | null) => {\n            while (node != null) {\n                if (node.value == value) return true;\n                if (initialSplayCount != this.splayCount) {\n                    throw \"Concurrent modification during iteration.\";\n                }\n                if (node.right != null && visit(node.right)) {\n                    return true;\n                }\n                node = node.left;\n            }\n            return false;\n        }\n\n        return visit(this.root);\n    }\n\n    set(key: K, value: V) {\n        const comp = this.splay(key);\n        if (comp == 0) {\n            this.root = this.root!.replaceValue(value);\n            this.splayCount += 1;\n            return this;\n        }\n        this.addNewRoot(new SplayTreeMapNode(key, value), comp);\n        return this;\n    }\n\n    setAll(other: Map<K, V>) {\n        other.forEach((value: V, key: K) => {\n            this.set(key, value);\n        });\n    }\n\n    setIfAbsent(key: K, ifAbsent: () => V) {\n        let comp = this.splay(key);\n        if (comp == 0) {\n            return this.root!.value;\n        }\n        const modificationCount = this.modificationCount;\n        const splayCount = this.splayCount;\n        const value = ifAbsent();\n        if (modificationCount != this.modificationCount) {\n            throw \"Concurrent modification during iteration.\";\n        }\n        if (splayCount != this.splayCount) {\n            comp = this.splay(key);\n        }\n        this.addNewRoot(new SplayTreeMapNode(key, value), comp);\n        return value;\n    }\n\n    isEmpty() {\n        return this.root == null;\n    }\n\n    isNotEmpty() {\n        return !this.isEmpty();\n    }\n\n    firstKey() {\n        if (this.root == null) return null;\n        return this._first()!.key;\n    }\n\n    lastKey() {\n        if (this.root == null) return null;\n        return this._last()!.key;\n    }\n\n    lastKeyBefore(key: K) {\n        if (key == null) throw \"Invalid arguments(s)\";\n        if (this.root == null) return null;\n        const comp = this.splay(key);\n        if (comp < 0) return this.root!.key;\n        let node: SplayTreeMapNode<K, V> | null = this.root!.left;\n        if (node == null) return null;\n        let nodeRight = node.right;\n        while (nodeRight != null) {\n            node = nodeRight;\n            nodeRight = node.right;\n        }\n        return node!.key;\n    }\n\n    firstKeyAfter(key: K) {\n        if (key == null) throw \"Invalid arguments(s)\";\n        if (this.root == null) return null;\n        const comp = this.splay(key);\n        if (comp > 0) return this.root!.key;\n        let node: SplayTreeMapNode<K, V> | null = this.root!.right;\n        if (node == null) return null;\n        let nodeLeft = node.left;\n        while (nodeLeft != null) {\n            node = nodeLeft;\n            nodeLeft = node.left;\n        }\n        return node!.key;\n    }\n\n    update(key: K, update: (value: V) => V, ifAbsent?: () => V) {\n        let comp = this.splay(key);\n        if (comp == 0) {\n            const modificationCount = this.modificationCount;\n            const splayCount = this.splayCount;\n            const newValue = update(this.root!.value);\n            if (modificationCount != this.modificationCount) {\n                throw \"Concurrent modification during iteration.\";\n            }\n            if (splayCount != this.splayCount) {\n                this.splay(key);\n            }\n            this.root = this.root!.replaceValue(newValue);\n            this.splayCount += 1;\n            return newValue;\n        }\n        if (ifAbsent != null) {\n            const modificationCount = this.modificationCount;\n            const splayCount = this.splayCount;\n            const newValue = ifAbsent();\n            if (modificationCount != this.modificationCount) {\n                throw \"Concurrent modification during iteration.\";\n            }\n            if (splayCount != this.splayCount) {\n                comp = this.splay(key);\n            }\n            this.addNewRoot(new SplayTreeMapNode(key, newValue), comp);\n            return newValue;\n        }\n        throw \"Invalid argument (key): Key not in map.\"\n    }\n\n    updateAll(update: (key: K, value: V) => V) {\n        const root = this.root;\n        if (root == null) return;\n        const iterator = new SplayTreeMapEntryIterableIterator(this.wrap());\n        let node: IteratorResult<[K, V]>;\n        while (node = iterator.next(), !node.done) {\n            const newValue = update(...node.value);\n            iterator.replaceValue(newValue);\n        }\n    }\n\n    keys(): IterableIterator<K> {\n        return new SplayTreeKeyIterableIterator<K, SplayTreeMapNode<K, V>>(this.wrap());\n    }\n\n    values(): IterableIterator<V> {\n        return new SplayTreeValueIterableIterator<K, V>(this.wrap());\n    }\n\n    entries(): IterableIterator<[K, V]> {\n        return this[Symbol.iterator]();\n    }\n\n    [Symbol.iterator](): IterableIterator<[K, V]> {\n        return new SplayTreeMapEntryIterableIterator<K, V>(this.wrap());\n    }\n\n    [Symbol.toStringTag] = '[object Map]'\n}\n\nexport class SplayTreeSet<E> extends SplayTree<E, SplayTreeSetNode<E>> implements Iterable<E>, Set<E> {\n    protected root: SplayTreeSetNode<E> | null = null;\n\n    protected compare: Comparator<E>;\n    protected validKey: Predicate<unknown>;\n\n    constructor(compare?: Comparator<E>, isValidKey?: Predicate<unknown>) {\n        super();\n        this.compare = compare ?? this.defaultCompare();\n        this.validKey = isValidKey ?? ((v: unknown) => v != null && v != undefined );\n    }\n\n    delete(element: unknown) {\n        if (!this.validKey(element)) return false;\n        return this._delete(element as E) != null;\n    }\n\n    deleteAll(elements: Iterable<unknown>) {\n        for (const element of elements) {\n            this.delete(element);\n        }\n    }\n\n    forEach(f: (element: E, element2: E, set: Set<E>) => void) {\n        const nodes: Iterator<E> = this[Symbol.iterator]();\n        let result: IteratorResult<E>;\n        while (result = nodes.next(), !result.done) {\n            f(result.value, result.value, this);\n        }\n    }\n\n    add(element: E) {\n        const compare = this.splay(element);\n        if (compare != 0) this.addNewRoot(new SplayTreeSetNode(element), compare);\n        return this;\n    }\n\n    addAndReturn(element: E) {\n        const compare = this.splay(element);\n        if (compare != 0) this.addNewRoot(new SplayTreeSetNode(element), compare);\n        return this.root!.key;\n    }\n\n    addAll(elements: Iterable<E>) {\n        for (const element of elements) {\n            this.add(element);\n        }\n    }\n\n    isEmpty() {\n        return this.root == null;\n    }\n\n    isNotEmpty() {\n        return this.root != null;\n    }\n\n    single() {\n        if (this.size == 0) throw \"Bad state: No element\";\n        if (this.size > 1) throw \"Bad state: Too many element\";\n        return this.root!.key;\n    }\n\n    first() {\n        if (this.size == 0) throw \"Bad state: No element\";\n        return this._first()!.key;\n    }\n\n    last() {\n        if (this.size == 0) throw \"Bad state: No element\";\n        return this._last()!.key;\n    }\n\n    lastBefore(element: E) {\n        if (element == null) throw \"Invalid arguments(s)\";\n        if (this.root == null) return null;\n        const comp = this.splay(element);\n        if (comp < 0) return this.root!.key;\n        let node: SplayTreeSetNode<E> | null = this.root!.left;\n        if (node == null) return null;\n        let nodeRight = node.right;\n        while (nodeRight != null) {\n            node = nodeRight;\n            nodeRight = node.right;\n        }\n        return node!.key;\n    }\n\n    firstAfter(element: E) {\n        if (element == null) throw \"Invalid arguments(s)\";\n        if (this.root == null) return null;\n        const comp = this.splay(element);\n        if (comp > 0) return this.root!.key;\n        let node: SplayTreeSetNode<E> | null = this.root!.right;\n        if (node == null) return null;\n        let nodeLeft = node.left;\n        while (nodeLeft != null) {\n            node = nodeLeft;\n            nodeLeft = node.left;\n        }\n        return node!.key;\n    }\n\n    retainAll(elements: Iterable<unknown>) {\n        const retainSet = new SplayTreeSet<E>(this.compare, this.validKey);\n        const modificationCount = this.modificationCount;\n        for (const object of elements) {\n            if (modificationCount != this.modificationCount) {\n                throw \"Concurrent modification during iteration.\";\n            }\n            if (this.validKey(object) && this.splay(object as E) == 0) {\n                retainSet.add(this.root!.key);\n            }\n        }\n        if (retainSet.size != this.size) {\n            this.root = retainSet.root;\n            this.size = retainSet.size;\n            this.modificationCount++;\n        }\n    }\n\n    lookup(object: unknown): E | null {\n        if (!this.validKey(object)) return null;\n        const comp = this.splay(object as E);\n        if (comp != 0) return null;\n        return this.root!.key;\n    }\n\n    intersection(other: Set<unknown>): Set<E> {\n        const result = new SplayTreeSet<E>(this.compare, this.validKey);\n        for (const element of this) {\n            if (other.has(element)) result.add(element);\n        }\n        return result;\n    }\n\n    difference(other: Set<unknown>): Set<E> {\n        const result = new SplayTreeSet<E>(this.compare, this.validKey);\n        for (const element of this) {\n            if (!other.has(element)) result.add(element);\n        }\n        return result;\n    }\n\n    union(other: Set<E>): Set<E> {\n        const u = this.clone();\n        u.addAll(other);\n        return u;\n    }\n\n    protected clone() {\n        const set = new SplayTreeSet<E>(this.compare, this.validKey);\n        set.size = this.size;\n        set.root = this.copyNode<SplayTreeSetNode<E>>(this.root);\n        return set;\n    }\n\n    protected copyNode<Node extends SplayTreeNode<E, Node>>(node: Node | null) {\n        if (node == null) return null;\n        function copyChildren(node: Node, dest: SplayTreeSetNode<E>) {\n            let left: Node | null;\n            let right: Node | null;\n            do {\n                left = node.left;\n                right = node.right;\n                if (left != null) {\n                    const newLeft = new SplayTreeSetNode<E>(left.key);\n                    dest.left = newLeft;\n                    copyChildren(left, newLeft);\n                }\n                if (right != null) {\n                    const newRight = new SplayTreeSetNode<E>(right.key);\n                    dest.right = newRight;\n                    node = right;\n                    dest = newRight;\n                }\n            } while (right != null);\n        }\n\n        const result = new SplayTreeSetNode<E>(node.key);\n        copyChildren(node, result);\n        return result;\n    }\n\n    toSet(): Set<E> {\n        return this.clone();\n    }\n\n    entries(): IterableIterator<[E, E]> {\n        return new SplayTreeSetEntryIterableIterator<E, SplayTreeSetNode<E>>(this.wrap());\n    }\n\n    keys(): IterableIterator<E> {\n        return this[Symbol.iterator]();\n    }\n    \n    values(): IterableIterator<E> {\n        return this[Symbol.iterator]();\n    }\n\n    [Symbol.iterator](): IterableIterator<E> {\n        return new SplayTreeKeyIterableIterator<E, SplayTreeSetNode<E>>(this.wrap());\n    }\n\n    [Symbol.toStringTag] = '[object Set]'\n}\n\ninterface SplayTreeWrapper<K, Node extends SplayTreeNode<K, Node>> {\n    getRoot: () => Node | null;\n    setRoot: (root: Node | null) => void;\n    getSize: () => number;\n    getModificationCount: () => number;\n    getSplayCount: () => number;\n    setSplayCount: (count: number) => void;\n    splay: (key: K) => number;\n    has: (key: unknown) => boolean;\n}\n\ntype SplayTreeMapWrapper<K, V> = SplayTreeWrapper<K, SplayTreeMapNode<K, V>>;\n\nabstract class SplayTreeIterableIterator<K, Node extends SplayTreeNode<K, Node>, T> implements IterableIterator<T> {\n    protected readonly tree: SplayTreeWrapper<K, Node>;\n\n    protected readonly path = new Array<Node>();\n\n    protected modificationCount: number | null = null;\n\n    protected splayCount: number;\n\n    constructor(tree: SplayTreeWrapper<K, Node>) {\n        this.tree = tree;\n        this.splayCount = tree.getSplayCount();\n    }\n\n    [Symbol.iterator](): IterableIterator<T> {\n        return this;\n    }\n\n    next(): IteratorResult<T, null> {\n        if (this.moveNext()) return { done: false, value: this.current()! }\n        return { done: true, value: null }\n    }\n\n    protected current() {\n        if (!this.path.length) return null;\n        const node = this.path[this.path.length - 1];\n        return this.getValue(node);\n    }\n\n    protected rebuildPath(key: K) {\n        this.path.splice(0, this.path.length)\n        this.tree.splay(key);\n        this.path.push(this.tree.getRoot()!);\n        this.splayCount = this.tree.getSplayCount();\n    }\n\n    protected findLeftMostDescendent(node: Node | null) {\n        while (node != null) {\n            this.path.push(node);\n            node = node.left;\n        }\n    }\n\n    protected moveNext() {\n        if (this.modificationCount != this.tree.getModificationCount()) {\n            if (this.modificationCount == null) {\n                this.modificationCount = this.tree.getModificationCount();\n                let node = this.tree.getRoot();\n                while (node != null) {\n                    this.path.push(node);\n                    node = node.left;\n                }\n                return this.path.length > 0;\n            }\n            throw \"Concurrent modification during iteration.\";\n        }\n        if (!this.path.length) return false;\n        if (this.splayCount != this.tree.getSplayCount()) {\n            this.rebuildPath(this.path[this.path.length - 1].key);\n        }\n        let node = this.path[this.path.length - 1];\n        let next = node.right;\n        if (next != null) {\n            while (next != null) {\n                this.path.push(next);\n                next = next.left;\n            }\n            return true;\n        }\n        this.path.pop();\n        while (this.path.length && this.path[this.path.length - 1].right === node) {\n            node = this.path.pop()!;\n        }\n        return this.path.length > 0;\n    }\n\n    protected abstract getValue(node: Node): T\n}\n\nclass SplayTreeKeyIterableIterator<K, Node extends SplayTreeNode<K, Node>> extends SplayTreeIterableIterator<K, Node, K> {\n\n    protected getValue(node: Node) {\n        return node.key;\n    }\n}\n\nclass SplayTreeSetEntryIterableIterator<K, Node extends SplayTreeNode<K, Node>> extends SplayTreeIterableIterator<K, Node, [K, K]> {\n\n    protected getValue(node: Node): [K, K] {\n        return [node.key, node.key];\n    }\n}\n\nclass SplayTreeValueIterableIterator<K, V> extends SplayTreeIterableIterator<K, SplayTreeMapNode<K, V>, V> {\n\n    constructor(map: SplayTreeMapWrapper<K, V>) {\n        super(map);\n    }\n\n    protected getValue(node: SplayTreeMapNode<K, V>) {\n        return node.value;\n    }\n}\n\nclass SplayTreeMapEntryIterableIterator<K, V> extends SplayTreeIterableIterator<K, SplayTreeMapNode<K, V>, [K, V]> {\n\n    constructor(map: SplayTreeMapWrapper<K, V>) {\n        super(map);\n    }\n\n    protected getValue(node: SplayTreeMapNode<K, V>): [K, V] {\n        return [node.key, node.value];\n    }\n\n    replaceValue(value: V) {\n        if (this.modificationCount != this.tree.getModificationCount()) {\n            throw \"Concurrent modification during iteration.\";\n        }\n        if (this.splayCount != this.tree.getSplayCount()) {\n            this.rebuildPath(this.path[this.path.length - 1].key);\n        }\n        const last = this.path.pop()!;\n        const newLast = last.replaceValue(value);\n        if (!this.path.length) {\n            this.tree.setRoot(newLast);\n        } else {\n            const parent = this.path[this.path.length - 1];\n            if (last === parent.left) {\n                parent.left = newLast;\n            } else {\n                parent.right = newLast;\n            }\n        }\n        this.path.push(newLast);\n        const count = this.tree.getSplayCount() + 1;\n        this.tree.setSplayCount(count);\n        this.splayCount = count;\n    }\n}"],"mappings":";AAGA,IAAMA,aAAA,GAAN,MAA4D;EAC/CC,GAAA;EAETC,IAAA,GAAoB;EACpBC,KAAA,GAAqB;EAErBC,YAAYH,GAAA,EAAQ;IAChB,KAAKA,GAAA,GAAMA,GAAA;EACf;AACJ;AAEA,IAAMI,gBAAA,GAAN,cAAkCL,aAAA,CAAsC;EACpEI,YAAYH,GAAA,EAAQ;IAChB,MAAMA,GAAG;EACb;AACJ;AAEA,IAAMK,gBAAA,GAAN,MAAMC,iBAAA,SAA+BP,aAAA,CAAyC;EACjEQ,KAAA;EAETJ,YAAYH,GAAA,EAAQO,KAAA,EAAU;IAC1B,MAAMP,GAAG;IACT,KAAKO,KAAA,GAAQA,KAAA;EACjB;EAEAC,aAAaD,KAAA,EAAU;IACnB,MAAME,IAAA,GAAO,IAAIH,iBAAA,CAAiB,KAAKN,GAAA,EAAKO,KAAK;IACjDE,IAAA,CAAKR,IAAA,GAAO,KAAKA,IAAA;IACjBQ,IAAA,CAAKP,KAAA,GAAQ,KAAKA,KAAA;IAClB,OAAOO,IAAA;EACX;AACJ;AAEA,IAAeC,SAAA,GAAf,MAAiE;EAGtDC,IAAA,GAAO;EAEJC,iBAAA,GAAoB;EAEpBC,UAAA,GAAa;EAMbC,MAAMd,GAAA,EAAQ;IACpB,MAAMe,IAAA,GAAO,KAAKA,IAAA;IAClB,IAAIA,IAAA,IAAQ,MAAM;MACd,KAAKC,OAAA,CAAQhB,GAAA,EAAKA,GAAG;MACrB,OAAO;IACX;IAEA,IAAIE,KAAA,GAAqB;IACzB,IAAIe,YAAA,GAA4B;IAChC,IAAIhB,IAAA,GAAoB;IACxB,IAAIiB,WAAA,GAA2B;IAC/B,IAAIC,OAAA,GAAUJ,IAAA;IACd,MAAMC,OAAA,GAAU,KAAKA,OAAA;IACrB,IAAII,IAAA;IACJ,OAAO,MAAM;MACTA,IAAA,GAAOJ,OAAA,CAAQG,OAAA,CAAQnB,GAAA,EAAKA,GAAG;MAC/B,IAAIoB,IAAA,GAAO,GAAG;QACV,IAAIC,WAAA,GAAcF,OAAA,CAAQlB,IAAA;QAC1B,IAAIoB,WAAA,IAAe,MAAM;QACzBD,IAAA,GAAOJ,OAAA,CAAQK,WAAA,CAAYrB,GAAA,EAAKA,GAAG;QACnC,IAAIoB,IAAA,GAAO,GAAG;UACVD,OAAA,CAAQlB,IAAA,GAAOoB,WAAA,CAAYnB,KAAA;UAC3BmB,WAAA,CAAYnB,KAAA,GAAQiB,OAAA;UACpBA,OAAA,GAAUE,WAAA;UACVA,WAAA,GAAcF,OAAA,CAAQlB,IAAA;UACtB,IAAIoB,WAAA,IAAe,MAAM;QAC7B;QACA,IAAInB,KAAA,IAAS,MAAM;UACfe,YAAA,GAAeE,OAAA;QACnB,OAAO;UACHjB,KAAA,CAAMD,IAAA,GAAOkB,OAAA;QACjB;QACAjB,KAAA,GAAQiB,OAAA;QACRA,OAAA,GAAUE,WAAA;MACd,WAAWD,IAAA,GAAO,GAAG;QACjB,IAAIE,YAAA,GAAeH,OAAA,CAAQjB,KAAA;QAC3B,IAAIoB,YAAA,IAAgB,MAAM;QAC1BF,IAAA,GAAOJ,OAAA,CAAQM,YAAA,CAAatB,GAAA,EAAKA,GAAG;QACpC,IAAIoB,IAAA,GAAO,GAAG;UACVD,OAAA,CAAQjB,KAAA,GAAQoB,YAAA,CAAarB,IAAA;UAC7BqB,YAAA,CAAarB,IAAA,GAAOkB,OAAA;UACpBA,OAAA,GAAUG,YAAA;UACVA,YAAA,GAAeH,OAAA,CAAQjB,KAAA;UACvB,IAAIoB,YAAA,IAAgB,MAAM;QAC9B;QACA,IAAIrB,IAAA,IAAQ,MAAM;UACdiB,WAAA,GAAcC,OAAA;QAClB,OAAO;UACHlB,IAAA,CAAKC,KAAA,GAAQiB,OAAA;QACjB;QACAlB,IAAA,GAAOkB,OAAA;QACPA,OAAA,GAAUG,YAAA;MACd,OAAO;QACH;MACJ;IACJ;IACA,IAAIrB,IAAA,IAAQ,MAAM;MACdA,IAAA,CAAKC,KAAA,GAAQiB,OAAA,CAAQlB,IAAA;MACrBkB,OAAA,CAAQlB,IAAA,GAAOiB,WAAA;IACnB;IACA,IAAIhB,KAAA,IAAS,MAAM;MACfA,KAAA,CAAMD,IAAA,GAAOkB,OAAA,CAAQjB,KAAA;MACrBiB,OAAA,CAAQjB,KAAA,GAAQe,YAAA;IACpB;IACA,IAAI,KAAKF,IAAA,KAASI,OAAA,EAAS;MACvB,KAAKJ,IAAA,GAAOI,OAAA;MACZ,KAAKN,UAAA;IACT;IACA,OAAOO,IAAA;EACX;EAEUG,SAASd,IAAA,EAAY;IAC3B,IAAIU,OAAA,GAAUV,IAAA;IACd,IAAIe,QAAA,GAAWL,OAAA,CAAQlB,IAAA;IACvB,OAAOuB,QAAA,IAAY,MAAM;MACrB,MAAMvB,IAAA,GAAOuB,QAAA;MACbL,OAAA,CAAQlB,IAAA,GAAOA,IAAA,CAAKC,KAAA;MACpBD,IAAA,CAAKC,KAAA,GAAQiB,OAAA;MACbA,OAAA,GAAUlB,IAAA;MACVuB,QAAA,GAAWL,OAAA,CAAQlB,IAAA;IACvB;IACA,OAAOkB,OAAA;EACX;EAEUM,SAAShB,IAAA,EAAY;IAC3B,IAAIU,OAAA,GAAUV,IAAA;IACd,IAAIiB,SAAA,GAAYP,OAAA,CAAQjB,KAAA;IACxB,OAAOwB,SAAA,IAAa,MAAM;MACtB,MAAMxB,KAAA,GAAQwB,SAAA;MACdP,OAAA,CAAQjB,KAAA,GAAQA,KAAA,CAAMD,IAAA;MACtBC,KAAA,CAAMD,IAAA,GAAOkB,OAAA;MACbA,OAAA,GAAUjB,KAAA;MACVwB,SAAA,GAAYP,OAAA,CAAQjB,KAAA;IACxB;IACA,OAAOiB,OAAA;EACX;EAEUQ,QAAQ3B,GAAA,EAAQ;IACtB,IAAI,KAAKe,IAAA,IAAQ,MAAM,OAAO;IAC9B,MAAMK,IAAA,GAAO,KAAKN,KAAA,CAAMd,GAAG;IAC3B,IAAIoB,IAAA,IAAQ,GAAG,OAAO;IACtB,IAAIL,IAAA,GAAO,KAAKA,IAAA;IAChB,MAAMa,MAAA,GAASb,IAAA;IACf,MAAMd,IAAA,GAAOc,IAAA,CAAKd,IAAA;IAClB,KAAKU,IAAA;IACL,IAAIV,IAAA,IAAQ,MAAM;MACd,KAAKc,IAAA,GAAOA,IAAA,CAAKb,KAAA;IACrB,OAAO;MACH,MAAMA,KAAA,GAAQa,IAAA,CAAKb,KAAA;MACnBa,IAAA,GAAO,KAAKU,QAAA,CAASxB,IAAI;MAEzBc,IAAA,CAAKb,KAAA,GAAQA,KAAA;MACb,KAAKa,IAAA,GAAOA,IAAA;IAChB;IACA,KAAKH,iBAAA;IACL,OAAOgB,MAAA;EACX;EAEUC,WAAWpB,IAAA,EAAYW,IAAA,EAAc;IAC3C,KAAKT,IAAA;IACL,KAAKC,iBAAA;IACL,MAAMG,IAAA,GAAO,KAAKA,IAAA;IAClB,IAAIA,IAAA,IAAQ,MAAM;MACd,KAAKA,IAAA,GAAON,IAAA;MACZ;IACJ;IACA,IAAIW,IAAA,GAAO,GAAG;MACVX,IAAA,CAAKR,IAAA,GAAOc,IAAA;MACZN,IAAA,CAAKP,KAAA,GAAQa,IAAA,CAAKb,KAAA;MAClBa,IAAA,CAAKb,KAAA,GAAQ;IACjB,OAAO;MACHO,IAAA,CAAKP,KAAA,GAAQa,IAAA;MACbN,IAAA,CAAKR,IAAA,GAAOc,IAAA,CAAKd,IAAA;MACjBc,IAAA,CAAKd,IAAA,GAAO;IAChB;IACA,KAAKc,IAAA,GAAON,IAAA;EAChB;EAEUqB,OAAA,EAAS;IACf,MAAMf,IAAA,GAAO,KAAKA,IAAA;IAClB,IAAIA,IAAA,IAAQ,MAAM,OAAO;IACzB,KAAKA,IAAA,GAAO,KAAKQ,QAAA,CAASR,IAAI;IAC9B,OAAO,KAAKA,IAAA;EAChB;EAEUgB,MAAA,EAAQ;IACd,MAAMhB,IAAA,GAAO,KAAKA,IAAA;IAClB,IAAIA,IAAA,IAAQ,MAAM,OAAO;IACzB,KAAKA,IAAA,GAAO,KAAKU,QAAA,CAASV,IAAI;IAC9B,OAAO,KAAKA,IAAA;EAChB;EAEOiB,MAAA,EAAQ;IACX,KAAKjB,IAAA,GAAO;IACZ,KAAKJ,IAAA,GAAO;IACZ,KAAKC,iBAAA;EACT;EAEOqB,IAAIjC,GAAA,EAAc;IACrB,OAAO,KAAKkC,QAAA,CAASlC,GAAG,KAAK,KAAKc,KAAA,CAAMd,GAAQ,KAAK;EACzD;EAEUmC,eAAA,EAAgC;IACtC,OAAO,CAACC,CAAA,EAAMC,CAAA,KAASD,CAAA,GAAIC,CAAA,GAAI,KAAKD,CAAA,GAAIC,CAAA,GAAI,IAAI;EACpD;EAEUC,KAAA,EAAkC;IACxC,OAAO;MACHC,OAAA,EAASA,CAAA,KAAM;QAAE,OAAO,KAAKxB,IAAA;MAAK;MAClCyB,OAAA,EAAUzB,IAAA,IAAS;QAAE,KAAKA,IAAA,GAAOA,IAAA;MAAK;MACtC0B,OAAA,EAASA,CAAA,KAAM;QAAE,OAAO,KAAK9B,IAAA;MAAK;MAClC+B,oBAAA,EAAsBA,CAAA,KAAM;QAAE,OAAO,KAAK9B,iBAAA;MAAkB;MAC5D+B,aAAA,EAAeA,CAAA,KAAM;QAAE,OAAO,KAAK9B,UAAA;MAAW;MAC9C+B,aAAA,EAAgBC,KAAA,IAAU;QAAE,KAAKhC,UAAA,GAAagC,KAAA;MAAM;MACpD/B,KAAA,EAAQd,GAAA,IAAQ;QAAE,OAAO,KAAKc,KAAA,CAAMd,GAAG;MAAE;MACzCiC,GAAA,EAAMjC,GAAA,IAAQ;QAAE,OAAO,KAAKiC,GAAA,CAAIjC,GAAG;MAAE;IACzC;EACJ;AACJ;AAEO,IAAM8C,YAAA,GAAN,cAAiCpC,SAAA,CAA4E;EACtGK,IAAA,GAAsC;EAEtCC,OAAA;EACAkB,QAAA;EAEV/B,YAAYa,OAAA,EAAyB+B,UAAA,EAAiC;IAClE,MAAM;IACN,KAAK/B,OAAA,GAAUA,OAAA,IAAW,KAAKmB,cAAA,CAAe;IAC9C,KAAKD,QAAA,GAAWa,UAAA,KAAgBX,CAAA,IAAeA,CAAA,IAAK,QAAQA,CAAA,IAAK;EACrE;EAEAY,OAAOhD,GAAA,EAAc;IACjB,IAAI,CAAC,KAAKkC,QAAA,CAASlC,GAAG,GAAG,OAAO;IAChC,OAAO,KAAK2B,OAAA,CAAQ3B,GAAQ,KAAK;EACrC;EAEAiD,QAAQC,CAAA,EAA+C;IACnD,MAAMC,KAAA,GAA0B,IAAIC,iCAAA,CAAwC,KAAKd,IAAA,CAAK,CAAC;IACvF,IAAIV,MAAA;IACJ,OAAOA,MAAA,GAASuB,KAAA,CAAME,IAAA,CAAK,GAAG,CAACzB,MAAA,CAAO0B,IAAA,EAAM;MACxCJ,CAAA,CAAEtB,MAAA,CAAOrB,KAAA,CAAM,CAAC,GAAGqB,MAAA,CAAOrB,KAAA,CAAM,CAAC,GAAG,IAAI;IAC5C;EACJ;EAEAgD,IAAIvD,GAAA,EAA6B;IAC7B,IAAI,CAAC,KAAKkC,QAAA,CAASlC,GAAG,GAAG,OAAO;IAChC,IAAI,KAAKe,IAAA,IAAQ,MAAM;MACnB,MAAMK,IAAA,GAAO,KAAKN,KAAA,CAAMd,GAAQ;MAChC,IAAIoB,IAAA,IAAQ,GAAG;QACX,OAAO,KAAKL,IAAA,CAAMR,KAAA;MACtB;IACJ;IACA,OAAO;EACX;EAEAiD,SAASjD,KAAA,EAAgB;IACrB,MAAMkD,iBAAA,GAAoB,KAAK5C,UAAA;IAC/B,MAAM6C,KAAA,GAASjD,IAAA,IAAwC;MACnD,OAAOA,IAAA,IAAQ,MAAM;QACjB,IAAIA,IAAA,CAAKF,KAAA,IAASA,KAAA,EAAO,OAAO;QAChC,IAAIkD,iBAAA,IAAqB,KAAK5C,UAAA,EAAY;UACtC,MAAM;QACV;QACA,IAAIJ,IAAA,CAAKP,KAAA,IAAS,QAAQwD,KAAA,CAAMjD,IAAA,CAAKP,KAAK,GAAG;UACzC,OAAO;QACX;QACAO,IAAA,GAAOA,IAAA,CAAKR,IAAA;MAChB;MACA,OAAO;IACX;IAEA,OAAOyD,KAAA,CAAM,KAAK3C,IAAI;EAC1B;EAEA4C,IAAI3D,GAAA,EAAQO,KAAA,EAAU;IAClB,MAAMa,IAAA,GAAO,KAAKN,KAAA,CAAMd,GAAG;IAC3B,IAAIoB,IAAA,IAAQ,GAAG;MACX,KAAKL,IAAA,GAAO,KAAKA,IAAA,CAAMP,YAAA,CAAaD,KAAK;MACzC,KAAKM,UAAA,IAAc;MACnB,OAAO;IACX;IACA,KAAKgB,UAAA,CAAW,IAAIxB,gBAAA,CAAiBL,GAAA,EAAKO,KAAK,GAAGa,IAAI;IACtD,OAAO;EACX;EAEAwC,OAAOC,KAAA,EAAkB;IACrBA,KAAA,CAAMZ,OAAA,CAAQ,CAAC1C,KAAA,EAAUP,GAAA,KAAW;MAChC,KAAK2D,GAAA,CAAI3D,GAAA,EAAKO,KAAK;IACvB,CAAC;EACL;EAEAuD,YAAY9D,GAAA,EAAQ+D,QAAA,EAAmB;IACnC,IAAI3C,IAAA,GAAO,KAAKN,KAAA,CAAMd,GAAG;IACzB,IAAIoB,IAAA,IAAQ,GAAG;MACX,OAAO,KAAKL,IAAA,CAAMR,KAAA;IACtB;IACA,MAAMK,iBAAA,GAAoB,KAAKA,iBAAA;IAC/B,MAAMC,UAAA,GAAa,KAAKA,UAAA;IACxB,MAAMN,KAAA,GAAQwD,QAAA,CAAS;IACvB,IAAInD,iBAAA,IAAqB,KAAKA,iBAAA,EAAmB;MAC7C,MAAM;IACV;IACA,IAAIC,UAAA,IAAc,KAAKA,UAAA,EAAY;MAC/BO,IAAA,GAAO,KAAKN,KAAA,CAAMd,GAAG;IACzB;IACA,KAAK6B,UAAA,CAAW,IAAIxB,gBAAA,CAAiBL,GAAA,EAAKO,KAAK,GAAGa,IAAI;IACtD,OAAOb,KAAA;EACX;EAEAyD,QAAA,EAAU;IACN,OAAO,KAAKjD,IAAA,IAAQ;EACxB;EAEAkD,WAAA,EAAa;IACT,OAAO,CAAC,KAAKD,OAAA,CAAQ;EACzB;EAEAE,SAAA,EAAW;IACP,IAAI,KAAKnD,IAAA,IAAQ,MAAM,OAAO;IAC9B,OAAO,KAAKe,MAAA,CAAO,EAAG9B,GAAA;EAC1B;EAEAmE,QAAA,EAAU;IACN,IAAI,KAAKpD,IAAA,IAAQ,MAAM,OAAO;IAC9B,OAAO,KAAKgB,KAAA,CAAM,EAAG/B,GAAA;EACzB;EAEAoE,cAAcpE,GAAA,EAAQ;IAClB,IAAIA,GAAA,IAAO,MAAM,MAAM;IACvB,IAAI,KAAKe,IAAA,IAAQ,MAAM,OAAO;IAC9B,MAAMK,IAAA,GAAO,KAAKN,KAAA,CAAMd,GAAG;IAC3B,IAAIoB,IAAA,GAAO,GAAG,OAAO,KAAKL,IAAA,CAAMf,GAAA;IAChC,IAAIS,IAAA,GAAsC,KAAKM,IAAA,CAAMd,IAAA;IACrD,IAAIQ,IAAA,IAAQ,MAAM,OAAO;IACzB,IAAI4D,SAAA,GAAY5D,IAAA,CAAKP,KAAA;IACrB,OAAOmE,SAAA,IAAa,MAAM;MACtB5D,IAAA,GAAO4D,SAAA;MACPA,SAAA,GAAY5D,IAAA,CAAKP,KAAA;IACrB;IACA,OAAOO,IAAA,CAAMT,GAAA;EACjB;EAEAsE,cAActE,GAAA,EAAQ;IAClB,IAAIA,GAAA,IAAO,MAAM,MAAM;IACvB,IAAI,KAAKe,IAAA,IAAQ,MAAM,OAAO;IAC9B,MAAMK,IAAA,GAAO,KAAKN,KAAA,CAAMd,GAAG;IAC3B,IAAIoB,IAAA,GAAO,GAAG,OAAO,KAAKL,IAAA,CAAMf,GAAA;IAChC,IAAIS,IAAA,GAAsC,KAAKM,IAAA,CAAMb,KAAA;IACrD,IAAIO,IAAA,IAAQ,MAAM,OAAO;IACzB,IAAI8D,QAAA,GAAW9D,IAAA,CAAKR,IAAA;IACpB,OAAOsE,QAAA,IAAY,MAAM;MACrB9D,IAAA,GAAO8D,QAAA;MACPA,QAAA,GAAW9D,IAAA,CAAKR,IAAA;IACpB;IACA,OAAOQ,IAAA,CAAMT,GAAA;EACjB;EAEAwE,OAAOxE,GAAA,EAAQwE,MAAA,EAAyBT,QAAA,EAAoB;IACxD,IAAI3C,IAAA,GAAO,KAAKN,KAAA,CAAMd,GAAG;IACzB,IAAIoB,IAAA,IAAQ,GAAG;MACX,MAAMR,iBAAA,GAAoB,KAAKA,iBAAA;MAC/B,MAAMC,UAAA,GAAa,KAAKA,UAAA;MACxB,MAAM4D,QAAA,GAAWD,MAAA,CAAO,KAAKzD,IAAA,CAAMR,KAAK;MACxC,IAAIK,iBAAA,IAAqB,KAAKA,iBAAA,EAAmB;QAC7C,MAAM;MACV;MACA,IAAIC,UAAA,IAAc,KAAKA,UAAA,EAAY;QAC/B,KAAKC,KAAA,CAAMd,GAAG;MAClB;MACA,KAAKe,IAAA,GAAO,KAAKA,IAAA,CAAMP,YAAA,CAAaiE,QAAQ;MAC5C,KAAK5D,UAAA,IAAc;MACnB,OAAO4D,QAAA;IACX;IACA,IAAIV,QAAA,IAAY,MAAM;MAClB,MAAMnD,iBAAA,GAAoB,KAAKA,iBAAA;MAC/B,MAAMC,UAAA,GAAa,KAAKA,UAAA;MACxB,MAAM4D,QAAA,GAAWV,QAAA,CAAS;MAC1B,IAAInD,iBAAA,IAAqB,KAAKA,iBAAA,EAAmB;QAC7C,MAAM;MACV;MACA,IAAIC,UAAA,IAAc,KAAKA,UAAA,EAAY;QAC/BO,IAAA,GAAO,KAAKN,KAAA,CAAMd,GAAG;MACzB;MACA,KAAK6B,UAAA,CAAW,IAAIxB,gBAAA,CAAiBL,GAAA,EAAKyE,QAAQ,GAAGrD,IAAI;MACzD,OAAOqD,QAAA;IACX;IACA,MAAM;EACV;EAEAC,UAAUF,MAAA,EAAiC;IACvC,MAAMzD,IAAA,GAAO,KAAKA,IAAA;IAClB,IAAIA,IAAA,IAAQ,MAAM;IAClB,MAAM4D,QAAA,GAAW,IAAIvB,iCAAA,CAAkC,KAAKd,IAAA,CAAK,CAAC;IAClE,IAAI7B,IAAA;IACJ,OAAOA,IAAA,GAAOkE,QAAA,CAAStB,IAAA,CAAK,GAAG,CAAC5C,IAAA,CAAK6C,IAAA,EAAM;MACvC,MAAMmB,QAAA,GAAWD,MAAA,CAAO,GAAG/D,IAAA,CAAKF,KAAK;MACrCoE,QAAA,CAASnE,YAAA,CAAaiE,QAAQ;IAClC;EACJ;EAEAG,KAAA,EAA4B;IACxB,OAAO,IAAIC,4BAAA,CAAwD,KAAKvC,IAAA,CAAK,CAAC;EAClF;EAEAwC,OAAA,EAA8B;IAC1B,OAAO,IAAIC,8BAAA,CAAqC,KAAKzC,IAAA,CAAK,CAAC;EAC/D;EAEA0C,QAAA,EAAoC;IAChC,OAAO,KAAKC,MAAA,CAAON,QAAQ,EAAE;EACjC;EAEA,CAACM,MAAA,CAAON,QAAQ,IAA8B;IAC1C,OAAO,IAAIvB,iCAAA,CAAwC,KAAKd,IAAA,CAAK,CAAC;EAClE;EAEA,CAAC2C,MAAA,CAAOC,WAAW,IAAI;AAC3B;AAEO,IAAMC,YAAA,GAAN,MAAMC,aAAA,SAAwB1E,SAAA,CAAiE;EACxFK,IAAA,GAAmC;EAEnCC,OAAA;EACAkB,QAAA;EAEV/B,YAAYa,OAAA,EAAyB+B,UAAA,EAAiC;IAClE,MAAM;IACN,KAAK/B,OAAA,GAAUA,OAAA,IAAW,KAAKmB,cAAA,CAAe;IAC9C,KAAKD,QAAA,GAAWa,UAAA,KAAgBsC,CAAA,IAAeA,CAAA,IAAK,QAAQA,CAAA,IAAK;EACrE;EAEArC,OAAOsC,OAAA,EAAkB;IACrB,IAAI,CAAC,KAAKpD,QAAA,CAASoD,OAAO,GAAG,OAAO;IACpC,OAAO,KAAK3D,OAAA,CAAQ2D,OAAY,KAAK;EACzC;EAEAC,UAAUC,QAAA,EAA6B;IACnC,WAAWF,OAAA,IAAWE,QAAA,EAAU;MAC5B,KAAKxC,MAAA,CAAOsC,OAAO;IACvB;EACJ;EAEArC,QAAQC,CAAA,EAAmD;IACvD,MAAMC,KAAA,GAAqB,KAAK8B,MAAA,CAAON,QAAQ,EAAE;IACjD,IAAI/C,MAAA;IACJ,OAAOA,MAAA,GAASuB,KAAA,CAAME,IAAA,CAAK,GAAG,CAACzB,MAAA,CAAO0B,IAAA,EAAM;MACxCJ,CAAA,CAAEtB,MAAA,CAAOrB,KAAA,EAAOqB,MAAA,CAAOrB,KAAA,EAAO,IAAI;IACtC;EACJ;EAEAkF,IAAIH,OAAA,EAAY;IACZ,MAAMtE,OAAA,GAAU,KAAKF,KAAA,CAAMwE,OAAO;IAClC,IAAItE,OAAA,IAAW,GAAG,KAAKa,UAAA,CAAW,IAAIzB,gBAAA,CAAiBkF,OAAO,GAAGtE,OAAO;IACxE,OAAO;EACX;EAEA0E,aAAaJ,OAAA,EAAY;IACrB,MAAMtE,OAAA,GAAU,KAAKF,KAAA,CAAMwE,OAAO;IAClC,IAAItE,OAAA,IAAW,GAAG,KAAKa,UAAA,CAAW,IAAIzB,gBAAA,CAAiBkF,OAAO,GAAGtE,OAAO;IACxE,OAAO,KAAKD,IAAA,CAAMf,GAAA;EACtB;EAEA2F,OAAOH,QAAA,EAAuB;IAC1B,WAAWF,OAAA,IAAWE,QAAA,EAAU;MAC5B,KAAKC,GAAA,CAAIH,OAAO;IACpB;EACJ;EAEAtB,QAAA,EAAU;IACN,OAAO,KAAKjD,IAAA,IAAQ;EACxB;EAEAkD,WAAA,EAAa;IACT,OAAO,KAAKlD,IAAA,IAAQ;EACxB;EAEA6E,OAAA,EAAS;IACL,IAAI,KAAKjF,IAAA,IAAQ,GAAG,MAAM;IAC1B,IAAI,KAAKA,IAAA,GAAO,GAAG,MAAM;IACzB,OAAO,KAAKI,IAAA,CAAMf,GAAA;EACtB;EAEA6F,MAAA,EAAQ;IACJ,IAAI,KAAKlF,IAAA,IAAQ,GAAG,MAAM;IAC1B,OAAO,KAAKmB,MAAA,CAAO,EAAG9B,GAAA;EAC1B;EAEA8F,KAAA,EAAO;IACH,IAAI,KAAKnF,IAAA,IAAQ,GAAG,MAAM;IAC1B,OAAO,KAAKoB,KAAA,CAAM,EAAG/B,GAAA;EACzB;EAEA+F,WAAWT,OAAA,EAAY;IACnB,IAAIA,OAAA,IAAW,MAAM,MAAM;IAC3B,IAAI,KAAKvE,IAAA,IAAQ,MAAM,OAAO;IAC9B,MAAMK,IAAA,GAAO,KAAKN,KAAA,CAAMwE,OAAO;IAC/B,IAAIlE,IAAA,GAAO,GAAG,OAAO,KAAKL,IAAA,CAAMf,GAAA;IAChC,IAAIS,IAAA,GAAmC,KAAKM,IAAA,CAAMd,IAAA;IAClD,IAAIQ,IAAA,IAAQ,MAAM,OAAO;IACzB,IAAI4D,SAAA,GAAY5D,IAAA,CAAKP,KAAA;IACrB,OAAOmE,SAAA,IAAa,MAAM;MACtB5D,IAAA,GAAO4D,SAAA;MACPA,SAAA,GAAY5D,IAAA,CAAKP,KAAA;IACrB;IACA,OAAOO,IAAA,CAAMT,GAAA;EACjB;EAEAgG,WAAWV,OAAA,EAAY;IACnB,IAAIA,OAAA,IAAW,MAAM,MAAM;IAC3B,IAAI,KAAKvE,IAAA,IAAQ,MAAM,OAAO;IAC9B,MAAMK,IAAA,GAAO,KAAKN,KAAA,CAAMwE,OAAO;IAC/B,IAAIlE,IAAA,GAAO,GAAG,OAAO,KAAKL,IAAA,CAAMf,GAAA;IAChC,IAAIS,IAAA,GAAmC,KAAKM,IAAA,CAAMb,KAAA;IAClD,IAAIO,IAAA,IAAQ,MAAM,OAAO;IACzB,IAAI8D,QAAA,GAAW9D,IAAA,CAAKR,IAAA;IACpB,OAAOsE,QAAA,IAAY,MAAM;MACrB9D,IAAA,GAAO8D,QAAA;MACPA,QAAA,GAAW9D,IAAA,CAAKR,IAAA;IACpB;IACA,OAAOQ,IAAA,CAAMT,GAAA;EACjB;EAEAiG,UAAUT,QAAA,EAA6B;IACnC,MAAMU,SAAA,GAAY,IAAId,aAAA,CAAgB,KAAKpE,OAAA,EAAS,KAAKkB,QAAQ;IACjE,MAAMtB,iBAAA,GAAoB,KAAKA,iBAAA;IAC/B,WAAWuF,MAAA,IAAUX,QAAA,EAAU;MAC3B,IAAI5E,iBAAA,IAAqB,KAAKA,iBAAA,EAAmB;QAC7C,MAAM;MACV;MACA,IAAI,KAAKsB,QAAA,CAASiE,MAAM,KAAK,KAAKrF,KAAA,CAAMqF,MAAW,KAAK,GAAG;QACvDD,SAAA,CAAUT,GAAA,CAAI,KAAK1E,IAAA,CAAMf,GAAG;MAChC;IACJ;IACA,IAAIkG,SAAA,CAAUvF,IAAA,IAAQ,KAAKA,IAAA,EAAM;MAC7B,KAAKI,IAAA,GAAOmF,SAAA,CAAUnF,IAAA;MACtB,KAAKJ,IAAA,GAAOuF,SAAA,CAAUvF,IAAA;MACtB,KAAKC,iBAAA;IACT;EACJ;EAEAwF,OAAOD,MAAA,EAA2B;IAC9B,IAAI,CAAC,KAAKjE,QAAA,CAASiE,MAAM,GAAG,OAAO;IACnC,MAAM/E,IAAA,GAAO,KAAKN,KAAA,CAAMqF,MAAW;IACnC,IAAI/E,IAAA,IAAQ,GAAG,OAAO;IACtB,OAAO,KAAKL,IAAA,CAAMf,GAAA;EACtB;EAEAqG,aAAaxC,KAAA,EAA6B;IACtC,MAAMjC,MAAA,GAAS,IAAIwD,aAAA,CAAgB,KAAKpE,OAAA,EAAS,KAAKkB,QAAQ;IAC9D,WAAWoD,OAAA,IAAW,MAAM;MACxB,IAAIzB,KAAA,CAAM5B,GAAA,CAAIqD,OAAO,GAAG1D,MAAA,CAAO6D,GAAA,CAAIH,OAAO;IAC9C;IACA,OAAO1D,MAAA;EACX;EAEA0E,WAAWzC,KAAA,EAA6B;IACpC,MAAMjC,MAAA,GAAS,IAAIwD,aAAA,CAAgB,KAAKpE,OAAA,EAAS,KAAKkB,QAAQ;IAC9D,WAAWoD,OAAA,IAAW,MAAM;MACxB,IAAI,CAACzB,KAAA,CAAM5B,GAAA,CAAIqD,OAAO,GAAG1D,MAAA,CAAO6D,GAAA,CAAIH,OAAO;IAC/C;IACA,OAAO1D,MAAA;EACX;EAEA2E,MAAM1C,KAAA,EAAuB;IACzB,MAAM2C,CAAA,GAAI,KAAKC,KAAA,CAAM;IACrBD,CAAA,CAAEb,MAAA,CAAO9B,KAAK;IACd,OAAO2C,CAAA;EACX;EAEUC,MAAA,EAAQ;IACd,MAAM9C,GAAA,GAAM,IAAIyB,aAAA,CAAgB,KAAKpE,OAAA,EAAS,KAAKkB,QAAQ;IAC3DyB,GAAA,CAAIhD,IAAA,GAAO,KAAKA,IAAA;IAChBgD,GAAA,CAAI5C,IAAA,GAAO,KAAK2F,QAAA,CAA8B,KAAK3F,IAAI;IACvD,OAAO4C,GAAA;EACX;EAEU+C,SAA8CjG,IAAA,EAAmB;IACvE,IAAIA,IAAA,IAAQ,MAAM,OAAO;IACzB,SAASkG,aAAaC,KAAA,EAAYC,IAAA,EAA2B;MACzD,IAAI5G,IAAA;MACJ,IAAIC,KAAA;MACJ,GAAG;QACCD,IAAA,GAAO2G,KAAA,CAAK3G,IAAA;QACZC,KAAA,GAAQ0G,KAAA,CAAK1G,KAAA;QACb,IAAID,IAAA,IAAQ,MAAM;UACd,MAAM6G,OAAA,GAAU,IAAI1G,gBAAA,CAAoBH,IAAA,CAAKD,GAAG;UAChD6G,IAAA,CAAK5G,IAAA,GAAO6G,OAAA;UACZH,YAAA,CAAa1G,IAAA,EAAM6G,OAAO;QAC9B;QACA,IAAI5G,KAAA,IAAS,MAAM;UACf,MAAM6G,QAAA,GAAW,IAAI3G,gBAAA,CAAoBF,KAAA,CAAMF,GAAG;UAClD6G,IAAA,CAAK3G,KAAA,GAAQ6G,QAAA;UACbH,KAAA,GAAO1G,KAAA;UACP2G,IAAA,GAAOE,QAAA;QACX;MACJ,SAAS7G,KAAA,IAAS;IACtB;IAEA,MAAM0B,MAAA,GAAS,IAAIxB,gBAAA,CAAoBK,IAAA,CAAKT,GAAG;IAC/C2G,YAAA,CAAalG,IAAA,EAAMmB,MAAM;IACzB,OAAOA,MAAA;EACX;EAEAoF,MAAA,EAAgB;IACZ,OAAO,KAAKP,KAAA,CAAM;EACtB;EAEAzB,QAAA,EAAoC;IAChC,OAAO,IAAIiC,iCAAA,CAA0D,KAAK3E,IAAA,CAAK,CAAC;EACpF;EAEAsC,KAAA,EAA4B;IACxB,OAAO,KAAKK,MAAA,CAAON,QAAQ,EAAE;EACjC;EAEAG,OAAA,EAA8B;IAC1B,OAAO,KAAKG,MAAA,CAAON,QAAQ,EAAE;EACjC;EAEA,CAACM,MAAA,CAAON,QAAQ,IAAyB;IACrC,OAAO,IAAIE,4BAAA,CAAqD,KAAKvC,IAAA,CAAK,CAAC;EAC/E;EAEA,CAAC2C,MAAA,CAAOC,WAAW,IAAI;AAC3B;AAeA,IAAegC,yBAAA,GAAf,MAAmH;EAC5FC,IAAA;EAEAC,IAAA,GAAO,IAAIC,KAAA,CAAY;EAEhCzG,iBAAA,GAAmC;EAEnCC,UAAA;EAEVV,YAAYgH,IAAA,EAAiC;IACzC,KAAKA,IAAA,GAAOA,IAAA;IACZ,KAAKtG,UAAA,GAAasG,IAAA,CAAKxE,aAAA,CAAc;EACzC;EAEA,CAACsC,MAAA,CAAON,QAAQ,IAAyB;IACrC,OAAO;EACX;EAEAtB,KAAA,EAAgC;IAC5B,IAAI,KAAKiE,QAAA,CAAS,GAAG,OAAO;MAAEhE,IAAA,EAAM;MAAO/C,KAAA,EAAO,KAAKY,OAAA,CAAQ;IAAG;IAClE,OAAO;MAAEmC,IAAA,EAAM;MAAM/C,KAAA,EAAO;IAAK;EACrC;EAEUY,QAAA,EAAU;IAChB,IAAI,CAAC,KAAKiG,IAAA,CAAKG,MAAA,EAAQ,OAAO;IAC9B,MAAM9G,IAAA,GAAO,KAAK2G,IAAA,CAAK,KAAKA,IAAA,CAAKG,MAAA,GAAS,CAAC;IAC3C,OAAO,KAAKC,QAAA,CAAS/G,IAAI;EAC7B;EAEUgH,YAAYzH,GAAA,EAAQ;IAC1B,KAAKoH,IAAA,CAAKM,MAAA,CAAO,GAAG,KAAKN,IAAA,CAAKG,MAAM;IACpC,KAAKJ,IAAA,CAAKrG,KAAA,CAAMd,GAAG;IACnB,KAAKoH,IAAA,CAAKO,IAAA,CAAK,KAAKR,IAAA,CAAK5E,OAAA,CAAQ,CAAE;IACnC,KAAK1B,UAAA,GAAa,KAAKsG,IAAA,CAAKxE,aAAA,CAAc;EAC9C;EAEUiF,uBAAuBnH,IAAA,EAAmB;IAChD,OAAOA,IAAA,IAAQ,MAAM;MACjB,KAAK2G,IAAA,CAAKO,IAAA,CAAKlH,IAAI;MACnBA,IAAA,GAAOA,IAAA,CAAKR,IAAA;IAChB;EACJ;EAEUqH,SAAA,EAAW;IACjB,IAAI,KAAK1G,iBAAA,IAAqB,KAAKuG,IAAA,CAAKzE,oBAAA,CAAqB,GAAG;MAC5D,IAAI,KAAK9B,iBAAA,IAAqB,MAAM;QAChC,KAAKA,iBAAA,GAAoB,KAAKuG,IAAA,CAAKzE,oBAAA,CAAqB;QACxD,IAAIkE,KAAA,GAAO,KAAKO,IAAA,CAAK5E,OAAA,CAAQ;QAC7B,OAAOqE,KAAA,IAAQ,MAAM;UACjB,KAAKQ,IAAA,CAAKO,IAAA,CAAKf,KAAI;UACnBA,KAAA,GAAOA,KAAA,CAAK3G,IAAA;QAChB;QACA,OAAO,KAAKmH,IAAA,CAAKG,MAAA,GAAS;MAC9B;MACA,MAAM;IACV;IACA,IAAI,CAAC,KAAKH,IAAA,CAAKG,MAAA,EAAQ,OAAO;IAC9B,IAAI,KAAK1G,UAAA,IAAc,KAAKsG,IAAA,CAAKxE,aAAA,CAAc,GAAG;MAC9C,KAAK8E,WAAA,CAAY,KAAKL,IAAA,CAAK,KAAKA,IAAA,CAAKG,MAAA,GAAS,CAAC,EAAEvH,GAAG;IACxD;IACA,IAAIS,IAAA,GAAO,KAAK2G,IAAA,CAAK,KAAKA,IAAA,CAAKG,MAAA,GAAS,CAAC;IACzC,IAAIlE,IAAA,GAAO5C,IAAA,CAAKP,KAAA;IAChB,IAAImD,IAAA,IAAQ,MAAM;MACd,OAAOA,IAAA,IAAQ,MAAM;QACjB,KAAK+D,IAAA,CAAKO,IAAA,CAAKtE,IAAI;QACnBA,IAAA,GAAOA,IAAA,CAAKpD,IAAA;MAChB;MACA,OAAO;IACX;IACA,KAAKmH,IAAA,CAAKS,GAAA,CAAI;IACd,OAAO,KAAKT,IAAA,CAAKG,MAAA,IAAU,KAAKH,IAAA,CAAK,KAAKA,IAAA,CAAKG,MAAA,GAAS,CAAC,EAAErH,KAAA,KAAUO,IAAA,EAAM;MACvEA,IAAA,GAAO,KAAK2G,IAAA,CAAKS,GAAA,CAAI;IACzB;IACA,OAAO,KAAKT,IAAA,CAAKG,MAAA,GAAS;EAC9B;AAGJ;AAEA,IAAM1C,4BAAA,GAAN,cAAmFqC,yBAAA,CAAsC;EAE3GM,SAAS/G,IAAA,EAAY;IAC3B,OAAOA,IAAA,CAAKT,GAAA;EAChB;AACJ;AAEA,IAAMiH,iCAAA,GAAN,cAAwFC,yBAAA,CAA2C;EAErHM,SAAS/G,IAAA,EAAoB;IACnC,OAAO,CAACA,IAAA,CAAKT,GAAA,EAAKS,IAAA,CAAKT,GAAG;EAC9B;AACJ;AAEA,IAAM+E,8BAAA,GAAN,cAAmDmC,yBAAA,CAAwD;EAEvG/G,YAAY2H,GAAA,EAAgC;IACxC,MAAMA,GAAG;EACb;EAEUN,SAAS/G,IAAA,EAA8B;IAC7C,OAAOA,IAAA,CAAKF,KAAA;EAChB;AACJ;AAEA,IAAM6C,iCAAA,GAAN,cAAsD8D,yBAAA,CAA6D;EAE/G/G,YAAY2H,GAAA,EAAgC;IACxC,MAAMA,GAAG;EACb;EAEUN,SAAS/G,IAAA,EAAsC;IACrD,OAAO,CAACA,IAAA,CAAKT,GAAA,EAAKS,IAAA,CAAKF,KAAK;EAChC;EAEAC,aAAaD,KAAA,EAAU;IACnB,IAAI,KAAKK,iBAAA,IAAqB,KAAKuG,IAAA,CAAKzE,oBAAA,CAAqB,GAAG;MAC5D,MAAM;IACV;IACA,IAAI,KAAK7B,UAAA,IAAc,KAAKsG,IAAA,CAAKxE,aAAA,CAAc,GAAG;MAC9C,KAAK8E,WAAA,CAAY,KAAKL,IAAA,CAAK,KAAKA,IAAA,CAAKG,MAAA,GAAS,CAAC,EAAEvH,GAAG;IACxD;IACA,MAAM8F,IAAA,GAAO,KAAKsB,IAAA,CAAKS,GAAA,CAAI;IAC3B,MAAME,OAAA,GAAUjC,IAAA,CAAKtF,YAAA,CAAaD,KAAK;IACvC,IAAI,CAAC,KAAK6G,IAAA,CAAKG,MAAA,EAAQ;MACnB,KAAKJ,IAAA,CAAK3E,OAAA,CAAQuF,OAAO;IAC7B,OAAO;MACH,MAAMC,MAAA,GAAS,KAAKZ,IAAA,CAAK,KAAKA,IAAA,CAAKG,MAAA,GAAS,CAAC;MAC7C,IAAIzB,IAAA,KAASkC,MAAA,CAAO/H,IAAA,EAAM;QACtB+H,MAAA,CAAO/H,IAAA,GAAO8H,OAAA;MAClB,OAAO;QACHC,MAAA,CAAO9H,KAAA,GAAQ6H,OAAA;MACnB;IACJ;IACA,KAAKX,IAAA,CAAKO,IAAA,CAAKI,OAAO;IACtB,MAAMlF,KAAA,GAAQ,KAAKsE,IAAA,CAAKxE,aAAA,CAAc,IAAI;IAC1C,KAAKwE,IAAA,CAAKvE,aAAA,CAAcC,KAAK;IAC7B,KAAKhC,UAAA,GAAagC,KAAA;EACtB;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}