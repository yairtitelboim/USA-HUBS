{"ast":null,"code":"// index.ts\nimport { distance } from \"@turf/distance\";\nimport { intersect } from \"@turf/intersect\";\nimport { polygon, featureCollection } from \"@turf/helpers\";\nfunction hexGrid(bbox, cellSide, options = {}) {\n  const clonedProperties = JSON.stringify(options.properties || {});\n  const [west, south, east, north] = bbox;\n  const centerY = (south + north) / 2;\n  const centerX = (west + east) / 2;\n  const xFraction = cellSide * 2 / distance([west, centerY], [east, centerY], options);\n  const cellWidth = xFraction * (east - west);\n  const yFraction = cellSide * 2 / distance([centerX, south], [centerX, north], options);\n  const cellHeight = yFraction * (north - south);\n  const radius = cellWidth / 2;\n  const hex_width = radius * 2;\n  const hex_height = Math.sqrt(3) / 2 * cellHeight;\n  const box_width = east - west;\n  const box_height = north - south;\n  const x_interval = 3 / 4 * hex_width;\n  const y_interval = hex_height;\n  const x_span = (box_width - hex_width) / (hex_width - radius / 2);\n  const x_count = Math.floor(x_span);\n  const x_adjust = (x_count * x_interval - radius / 2 - box_width) / 2 - radius / 2 + x_interval / 2;\n  const y_count = Math.floor((box_height - hex_height) / hex_height);\n  let y_adjust = (box_height - y_count * hex_height) / 2;\n  const hasOffsetY = y_count * hex_height - box_height > hex_height / 2;\n  if (hasOffsetY) {\n    y_adjust -= hex_height / 4;\n  }\n  const cosines = [];\n  const sines = [];\n  for (let i = 0; i < 6; i++) {\n    const angle = 2 * Math.PI / 6 * i;\n    cosines.push(Math.cos(angle));\n    sines.push(Math.sin(angle));\n  }\n  const results = [];\n  for (let x = 0; x <= x_count; x++) {\n    for (let y = 0; y <= y_count; y++) {\n      const isOdd = x % 2 === 1;\n      if (y === 0 && isOdd) continue;\n      if (y === 0 && hasOffsetY) continue;\n      const center_x = x * x_interval + west - x_adjust;\n      let center_y = y * y_interval + south + y_adjust;\n      if (isOdd) {\n        center_y -= hex_height / 2;\n      }\n      if (options.triangles === true) {\n        hexTriangles([center_x, center_y], cellWidth / 2, cellHeight / 2, JSON.parse(clonedProperties), cosines, sines).forEach(function (triangle) {\n          if (options.mask) {\n            if (intersect(featureCollection([options.mask, triangle]))) results.push(triangle);\n          } else {\n            results.push(triangle);\n          }\n        });\n      } else {\n        const hex = hexagon([center_x, center_y], cellWidth / 2, cellHeight / 2, JSON.parse(clonedProperties), cosines, sines);\n        if (options.mask) {\n          if (intersect(featureCollection([options.mask, hex]))) results.push(hex);\n        } else {\n          results.push(hex);\n        }\n      }\n    }\n  }\n  return featureCollection(results);\n}\nfunction hexagon(center, rx, ry, properties, cosines, sines) {\n  const vertices = [];\n  for (let i = 0; i < 6; i++) {\n    const x = center[0] + rx * cosines[i];\n    const y = center[1] + ry * sines[i];\n    vertices.push([x, y]);\n  }\n  vertices.push(vertices[0].slice());\n  return polygon([vertices], properties);\n}\nfunction hexTriangles(center, rx, ry, properties, cosines, sines) {\n  const triangles = [];\n  for (let i = 0; i < 6; i++) {\n    const vertices = [];\n    vertices.push(center);\n    vertices.push([center[0] + rx * cosines[i], center[1] + ry * sines[i]]);\n    vertices.push([center[0] + rx * cosines[(i + 1) % 6], center[1] + ry * sines[(i + 1) % 6]]);\n    vertices.push(center);\n    triangles.push(polygon([vertices], properties));\n  }\n  return triangles;\n}\nvar turf_hex_grid_default = hexGrid;\nexport { turf_hex_grid_default as default, hexGrid };","map":{"version":3,"names":["distance","intersect","polygon","featureCollection","hexGrid","bbox","cellSide","options","clonedProperties","JSON","stringify","properties","west","south","east","north","centerY","centerX","xFraction","cellWidth","yFraction","cellHeight","radius","hex_width","hex_height","Math","sqrt","box_width","box_height","x_interval","y_interval","x_span","x_count","floor","x_adjust","y_count","y_adjust","hasOffsetY","cosines","sines","i","angle","PI","push","cos","sin","results","x","y","isOdd","center_x","center_y","triangles","hexTriangles","parse","forEach","triangle","mask","hex","hexagon","center","rx","ry","vertices","slice","turf_hex_grid_default"],"sources":["/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/hex-grid/index.ts"],"sourcesContent":["import { distance } from \"@turf/distance\";\nimport { intersect } from \"@turf/intersect\";\nimport {\n  Feature,\n  FeatureCollection,\n  GeoJsonProperties,\n  Polygon,\n  BBox,\n} from \"geojson\";\nimport { polygon, featureCollection, Units } from \"@turf/helpers\";\n\n/**\n * Takes a bounding box and the diameter of the cell and returns a {@link FeatureCollection} of flat-topped\n * hexagons or triangles ({@link Polygon} features) aligned in an \"odd-q\" vertical grid as\n * described in [Hexagonal Grids](http://www.redblobgames.com/grids/hexagons/).\n *\n * @function\n * @param {BBox} bbox extent in [minX, minY, maxX, maxY] order\n * @param {number} cellSide length of the side of the the hexagons or triangles, in units. It will also coincide with the\n * radius of the circumcircle of the hexagons.\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] used in calculating cell size, can be degrees, radians, miles, or kilometers\n * @param {Object} [options.properties={}] passed to each hexagon or triangle of the grid\n * @param {Feature<Polygon>} [options.mask] if passed a Polygon or MultiPolygon, the grid Points will be created only inside it\n * @param {boolean} [options.triangles=false] whether to return as triangles instead of hexagons\n * @returns {FeatureCollection<Polygon>} a hexagonal grid\n * @example\n * var bbox = [-96,31,-84,40];\n * var cellSide = 50;\n * var options = {units: 'miles'};\n *\n * var hexgrid = turf.hexGrid(bbox, cellSide, options);\n *\n * //addToMap\n * var addToMap = [hexgrid];\n */\nfunction hexGrid<P extends GeoJsonProperties = GeoJsonProperties>(\n  bbox: BBox,\n  cellSide: number,\n  options: {\n    units?: Units;\n    triangles?: boolean;\n    properties?: P;\n    mask?: Feature<Polygon>;\n  } = {}\n): FeatureCollection<Polygon, P> {\n  // Issue => https://github.com/Turfjs/turf/issues/1284\n  const clonedProperties = JSON.stringify(options.properties || {});\n\n  const [west, south, east, north] = bbox;\n  const centerY = (south + north) / 2;\n  const centerX = (west + east) / 2;\n\n  // https://github.com/Turfjs/turf/issues/758\n  const xFraction =\n    (cellSide * 2) / distance([west, centerY], [east, centerY], options);\n  const cellWidth = xFraction * (east - west);\n  const yFraction =\n    (cellSide * 2) / distance([centerX, south], [centerX, north], options);\n  const cellHeight = yFraction * (north - south);\n  const radius = cellWidth / 2;\n\n  const hex_width = radius * 2;\n  const hex_height = (Math.sqrt(3) / 2) * cellHeight;\n\n  const box_width = east - west;\n  const box_height = north - south;\n\n  const x_interval = (3 / 4) * hex_width;\n  const y_interval = hex_height;\n\n  // adjust box_width so all hexagons will be inside the bbox\n  const x_span = (box_width - hex_width) / (hex_width - radius / 2);\n  const x_count = Math.floor(x_span);\n\n  const x_adjust =\n    (x_count * x_interval - radius / 2 - box_width) / 2 -\n    radius / 2 +\n    x_interval / 2;\n\n  // adjust box_height so all hexagons will be inside the bbox\n  const y_count = Math.floor((box_height - hex_height) / hex_height);\n\n  let y_adjust = (box_height - y_count * hex_height) / 2;\n\n  const hasOffsetY = y_count * hex_height - box_height > hex_height / 2;\n  if (hasOffsetY) {\n    y_adjust -= hex_height / 4;\n  }\n\n  // Precompute cosines and sines of angles used in hexagon creation for performance gain\n  const cosines = [];\n  const sines = [];\n  for (let i = 0; i < 6; i++) {\n    const angle = ((2 * Math.PI) / 6) * i;\n    cosines.push(Math.cos(angle));\n    sines.push(Math.sin(angle));\n  }\n\n  const results = [];\n  for (let x = 0; x <= x_count; x++) {\n    for (let y = 0; y <= y_count; y++) {\n      const isOdd = x % 2 === 1;\n      if (y === 0 && isOdd) continue;\n      if (y === 0 && hasOffsetY) continue;\n\n      const center_x = x * x_interval + west - x_adjust;\n      let center_y = y * y_interval + south + y_adjust;\n\n      if (isOdd) {\n        center_y -= hex_height / 2;\n      }\n\n      if (options.triangles === true) {\n        hexTriangles(\n          [center_x, center_y],\n          cellWidth / 2,\n          cellHeight / 2,\n          JSON.parse(clonedProperties),\n          cosines,\n          sines\n        ).forEach(function (triangle) {\n          if (options.mask) {\n            if (intersect(featureCollection([options.mask, triangle])))\n              results.push(triangle);\n          } else {\n            results.push(triangle);\n          }\n        });\n      } else {\n        const hex = hexagon(\n          [center_x, center_y],\n          cellWidth / 2,\n          cellHeight / 2,\n          JSON.parse(clonedProperties),\n          cosines,\n          sines\n        );\n        if (options.mask) {\n          if (intersect(featureCollection([options.mask, hex])))\n            results.push(hex);\n        } else {\n          results.push(hex);\n        }\n      }\n    }\n  }\n\n  return featureCollection(results) as FeatureCollection<Polygon, P>;\n}\n\n/**\n * Creates hexagon\n *\n * @private\n * @param {Array<number>} center of the hexagon\n * @param {number} rx half hexagon width\n * @param {number} ry half hexagon height\n * @param {Object} properties passed to each hexagon\n * @param {Array<number>} cosines precomputed\n * @param {Array<number>} sines precomputed\n * @returns {Feature<Polygon>} hexagon\n */\nfunction hexagon(\n  center: number[],\n  rx: number,\n  ry: number,\n  properties: GeoJsonProperties,\n  cosines: number[],\n  sines: number[]\n) {\n  const vertices = [];\n  for (let i = 0; i < 6; i++) {\n    const x = center[0] + rx * cosines[i];\n    const y = center[1] + ry * sines[i];\n    vertices.push([x, y]);\n  }\n  //first and last vertex must be the same\n  vertices.push(vertices[0].slice());\n  return polygon([vertices], properties);\n}\n\n/**\n * Creates triangles composing an hexagon\n *\n * @private\n * @param {Array<number>} center of the hexagon\n * @param {number} rx half triangle width\n * @param {number} ry half triangle height\n * @param {Object} properties passed to each triangle\n * @param {Array<number>} cosines precomputed\n * @param {Array<number>} sines precomputed\n * @returns {Array<Feature<Polygon>>} triangles\n */\nfunction hexTriangles(\n  center: number[],\n  rx: number,\n  ry: number,\n  properties: GeoJsonProperties,\n  cosines: number[],\n  sines: number[]\n) {\n  const triangles = [];\n  for (let i = 0; i < 6; i++) {\n    const vertices = [];\n    vertices.push(center);\n    vertices.push([center[0] + rx * cosines[i], center[1] + ry * sines[i]]);\n    vertices.push([\n      center[0] + rx * cosines[(i + 1) % 6],\n      center[1] + ry * sines[(i + 1) % 6],\n    ]);\n    vertices.push(center);\n    triangles.push(polygon([vertices], properties));\n  }\n  return triangles;\n}\n\nexport { hexGrid };\nexport default hexGrid;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}