{"ast":null,"code":"// index.ts\nimport { cleanCoords } from \"@turf/clean-coords\";\nimport { lineSegment } from \"@turf/line-segment\";\nimport { rhumbBearing } from \"@turf/rhumb-bearing\";\nimport { bearingToAzimuth } from \"@turf/helpers\";\nfunction booleanParallel(line1, line2) {\n  if (!line1) throw new Error(\"line1 is required\");\n  if (!line2) throw new Error(\"line2 is required\");\n  var type1 = getType(line1, \"line1\");\n  if (type1 !== \"LineString\") throw new Error(\"line1 must be a LineString\");\n  var type2 = getType(line2, \"line2\");\n  if (type2 !== \"LineString\") throw new Error(\"line2 must be a LineString\");\n  var segments1 = lineSegment(cleanCoords(line1)).features;\n  var segments2 = lineSegment(cleanCoords(line2)).features;\n  for (var i = 0; i < segments1.length; i++) {\n    var segment1 = segments1[i].geometry.coordinates;\n    if (!segments2[i]) break;\n    var segment2 = segments2[i].geometry.coordinates;\n    if (!isParallel(segment1, segment2)) return false;\n  }\n  return true;\n}\nfunction isParallel(segment1, segment2) {\n  var slope1 = bearingToAzimuth(rhumbBearing(segment1[0], segment1[1]));\n  var slope2 = bearingToAzimuth(rhumbBearing(segment2[0], segment2[1]));\n  return slope1 === slope2 || (slope2 - slope1) % 180 === 0;\n}\nfunction getType(geojson, name) {\n  if (geojson.geometry && geojson.geometry.type) return geojson.geometry.type;\n  if (geojson.type) return geojson.type;\n  throw new Error(\"Invalid GeoJSON object for \" + name);\n}\nvar turf_boolean_parallel_default = booleanParallel;\nexport { booleanParallel, turf_boolean_parallel_default as default };","map":{"version":3,"names":["cleanCoords","lineSegment","rhumbBearing","bearingToAzimuth","booleanParallel","line1","line2","Error","type1","getType","type2","segments1","features","segments2","i","length","segment1","geometry","coordinates","segment2","isParallel","slope1","slope2","geojson","name","type","turf_boolean_parallel_default"],"sources":["/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/boolean-parallel/index.ts"],"sourcesContent":["import { Feature, Geometry, LineString, Position } from \"geojson\";\nimport { cleanCoords } from \"@turf/clean-coords\";\nimport { lineSegment } from \"@turf/line-segment\";\nimport { rhumbBearing } from \"@turf/rhumb-bearing\";\nimport { bearingToAzimuth } from \"@turf/helpers\";\n\n/**\n * Boolean-Parallel returns True if each segment of `line1` is parallel to the correspondent segment of `line2`\n *\n * @function\n * @param {Geometry|Feature<LineString>} line1 GeoJSON Feature or Geometry\n * @param {Geometry|Feature<LineString>} line2 GeoJSON Feature or Geometry\n * @returns {boolean} true/false if the lines are parallel\n * @example\n * var line1 = turf.lineString([[0, 0], [0, 1]]);\n * var line2 = turf.lineString([[1, 0], [1, 1]]);\n *\n * turf.booleanParallel(line1, line2);\n * //=true\n */\nfunction booleanParallel(\n  line1: Feature<LineString> | LineString,\n  line2: Feature<LineString> | LineString\n): boolean {\n  // validation\n  if (!line1) throw new Error(\"line1 is required\");\n  if (!line2) throw new Error(\"line2 is required\");\n  var type1 = getType(line1, \"line1\");\n  if (type1 !== \"LineString\") throw new Error(\"line1 must be a LineString\");\n  var type2 = getType(line2, \"line2\");\n  if (type2 !== \"LineString\") throw new Error(\"line2 must be a LineString\");\n\n  var segments1 = lineSegment(cleanCoords(line1)).features;\n  var segments2 = lineSegment(cleanCoords(line2)).features;\n\n  for (var i = 0; i < segments1.length; i++) {\n    var segment1 = segments1[i].geometry.coordinates;\n    if (!segments2[i]) break;\n    var segment2 = segments2[i].geometry.coordinates;\n    if (!isParallel(segment1, segment2)) return false;\n  }\n  return true;\n}\n\n/**\n * Compares slopes and return result\n *\n * @private\n * @param {Geometry|Feature<LineString>} segment1 Geometry or Feature\n * @param {Geometry|Feature<LineString>} segment2 Geometry or Feature\n * @returns {boolean} if slopes are equal\n */\nfunction isParallel(segment1: Position[], segment2: Position[]) {\n  var slope1 = bearingToAzimuth(rhumbBearing(segment1[0], segment1[1]));\n  var slope2 = bearingToAzimuth(rhumbBearing(segment2[0], segment2[1]));\n  return slope1 === slope2 || (slope2 - slope1) % 180 === 0;\n}\n\n/**\n * Returns Feature's type\n *\n * @private\n * @param {Geometry|Feature<any>} geojson Geometry or Feature\n * @param {string} name of the variable\n * @returns {string} Feature's type\n */\nfunction getType(geojson: Geometry | Feature<any>, name: string) {\n  if ((geojson as Feature).geometry && (geojson as Feature).geometry.type)\n    return (geojson as Feature).geometry.type;\n  if (geojson.type) return geojson.type; // if GeoJSON geometry\n  throw new Error(\"Invalid GeoJSON object for \" + name);\n}\n\nexport { booleanParallel };\nexport default booleanParallel;\n"],"mappings":";AACA,SAASA,WAAA,QAAmB;AAC5B,SAASC,WAAA,QAAmB;AAC5B,SAASC,YAAA,QAAoB;AAC7B,SAASC,gBAAA,QAAwB;AAgBjC,SAASC,gBACPC,KAAA,EACAC,KAAA,EACS;EAET,IAAI,CAACD,KAAA,EAAO,MAAM,IAAIE,KAAA,CAAM,mBAAmB;EAC/C,IAAI,CAACD,KAAA,EAAO,MAAM,IAAIC,KAAA,CAAM,mBAAmB;EAC/C,IAAIC,KAAA,GAAQC,OAAA,CAAQJ,KAAA,EAAO,OAAO;EAClC,IAAIG,KAAA,KAAU,cAAc,MAAM,IAAID,KAAA,CAAM,4BAA4B;EACxE,IAAIG,KAAA,GAAQD,OAAA,CAAQH,KAAA,EAAO,OAAO;EAClC,IAAII,KAAA,KAAU,cAAc,MAAM,IAAIH,KAAA,CAAM,4BAA4B;EAExE,IAAII,SAAA,GAAYV,WAAA,CAAYD,WAAA,CAAYK,KAAK,CAAC,EAAEO,QAAA;EAChD,IAAIC,SAAA,GAAYZ,WAAA,CAAYD,WAAA,CAAYM,KAAK,CAAC,EAAEM,QAAA;EAEhD,SAASE,CAAA,GAAI,GAAGA,CAAA,GAAIH,SAAA,CAAUI,MAAA,EAAQD,CAAA,IAAK;IACzC,IAAIE,QAAA,GAAWL,SAAA,CAAUG,CAAC,EAAEG,QAAA,CAASC,WAAA;IACrC,IAAI,CAACL,SAAA,CAAUC,CAAC,GAAG;IACnB,IAAIK,QAAA,GAAWN,SAAA,CAAUC,CAAC,EAAEG,QAAA,CAASC,WAAA;IACrC,IAAI,CAACE,UAAA,CAAWJ,QAAA,EAAUG,QAAQ,GAAG,OAAO;EAC9C;EACA,OAAO;AACT;AAUA,SAASC,WAAWJ,QAAA,EAAsBG,QAAA,EAAsB;EAC9D,IAAIE,MAAA,GAASlB,gBAAA,CAAiBD,YAAA,CAAac,QAAA,CAAS,CAAC,GAAGA,QAAA,CAAS,CAAC,CAAC,CAAC;EACpE,IAAIM,MAAA,GAASnB,gBAAA,CAAiBD,YAAA,CAAaiB,QAAA,CAAS,CAAC,GAAGA,QAAA,CAAS,CAAC,CAAC,CAAC;EACpE,OAAOE,MAAA,KAAWC,MAAA,KAAWA,MAAA,GAASD,MAAA,IAAU,QAAQ;AAC1D;AAUA,SAASZ,QAAQc,OAAA,EAAkCC,IAAA,EAAc;EAC/D,IAAKD,OAAA,CAAoBN,QAAA,IAAaM,OAAA,CAAoBN,QAAA,CAASQ,IAAA,EACjE,OAAQF,OAAA,CAAoBN,QAAA,CAASQ,IAAA;EACvC,IAAIF,OAAA,CAAQE,IAAA,EAAM,OAAOF,OAAA,CAAQE,IAAA;EACjC,MAAM,IAAIlB,KAAA,CAAM,gCAAgCiB,IAAI;AACtD;AAGA,IAAOE,6BAAA,GAAQtB,eAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}