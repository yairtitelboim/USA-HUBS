{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\n\n// index.ts\nimport { distance } from \"@turf/distance\";\nimport { flattenEach } from \"@turf/meta\";\nimport { point, degreesToRadians, radiansToDegrees } from \"@turf/helpers\";\nimport { getCoord, getCoords } from \"@turf/invariant\";\nfunction nearestPointOnLine(lines, pt, options = {}) {\n  if (!lines || !pt) {\n    throw new Error(\"lines and pt are required arguments\");\n  }\n  const ptPos = getCoord(pt);\n  let closestPt = point([Infinity, Infinity], {\n    dist: Infinity,\n    index: -1,\n    multiFeatureIndex: -1,\n    location: -1\n  });\n  let length = 0;\n  flattenEach(lines, function (line, _featureIndex, multiFeatureIndex) {\n    const coords = getCoords(line);\n    for (let i = 0; i < coords.length - 1; i++) {\n      const start = point(coords[i]);\n      start.properties.dist = distance(pt, start, options);\n      const startPos = getCoord(start);\n      const stop = point(coords[i + 1]);\n      stop.properties.dist = distance(pt, stop, options);\n      const stopPos = getCoord(stop);\n      const sectionLength = distance(start, stop, options);\n      let intersectPos;\n      let wasEnd;\n      if (startPos[0] === ptPos[0] && startPos[1] === ptPos[1]) {\n        [intersectPos,, wasEnd] = [startPos, void 0, false];\n      } else if (stopPos[0] === ptPos[0] && stopPos[1] === ptPos[1]) {\n        [intersectPos,, wasEnd] = [stopPos, void 0, true];\n      } else {\n        [intersectPos,, wasEnd] = nearestPointOnSegment(start.geometry.coordinates, stop.geometry.coordinates, getCoord(pt));\n      }\n      let intersectPt;\n      if (intersectPos) {\n        intersectPt = point(intersectPos, {\n          dist: distance(pt, intersectPos, options),\n          multiFeatureIndex,\n          location: length + distance(start, intersectPos, options)\n        });\n      }\n      if (intersectPt && intersectPt.properties.dist < closestPt.properties.dist) {\n        closestPt = __spreadProps(__spreadValues({}, intersectPt), {\n          properties: __spreadProps(__spreadValues({}, intersectPt.properties), {\n            // Legacy behaviour where index progresses to next segment # if we\n            // went with the end point this iteration.\n            index: wasEnd ? i + 1 : i\n          })\n        });\n      }\n      length += sectionLength;\n    }\n  });\n  return closestPt;\n}\nfunction dot(v1, v2) {\n  const [v1x, v1y, v1z] = v1;\n  const [v2x, v2y, v2z] = v2;\n  return v1x * v2x + v1y * v2y + v1z * v2z;\n}\nfunction cross(v1, v2) {\n  const [v1x, v1y, v1z] = v1;\n  const [v2x, v2y, v2z] = v2;\n  return [v1y * v2z - v1z * v2y, v1z * v2x - v1x * v2z, v1x * v2y - v1y * v2x];\n}\nfunction magnitude(v) {\n  return Math.sqrt(Math.pow(v[0], 2) + Math.pow(v[1], 2) + Math.pow(v[2], 2));\n}\nfunction angle(v1, v2) {\n  const theta = dot(v1, v2) / (magnitude(v1) * magnitude(v2));\n  return Math.acos(Math.min(Math.max(theta, -1), 1));\n}\nfunction lngLatToVector(a) {\n  const lat = degreesToRadians(a[1]);\n  const lng = degreesToRadians(a[0]);\n  return [Math.cos(lat) * Math.cos(lng), Math.cos(lat) * Math.sin(lng), Math.sin(lat)];\n}\nfunction vectorToLngLat(v) {\n  const [x, y, z] = v;\n  const lat = radiansToDegrees(Math.asin(z));\n  const lng = radiansToDegrees(Math.atan2(y, x));\n  return [lng, lat];\n}\nfunction nearestPointOnSegment(posA, posB, posC) {\n  const A = lngLatToVector(posA);\n  const B = lngLatToVector(posB);\n  const C = lngLatToVector(posC);\n  const [Cx, Cy, Cz] = C;\n  const [D, E, F] = cross(A, B);\n  const a = E * Cz - F * Cy;\n  const b = F * Cx - D * Cz;\n  const c = D * Cy - E * Cx;\n  const f = c * E - b * F;\n  const g = a * F - c * D;\n  const h = b * D - a * E;\n  const t = 1 / Math.sqrt(Math.pow(f, 2) + Math.pow(g, 2) + Math.pow(h, 2));\n  const I1 = [f * t, g * t, h * t];\n  const I2 = [-1 * f * t, -1 * g * t, -1 * h * t];\n  const angleAB = angle(A, B);\n  const angleAI1 = angle(A, I1);\n  const angleBI1 = angle(B, I1);\n  const angleAI2 = angle(A, I2);\n  const angleBI2 = angle(B, I2);\n  let I;\n  if (angleAI1 < angleAI2 && angleAI1 < angleBI2 || angleBI1 < angleAI2 && angleBI1 < angleBI2) {\n    I = I1;\n  } else {\n    I = I2;\n  }\n  if (angle(A, I) > angleAB || angle(B, I) > angleAB) {\n    if (distance(vectorToLngLat(I), vectorToLngLat(A)) <= distance(vectorToLngLat(I), vectorToLngLat(B))) {\n      return [vectorToLngLat(A), true, false];\n    } else {\n      return [vectorToLngLat(B), false, true];\n    }\n  }\n  return [vectorToLngLat(I), false, false];\n}\nvar turf_nearest_point_on_line_default = nearestPointOnLine;\nexport { turf_nearest_point_on_line_default as default, nearestPointOnLine };","map":{"version":3,"names":["distance","flattenEach","point","degreesToRadians","radiansToDegrees","getCoord","getCoords","nearestPointOnLine","lines","pt","options","Error","ptPos","closestPt","Infinity","dist","index","multiFeatureIndex","location","length","line","_featureIndex","coords","i","start","properties","startPos","stop","stopPos","sectionLength","intersectPos","wasEnd","nearestPointOnSegment","geometry","coordinates","intersectPt","__spreadProps","__spreadValues","dot","v1","v2","v1x","v1y","v1z","v2x","v2y","v2z","cross","magnitude","v","Math","sqrt","pow","angle","theta","acos","min","max","lngLatToVector","a","lat","lng","cos","sin","vectorToLngLat","x","y","z","asin","atan2","posA","posB","posC","A","B","C","Cx","Cy","Cz","D","E","F","b","c","f","g","h","t","I1","I2","angleAB","angleAI1","angleBI1","angleAI2","angleBI2","I","turf_nearest_point_on_line_default"],"sources":["/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/nearest-point-on-line/index.ts"],"sourcesContent":["import { Feature, Point, Position, LineString, MultiLineString } from \"geojson\";\nimport { distance } from \"@turf/distance\";\nimport { flattenEach } from \"@turf/meta\";\nimport {\n  point,\n  degreesToRadians,\n  radiansToDegrees,\n  Coord,\n  Units,\n} from \"@turf/helpers\";\nimport { getCoord, getCoords } from \"@turf/invariant\";\n\n/**\n * Returns the nearest point on a line to a given point.\n *\n * @function\n * @param {Geometry|Feature<LineString|MultiLineString>} lines lines to snap to\n * @param {Geometry|Feature<Point>|number[]} pt point to snap from\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers\n * @returns {Feature<Point>} closest point on the `line` to `point`. The properties object will contain four values: `index`: closest point was found on nth line part, `multiFeatureIndex`: closest point was found on the nth line of the `MultiLineString`, `dist`: distance between pt and the closest point, `location`: distance along the line between start and the closest point.\n * @example\n * var line = turf.lineString([\n *     [-77.031669, 38.878605],\n *     [-77.029609, 38.881946],\n *     [-77.020339, 38.884084],\n *     [-77.025661, 38.885821],\n *     [-77.021884, 38.889563],\n *     [-77.019824, 38.892368]\n * ]);\n * var pt = turf.point([-77.037076, 38.884017]);\n *\n * var snapped = turf.nearestPointOnLine(line, pt, {units: 'miles'});\n *\n * //addToMap\n * var addToMap = [line, pt, snapped];\n * snapped.properties['marker-color'] = '#00f';\n */\nfunction nearestPointOnLine<G extends LineString | MultiLineString>(\n  lines: Feature<G> | G,\n  pt: Coord,\n  options: { units?: Units } = {}\n): Feature<\n  Point,\n  {\n    dist: number;\n    index: number;\n    multiFeatureIndex: number;\n    location: number;\n    [key: string]: any;\n  }\n> {\n  if (!lines || !pt) {\n    throw new Error(\"lines and pt are required arguments\");\n  }\n\n  const ptPos = getCoord(pt);\n\n  let closestPt: Feature<\n    Point,\n    { dist: number; index: number; multiFeatureIndex: number; location: number }\n  > = point([Infinity, Infinity], {\n    dist: Infinity,\n    index: -1,\n    multiFeatureIndex: -1,\n    location: -1,\n  });\n\n  let length = 0.0;\n  flattenEach(\n    lines,\n    function (line: any, _featureIndex: number, multiFeatureIndex: number) {\n      const coords: any = getCoords(line);\n\n      for (let i = 0; i < coords.length - 1; i++) {\n        //start - start of current line section\n        const start: Feature<Point, { dist: number }> = point(coords[i]);\n        start.properties.dist = distance(pt, start, options);\n        const startPos = getCoord(start);\n\n        //stop - end of current line section\n        const stop: Feature<Point, { dist: number }> = point(coords[i + 1]);\n        stop.properties.dist = distance(pt, stop, options);\n        const stopPos = getCoord(stop);\n\n        // sectionLength\n        const sectionLength = distance(start, stop, options);\n        let intersectPos: Position;\n        let wasEnd: boolean;\n\n        // Short circuit if snap point is start or end position of the line\n        // segment.\n        if (startPos[0] === ptPos[0] && startPos[1] === ptPos[1]) {\n          [intersectPos, , wasEnd] = [startPos, undefined, false];\n        } else if (stopPos[0] === ptPos[0] && stopPos[1] === ptPos[1]) {\n          [intersectPos, , wasEnd] = [stopPos, undefined, true];\n        } else {\n          // Otherwise, find the nearest point the hard way.\n          [intersectPos, , wasEnd] = nearestPointOnSegment(\n            start.geometry.coordinates,\n            stop.geometry.coordinates,\n            getCoord(pt)\n          );\n        }\n        let intersectPt:\n          | Feature<\n              Point,\n              { dist: number; multiFeatureIndex: number; location: number }\n            >\n          | undefined;\n\n        if (intersectPos) {\n          intersectPt = point(intersectPos, {\n            dist: distance(pt, intersectPos, options),\n            multiFeatureIndex: multiFeatureIndex,\n            location: length + distance(start, intersectPos, options),\n          });\n        }\n\n        if (\n          intersectPt &&\n          intersectPt.properties.dist < closestPt.properties.dist\n        ) {\n          closestPt = {\n            ...intersectPt,\n            properties: {\n              ...intersectPt.properties,\n              // Legacy behaviour where index progresses to next segment # if we\n              // went with the end point this iteration.\n              index: wasEnd ? i + 1 : i,\n            },\n          };\n        }\n\n        // update length\n        length += sectionLength;\n      }\n    }\n  );\n\n  return closestPt;\n}\n\n/*\n * Plan is to externalise these vector functions to a simple third party\n * library.\n * Possible candidate is @amandaghassaei/vector-math though having some import\n * issues.\n */\ntype Vector = [number, number, number];\n\nfunction dot(v1: Vector, v2: Vector): number {\n  const [v1x, v1y, v1z] = v1;\n  const [v2x, v2y, v2z] = v2;\n  return v1x * v2x + v1y * v2y + v1z * v2z;\n}\n\n// https://en.wikipedia.org/wiki/Cross_product\nfunction cross(v1: Vector, v2: Vector): Vector {\n  const [v1x, v1y, v1z] = v1;\n  const [v2x, v2y, v2z] = v2;\n  return [v1y * v2z - v1z * v2y, v1z * v2x - v1x * v2z, v1x * v2y - v1y * v2x];\n}\n\nfunction magnitude(v: Vector) {\n  return Math.sqrt(Math.pow(v[0], 2) + Math.pow(v[1], 2) + Math.pow(v[2], 2));\n}\n\nfunction angle(v1: Vector, v2: Vector): number {\n  const theta = dot(v1, v2) / (magnitude(v1) * magnitude(v2));\n  return Math.acos(Math.min(Math.max(theta, -1), 1));\n}\n\nfunction lngLatToVector(a: Position): Vector {\n  const lat = degreesToRadians(a[1]);\n  const lng = degreesToRadians(a[0]);\n  return [\n    Math.cos(lat) * Math.cos(lng),\n    Math.cos(lat) * Math.sin(lng),\n    Math.sin(lat),\n  ];\n}\n\nfunction vectorToLngLat(v: Vector): Position {\n  const [x, y, z] = v;\n  const lat = radiansToDegrees(Math.asin(z));\n  const lng = radiansToDegrees(Math.atan2(y, x));\n\n  return [lng, lat];\n}\n\nfunction nearestPointOnSegment(\n  posA: Position, // start point of segment to measure to\n  posB: Position, // end point of segment to measure to\n  posC: Position // point to measure from\n): [Position, boolean, boolean] {\n  // Based heavily on this article on finding cross track distance to an arc:\n  // https://gis.stackexchange.com/questions/209540/projecting-cross-track-distance-on-great-circle\n\n  // Convert spherical (lng, lat) to cartesian vector coords (x, y, z)\n  // In the below https://tikz.net/spherical_1/ we convert lng (ðœ™) and lat (ðœƒ)\n  // into vectors with x, y, and z components with a length (r) of 1.\n  const A = lngLatToVector(posA); // the vector from 0,0,0 to posA\n  const B = lngLatToVector(posB); // ... to posB\n  const C = lngLatToVector(posC); // ... to posC\n\n  // Components of target point.\n  const [Cx, Cy, Cz] = C;\n\n  // Calculate coefficients.\n  const [D, E, F] = cross(A, B);\n  const a = E * Cz - F * Cy;\n  const b = F * Cx - D * Cz;\n  const c = D * Cy - E * Cx;\n\n  const f = c * E - b * F;\n  const g = a * F - c * D;\n  const h = b * D - a * E;\n\n  const t = 1 / Math.sqrt(Math.pow(f, 2) + Math.pow(g, 2) + Math.pow(h, 2));\n\n  // Vectors to the two points these great circles intersect.\n  const I1: Vector = [f * t, g * t, h * t];\n  const I2: Vector = [-1 * f * t, -1 * g * t, -1 * h * t];\n\n  // Figure out which is the closest intersection to this segment of the great\n  // circle.\n  const angleAB = angle(A, B);\n  const angleAI1 = angle(A, I1);\n  const angleBI1 = angle(B, I1);\n  const angleAI2 = angle(A, I2);\n  const angleBI2 = angle(B, I2);\n\n  let I: Vector;\n\n  if (\n    (angleAI1 < angleAI2 && angleAI1 < angleBI2) ||\n    (angleBI1 < angleAI2 && angleBI1 < angleBI2)\n  ) {\n    I = I1;\n  } else {\n    I = I2;\n  }\n\n  // I is the closest intersection to the segment, though might not actually be\n  // ON the segment.\n\n  // If angle AI or BI is greater than angleAB, I lies on the circle *beyond* A\n  // and B so use the closest of A or B as the intersection\n  if (angle(A, I) > angleAB || angle(B, I) > angleAB) {\n    if (\n      distance(vectorToLngLat(I), vectorToLngLat(A)) <=\n      distance(vectorToLngLat(I), vectorToLngLat(B))\n    ) {\n      return [vectorToLngLat(A), true, false];\n    } else {\n      return [vectorToLngLat(B), false, true];\n    }\n  }\n\n  // As angleAI nor angleBI don't exceed angleAB, I is on the segment\n  return [vectorToLngLat(I), false, false];\n}\n\nexport { nearestPointOnLine };\nexport default nearestPointOnLine;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}