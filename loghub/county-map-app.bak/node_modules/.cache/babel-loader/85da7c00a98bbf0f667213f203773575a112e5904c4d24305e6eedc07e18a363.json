{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\n\n// index.ts\nimport { clone } from \"@turf/clone\";\nimport { distance } from \"@turf/distance\";\nimport { featureEach } from \"@turf/meta\";\nfunction nearestPoint(targetPoint, points, options = {}) {\n  if (!targetPoint) throw new Error(\"targetPoint is required\");\n  if (!points) throw new Error(\"points is required\");\n  let minDist = Infinity;\n  let bestFeatureIndex = 0;\n  featureEach(points, (pt, featureIndex) => {\n    const distanceToPoint = distance(targetPoint, pt, options);\n    if (distanceToPoint < minDist) {\n      bestFeatureIndex = featureIndex;\n      minDist = distanceToPoint;\n    }\n  });\n  const nearestPoint2 = clone(points.features[bestFeatureIndex]);\n  return __spreadProps(__spreadValues({}, nearestPoint2), {\n    properties: __spreadProps(__spreadValues({}, nearestPoint2.properties), {\n      featureIndex: bestFeatureIndex,\n      distanceToPoint: minDist\n    })\n  });\n}\nvar turf_nearest_point_default = nearestPoint;\nexport { turf_nearest_point_default as default, nearestPoint };","map":{"version":3,"names":["clone","distance","featureEach","nearestPoint","targetPoint","points","options","Error","minDist","Infinity","bestFeatureIndex","pt","featureIndex","distanceToPoint","nearestPoint2","features","__spreadProps","__spreadValues","properties","turf_nearest_point_default"],"sources":["/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/nearest-point/index.ts"],"sourcesContent":["import { Feature, FeatureCollection, Point } from \"geojson\";\nimport { Coord, Units } from \"@turf/helpers\";\nimport { clone } from \"@turf/clone\";\nimport { distance } from \"@turf/distance\";\nimport { featureEach } from \"@turf/meta\";\n\ninterface NearestPoint extends Feature<Point> {\n  properties: {\n    featureIndex: number;\n    distanceToPoint: number;\n    [key: string]: any;\n  };\n}\n\n/**\n * Takes a reference {@link Point|point} and a FeatureCollection of Features\n * with Point geometries and returns the\n * point from the FeatureCollection closest to the reference. This calculation\n * is geodesic.\n *\n * @function\n * @param {Coord} targetPoint the reference point\n * @param {FeatureCollection<Point>} points against input point set\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] the units of the numeric result\n * @returns {Feature<Point>} the closest point in the set to the reference point\n * @example\n * var targetPoint = turf.point([28.965797, 41.010086], {\"marker-color\": \"#0F0\"});\n * var points = turf.featureCollection([\n *     turf.point([28.973865, 41.011122]),\n *     turf.point([28.948459, 41.024204]),\n *     turf.point([28.938674, 41.013324])\n * ]);\n *\n * var nearest = turf.nearestPoint(targetPoint, points);\n *\n * //addToMap\n * var addToMap = [targetPoint, points, nearest];\n * nearest.properties['marker-color'] = '#F00';\n */\nfunction nearestPoint(\n  targetPoint: Coord,\n  points: FeatureCollection<Point>,\n  options: {\n    units?: Units;\n  } = {}\n): NearestPoint {\n  // Input validation\n  if (!targetPoint) throw new Error(\"targetPoint is required\");\n  if (!points) throw new Error(\"points is required\");\n\n  let minDist = Infinity;\n  let bestFeatureIndex = 0;\n  featureEach(points, (pt, featureIndex) => {\n    const distanceToPoint = distance(targetPoint, pt, options);\n    if (distanceToPoint < minDist) {\n      bestFeatureIndex = featureIndex;\n      minDist = distanceToPoint;\n    }\n  });\n  const nearestPoint = clone(points.features[bestFeatureIndex]);\n\n  return {\n    ...nearestPoint,\n    properties: {\n      ...nearestPoint.properties,\n      featureIndex: bestFeatureIndex,\n      distanceToPoint: minDist,\n    },\n  };\n}\n\nexport { nearestPoint, NearestPoint };\nexport default nearestPoint;\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAEA,SAASA,KAAA,QAAa;AACtB,SAASC,QAAA,QAAgB;AACzB,SAASC,WAAA,QAAmB;AAoC5B,SAASC,aACPC,WAAA,EACAC,MAAA,EACAC,OAAA,GAEI,CAAC,GACS;EAEd,IAAI,CAACF,WAAA,EAAa,MAAM,IAAIG,KAAA,CAAM,yBAAyB;EAC3D,IAAI,CAACF,MAAA,EAAQ,MAAM,IAAIE,KAAA,CAAM,oBAAoB;EAEjD,IAAIC,OAAA,GAAUC,QAAA;EACd,IAAIC,gBAAA,GAAmB;EACvBR,WAAA,CAAYG,MAAA,EAAQ,CAACM,EAAA,EAAIC,YAAA,KAAiB;IACxC,MAAMC,eAAA,GAAkBZ,QAAA,CAASG,WAAA,EAAaO,EAAA,EAAIL,OAAO;IACzD,IAAIO,eAAA,GAAkBL,OAAA,EAAS;MAC7BE,gBAAA,GAAmBE,YAAA;MACnBJ,OAAA,GAAUK,eAAA;IACZ;EACF,CAAC;EACD,MAAMC,aAAA,GAAed,KAAA,CAAMK,MAAA,CAAOU,QAAA,CAASL,gBAAgB,CAAC;EAE5D,OAAOM,aAAA,CAAAC,cAAA,KACFH,aAAA,GADE;IAELI,UAAA,EAAYF,aAAA,CAAAC,cAAA,KACPH,aAAA,CAAaI,UAAA,GADN;MAEVN,YAAA,EAAcF,gBAAA;MACdG,eAAA,EAAiBL;IACnB;EACF;AACF;AAGA,IAAOW,0BAAA,GAAQhB,YAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}