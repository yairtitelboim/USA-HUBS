{"ast":null,"code":"!function (t, e) {\n  \"object\" == typeof exports && \"undefined\" != typeof module ? module.exports = e() : \"function\" == typeof define && define.amd ? define(e) : (t = \"undefined\" != typeof globalThis ? globalThis : t || self).jsts = e();\n}(this, function () {\n  \"use strict\";\n\n  function t(t, e) {\n    (null == e || e > t.length) && (e = t.length);\n    for (var n = 0, i = Array(e); n < e; n++) i[n] = t[n];\n    return i;\n  }\n  function e(t, e, n) {\n    return e = u(e), function (t, e) {\n      if (e && (\"object\" == typeof e || \"function\" == typeof e)) return e;\n      if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\");\n      return function (t) {\n        if (void 0 === t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        return t;\n      }(t);\n    }(t, h() ? Reflect.construct(e, n || [], u(t).constructor) : e.apply(t, n));\n  }\n  function n(t, e) {\n    if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n  }\n  function i(t, e, n) {\n    if (h()) return Reflect.construct.apply(null, arguments);\n    var i = [null];\n    i.push.apply(i, e);\n    var r = new (t.bind.apply(t, i))();\n    return n && c(r, n.prototype), r;\n  }\n  function r(t, e) {\n    for (var n = 0; n < e.length; n++) {\n      var i = e[n];\n      i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(t, v(i.key), i);\n    }\n  }\n  function s(t, e, n) {\n    return e && r(t.prototype, e), n && r(t, n), Object.defineProperty(t, \"prototype\", {\n      writable: !1\n    }), t;\n  }\n  function a(t, e) {\n    var n = \"undefined\" != typeof Symbol && t[Symbol.iterator] || t[\"@@iterator\"];\n    if (!n) {\n      if (Array.isArray(t) || (n = y(t)) || e) {\n        n && (t = n);\n        var i = 0,\n          r = function () {};\n        return {\n          s: r,\n          n: function () {\n            return i >= t.length ? {\n              done: !0\n            } : {\n              done: !1,\n              value: t[i++]\n            };\n          },\n          e: function (t) {\n            throw t;\n          },\n          f: r\n        };\n      }\n      throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n    var s,\n      a = !0,\n      o = !1;\n    return {\n      s: function () {\n        n = n.call(t);\n      },\n      n: function () {\n        var t = n.next();\n        return a = t.done, t;\n      },\n      e: function (t) {\n        o = !0, s = t;\n      },\n      f: function () {\n        try {\n          a || null == n.return || n.return();\n        } finally {\n          if (o) throw s;\n        }\n      }\n    };\n  }\n  function o() {\n    return o = \"undefined\" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (t, e, n) {\n      var i = function (t, e) {\n        for (; !{}.hasOwnProperty.call(t, e) && null !== (t = u(t)););\n        return t;\n      }(t, e);\n      if (i) {\n        var r = Object.getOwnPropertyDescriptor(i, e);\n        return r.get ? r.get.call(arguments.length < 3 ? t : n) : r.value;\n      }\n    }, o.apply(null, arguments);\n  }\n  function u(t) {\n    return u = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {\n      return t.__proto__ || Object.getPrototypeOf(t);\n    }, u(t);\n  }\n  function l(t, e) {\n    if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\");\n    t.prototype = Object.create(e && e.prototype, {\n      constructor: {\n        value: t,\n        writable: !0,\n        configurable: !0\n      }\n    }), Object.defineProperty(t, \"prototype\", {\n      writable: !1\n    }), e && c(t, e);\n  }\n  function h() {\n    try {\n      var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    } catch (t) {}\n    return (h = function () {\n      return !!t;\n    })();\n  }\n  function c(t, e) {\n    return c = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {\n      return t.__proto__ = e, t;\n    }, c(t, e);\n  }\n  function f(t, e, n, i) {\n    var r = o(u(1 & i ? t.prototype : t), e, n);\n    return 2 & i && \"function\" == typeof r ? function (t) {\n      return r.apply(n, t);\n    } : r;\n  }\n  function g(e) {\n    return function (e) {\n      if (Array.isArray(e)) return t(e);\n    }(e) || function (t) {\n      if (\"undefined\" != typeof Symbol && null != t[Symbol.iterator] || null != t[\"@@iterator\"]) return Array.from(t);\n    }(e) || y(e) || function () {\n      throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }();\n  }\n  function v(t) {\n    var e = function (t, e) {\n      if (\"object\" != typeof t || !t) return t;\n      var n = t[Symbol.toPrimitive];\n      if (void 0 !== n) {\n        var i = n.call(t, e);\n        if (\"object\" != typeof i) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n      }\n      return String(t);\n    }(t, \"string\");\n    return \"symbol\" == typeof e ? e : e + \"\";\n  }\n  function y(e, n) {\n    if (e) {\n      if (\"string\" == typeof e) return t(e, n);\n      var i = {}.toString.call(e).slice(8, -1);\n      return \"Object\" === i && e.constructor && (i = e.constructor.name), \"Map\" === i || \"Set\" === i ? Array.from(e) : \"Arguments\" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? t(e, n) : void 0;\n    }\n  }\n  function d(t) {\n    var e = \"function\" == typeof Map ? new Map() : void 0;\n    return d = function (t) {\n      if (null === t || !function (t) {\n        try {\n          return -1 !== Function.toString.call(t).indexOf(\"[native code]\");\n        } catch (e) {\n          return \"function\" == typeof t;\n        }\n      }(t)) return t;\n      if (\"function\" != typeof t) throw new TypeError(\"Super expression must either be null or a function\");\n      if (void 0 !== e) {\n        if (e.has(t)) return e.get(t);\n        e.set(t, n);\n      }\n      function n() {\n        return i(t, arguments, u(this).constructor);\n      }\n      return n.prototype = Object.create(t.prototype, {\n        constructor: {\n          value: n,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), c(n, t);\n    }, d(t);\n  }\n  var _ = function () {\n    function t() {\n      n(this, t), t.constructor_.apply(this, arguments);\n    }\n    return s(t, [{\n      key: \"getEndCapStyle\",\n      value: function () {\n        return this._endCapStyle;\n      }\n    }, {\n      key: \"isSingleSided\",\n      value: function () {\n        return this._isSingleSided;\n      }\n    }, {\n      key: \"setQuadrantSegments\",\n      value: function (e) {\n        this._quadrantSegments = e, 0 === this._quadrantSegments && (this._joinStyle = t.JOIN_BEVEL), this._quadrantSegments < 0 && (this._joinStyle = t.JOIN_MITRE, this._mitreLimit = Math.abs(this._quadrantSegments)), e <= 0 && (this._quadrantSegments = 1), this._joinStyle !== t.JOIN_ROUND && (this._quadrantSegments = t.DEFAULT_QUADRANT_SEGMENTS);\n      }\n    }, {\n      key: \"getJoinStyle\",\n      value: function () {\n        return this._joinStyle;\n      }\n    }, {\n      key: \"setJoinStyle\",\n      value: function (t) {\n        this._joinStyle = t;\n      }\n    }, {\n      key: \"setSimplifyFactor\",\n      value: function (t) {\n        this._simplifyFactor = t < 0 ? 0 : t;\n      }\n    }, {\n      key: \"getSimplifyFactor\",\n      value: function () {\n        return this._simplifyFactor;\n      }\n    }, {\n      key: \"getQuadrantSegments\",\n      value: function () {\n        return this._quadrantSegments;\n      }\n    }, {\n      key: \"setEndCapStyle\",\n      value: function (t) {\n        this._endCapStyle = t;\n      }\n    }, {\n      key: \"getMitreLimit\",\n      value: function () {\n        return this._mitreLimit;\n      }\n    }, {\n      key: \"setMitreLimit\",\n      value: function (t) {\n        this._mitreLimit = t;\n      }\n    }, {\n      key: \"setSingleSided\",\n      value: function (t) {\n        this._isSingleSided = t;\n      }\n    }], [{\n      key: \"constructor_\",\n      value: function () {\n        if (this._quadrantSegments = t.DEFAULT_QUADRANT_SEGMENTS, this._endCapStyle = t.CAP_ROUND, this._joinStyle = t.JOIN_ROUND, this._mitreLimit = t.DEFAULT_MITRE_LIMIT, this._isSingleSided = !1, this._simplifyFactor = t.DEFAULT_SIMPLIFY_FACTOR, 0 === arguments.length) ;else if (1 === arguments.length) {\n          var e = arguments[0];\n          this.setQuadrantSegments(e);\n        } else if (2 === arguments.length) {\n          var n = arguments[0],\n            i = arguments[1];\n          this.setQuadrantSegments(n), this.setEndCapStyle(i);\n        } else if (4 === arguments.length) {\n          var r = arguments[0],\n            s = arguments[1],\n            a = arguments[2],\n            o = arguments[3];\n          this.setQuadrantSegments(r), this.setEndCapStyle(s), this.setJoinStyle(a), this.setMitreLimit(o);\n        }\n      }\n    }, {\n      key: \"bufferDistanceError\",\n      value: function (t) {\n        var e = Math.PI / 2 / t;\n        return 1 - Math.cos(e / 2);\n      }\n    }]);\n  }();\n  _.CAP_ROUND = 1, _.CAP_FLAT = 2, _.CAP_SQUARE = 3, _.JOIN_ROUND = 1, _.JOIN_MITRE = 2, _.JOIN_BEVEL = 3, _.DEFAULT_QUADRANT_SEGMENTS = 8, _.DEFAULT_MITRE_LIMIT = 5, _.DEFAULT_SIMPLIFY_FACTOR = .01;\n  var p = function (t) {\n      function i(t) {\n        var r;\n        return n(this, i), (r = e(this, i, [t])).name = Object.keys({\n          Exception: i\n        })[0], r;\n      }\n      return l(i, t), s(i, [{\n        key: \"toString\",\n        value: function () {\n          return this.message;\n        }\n      }]);\n    }(d(Error)),\n    m = function (t) {\n      function i(t) {\n        var r;\n        return n(this, i), (r = e(this, i, [t])).name = Object.keys({\n          IllegalArgumentException: i\n        })[0], r;\n      }\n      return l(i, t), s(i);\n    }(p),\n    k = function () {\n      return s(function t() {\n        n(this, t);\n      }, [{\n        key: \"filter\",\n        value: function (t) {}\n      }]);\n    }();\n  function x() {}\n  function I() {}\n  function E() {}\n  var N,\n    T,\n    S,\n    L,\n    C,\n    R,\n    w,\n    O,\n    b = function () {\n      return s(function t() {\n        n(this, t);\n      }, null, [{\n        key: \"equalsWithTolerance\",\n        value: function (t, e, n) {\n          return Math.abs(t - e) <= n;\n        }\n      }]);\n    }(),\n    M = function () {\n      return s(function t(e, i) {\n        n(this, t), this.low = i || 0, this.high = e || 0;\n      }, null, [{\n        key: \"toBinaryString\",\n        value: function (t) {\n          var e,\n            n = \"\";\n          for (e = 2147483648; e > 0; e >>>= 1) n += (t.high & e) === e ? \"1\" : \"0\";\n          for (e = 2147483648; e > 0; e >>>= 1) n += (t.low & e) === e ? \"1\" : \"0\";\n          return n;\n        }\n      }]);\n    }();\n  function A() {}\n  function P() {}\n  A.NaN = NaN, A.isNaN = function (t) {\n    return Number.isNaN(t);\n  }, A.isInfinite = function (t) {\n    return !Number.isFinite(t);\n  }, A.MAX_VALUE = Number.MAX_VALUE, A.POSITIVE_INFINITY = Number.POSITIVE_INFINITY, A.NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY, \"function\" == typeof Float64Array && \"function\" == typeof Int32Array ? (R = 2146435072, w = new Float64Array(1), O = new Int32Array(w.buffer), A.doubleToLongBits = function (t) {\n    w[0] = t;\n    var e = 0 | O[0],\n      n = 0 | O[1];\n    return (n & R) === R && 1048575 & n && 0 !== e && (e = 0, n = 2146959360), new M(n, e);\n  }, A.longBitsToDouble = function (t) {\n    return O[0] = t.low, O[1] = t.high, w[0];\n  }) : (N = 1023, T = Math.log2, S = Math.floor, L = Math.pow, C = function () {\n    for (var t = 53; t > 0; t--) {\n      var e = L(2, t) - 1;\n      if (S(T(e)) + 1 === t) return e;\n    }\n    return 0;\n  }(), A.doubleToLongBits = function (t) {\n    var e, n, i, r, s, a, o, u, l;\n    if (t < 0 || 1 / t === Number.NEGATIVE_INFINITY ? (a = 1 << 31, t = -t) : a = 0, 0 === t) return new M(u = a, l = 0);\n    if (t === 1 / 0) return new M(u = 2146435072 | a, l = 0);\n    if (t != t) return new M(u = 2146959360, l = 0);\n    if (r = 0, l = 0, (e = S(t)) > 1) if (e <= C) (r = S(T(e))) <= 20 ? (l = 0, u = e << 20 - r & 1048575) : (l = e % (n = L(2, i = r - 20)) << 32 - i, u = e / n & 1048575);else for (i = e, l = 0; 0 !== (i = S(n = i / 2));) r++, l >>>= 1, l |= (1 & u) << 31, u >>>= 1, n !== i && (u |= 524288);\n    if (o = r + N, s = 0 === e, e = t - e, r < 52 && 0 !== e) for (i = 0;;) {\n      if ((n = 2 * e) >= 1 ? (e = n - 1, s ? (o--, s = !1) : (i <<= 1, i |= 1, r++)) : (e = n, s ? 0 == --o && (r++, s = !1) : (i <<= 1, r++)), 20 === r) u |= i, i = 0;else if (52 === r) {\n        l |= i;\n        break;\n      }\n      if (1 === n) {\n        r < 20 ? u |= i << 20 - r : r < 52 && (l |= i << 52 - r);\n        break;\n      }\n    }\n    return u |= o << 20, new M(u |= a, l);\n  }, A.longBitsToDouble = function (t) {\n    var e,\n      n,\n      i,\n      r,\n      s = t.high,\n      a = t.low,\n      o = s & 1 << 31 ? -1 : 1;\n    for (i = ((2146435072 & s) >> 20) - N, r = 0, n = 1 << 19, e = 1; e <= 20; e++) s & n && (r += L(2, -e)), n >>>= 1;\n    for (n = 1 << 31, e = 21; e <= 52; e++) a & n && (r += L(2, -e)), n >>>= 1;\n    if (-1023 === i) {\n      if (0 === r) return 0 * o;\n      i = -1022;\n    } else {\n      if (1024 === i) return 0 === r ? o / 0 : NaN;\n      r += 1;\n    }\n    return o * r * L(2, i);\n  });\n  var D = function (t) {\n      function i(t) {\n        var r;\n        return n(this, i), (r = e(this, i, [t])).name = Object.keys({\n          RuntimeException: i\n        })[0], r;\n      }\n      return l(i, t), s(i);\n    }(p),\n    F = function (t) {\n      function i() {\n        var t;\n        return n(this, i), t = e(this, i), i.constructor_.apply(t, arguments), t;\n      }\n      return l(i, t), s(i, null, [{\n        key: \"constructor_\",\n        value: function () {\n          if (0 === arguments.length) D.constructor_.call(this);else if (1 === arguments.length) {\n            var t = arguments[0];\n            D.constructor_.call(this, t);\n          }\n        }\n      }]);\n    }(D),\n    G = function () {\n      function t() {\n        n(this, t);\n      }\n      return s(t, null, [{\n        key: \"shouldNeverReachHere\",\n        value: function () {\n          if (0 === arguments.length) t.shouldNeverReachHere(null);else if (1 === arguments.length) {\n            var e = arguments[0];\n            throw new F(\"Should never reach here\" + (null !== e ? \": \" + e : \"\"));\n          }\n        }\n      }, {\n        key: \"isTrue\",\n        value: function () {\n          if (1 === arguments.length) {\n            var e = arguments[0];\n            t.isTrue(e, null);\n          } else if (2 === arguments.length) {\n            var n = arguments[1];\n            if (!arguments[0]) throw null === n ? new F() : new F(n);\n          }\n        }\n      }, {\n        key: \"equals\",\n        value: function () {\n          if (2 === arguments.length) {\n            var e = arguments[0],\n              n = arguments[1];\n            t.equals(e, n, null);\n          } else if (3 === arguments.length) {\n            var i = arguments[0],\n              r = arguments[1],\n              s = arguments[2];\n            if (!r.equals(i)) throw new F(\"Expected \" + i + \" but encountered \" + r + (null !== s ? \": \" + s : \"\"));\n          }\n        }\n      }]);\n    }(),\n    q = new ArrayBuffer(8),\n    Y = new Float64Array(q),\n    z = new Int32Array(q),\n    X = function () {\n      function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }\n      return s(t, [{\n        key: \"getM\",\n        value: function () {\n          return A.NaN;\n        }\n      }, {\n        key: \"setOrdinate\",\n        value: function (e, n) {\n          switch (e) {\n            case t.X:\n              this.x = n;\n              break;\n            case t.Y:\n              this.y = n;\n              break;\n            case t.Z:\n              this.setZ(n);\n              break;\n            default:\n              throw new m(\"Invalid ordinate index: \" + e);\n          }\n        }\n      }, {\n        key: \"equals2D\",\n        value: function () {\n          if (1 === arguments.length) {\n            var t = arguments[0];\n            return this.x === t.x && this.y === t.y;\n          }\n          if (2 === arguments.length) {\n            var e = arguments[0],\n              n = arguments[1];\n            return !!b.equalsWithTolerance(this.x, e.x, n) && !!b.equalsWithTolerance(this.y, e.y, n);\n          }\n        }\n      }, {\n        key: \"setM\",\n        value: function (e) {\n          throw new m(\"Invalid ordinate index: \" + t.M);\n        }\n      }, {\n        key: \"getZ\",\n        value: function () {\n          return this.z;\n        }\n      }, {\n        key: \"getOrdinate\",\n        value: function (e) {\n          switch (e) {\n            case t.X:\n              return this.x;\n            case t.Y:\n              return this.y;\n            case t.Z:\n              return this.getZ();\n          }\n          throw new m(\"Invalid ordinate index: \" + e);\n        }\n      }, {\n        key: \"equals3D\",\n        value: function (t) {\n          return this.x === t.x && this.y === t.y && (this.getZ() === t.getZ() || A.isNaN(this.getZ()) && A.isNaN(t.getZ()));\n        }\n      }, {\n        key: \"equals\",\n        value: function (e) {\n          return e instanceof t && this.equals2D(e);\n        }\n      }, {\n        key: \"equalInZ\",\n        value: function (t, e) {\n          return b.equalsWithTolerance(this.getZ(), t.getZ(), e);\n        }\n      }, {\n        key: \"setX\",\n        value: function (t) {\n          this.x = t;\n        }\n      }, {\n        key: \"compareTo\",\n        value: function (t) {\n          var e = t;\n          return this.x < e.x ? -1 : this.x > e.x ? 1 : this.y < e.y ? -1 : this.y > e.y ? 1 : 0;\n        }\n      }, {\n        key: \"getX\",\n        value: function () {\n          return this.x;\n        }\n      }, {\n        key: \"setZ\",\n        value: function (t) {\n          this.z = t;\n        }\n      }, {\n        key: \"clone\",\n        value: function () {\n          try {\n            return null;\n          } catch (t) {\n            if (t instanceof CloneNotSupportedException) return G.shouldNeverReachHere(\"this shouldn't happen because this class is Cloneable\"), null;\n            throw t;\n          }\n        }\n      }, {\n        key: \"copy\",\n        value: function () {\n          return new t(this);\n        }\n      }, {\n        key: \"toString\",\n        value: function () {\n          return \"(\" + this.x + \", \" + this.y + \", \" + this.getZ() + \")\";\n        }\n      }, {\n        key: \"distance3D\",\n        value: function (t) {\n          var e = this.x - t.x,\n            n = this.y - t.y,\n            i = this.getZ() - t.getZ();\n          return Math.sqrt(e * e + n * n + i * i);\n        }\n      }, {\n        key: \"getY\",\n        value: function () {\n          return this.y;\n        }\n      }, {\n        key: \"setY\",\n        value: function (t) {\n          this.y = t;\n        }\n      }, {\n        key: \"distance\",\n        value: function (t) {\n          var e = this.x - t.x,\n            n = this.y - t.y;\n          return Math.sqrt(e * e + n * n);\n        }\n      }, {\n        key: \"hashCode\",\n        value: function () {\n          var e = 17;\n          return e = 37 * (e = 37 * e + t.hashCode(this.x)) + t.hashCode(this.y);\n        }\n      }, {\n        key: \"setCoordinate\",\n        value: function (t) {\n          this.x = t.x, this.y = t.y, this.z = t.getZ();\n        }\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [x, I, E];\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          if (this.x = null, this.y = null, this.z = null, 0 === arguments.length) t.constructor_.call(this, 0, 0);else if (1 === arguments.length) {\n            var e = arguments[0];\n            t.constructor_.call(this, e.x, e.y, e.getZ());\n          } else if (2 === arguments.length) {\n            var n = arguments[0],\n              i = arguments[1];\n            t.constructor_.call(this, n, i, t.NULL_ORDINATE);\n          } else if (3 === arguments.length) {\n            var r = arguments[0],\n              s = arguments[1],\n              a = arguments[2];\n            this.x = r, this.y = s, this.z = a;\n          }\n        }\n      }, {\n        key: \"hashCode\",\n        value: function (t) {\n          return Y[0] = t, z[0] ^ z[1];\n        }\n      }]);\n    }(),\n    B = function () {\n      function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }\n      return s(t, [{\n        key: \"compare\",\n        value: function (e, n) {\n          var i = t.compare(e.x, n.x);\n          if (0 !== i) return i;\n          var r = t.compare(e.y, n.y);\n          return 0 !== r ? r : this._dimensionsToTest <= 2 ? 0 : t.compare(e.getZ(), n.getZ());\n        }\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [P];\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          if (this._dimensionsToTest = 2, 0 === arguments.length) t.constructor_.call(this, 2);else if (1 === arguments.length) {\n            var e = arguments[0];\n            if (2 !== e && 3 !== e) throw new m(\"only 2 or 3 dimensions may be specified\");\n            this._dimensionsToTest = e;\n          }\n        }\n      }, {\n        key: \"compare\",\n        value: function (t, e) {\n          return t < e ? -1 : t > e ? 1 : A.isNaN(t) ? A.isNaN(e) ? 0 : -1 : A.isNaN(e) ? 1 : 0;\n        }\n      }]);\n    }();\n  X.DimensionalComparator = B, X.NULL_ORDINATE = A.NaN, X.X = 0, X.Y = 1, X.Z = 2, X.M = 3;\n  var U = function () {\n      function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }\n      return s(t, [{\n        key: \"getArea\",\n        value: function () {\n          return this.getWidth() * this.getHeight();\n        }\n      }, {\n        key: \"equals\",\n        value: function (e) {\n          if (!(e instanceof t)) return !1;\n          var n = e;\n          return this.isNull() ? n.isNull() : this._maxx === n.getMaxX() && this._maxy === n.getMaxY() && this._minx === n.getMinX() && this._miny === n.getMinY();\n        }\n      }, {\n        key: \"intersection\",\n        value: function (e) {\n          if (this.isNull() || e.isNull() || !this.intersects(e)) return new t();\n          var n = this._minx > e._minx ? this._minx : e._minx,\n            i = this._miny > e._miny ? this._miny : e._miny;\n          return new t(n, this._maxx < e._maxx ? this._maxx : e._maxx, i, this._maxy < e._maxy ? this._maxy : e._maxy);\n        }\n      }, {\n        key: \"isNull\",\n        value: function () {\n          return this._maxx < this._minx;\n        }\n      }, {\n        key: \"getMaxX\",\n        value: function () {\n          return this._maxx;\n        }\n      }, {\n        key: \"covers\",\n        value: function () {\n          if (1 === arguments.length) {\n            if (arguments[0] instanceof X) {\n              var e = arguments[0];\n              return this.covers(e.x, e.y);\n            }\n            if (arguments[0] instanceof t) {\n              var n = arguments[0];\n              return !this.isNull() && !n.isNull() && n.getMinX() >= this._minx && n.getMaxX() <= this._maxx && n.getMinY() >= this._miny && n.getMaxY() <= this._maxy;\n            }\n          } else if (2 === arguments.length) {\n            var i = arguments[0],\n              r = arguments[1];\n            return !this.isNull() && i >= this._minx && i <= this._maxx && r >= this._miny && r <= this._maxy;\n          }\n        }\n      }, {\n        key: \"intersects\",\n        value: function () {\n          if (1 === arguments.length) {\n            if (arguments[0] instanceof t) {\n              var e = arguments[0];\n              return !this.isNull() && !e.isNull() && !(e._minx > this._maxx || e._maxx < this._minx || e._miny > this._maxy || e._maxy < this._miny);\n            }\n            if (arguments[0] instanceof X) {\n              var n = arguments[0];\n              return this.intersects(n.x, n.y);\n            }\n          } else if (2 === arguments.length) {\n            if (arguments[0] instanceof X && arguments[1] instanceof X) {\n              var i = arguments[0],\n                r = arguments[1];\n              return !this.isNull() && !((i.x < r.x ? i.x : r.x) > this._maxx) && !((i.x > r.x ? i.x : r.x) < this._minx) && !((i.y < r.y ? i.y : r.y) > this._maxy) && !((i.y > r.y ? i.y : r.y) < this._miny);\n            }\n            if (\"number\" == typeof arguments[0] && \"number\" == typeof arguments[1]) {\n              var s = arguments[0],\n                a = arguments[1];\n              return !this.isNull() && !(s > this._maxx || s < this._minx || a > this._maxy || a < this._miny);\n            }\n          }\n        }\n      }, {\n        key: \"getMinY\",\n        value: function () {\n          return this._miny;\n        }\n      }, {\n        key: \"getDiameter\",\n        value: function () {\n          if (this.isNull()) return 0;\n          var t = this.getWidth(),\n            e = this.getHeight();\n          return Math.sqrt(t * t + e * e);\n        }\n      }, {\n        key: \"getMinX\",\n        value: function () {\n          return this._minx;\n        }\n      }, {\n        key: \"expandToInclude\",\n        value: function () {\n          if (1 === arguments.length) {\n            if (arguments[0] instanceof X) {\n              var e = arguments[0];\n              this.expandToInclude(e.x, e.y);\n            } else if (arguments[0] instanceof t) {\n              var n = arguments[0];\n              if (n.isNull()) return null;\n              this.isNull() ? (this._minx = n.getMinX(), this._maxx = n.getMaxX(), this._miny = n.getMinY(), this._maxy = n.getMaxY()) : (n._minx < this._minx && (this._minx = n._minx), n._maxx > this._maxx && (this._maxx = n._maxx), n._miny < this._miny && (this._miny = n._miny), n._maxy > this._maxy && (this._maxy = n._maxy));\n            }\n          } else if (2 === arguments.length) {\n            var i = arguments[0],\n              r = arguments[1];\n            this.isNull() ? (this._minx = i, this._maxx = i, this._miny = r, this._maxy = r) : (i < this._minx && (this._minx = i), i > this._maxx && (this._maxx = i), r < this._miny && (this._miny = r), r > this._maxy && (this._maxy = r));\n          }\n        }\n      }, {\n        key: \"minExtent\",\n        value: function () {\n          if (this.isNull()) return 0;\n          var t = this.getWidth(),\n            e = this.getHeight();\n          return t < e ? t : e;\n        }\n      }, {\n        key: \"getWidth\",\n        value: function () {\n          return this.isNull() ? 0 : this._maxx - this._minx;\n        }\n      }, {\n        key: \"compareTo\",\n        value: function (t) {\n          var e = t;\n          return this.isNull() ? e.isNull() ? 0 : -1 : e.isNull() ? 1 : this._minx < e._minx ? -1 : this._minx > e._minx ? 1 : this._miny < e._miny ? -1 : this._miny > e._miny ? 1 : this._maxx < e._maxx ? -1 : this._maxx > e._maxx ? 1 : this._maxy < e._maxy ? -1 : this._maxy > e._maxy ? 1 : 0;\n        }\n      }, {\n        key: \"translate\",\n        value: function (t, e) {\n          if (this.isNull()) return null;\n          this.init(this.getMinX() + t, this.getMaxX() + t, this.getMinY() + e, this.getMaxY() + e);\n        }\n      }, {\n        key: \"copy\",\n        value: function () {\n          return new t(this);\n        }\n      }, {\n        key: \"toString\",\n        value: function () {\n          return \"Env[\" + this._minx + \" : \" + this._maxx + \", \" + this._miny + \" : \" + this._maxy + \"]\";\n        }\n      }, {\n        key: \"setToNull\",\n        value: function () {\n          this._minx = 0, this._maxx = -1, this._miny = 0, this._maxy = -1;\n        }\n      }, {\n        key: \"disjoint\",\n        value: function (t) {\n          return !(!this.isNull() && !t.isNull()) || t._minx > this._maxx || t._maxx < this._minx || t._miny > this._maxy || t._maxy < this._miny;\n        }\n      }, {\n        key: \"getHeight\",\n        value: function () {\n          return this.isNull() ? 0 : this._maxy - this._miny;\n        }\n      }, {\n        key: \"maxExtent\",\n        value: function () {\n          if (this.isNull()) return 0;\n          var t = this.getWidth(),\n            e = this.getHeight();\n          return t > e ? t : e;\n        }\n      }, {\n        key: \"expandBy\",\n        value: function () {\n          if (1 === arguments.length) {\n            var t = arguments[0];\n            this.expandBy(t, t);\n          } else if (2 === arguments.length) {\n            var e = arguments[0],\n              n = arguments[1];\n            if (this.isNull()) return null;\n            this._minx -= e, this._maxx += e, this._miny -= n, this._maxy += n, (this._minx > this._maxx || this._miny > this._maxy) && this.setToNull();\n          }\n        }\n      }, {\n        key: \"contains\",\n        value: function () {\n          if (1 === arguments.length) {\n            if (arguments[0] instanceof t) {\n              var e = arguments[0];\n              return this.covers(e);\n            }\n            if (arguments[0] instanceof X) {\n              var n = arguments[0];\n              return this.covers(n);\n            }\n          } else if (2 === arguments.length) {\n            var i = arguments[0],\n              r = arguments[1];\n            return this.covers(i, r);\n          }\n        }\n      }, {\n        key: \"centre\",\n        value: function () {\n          return this.isNull() ? null : new X((this.getMinX() + this.getMaxX()) / 2, (this.getMinY() + this.getMaxY()) / 2);\n        }\n      }, {\n        key: \"init\",\n        value: function () {\n          if (0 === arguments.length) this.setToNull();else if (1 === arguments.length) {\n            if (arguments[0] instanceof X) {\n              var e = arguments[0];\n              this.init(e.x, e.x, e.y, e.y);\n            } else if (arguments[0] instanceof t) {\n              var n = arguments[0];\n              this._minx = n._minx, this._maxx = n._maxx, this._miny = n._miny, this._maxy = n._maxy;\n            }\n          } else if (2 === arguments.length) {\n            var i = arguments[0],\n              r = arguments[1];\n            this.init(i.x, r.x, i.y, r.y);\n          } else if (4 === arguments.length) {\n            var s = arguments[0],\n              a = arguments[1],\n              o = arguments[2],\n              u = arguments[3];\n            s < a ? (this._minx = s, this._maxx = a) : (this._minx = a, this._maxx = s), o < u ? (this._miny = o, this._maxy = u) : (this._miny = u, this._maxy = o);\n          }\n        }\n      }, {\n        key: \"getMaxY\",\n        value: function () {\n          return this._maxy;\n        }\n      }, {\n        key: \"distance\",\n        value: function (t) {\n          if (this.intersects(t)) return 0;\n          var e = 0;\n          this._maxx < t._minx ? e = t._minx - this._maxx : this._minx > t._maxx && (e = this._minx - t._maxx);\n          var n = 0;\n          return this._maxy < t._miny ? n = t._miny - this._maxy : this._miny > t._maxy && (n = this._miny - t._maxy), 0 === e ? n : 0 === n ? e : Math.sqrt(e * e + n * n);\n        }\n      }, {\n        key: \"hashCode\",\n        value: function () {\n          var t = 17;\n          return t = 37 * (t = 37 * (t = 37 * (t = 37 * t + X.hashCode(this._minx)) + X.hashCode(this._maxx)) + X.hashCode(this._miny)) + X.hashCode(this._maxy);\n        }\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [x, E];\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          if (this._minx = null, this._maxx = null, this._miny = null, this._maxy = null, 0 === arguments.length) this.init();else if (1 === arguments.length) {\n            if (arguments[0] instanceof X) {\n              var e = arguments[0];\n              this.init(e.x, e.x, e.y, e.y);\n            } else if (arguments[0] instanceof t) {\n              var n = arguments[0];\n              this.init(n);\n            }\n          } else if (2 === arguments.length) {\n            var i = arguments[0],\n              r = arguments[1];\n            this.init(i.x, r.x, i.y, r.y);\n          } else if (4 === arguments.length) {\n            var s = arguments[0],\n              a = arguments[1],\n              o = arguments[2],\n              u = arguments[3];\n            this.init(s, a, o, u);\n          }\n        }\n      }, {\n        key: \"intersects\",\n        value: function () {\n          if (3 === arguments.length) {\n            var t = arguments[0],\n              e = arguments[1],\n              n = arguments[2];\n            return n.x >= (t.x < e.x ? t.x : e.x) && n.x <= (t.x > e.x ? t.x : e.x) && n.y >= (t.y < e.y ? t.y : e.y) && n.y <= (t.y > e.y ? t.y : e.y);\n          }\n          if (4 === arguments.length) {\n            var i = arguments[0],\n              r = arguments[1],\n              s = arguments[2],\n              a = arguments[3],\n              o = Math.min(s.x, a.x),\n              u = Math.max(s.x, a.x),\n              l = Math.min(i.x, r.x),\n              h = Math.max(i.x, r.x);\n            return !(l > u) && !(h < o) && (o = Math.min(s.y, a.y), u = Math.max(s.y, a.y), l = Math.min(i.y, r.y), h = Math.max(i.y, r.y), !(l > u) && !(h < o));\n          }\n        }\n      }]);\n    }(),\n    V = function () {\n      function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }\n      return s(t, [{\n        key: \"isGeometryCollection\",\n        value: function () {\n          return this.getTypeCode() === t.TYPECODE_GEOMETRYCOLLECTION;\n        }\n      }, {\n        key: \"getFactory\",\n        value: function () {\n          return this._factory;\n        }\n      }, {\n        key: \"getGeometryN\",\n        value: function (t) {\n          return this;\n        }\n      }, {\n        key: \"getArea\",\n        value: function () {\n          return 0;\n        }\n      }, {\n        key: \"isRectangle\",\n        value: function () {\n          return !1;\n        }\n      }, {\n        key: \"equalsExact\",\n        value: function (t) {\n          return this === t || this.equalsExact(t, 0);\n        }\n      }, {\n        key: \"geometryChanged\",\n        value: function () {\n          this.apply(t.geometryChangedFilter);\n        }\n      }, {\n        key: \"geometryChangedAction\",\n        value: function () {\n          this._envelope = null;\n        }\n      }, {\n        key: \"equalsNorm\",\n        value: function (t) {\n          return null !== t && this.norm().equalsExact(t.norm());\n        }\n      }, {\n        key: \"getLength\",\n        value: function () {\n          return 0;\n        }\n      }, {\n        key: \"getNumGeometries\",\n        value: function () {\n          return 1;\n        }\n      }, {\n        key: \"compareTo\",\n        value: function () {\n          var t;\n          if (1 === arguments.length) {\n            var e = arguments[0];\n            return t = e, this.getTypeCode() !== t.getTypeCode() ? this.getTypeCode() - t.getTypeCode() : this.isEmpty() && t.isEmpty() ? 0 : this.isEmpty() ? -1 : t.isEmpty() ? 1 : this.compareToSameClass(e);\n          }\n          if (2 === arguments.length) {\n            var n = arguments[0],\n              i = arguments[1];\n            return t = n, this.getTypeCode() !== t.getTypeCode() ? this.getTypeCode() - t.getTypeCode() : this.isEmpty() && t.isEmpty() ? 0 : this.isEmpty() ? -1 : t.isEmpty() ? 1 : this.compareToSameClass(n, i);\n          }\n        }\n      }, {\n        key: \"getUserData\",\n        value: function () {\n          return this._userData;\n        }\n      }, {\n        key: \"getSRID\",\n        value: function () {\n          return this._SRID;\n        }\n      }, {\n        key: \"getEnvelope\",\n        value: function () {\n          return this.getFactory().toGeometry(this.getEnvelopeInternal());\n        }\n      }, {\n        key: \"checkNotGeometryCollection\",\n        value: function (e) {\n          if (e.getTypeCode() === t.TYPECODE_GEOMETRYCOLLECTION) throw new m(\"This method does not support GeometryCollection arguments\");\n        }\n      }, {\n        key: \"equal\",\n        value: function (t, e, n) {\n          return 0 === n ? t.equals(e) : t.distance(e) <= n;\n        }\n      }, {\n        key: \"norm\",\n        value: function () {\n          var t = this.copy();\n          return t.normalize(), t;\n        }\n      }, {\n        key: \"reverse\",\n        value: function () {\n          var t = this.reverseInternal();\n          return null != this.envelope && (t.envelope = this.envelope.copy()), t.setSRID(this.getSRID()), t;\n        }\n      }, {\n        key: \"copy\",\n        value: function () {\n          var t = this.copyInternal();\n          return t.envelope = null == this._envelope ? null : this._envelope.copy(), t._SRID = this._SRID, t._userData = this._userData, t;\n        }\n      }, {\n        key: \"getPrecisionModel\",\n        value: function () {\n          return this._factory.getPrecisionModel();\n        }\n      }, {\n        key: \"getEnvelopeInternal\",\n        value: function () {\n          return null === this._envelope && (this._envelope = this.computeEnvelopeInternal()), new U(this._envelope);\n        }\n      }, {\n        key: \"setSRID\",\n        value: function (t) {\n          this._SRID = t;\n        }\n      }, {\n        key: \"setUserData\",\n        value: function (t) {\n          this._userData = t;\n        }\n      }, {\n        key: \"compare\",\n        value: function (t, e) {\n          for (var n = t.iterator(), i = e.iterator(); n.hasNext() && i.hasNext();) {\n            var r = n.next(),\n              s = i.next(),\n              a = r.compareTo(s);\n            if (0 !== a) return a;\n          }\n          return n.hasNext() ? 1 : i.hasNext() ? -1 : 0;\n        }\n      }, {\n        key: \"hashCode\",\n        value: function () {\n          return this.getEnvelopeInternal().hashCode();\n        }\n      }, {\n        key: \"isEquivalentClass\",\n        value: function (t) {\n          return this.getClass() === t.getClass();\n        }\n      }, {\n        key: \"isGeometryCollectionOrDerived\",\n        value: function () {\n          return this.getTypeCode() === t.TYPECODE_GEOMETRYCOLLECTION || this.getTypeCode() === t.TYPECODE_MULTIPOINT || this.getTypeCode() === t.TYPECODE_MULTILINESTRING || this.getTypeCode() === t.TYPECODE_MULTIPOLYGON;\n        }\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [I, x, E];\n        }\n      }, {\n        key: \"getClass\",\n        value: function () {\n          return t;\n        }\n      }], [{\n        key: \"hasNonEmptyElements\",\n        value: function (t) {\n          for (var e = 0; e < t.length; e++) if (!t[e].isEmpty()) return !0;\n          return !1;\n        }\n      }, {\n        key: \"hasNullElements\",\n        value: function (t) {\n          for (var e = 0; e < t.length; e++) if (null === t[e]) return !0;\n          return !1;\n        }\n      }]);\n    }();\n  V.constructor_ = function (t) {\n    t && (this._envelope = null, this._userData = null, this._factory = t, this._SRID = t.getSRID());\n  }, V.TYPECODE_POINT = 0, V.TYPECODE_MULTIPOINT = 1, V.TYPECODE_LINESTRING = 2, V.TYPECODE_LINEARRING = 3, V.TYPECODE_MULTILINESTRING = 4, V.TYPECODE_POLYGON = 5, V.TYPECODE_MULTIPOLYGON = 6, V.TYPECODE_GEOMETRYCOLLECTION = 7, V.TYPENAME_POINT = \"Point\", V.TYPENAME_MULTIPOINT = \"MultiPoint\", V.TYPENAME_LINESTRING = \"LineString\", V.TYPENAME_LINEARRING = \"LinearRing\", V.TYPENAME_MULTILINESTRING = \"MultiLineString\", V.TYPENAME_POLYGON = \"Polygon\", V.TYPENAME_MULTIPOLYGON = \"MultiPolygon\", V.TYPENAME_GEOMETRYCOLLECTION = \"GeometryCollection\", V.geometryChangedFilter = {\n    get interfaces_() {\n      return [k];\n    },\n    filter: function (t) {\n      t.geometryChangedAction();\n    }\n  };\n  var H = function () {\n    function t() {\n      n(this, t);\n    }\n    return s(t, null, [{\n      key: \"toLocationSymbol\",\n      value: function (e) {\n        switch (e) {\n          case t.EXTERIOR:\n            return \"e\";\n          case t.BOUNDARY:\n            return \"b\";\n          case t.INTERIOR:\n            return \"i\";\n          case t.NONE:\n            return \"-\";\n        }\n        throw new m(\"Unknown location value: \" + e);\n      }\n    }]);\n  }();\n  H.INTERIOR = 0, H.BOUNDARY = 1, H.EXTERIOR = 2, H.NONE = -1;\n  var Z = function () {\n      return s(function t() {\n        n(this, t);\n      }, [{\n        key: \"add\",\n        value: function () {}\n      }, {\n        key: \"addAll\",\n        value: function () {}\n      }, {\n        key: \"isEmpty\",\n        value: function () {}\n      }, {\n        key: \"iterator\",\n        value: function () {}\n      }, {\n        key: \"size\",\n        value: function () {}\n      }, {\n        key: \"toArray\",\n        value: function () {}\n      }, {\n        key: \"remove\",\n        value: function () {}\n      }]);\n    }(),\n    j = function (t) {\n      function i(t) {\n        var r;\n        return n(this, i), (r = e(this, i, [t])).name = Object.keys({\n          NoSuchElementException: i\n        })[0], r;\n      }\n      return l(i, t), s(i);\n    }(p),\n    W = function (t) {\n      function i(t) {\n        var r;\n        return n(this, i), (r = e(this, i, [t])).name = Object.keys({\n          UnsupportedOperationException: i\n        })[0], r;\n      }\n      return l(i, t), s(i);\n    }(p),\n    K = function (t) {\n      function i() {\n        return n(this, i), e(this, i, arguments);\n      }\n      return l(i, t), s(i, [{\n        key: \"contains\",\n        value: function () {}\n      }]);\n    }(Z),\n    J = function (t) {\n      function i(t) {\n        var r;\n        return n(this, i), (r = e(this, i)).map = new Map(), t instanceof Z && r.addAll(t), r;\n      }\n      return l(i, t), s(i, [{\n        key: \"contains\",\n        value: function (t) {\n          var e = t.hashCode ? t.hashCode() : t;\n          return !!this.map.has(e);\n        }\n      }, {\n        key: \"add\",\n        value: function (t) {\n          var e = t.hashCode ? t.hashCode() : t;\n          return !this.map.has(e) && !!this.map.set(e, t);\n        }\n      }, {\n        key: \"addAll\",\n        value: function (t) {\n          var e,\n            n = a(t);\n          try {\n            for (n.s(); !(e = n.n()).done;) {\n              var i = e.value;\n              this.add(i);\n            }\n          } catch (t) {\n            n.e(t);\n          } finally {\n            n.f();\n          }\n          return !0;\n        }\n      }, {\n        key: \"remove\",\n        value: function () {\n          throw new W();\n        }\n      }, {\n        key: \"size\",\n        value: function () {\n          return this.map.size;\n        }\n      }, {\n        key: \"isEmpty\",\n        value: function () {\n          return 0 === this.map.size;\n        }\n      }, {\n        key: \"toArray\",\n        value: function () {\n          return Array.from(this.map.values());\n        }\n      }, {\n        key: \"iterator\",\n        value: function () {\n          return new Q(this.map);\n        }\n      }, {\n        key: Symbol.iterator,\n        value: function () {\n          return this.map;\n        }\n      }]);\n    }(K),\n    Q = function () {\n      return s(function t(e) {\n        n(this, t), this.iterator = e.values();\n        var i = this.iterator.next(),\n          r = i.done,\n          s = i.value;\n        this.done = r, this.value = s;\n      }, [{\n        key: \"next\",\n        value: function () {\n          if (this.done) throw new j();\n          var t = this.value,\n            e = this.iterator.next(),\n            n = e.done,\n            i = e.value;\n          return this.done = n, this.value = i, t;\n        }\n      }, {\n        key: \"hasNext\",\n        value: function () {\n          return !this.done;\n        }\n      }, {\n        key: \"remove\",\n        value: function () {\n          throw new W();\n        }\n      }]);\n    }(),\n    $ = function () {\n      function t() {\n        n(this, t);\n      }\n      return s(t, null, [{\n        key: \"opposite\",\n        value: function (e) {\n          return e === t.LEFT ? t.RIGHT : e === t.RIGHT ? t.LEFT : e;\n        }\n      }]);\n    }();\n  $.ON = 0, $.LEFT = 1, $.RIGHT = 2;\n  var tt = function (t) {\n      function i(t) {\n        var r;\n        return n(this, i), (r = e(this, i, [t])).name = Object.keys({\n          EmptyStackException: i\n        })[0], r;\n      }\n      return l(i, t), s(i);\n    }(p),\n    et = function (t) {\n      function i(t) {\n        var r;\n        return n(this, i), (r = e(this, i, [t])).name = Object.keys({\n          IndexOutOfBoundsException: i\n        })[0], r;\n      }\n      return l(i, t), s(i);\n    }(p),\n    nt = function (t) {\n      function i() {\n        return n(this, i), e(this, i, arguments);\n      }\n      return l(i, t), s(i, [{\n        key: \"get\",\n        value: function () {}\n      }, {\n        key: \"set\",\n        value: function () {}\n      }, {\n        key: \"isEmpty\",\n        value: function () {}\n      }]);\n    }(Z),\n    it = function (t) {\n      function i() {\n        var t;\n        return n(this, i), (t = e(this, i)).array = [], t;\n      }\n      return l(i, t), s(i, [{\n        key: \"add\",\n        value: function (t) {\n          return this.array.push(t), !0;\n        }\n      }, {\n        key: \"get\",\n        value: function (t) {\n          if (t < 0 || t >= this.size()) throw new et();\n          return this.array[t];\n        }\n      }, {\n        key: \"push\",\n        value: function (t) {\n          return this.array.push(t), t;\n        }\n      }, {\n        key: \"pop\",\n        value: function () {\n          if (0 === this.array.length) throw new tt();\n          return this.array.pop();\n        }\n      }, {\n        key: \"peek\",\n        value: function () {\n          if (0 === this.array.length) throw new tt();\n          return this.array[this.array.length - 1];\n        }\n      }, {\n        key: \"empty\",\n        value: function () {\n          return 0 === this.array.length;\n        }\n      }, {\n        key: \"isEmpty\",\n        value: function () {\n          return this.empty();\n        }\n      }, {\n        key: \"search\",\n        value: function (t) {\n          return this.array.indexOf(t);\n        }\n      }, {\n        key: \"size\",\n        value: function () {\n          return this.array.length;\n        }\n      }, {\n        key: \"toArray\",\n        value: function () {\n          return this.array.slice();\n        }\n      }]);\n    }(nt);\n  function rt(t, e) {\n    return t.interfaces_ && t.interfaces_.indexOf(e) > -1;\n  }\n  var st = function () {\n      return s(function t(e) {\n        n(this, t), this.str = e;\n      }, [{\n        key: \"append\",\n        value: function (t) {\n          this.str += t;\n        }\n      }, {\n        key: \"setCharAt\",\n        value: function (t, e) {\n          this.str = this.str.substr(0, t) + e + this.str.substr(t + 1);\n        }\n      }, {\n        key: \"toString\",\n        value: function () {\n          return this.str;\n        }\n      }]);\n    }(),\n    at = function () {\n      function t(e) {\n        n(this, t), this.value = e;\n      }\n      return s(t, [{\n        key: \"intValue\",\n        value: function () {\n          return this.value;\n        }\n      }, {\n        key: \"compareTo\",\n        value: function (t) {\n          return this.value < t ? -1 : this.value > t ? 1 : 0;\n        }\n      }], [{\n        key: \"compare\",\n        value: function (t, e) {\n          return t < e ? -1 : t > e ? 1 : 0;\n        }\n      }, {\n        key: \"isNan\",\n        value: function (t) {\n          return Number.isNaN(t);\n        }\n      }, {\n        key: \"valueOf\",\n        value: function (e) {\n          return new t(e);\n        }\n      }]);\n    }(),\n    ot = function () {\n      return s(function t() {\n        n(this, t);\n      }, null, [{\n        key: \"isWhitespace\",\n        value: function (t) {\n          return t <= 32 && t >= 0 || 127 === t;\n        }\n      }, {\n        key: \"toUpperCase\",\n        value: function (t) {\n          return t.toUpperCase();\n        }\n      }]);\n    }(),\n    ut = function () {\n      function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }\n      return s(t, [{\n        key: \"le\",\n        value: function (t) {\n          return this._hi < t._hi || this._hi === t._hi && this._lo <= t._lo;\n        }\n      }, {\n        key: \"extractSignificantDigits\",\n        value: function (e, n) {\n          var i = this.abs(),\n            r = t.magnitude(i._hi),\n            s = t.TEN.pow(r);\n          (i = i.divide(s)).gt(t.TEN) ? (i = i.divide(t.TEN), r += 1) : i.lt(t.ONE) && (i = i.multiply(t.TEN), r -= 1);\n          for (var a = r + 1, o = new st(), u = t.MAX_PRINT_DIGITS - 1, l = 0; l <= u; l++) {\n            e && l === a && o.append(\".\");\n            var h = Math.trunc(i._hi);\n            if (h < 0) break;\n            var c = !1,\n              f = 0;\n            h > 9 ? (c = !0, f = \"9\") : f = \"0\" + h, o.append(f), i = i.subtract(t.valueOf(h)).multiply(t.TEN), c && i.selfAdd(t.TEN);\n            var g = !0,\n              v = t.magnitude(i._hi);\n            if (v < 0 && Math.abs(v) >= u - l && (g = !1), !g) break;\n          }\n          return n[0] = r, o.toString();\n        }\n      }, {\n        key: \"sqr\",\n        value: function () {\n          return this.multiply(this);\n        }\n      }, {\n        key: \"doubleValue\",\n        value: function () {\n          return this._hi + this._lo;\n        }\n      }, {\n        key: \"subtract\",\n        value: function () {\n          if (arguments[0] instanceof t) {\n            var e = arguments[0];\n            return this.add(e.negate());\n          }\n          if (\"number\" == typeof arguments[0]) {\n            var n = arguments[0];\n            return this.add(-n);\n          }\n        }\n      }, {\n        key: \"equals\",\n        value: function () {\n          if (1 === arguments.length && arguments[0] instanceof t) {\n            var e = arguments[0];\n            return this._hi === e._hi && this._lo === e._lo;\n          }\n        }\n      }, {\n        key: \"isZero\",\n        value: function () {\n          return 0 === this._hi && 0 === this._lo;\n        }\n      }, {\n        key: \"selfSubtract\",\n        value: function () {\n          if (arguments[0] instanceof t) {\n            var e = arguments[0];\n            return this.isNaN() ? this : this.selfAdd(-e._hi, -e._lo);\n          }\n          if (\"number\" == typeof arguments[0]) {\n            var n = arguments[0];\n            return this.isNaN() ? this : this.selfAdd(-n, 0);\n          }\n        }\n      }, {\n        key: \"getSpecialNumberString\",\n        value: function () {\n          return this.isZero() ? \"0.0\" : this.isNaN() ? \"NaN \" : null;\n        }\n      }, {\n        key: \"min\",\n        value: function (t) {\n          return this.le(t) ? this : t;\n        }\n      }, {\n        key: \"selfDivide\",\n        value: function () {\n          if (1 === arguments.length) {\n            if (arguments[0] instanceof t) {\n              var e = arguments[0];\n              return this.selfDivide(e._hi, e._lo);\n            }\n            if (\"number\" == typeof arguments[0]) {\n              var n = arguments[0];\n              return this.selfDivide(n, 0);\n            }\n          } else if (2 === arguments.length) {\n            var i,\n              r,\n              s,\n              a,\n              o = arguments[0],\n              u = arguments[1],\n              l = null,\n              h = null,\n              c = null,\n              f = null;\n            return s = this._hi / o, f = (l = (c = t.SPLIT * s) - (l = c - s)) * (h = (f = t.SPLIT * o) - (h = f - o)) - (a = s * o) + l * (r = o - h) + (i = s - l) * h + i * r, f = s + (c = (this._hi - a - f + this._lo - s * u) / o), this._hi = f, this._lo = s - f + c, this;\n          }\n        }\n      }, {\n        key: \"dump\",\n        value: function () {\n          return \"DD<\" + this._hi + \", \" + this._lo + \">\";\n        }\n      }, {\n        key: \"divide\",\n        value: function () {\n          if (arguments[0] instanceof t) {\n            var e,\n              n,\n              i,\n              r,\n              s = arguments[0],\n              a = null,\n              o = null,\n              u = null,\n              l = null;\n            return e = (i = this._hi / s._hi) - (a = (u = t.SPLIT * i) - (a = u - i)), l = a * (o = (l = t.SPLIT * s._hi) - (o = l - s._hi)) - (r = i * s._hi) + a * (n = s._hi - o) + e * o + e * n, new t(l = i + (u = (this._hi - r - l + this._lo - i * s._lo) / s._hi), i - l + u);\n          }\n          if (\"number\" == typeof arguments[0]) {\n            var h = arguments[0];\n            return A.isNaN(h) ? t.createNaN() : t.copy(this).selfDivide(h, 0);\n          }\n        }\n      }, {\n        key: \"ge\",\n        value: function (t) {\n          return this._hi > t._hi || this._hi === t._hi && this._lo >= t._lo;\n        }\n      }, {\n        key: \"pow\",\n        value: function (e) {\n          if (0 === e) return t.valueOf(1);\n          var n = new t(this),\n            i = t.valueOf(1),\n            r = Math.abs(e);\n          if (r > 1) for (; r > 0;) r % 2 == 1 && i.selfMultiply(n), (r /= 2) > 0 && (n = n.sqr());else i = n;\n          return e < 0 ? i.reciprocal() : i;\n        }\n      }, {\n        key: \"ceil\",\n        value: function () {\n          if (this.isNaN()) return t.NaN;\n          var e = Math.ceil(this._hi),\n            n = 0;\n          return e === this._hi && (n = Math.ceil(this._lo)), new t(e, n);\n        }\n      }, {\n        key: \"compareTo\",\n        value: function (t) {\n          var e = t;\n          return this._hi < e._hi ? -1 : this._hi > e._hi ? 1 : this._lo < e._lo ? -1 : this._lo > e._lo ? 1 : 0;\n        }\n      }, {\n        key: \"rint\",\n        value: function () {\n          return this.isNaN() ? this : this.add(.5).floor();\n        }\n      }, {\n        key: \"setValue\",\n        value: function () {\n          if (arguments[0] instanceof t) {\n            var e = arguments[0];\n            return this.init(e), this;\n          }\n          if (\"number\" == typeof arguments[0]) {\n            var n = arguments[0];\n            return this.init(n), this;\n          }\n        }\n      }, {\n        key: \"max\",\n        value: function (t) {\n          return this.ge(t) ? this : t;\n        }\n      }, {\n        key: \"sqrt\",\n        value: function () {\n          if (this.isZero()) return t.valueOf(0);\n          if (this.isNegative()) return t.NaN;\n          var e = 1 / Math.sqrt(this._hi),\n            n = this._hi * e,\n            i = t.valueOf(n),\n            r = this.subtract(i.sqr())._hi * (.5 * e);\n          return i.add(r);\n        }\n      }, {\n        key: \"selfAdd\",\n        value: function () {\n          if (1 === arguments.length) {\n            if (arguments[0] instanceof t) {\n              var e = arguments[0];\n              return this.selfAdd(e._hi, e._lo);\n            }\n            if (\"number\" == typeof arguments[0]) {\n              var n,\n                i,\n                r,\n                s,\n                a,\n                o = arguments[0],\n                u = null;\n              return u = (r = this._hi + o) - (s = r - this._hi), i = (a = (u = o - s + (this._hi - u)) + this._lo) + (r - (n = r + a)), this._hi = n + i, this._lo = i + (n - this._hi), this;\n            }\n          } else if (2 === arguments.length) {\n            var l,\n              h,\n              c,\n              f,\n              g = arguments[0],\n              v = arguments[1],\n              y = null,\n              d = null,\n              _ = null;\n            c = this._hi + g, h = this._lo + v, d = c - (_ = c - this._hi), y = h - (f = h - this._lo);\n            var p = (l = c + (_ = (d = g - _ + (this._hi - d)) + h)) + (_ = (y = v - f + (this._lo - y)) + (_ + (c - l))),\n              m = _ + (l - p);\n            return this._hi = p, this._lo = m, this;\n          }\n        }\n      }, {\n        key: \"selfMultiply\",\n        value: function () {\n          if (1 === arguments.length) {\n            if (arguments[0] instanceof t) {\n              var e = arguments[0];\n              return this.selfMultiply(e._hi, e._lo);\n            }\n            if (\"number\" == typeof arguments[0]) {\n              var n = arguments[0];\n              return this.selfMultiply(n, 0);\n            }\n          } else if (2 === arguments.length) {\n            var i,\n              r,\n              s = arguments[0],\n              a = arguments[1],\n              o = null,\n              u = null,\n              l = null,\n              h = null;\n            o = (l = t.SPLIT * this._hi) - this._hi, h = t.SPLIT * s, o = l - o, i = this._hi - o, u = h - s;\n            var c = (l = this._hi * s) + (h = o * (u = h - u) - l + o * (r = s - u) + i * u + i * r + (this._hi * a + this._lo * s)),\n              f = h + (o = l - c);\n            return this._hi = c, this._lo = f, this;\n          }\n        }\n      }, {\n        key: \"selfSqr\",\n        value: function () {\n          return this.selfMultiply(this);\n        }\n      }, {\n        key: \"floor\",\n        value: function () {\n          if (this.isNaN()) return t.NaN;\n          var e = Math.floor(this._hi),\n            n = 0;\n          return e === this._hi && (n = Math.floor(this._lo)), new t(e, n);\n        }\n      }, {\n        key: \"negate\",\n        value: function () {\n          return this.isNaN() ? this : new t(-this._hi, -this._lo);\n        }\n      }, {\n        key: \"clone\",\n        value: function () {\n          try {\n            return null;\n          } catch (t) {\n            if (t instanceof CloneNotSupportedException) return null;\n            throw t;\n          }\n        }\n      }, {\n        key: \"multiply\",\n        value: function () {\n          if (arguments[0] instanceof t) {\n            var e = arguments[0];\n            return e.isNaN() ? t.createNaN() : t.copy(this).selfMultiply(e);\n          }\n          if (\"number\" == typeof arguments[0]) {\n            var n = arguments[0];\n            return A.isNaN(n) ? t.createNaN() : t.copy(this).selfMultiply(n, 0);\n          }\n        }\n      }, {\n        key: \"isNaN\",\n        value: function () {\n          return A.isNaN(this._hi);\n        }\n      }, {\n        key: \"intValue\",\n        value: function () {\n          return Math.trunc(this._hi);\n        }\n      }, {\n        key: \"toString\",\n        value: function () {\n          var e = t.magnitude(this._hi);\n          return e >= -3 && e <= 20 ? this.toStandardNotation() : this.toSciNotation();\n        }\n      }, {\n        key: \"toStandardNotation\",\n        value: function () {\n          var e = this.getSpecialNumberString();\n          if (null !== e) return e;\n          var n = new Array(1).fill(null),\n            i = this.extractSignificantDigits(!0, n),\n            r = n[0] + 1,\n            s = i;\n          if (\".\" === i.charAt(0)) s = \"0\" + i;else if (r < 0) s = \"0.\" + t.stringOfChar(\"0\", -r) + i;else if (-1 === i.indexOf(\".\")) {\n            var a = r - i.length;\n            s = i + t.stringOfChar(\"0\", a) + \".0\";\n          }\n          return this.isNegative() ? \"-\" + s : s;\n        }\n      }, {\n        key: \"reciprocal\",\n        value: function () {\n          var e,\n            n,\n            i,\n            r,\n            s = null,\n            a = null,\n            o = null,\n            u = null;\n          e = (i = 1 / this._hi) - (s = (o = t.SPLIT * i) - (s = o - i)), a = (u = t.SPLIT * this._hi) - this._hi;\n          var l = i + (o = (1 - (r = i * this._hi) - (u = s * (a = u - a) - r + s * (n = this._hi - a) + e * a + e * n) - i * this._lo) / this._hi);\n          return new t(l, i - l + o);\n        }\n      }, {\n        key: \"toSciNotation\",\n        value: function () {\n          if (this.isZero()) return t.SCI_NOT_ZERO;\n          var e = this.getSpecialNumberString();\n          if (null !== e) return e;\n          var n = new Array(1).fill(null),\n            i = this.extractSignificantDigits(!1, n),\n            r = t.SCI_NOT_EXPONENT_CHAR + n[0];\n          if (\"0\" === i.charAt(0)) throw new IllegalStateException(\"Found leading zero: \" + i);\n          var s = \"\";\n          i.length > 1 && (s = i.substring(1));\n          var a = i.charAt(0) + \".\" + s;\n          return this.isNegative() ? \"-\" + a + r : a + r;\n        }\n      }, {\n        key: \"abs\",\n        value: function () {\n          return this.isNaN() ? t.NaN : this.isNegative() ? this.negate() : new t(this);\n        }\n      }, {\n        key: \"isPositive\",\n        value: function () {\n          return this._hi > 0 || 0 === this._hi && this._lo > 0;\n        }\n      }, {\n        key: \"lt\",\n        value: function (t) {\n          return this._hi < t._hi || this._hi === t._hi && this._lo < t._lo;\n        }\n      }, {\n        key: \"add\",\n        value: function () {\n          if (arguments[0] instanceof t) {\n            var e = arguments[0];\n            return t.copy(this).selfAdd(e);\n          }\n          if (\"number\" == typeof arguments[0]) {\n            var n = arguments[0];\n            return t.copy(this).selfAdd(n);\n          }\n        }\n      }, {\n        key: \"init\",\n        value: function () {\n          if (1 === arguments.length) {\n            if (\"number\" == typeof arguments[0]) {\n              var e = arguments[0];\n              this._hi = e, this._lo = 0;\n            } else if (arguments[0] instanceof t) {\n              var n = arguments[0];\n              this._hi = n._hi, this._lo = n._lo;\n            }\n          } else if (2 === arguments.length) {\n            var i = arguments[0],\n              r = arguments[1];\n            this._hi = i, this._lo = r;\n          }\n        }\n      }, {\n        key: \"gt\",\n        value: function (t) {\n          return this._hi > t._hi || this._hi === t._hi && this._lo > t._lo;\n        }\n      }, {\n        key: \"isNegative\",\n        value: function () {\n          return this._hi < 0 || 0 === this._hi && this._lo < 0;\n        }\n      }, {\n        key: \"trunc\",\n        value: function () {\n          return this.isNaN() ? t.NaN : this.isPositive() ? this.floor() : this.ceil();\n        }\n      }, {\n        key: \"signum\",\n        value: function () {\n          return this._hi > 0 ? 1 : this._hi < 0 ? -1 : this._lo > 0 ? 1 : this._lo < 0 ? -1 : 0;\n        }\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [E, x, I];\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          if (this._hi = 0, this._lo = 0, 0 === arguments.length) this.init(0);else if (1 === arguments.length) {\n            if (\"number\" == typeof arguments[0]) {\n              var e = arguments[0];\n              this.init(e);\n            } else if (arguments[0] instanceof t) {\n              var n = arguments[0];\n              this.init(n);\n            } else if (\"string\" == typeof arguments[0]) {\n              var i = arguments[0];\n              t.constructor_.call(this, t.parse(i));\n            }\n          } else if (2 === arguments.length) {\n            var r = arguments[0],\n              s = arguments[1];\n            this.init(r, s);\n          }\n        }\n      }, {\n        key: \"determinant\",\n        value: function () {\n          if (\"number\" == typeof arguments[3] && \"number\" == typeof arguments[2] && \"number\" == typeof arguments[0] && \"number\" == typeof arguments[1]) {\n            var e = arguments[0],\n              n = arguments[1],\n              i = arguments[2],\n              r = arguments[3];\n            return t.determinant(t.valueOf(e), t.valueOf(n), t.valueOf(i), t.valueOf(r));\n          }\n          if (arguments[3] instanceof t && arguments[2] instanceof t && arguments[0] instanceof t && arguments[1] instanceof t) {\n            var s = arguments[1],\n              a = arguments[2],\n              o = arguments[3];\n            return arguments[0].multiply(o).selfSubtract(s.multiply(a));\n          }\n        }\n      }, {\n        key: \"sqr\",\n        value: function (e) {\n          return t.valueOf(e).selfMultiply(e);\n        }\n      }, {\n        key: \"valueOf\",\n        value: function () {\n          if (\"string\" == typeof arguments[0]) {\n            var e = arguments[0];\n            return t.parse(e);\n          }\n          if (\"number\" == typeof arguments[0]) return new t(arguments[0]);\n        }\n      }, {\n        key: \"sqrt\",\n        value: function (e) {\n          return t.valueOf(e).sqrt();\n        }\n      }, {\n        key: \"parse\",\n        value: function (e) {\n          for (var n = 0, i = e.length; ot.isWhitespace(e.charAt(n));) n++;\n          var r = !1;\n          if (n < i) {\n            var s = e.charAt(n);\n            \"-\" !== s && \"+\" !== s || (n++, \"-\" === s && (r = !0));\n          }\n          for (var a = new t(), o = 0, u = 0, l = 0, h = !1; !(n >= i);) {\n            var c = e.charAt(n);\n            if (n++, ot.isDigit(c)) {\n              var f = c - \"0\";\n              a.selfMultiply(t.TEN), a.selfAdd(f), o++;\n            } else {\n              if (\".\" !== c) {\n                if (\"e\" === c || \"E\" === c) {\n                  var g = e.substring(n);\n                  try {\n                    l = at.parseInt(g);\n                  } catch (t) {\n                    throw t instanceof NumberFormatException ? new NumberFormatException(\"Invalid exponent \" + g + \" in string \" + e) : t;\n                  }\n                  break;\n                }\n                throw new NumberFormatException(\"Unexpected character '\" + c + \"' at position \" + n + \" in string \" + e);\n              }\n              u = o, h = !0;\n            }\n          }\n          var v = a;\n          h || (u = o);\n          var y = o - u - l;\n          if (0 === y) v = a;else if (y > 0) {\n            var d = t.TEN.pow(y);\n            v = a.divide(d);\n          } else if (y < 0) {\n            var _ = t.TEN.pow(-y);\n            v = a.multiply(_);\n          }\n          return r ? v.negate() : v;\n        }\n      }, {\n        key: \"createNaN\",\n        value: function () {\n          return new t(A.NaN, A.NaN);\n        }\n      }, {\n        key: \"copy\",\n        value: function (e) {\n          return new t(e);\n        }\n      }, {\n        key: \"magnitude\",\n        value: function (t) {\n          var e = Math.abs(t),\n            n = Math.log(e) / Math.log(10),\n            i = Math.trunc(Math.floor(n));\n          return 10 * Math.pow(10, i) <= e && (i += 1), i;\n        }\n      }, {\n        key: \"stringOfChar\",\n        value: function (t, e) {\n          for (var n = new st(), i = 0; i < e; i++) n.append(t);\n          return n.toString();\n        }\n      }]);\n    }();\n  ut.PI = new ut(3.141592653589793, 12246467991473532e-32), ut.TWO_PI = new ut(6.283185307179586, 24492935982947064e-32), ut.PI_2 = new ut(1.5707963267948966, 6123233995736766e-32), ut.E = new ut(2.718281828459045, 14456468917292502e-32), ut.NaN = new ut(A.NaN, A.NaN), ut.EPS = 123259516440783e-46, ut.SPLIT = 134217729, ut.MAX_PRINT_DIGITS = 32, ut.TEN = ut.valueOf(10), ut.ONE = ut.valueOf(1), ut.SCI_NOT_EXPONENT_CHAR = \"E\", ut.SCI_NOT_ZERO = \"0.0E0\";\n  var lt = function () {\n    function t() {\n      n(this, t);\n    }\n    return s(t, null, [{\n      key: \"orientationIndex\",\n      value: function (e, n, i) {\n        var r = t.orientationIndexFilter(e, n, i);\n        if (r <= 1) return r;\n        var s = ut.valueOf(n.x).selfAdd(-e.x),\n          a = ut.valueOf(n.y).selfAdd(-e.y),\n          o = ut.valueOf(i.x).selfAdd(-n.x),\n          u = ut.valueOf(i.y).selfAdd(-n.y);\n        return s.selfMultiply(u).selfSubtract(a.selfMultiply(o)).signum();\n      }\n    }, {\n      key: \"signOfDet2x2\",\n      value: function () {\n        if (arguments[3] instanceof ut && arguments[2] instanceof ut && arguments[0] instanceof ut && arguments[1] instanceof ut) {\n          var t = arguments[1],\n            e = arguments[2],\n            n = arguments[3];\n          return arguments[0].multiply(n).selfSubtract(t.multiply(e)).signum();\n        }\n        if (\"number\" == typeof arguments[3] && \"number\" == typeof arguments[2] && \"number\" == typeof arguments[0] && \"number\" == typeof arguments[1]) {\n          var i = arguments[0],\n            r = arguments[1],\n            s = arguments[2],\n            a = arguments[3],\n            o = ut.valueOf(i),\n            u = ut.valueOf(r),\n            l = ut.valueOf(s),\n            h = ut.valueOf(a);\n          return o.multiply(h).selfSubtract(u.multiply(l)).signum();\n        }\n      }\n    }, {\n      key: \"intersection\",\n      value: function (t, e, n, i) {\n        var r = new ut(t.y).selfSubtract(e.y),\n          s = new ut(e.x).selfSubtract(t.x),\n          a = new ut(t.x).selfMultiply(e.y).selfSubtract(new ut(e.x).selfMultiply(t.y)),\n          o = new ut(n.y).selfSubtract(i.y),\n          u = new ut(i.x).selfSubtract(n.x),\n          l = new ut(n.x).selfMultiply(i.y).selfSubtract(new ut(i.x).selfMultiply(n.y)),\n          h = s.multiply(l).selfSubtract(u.multiply(a)),\n          c = o.multiply(a).selfSubtract(r.multiply(l)),\n          f = r.multiply(u).selfSubtract(o.multiply(s)),\n          g = h.selfDivide(f).doubleValue(),\n          v = c.selfDivide(f).doubleValue();\n        return A.isNaN(g) || A.isInfinite(g) || A.isNaN(v) || A.isInfinite(v) ? null : new X(g, v);\n      }\n    }, {\n      key: \"orientationIndexFilter\",\n      value: function (e, n, i) {\n        var r = null,\n          s = (e.x - i.x) * (n.y - i.y),\n          a = (e.y - i.y) * (n.x - i.x),\n          o = s - a;\n        if (s > 0) {\n          if (a <= 0) return t.signum(o);\n          r = s + a;\n        } else {\n          if (!(s < 0)) return t.signum(o);\n          if (a >= 0) return t.signum(o);\n          r = -s - a;\n        }\n        var u = t.DP_SAFE_EPSILON * r;\n        return o >= u || -o >= u ? t.signum(o) : 2;\n      }\n    }, {\n      key: \"signum\",\n      value: function (t) {\n        return t > 0 ? 1 : t < 0 ? -1 : 0;\n      }\n    }]);\n  }();\n  lt.DP_SAFE_EPSILON = 1e-15;\n  var ht = function () {\n    return s(function t() {\n      n(this, t);\n    }, [{\n      key: \"getM\",\n      value: function (t) {\n        if (this.hasM()) {\n          var e = this.getDimension() - this.getMeasures();\n          return this.getOrdinate(t, e);\n        }\n        return A.NaN;\n      }\n    }, {\n      key: \"setOrdinate\",\n      value: function (t, e, n) {}\n    }, {\n      key: \"getZ\",\n      value: function (t) {\n        return this.hasZ() ? this.getOrdinate(t, 2) : A.NaN;\n      }\n    }, {\n      key: \"size\",\n      value: function () {}\n    }, {\n      key: \"getOrdinate\",\n      value: function (t, e) {}\n    }, {\n      key: \"getCoordinate\",\n      value: function () {}\n    }, {\n      key: \"getCoordinateCopy\",\n      value: function (t) {}\n    }, {\n      key: \"createCoordinate\",\n      value: function () {}\n    }, {\n      key: \"getDimension\",\n      value: function () {}\n    }, {\n      key: \"hasM\",\n      value: function () {\n        return this.getMeasures() > 0;\n      }\n    }, {\n      key: \"getX\",\n      value: function (t) {}\n    }, {\n      key: \"hasZ\",\n      value: function () {\n        return this.getDimension() - this.getMeasures() > 2;\n      }\n    }, {\n      key: \"getMeasures\",\n      value: function () {\n        return 0;\n      }\n    }, {\n      key: \"expandEnvelope\",\n      value: function (t) {}\n    }, {\n      key: \"copy\",\n      value: function () {}\n    }, {\n      key: \"getY\",\n      value: function (t) {}\n    }, {\n      key: \"toCoordinateArray\",\n      value: function () {}\n    }, {\n      key: \"interfaces_\",\n      get: function () {\n        return [I];\n      }\n    }]);\n  }();\n  ht.X = 0, ht.Y = 1, ht.Z = 2, ht.M = 3;\n  var ct = function () {\n    function t() {\n      n(this, t);\n    }\n    return s(t, null, [{\n      key: \"index\",\n      value: function (t, e, n) {\n        return lt.orientationIndex(t, e, n);\n      }\n    }, {\n      key: \"isCCW\",\n      value: function () {\n        if (arguments[0] instanceof Array) {\n          var e = arguments[0],\n            n = e.length - 1;\n          if (n < 3) throw new m(\"Ring has fewer than 4 points, so orientation cannot be determined\");\n          for (var i = e[0], r = 0, s = 1; s <= n; s++) {\n            var a = e[s];\n            a.y > i.y && (i = a, r = s);\n          }\n          var o = r;\n          do {\n            (o -= 1) < 0 && (o = n);\n          } while (e[o].equals2D(i) && o !== r);\n          var u = r;\n          do {\n            u = (u + 1) % n;\n          } while (e[u].equals2D(i) && u !== r);\n          var l = e[o],\n            h = e[u];\n          if (l.equals2D(i) || h.equals2D(i) || l.equals2D(h)) return !1;\n          var c = t.index(l, i, h);\n          return 0 === c ? l.x > h.x : c > 0;\n        }\n        if (rt(arguments[0], ht)) {\n          var f = arguments[0],\n            g = f.size() - 1;\n          if (g < 3) throw new m(\"Ring has fewer than 4 points, so orientation cannot be determined\");\n          for (var v = f.getCoordinate(0), y = 0, d = 1; d <= g; d++) {\n            var _ = f.getCoordinate(d);\n            _.y > v.y && (v = _, y = d);\n          }\n          var p = null,\n            k = y;\n          do {\n            (k -= 1) < 0 && (k = g), p = f.getCoordinate(k);\n          } while (p.equals2D(v) && k !== y);\n          var x = null,\n            I = y;\n          do {\n            I = (I + 1) % g, x = f.getCoordinate(I);\n          } while (x.equals2D(v) && I !== y);\n          if (p.equals2D(v) || x.equals2D(v) || p.equals2D(x)) return !1;\n          var E = t.index(p, v, x);\n          return 0 === E ? p.x > x.x : E > 0;\n        }\n      }\n    }]);\n  }();\n  ct.CLOCKWISE = -1, ct.RIGHT = ct.CLOCKWISE, ct.COUNTERCLOCKWISE = 1, ct.LEFT = ct.COUNTERCLOCKWISE, ct.COLLINEAR = 0, ct.STRAIGHT = ct.COLLINEAR;\n  var ft = function () {\n      return s(function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }, [{\n        key: \"getCoordinate\",\n        value: function () {\n          return this._minCoord;\n        }\n      }, {\n        key: \"getRightmostSide\",\n        value: function (t, e) {\n          var n = this.getRightmostSideOfSegment(t, e);\n          return n < 0 && (n = this.getRightmostSideOfSegment(t, e - 1)), n < 0 && (this._minCoord = null, this.checkForRightmostCoordinate(t)), n;\n        }\n      }, {\n        key: \"findRightmostEdgeAtVertex\",\n        value: function () {\n          var t = this._minDe.getEdge().getCoordinates();\n          G.isTrue(this._minIndex > 0 && this._minIndex < t.length, \"rightmost point expected to be interior vertex of edge\");\n          var e = t[this._minIndex - 1],\n            n = t[this._minIndex + 1],\n            i = ct.index(this._minCoord, n, e),\n            r = !1;\n          (e.y < this._minCoord.y && n.y < this._minCoord.y && i === ct.COUNTERCLOCKWISE || e.y > this._minCoord.y && n.y > this._minCoord.y && i === ct.CLOCKWISE) && (r = !0), r && (this._minIndex = this._minIndex - 1);\n        }\n      }, {\n        key: \"getRightmostSideOfSegment\",\n        value: function (t, e) {\n          var n = t.getEdge().getCoordinates();\n          if (e < 0 || e + 1 >= n.length) return -1;\n          if (n[e].y === n[e + 1].y) return -1;\n          var i = $.LEFT;\n          return n[e].y < n[e + 1].y && (i = $.RIGHT), i;\n        }\n      }, {\n        key: \"getEdge\",\n        value: function () {\n          return this._orientedDe;\n        }\n      }, {\n        key: \"checkForRightmostCoordinate\",\n        value: function (t) {\n          for (var e = t.getEdge().getCoordinates(), n = 0; n < e.length - 1; n++) (null === this._minCoord || e[n].x > this._minCoord.x) && (this._minDe = t, this._minIndex = n, this._minCoord = e[n]);\n        }\n      }, {\n        key: \"findRightmostEdgeAtNode\",\n        value: function () {\n          var t = this._minDe.getNode().getEdges();\n          this._minDe = t.getRightmostEdge(), this._minDe.isForward() || (this._minDe = this._minDe.getSym(), this._minIndex = this._minDe.getEdge().getCoordinates().length - 1);\n        }\n      }, {\n        key: \"findEdge\",\n        value: function (t) {\n          for (var e = t.iterator(); e.hasNext();) {\n            var n = e.next();\n            n.isForward() && this.checkForRightmostCoordinate(n);\n          }\n          G.isTrue(0 !== this._minIndex || this._minCoord.equals(this._minDe.getCoordinate()), \"inconsistency in rightmost processing\"), 0 === this._minIndex ? this.findRightmostEdgeAtNode() : this.findRightmostEdgeAtVertex(), this._orientedDe = this._minDe, this.getRightmostSide(this._minDe, this._minIndex) === $.LEFT && (this._orientedDe = this._minDe.getSym());\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this._minIndex = -1, this._minCoord = null, this._minDe = null, this._orientedDe = null;\n        }\n      }]);\n    }(),\n    gt = function (t) {\n      function i(t, r) {\n        var s;\n        return n(this, i), (s = e(this, i, [r ? t + \" [ \" + r + \" ]\" : t])).pt = r ? new X(r) : void 0, s.name = Object.keys({\n          TopologyException: i\n        })[0], s;\n      }\n      return l(i, t), s(i, [{\n        key: \"getCoordinate\",\n        value: function () {\n          return this.pt;\n        }\n      }]);\n    }(D),\n    vt = function () {\n      return s(function t() {\n        n(this, t), this.array = [];\n      }, [{\n        key: \"addLast\",\n        value: function (t) {\n          this.array.push(t);\n        }\n      }, {\n        key: \"removeFirst\",\n        value: function () {\n          return this.array.shift();\n        }\n      }, {\n        key: \"isEmpty\",\n        value: function () {\n          return 0 === this.array.length;\n        }\n      }]);\n    }(),\n    yt = function (t) {\n      function i(t) {\n        var r;\n        return n(this, i), (r = e(this, i)).array = [], t instanceof Z && r.addAll(t), r;\n      }\n      return l(i, t), s(i, [{\n        key: \"interfaces_\",\n        get: function () {\n          return [nt, Z];\n        }\n      }, {\n        key: \"ensureCapacity\",\n        value: function () {}\n      }, {\n        key: \"add\",\n        value: function (t) {\n          return 1 === arguments.length ? this.array.push(t) : this.array.splice(arguments[0], 0, arguments[1]), !0;\n        }\n      }, {\n        key: \"clear\",\n        value: function () {\n          this.array = [];\n        }\n      }, {\n        key: \"addAll\",\n        value: function (t) {\n          var e,\n            n = a(t);\n          try {\n            for (n.s(); !(e = n.n()).done;) {\n              var i = e.value;\n              this.array.push(i);\n            }\n          } catch (t) {\n            n.e(t);\n          } finally {\n            n.f();\n          }\n        }\n      }, {\n        key: \"set\",\n        value: function (t, e) {\n          var n = this.array[t];\n          return this.array[t] = e, n;\n        }\n      }, {\n        key: \"iterator\",\n        value: function () {\n          return new dt(this);\n        }\n      }, {\n        key: \"get\",\n        value: function (t) {\n          if (t < 0 || t >= this.size()) throw new et();\n          return this.array[t];\n        }\n      }, {\n        key: \"isEmpty\",\n        value: function () {\n          return 0 === this.array.length;\n        }\n      }, {\n        key: \"sort\",\n        value: function (t) {\n          t ? this.array.sort(function (e, n) {\n            return t.compare(e, n);\n          }) : this.array.sort();\n        }\n      }, {\n        key: \"size\",\n        value: function () {\n          return this.array.length;\n        }\n      }, {\n        key: \"toArray\",\n        value: function () {\n          return this.array.slice();\n        }\n      }, {\n        key: \"remove\",\n        value: function (t) {\n          for (var e = 0, n = this.array.length; e < n; e++) if (this.array[e] === t) return !!this.array.splice(e, 1);\n          return !1;\n        }\n      }, {\n        key: Symbol.iterator,\n        value: function () {\n          return this.array.values();\n        }\n      }]);\n    }(nt),\n    dt = function () {\n      return s(function t(e) {\n        n(this, t), this.arrayList = e, this.position = 0;\n      }, [{\n        key: \"next\",\n        value: function () {\n          if (this.position === this.arrayList.size()) throw new j();\n          return this.arrayList.get(this.position++);\n        }\n      }, {\n        key: \"hasNext\",\n        value: function () {\n          return this.position < this.arrayList.size();\n        }\n      }, {\n        key: \"set\",\n        value: function (t) {\n          return this.arrayList.set(this.position - 1, t);\n        }\n      }, {\n        key: \"remove\",\n        value: function () {\n          this.arrayList.remove(this.arrayList.get(this.position));\n        }\n      }]);\n    }(),\n    _t = function () {\n      return s(function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }, [{\n        key: \"clearVisitedEdges\",\n        value: function () {\n          for (var t = this._dirEdgeList.iterator(); t.hasNext();) {\n            t.next().setVisited(!1);\n          }\n        }\n      }, {\n        key: \"getRightmostCoordinate\",\n        value: function () {\n          return this._rightMostCoord;\n        }\n      }, {\n        key: \"computeNodeDepth\",\n        value: function (t) {\n          for (var e = null, n = t.getEdges().iterator(); n.hasNext();) {\n            var i = n.next();\n            if (i.isVisited() || i.getSym().isVisited()) {\n              e = i;\n              break;\n            }\n          }\n          if (null === e) throw new gt(\"unable to find edge to compute depths at \" + t.getCoordinate());\n          t.getEdges().computeDepths(e);\n          for (var r = t.getEdges().iterator(); r.hasNext();) {\n            var s = r.next();\n            s.setVisited(!0), this.copySymDepths(s);\n          }\n        }\n      }, {\n        key: \"computeDepth\",\n        value: function (t) {\n          this.clearVisitedEdges();\n          var e = this._finder.getEdge();\n          e.getNode(), e.getLabel(), e.setEdgeDepths($.RIGHT, t), this.copySymDepths(e), this.computeDepths(e);\n        }\n      }, {\n        key: \"create\",\n        value: function (t) {\n          this.addReachable(t), this._finder.findEdge(this._dirEdgeList), this._rightMostCoord = this._finder.getCoordinate();\n        }\n      }, {\n        key: \"findResultEdges\",\n        value: function () {\n          for (var t = this._dirEdgeList.iterator(); t.hasNext();) {\n            var e = t.next();\n            e.getDepth($.RIGHT) >= 1 && e.getDepth($.LEFT) <= 0 && !e.isInteriorAreaEdge() && e.setInResult(!0);\n          }\n        }\n      }, {\n        key: \"computeDepths\",\n        value: function (t) {\n          var e = new J(),\n            n = new vt(),\n            i = t.getNode();\n          for (n.addLast(i), e.add(i), t.setVisited(!0); !n.isEmpty();) {\n            var r = n.removeFirst();\n            e.add(r), this.computeNodeDepth(r);\n            for (var s = r.getEdges().iterator(); s.hasNext();) {\n              var a = s.next().getSym();\n              if (!a.isVisited()) {\n                var o = a.getNode();\n                e.contains(o) || (n.addLast(o), e.add(o));\n              }\n            }\n          }\n        }\n      }, {\n        key: \"compareTo\",\n        value: function (t) {\n          var e = t;\n          return this._rightMostCoord.x < e._rightMostCoord.x ? -1 : this._rightMostCoord.x > e._rightMostCoord.x ? 1 : 0;\n        }\n      }, {\n        key: \"getEnvelope\",\n        value: function () {\n          if (null === this._env) {\n            for (var t = new U(), e = this._dirEdgeList.iterator(); e.hasNext();) for (var n = e.next().getEdge().getCoordinates(), i = 0; i < n.length - 1; i++) t.expandToInclude(n[i]);\n            this._env = t;\n          }\n          return this._env;\n        }\n      }, {\n        key: \"addReachable\",\n        value: function (t) {\n          var e = new it();\n          for (e.add(t); !e.empty();) {\n            var n = e.pop();\n            this.add(n, e);\n          }\n        }\n      }, {\n        key: \"copySymDepths\",\n        value: function (t) {\n          var e = t.getSym();\n          e.setDepth($.LEFT, t.getDepth($.RIGHT)), e.setDepth($.RIGHT, t.getDepth($.LEFT));\n        }\n      }, {\n        key: \"add\",\n        value: function (t, e) {\n          t.setVisited(!0), this._nodes.add(t);\n          for (var n = t.getEdges().iterator(); n.hasNext();) {\n            var i = n.next();\n            this._dirEdgeList.add(i);\n            var r = i.getSym().getNode();\n            r.isVisited() || e.push(r);\n          }\n        }\n      }, {\n        key: \"getNodes\",\n        value: function () {\n          return this._nodes;\n        }\n      }, {\n        key: \"getDirectedEdges\",\n        value: function () {\n          return this._dirEdgeList;\n        }\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [x];\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this._finder = null, this._dirEdgeList = new yt(), this._nodes = new yt(), this._rightMostCoord = null, this._env = null, this._finder = new ft();\n        }\n      }]);\n    }(),\n    pt = function () {\n      return s(function t() {\n        n(this, t);\n      }, null, [{\n        key: \"intersection\",\n        value: function (t, e, n, i) {\n          var r = t.x < e.x ? t.x : e.x,\n            s = t.y < e.y ? t.y : e.y,\n            a = t.x > e.x ? t.x : e.x,\n            o = t.y > e.y ? t.y : e.y,\n            u = n.x < i.x ? n.x : i.x,\n            l = n.y < i.y ? n.y : i.y,\n            h = n.x > i.x ? n.x : i.x,\n            c = n.y > i.y ? n.y : i.y,\n            f = ((r > u ? r : u) + (a < h ? a : h)) / 2,\n            g = ((s > l ? s : l) + (o < c ? o : c)) / 2,\n            v = t.x - f,\n            y = t.y - g,\n            d = e.x - f,\n            _ = e.y - g,\n            p = n.x - f,\n            m = n.y - g,\n            k = i.x - f,\n            x = i.y - g,\n            I = y - _,\n            E = d - v,\n            N = v * _ - d * y,\n            T = m - x,\n            S = k - p,\n            L = p * x - k * m,\n            C = I * S - T * E,\n            R = (E * L - S * N) / C,\n            w = (T * N - I * L) / C;\n          return A.isNaN(R) || A.isInfinite(R) || A.isNaN(w) || A.isInfinite(w) ? null : new X(R + f, w + g);\n        }\n      }]);\n    }(),\n    mt = function () {\n      return s(function t() {\n        n(this, t);\n      }, null, [{\n        key: \"arraycopy\",\n        value: function (t, e, n, i, r) {\n          for (var s = 0, a = e; a < e + r; a++) n[i + s] = t[a], s++;\n        }\n      }, {\n        key: \"getProperty\",\n        value: function (t) {\n          return {\n            \"line.separator\": \"\\n\"\n          }[t];\n        }\n      }]);\n    }(),\n    kt = function () {\n      function t() {\n        n(this, t);\n      }\n      return s(t, null, [{\n        key: \"log10\",\n        value: function (e) {\n          var n = Math.log(e);\n          return A.isInfinite(n) || A.isNaN(n) ? n : n / t.LOG_10;\n        }\n      }, {\n        key: \"min\",\n        value: function (t, e, n, i) {\n          var r = t;\n          return e < r && (r = e), n < r && (r = n), i < r && (r = i), r;\n        }\n      }, {\n        key: \"clamp\",\n        value: function () {\n          if (\"number\" == typeof arguments[2] && \"number\" == typeof arguments[0] && \"number\" == typeof arguments[1]) {\n            var t = arguments[0],\n              e = arguments[1],\n              n = arguments[2];\n            return t < e ? e : t > n ? n : t;\n          }\n          if (Number.isInteger(arguments[2]) && Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {\n            var i = arguments[0],\n              r = arguments[1],\n              s = arguments[2];\n            return i < r ? r : i > s ? s : i;\n          }\n        }\n      }, {\n        key: \"wrap\",\n        value: function (t, e) {\n          return t < 0 ? e - -t % e : t % e;\n        }\n      }, {\n        key: \"max\",\n        value: function () {\n          if (3 === arguments.length) {\n            var t = arguments[1],\n              e = arguments[2],\n              n = arguments[0];\n            return t > n && (n = t), e > n && (n = e), n;\n          }\n          if (4 === arguments.length) {\n            var i = arguments[1],\n              r = arguments[2],\n              s = arguments[3],\n              a = arguments[0];\n            return i > a && (a = i), r > a && (a = r), s > a && (a = s), a;\n          }\n        }\n      }, {\n        key: \"average\",\n        value: function (t, e) {\n          return (t + e) / 2;\n        }\n      }]);\n    }();\n  kt.LOG_10 = Math.log(10);\n  var xt = function () {\n      function t() {\n        n(this, t);\n      }\n      return s(t, null, [{\n        key: \"segmentToSegment\",\n        value: function (e, n, i, r) {\n          if (e.equals(n)) return t.pointToSegment(e, i, r);\n          if (i.equals(r)) return t.pointToSegment(r, e, n);\n          var s = !1;\n          if (U.intersects(e, n, i, r)) {\n            var a = (n.x - e.x) * (r.y - i.y) - (n.y - e.y) * (r.x - i.x);\n            if (0 === a) s = !0;else {\n              var o = (e.y - i.y) * (r.x - i.x) - (e.x - i.x) * (r.y - i.y),\n                u = ((e.y - i.y) * (n.x - e.x) - (e.x - i.x) * (n.y - e.y)) / a,\n                l = o / a;\n              (l < 0 || l > 1 || u < 0 || u > 1) && (s = !0);\n            }\n          } else s = !0;\n          return s ? kt.min(t.pointToSegment(e, i, r), t.pointToSegment(n, i, r), t.pointToSegment(i, e, n), t.pointToSegment(r, e, n)) : 0;\n        }\n      }, {\n        key: \"pointToSegment\",\n        value: function (t, e, n) {\n          if (e.x === n.x && e.y === n.y) return t.distance(e);\n          var i = (n.x - e.x) * (n.x - e.x) + (n.y - e.y) * (n.y - e.y),\n            r = ((t.x - e.x) * (n.x - e.x) + (t.y - e.y) * (n.y - e.y)) / i;\n          if (r <= 0) return t.distance(e);\n          if (r >= 1) return t.distance(n);\n          var s = ((e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)) / i;\n          return Math.abs(s) * Math.sqrt(i);\n        }\n      }, {\n        key: \"pointToLinePerpendicular\",\n        value: function (t, e, n) {\n          var i = (n.x - e.x) * (n.x - e.x) + (n.y - e.y) * (n.y - e.y),\n            r = ((e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)) / i;\n          return Math.abs(r) * Math.sqrt(i);\n        }\n      }, {\n        key: \"pointToSegmentString\",\n        value: function (e, n) {\n          if (0 === n.length) throw new m(\"Line array must contain at least one vertex\");\n          for (var i = e.distance(n[0]), r = 0; r < n.length - 1; r++) {\n            var s = t.pointToSegment(e, n[r], n[r + 1]);\n            s < i && (i = s);\n          }\n          return i;\n        }\n      }]);\n    }(),\n    It = function () {\n      return s(function t() {\n        n(this, t);\n      }, [{\n        key: \"create\",\n        value: function () {\n          if (1 === arguments.length) arguments[0] instanceof Array || rt(arguments[0], ht);else if (2 === arguments.length) ;else if (3 === arguments.length) {\n            var t = arguments[0],\n              e = arguments[1];\n            return this.create(t, e);\n          }\n        }\n      }]);\n    }(),\n    Et = function () {\n      return s(function t() {\n        n(this, t);\n      }, [{\n        key: \"filter\",\n        value: function (t) {}\n      }]);\n    }(),\n    Nt = function () {\n      return s(function t() {\n        n(this, t);\n      }, null, [{\n        key: \"ofLine\",\n        value: function (t) {\n          var e = t.size();\n          if (e <= 1) return 0;\n          var n = 0,\n            i = new X();\n          t.getCoordinate(0, i);\n          for (var r = i.x, s = i.y, a = 1; a < e; a++) {\n            t.getCoordinate(a, i);\n            var o = i.x,\n              u = i.y,\n              l = o - r,\n              h = u - s;\n            n += Math.sqrt(l * l + h * h), r = o, s = u;\n          }\n          return n;\n        }\n      }]);\n    }(),\n    Tt = s(function t() {\n      n(this, t);\n    }),\n    St = function () {\n      function t() {\n        n(this, t);\n      }\n      return s(t, null, [{\n        key: \"copyCoord\",\n        value: function (t, e, n, i) {\n          for (var r = Math.min(t.getDimension(), n.getDimension()), s = 0; s < r; s++) n.setOrdinate(i, s, t.getOrdinate(e, s));\n        }\n      }, {\n        key: \"isRing\",\n        value: function (t) {\n          var e = t.size();\n          return 0 === e || !(e <= 3) && t.getOrdinate(0, ht.X) === t.getOrdinate(e - 1, ht.X) && t.getOrdinate(0, ht.Y) === t.getOrdinate(e - 1, ht.Y);\n        }\n      }, {\n        key: \"scroll\",\n        value: function () {\n          if (2 === arguments.length) {\n            if (rt(arguments[0], ht) && Number.isInteger(arguments[1])) {\n              var e = arguments[0],\n                n = arguments[1];\n              t.scroll(e, n, t.isRing(e));\n            } else if (rt(arguments[0], ht) && arguments[1] instanceof X) {\n              var i = arguments[0],\n                r = arguments[1],\n                s = t.indexOf(r, i);\n              if (s <= 0) return null;\n              t.scroll(i, s);\n            }\n          } else if (3 === arguments.length) {\n            var a = arguments[0],\n              o = arguments[1],\n              u = arguments[2];\n            if (o <= 0) return null;\n            for (var l = a.copy(), h = u ? a.size() - 1 : a.size(), c = 0; c < h; c++) for (var f = 0; f < a.getDimension(); f++) a.setOrdinate(c, f, l.getOrdinate((o + c) % h, f));\n            if (u) for (var g = 0; g < a.getDimension(); g++) a.setOrdinate(h, g, a.getOrdinate(0, g));\n          }\n        }\n      }, {\n        key: \"isEqual\",\n        value: function (t, e) {\n          var n = t.size();\n          if (n !== e.size()) return !1;\n          for (var i = Math.min(t.getDimension(), e.getDimension()), r = 0; r < n; r++) for (var s = 0; s < i; s++) {\n            var a = t.getOrdinate(r, s),\n              o = e.getOrdinate(r, s);\n            if (t.getOrdinate(r, s) !== e.getOrdinate(r, s) && (!A.isNaN(a) || !A.isNaN(o))) return !1;\n          }\n          return !0;\n        }\n      }, {\n        key: \"minCoordinateIndex\",\n        value: function () {\n          if (1 === arguments.length) {\n            var e = arguments[0];\n            return t.minCoordinateIndex(e, 0, e.size() - 1);\n          }\n          if (3 === arguments.length) {\n            for (var n = arguments[0], i = arguments[2], r = -1, s = null, a = arguments[1]; a <= i; a++) {\n              var o = n.getCoordinate(a);\n              (null === s || s.compareTo(o) > 0) && (s = o, r = a);\n            }\n            return r;\n          }\n        }\n      }, {\n        key: \"extend\",\n        value: function (e, n, i) {\n          var r = e.create(i, n.getDimension()),\n            s = n.size();\n          if (t.copy(n, 0, r, 0, s), s > 0) for (var a = s; a < i; a++) t.copy(n, s - 1, r, a, 1);\n          return r;\n        }\n      }, {\n        key: \"reverse\",\n        value: function (e) {\n          for (var n = e.size() - 1, i = Math.trunc(n / 2), r = 0; r <= i; r++) t.swap(e, r, n - r);\n        }\n      }, {\n        key: \"swap\",\n        value: function (t, e, n) {\n          if (e === n) return null;\n          for (var i = 0; i < t.getDimension(); i++) {\n            var r = t.getOrdinate(e, i);\n            t.setOrdinate(e, i, t.getOrdinate(n, i)), t.setOrdinate(n, i, r);\n          }\n        }\n      }, {\n        key: \"copy\",\n        value: function (e, n, i, r, s) {\n          for (var a = 0; a < s; a++) t.copyCoord(e, n + a, i, r + a);\n        }\n      }, {\n        key: \"ensureValidRing\",\n        value: function (e, n) {\n          var i = n.size();\n          return 0 === i ? n : i <= 3 ? t.createClosedRing(e, n, 4) : n.getOrdinate(0, ht.X) === n.getOrdinate(i - 1, ht.X) && n.getOrdinate(0, ht.Y) === n.getOrdinate(i - 1, ht.Y) ? n : t.createClosedRing(e, n, i + 1);\n        }\n      }, {\n        key: \"indexOf\",\n        value: function (t, e) {\n          for (var n = 0; n < e.size(); n++) if (t.x === e.getOrdinate(n, ht.X) && t.y === e.getOrdinate(n, ht.Y)) return n;\n          return -1;\n        }\n      }, {\n        key: \"createClosedRing\",\n        value: function (e, n, i) {\n          var r = e.create(i, n.getDimension()),\n            s = n.size();\n          t.copy(n, 0, r, 0, s);\n          for (var a = s; a < i; a++) t.copy(n, 0, r, a, 1);\n          return r;\n        }\n      }, {\n        key: \"minCoordinate\",\n        value: function (t) {\n          for (var e = null, n = 0; n < t.size(); n++) {\n            var i = t.getCoordinate(n);\n            (null === e || e.compareTo(i) > 0) && (e = i);\n          }\n          return e;\n        }\n      }]);\n    }(),\n    Lt = function () {\n      function t() {\n        n(this, t);\n      }\n      return s(t, null, [{\n        key: \"toDimensionSymbol\",\n        value: function (e) {\n          switch (e) {\n            case t.FALSE:\n              return t.SYM_FALSE;\n            case t.TRUE:\n              return t.SYM_TRUE;\n            case t.DONTCARE:\n              return t.SYM_DONTCARE;\n            case t.P:\n              return t.SYM_P;\n            case t.L:\n              return t.SYM_L;\n            case t.A:\n              return t.SYM_A;\n          }\n          throw new m(\"Unknown dimension value: \" + e);\n        }\n      }, {\n        key: \"toDimensionValue\",\n        value: function (e) {\n          switch (ot.toUpperCase(e)) {\n            case t.SYM_FALSE:\n              return t.FALSE;\n            case t.SYM_TRUE:\n              return t.TRUE;\n            case t.SYM_DONTCARE:\n              return t.DONTCARE;\n            case t.SYM_P:\n              return t.P;\n            case t.SYM_L:\n              return t.L;\n            case t.SYM_A:\n              return t.A;\n          }\n          throw new m(\"Unknown dimension symbol: \" + e);\n        }\n      }]);\n    }();\n  Lt.P = 0, Lt.L = 1, Lt.A = 2, Lt.FALSE = -1, Lt.TRUE = -2, Lt.DONTCARE = -3, Lt.SYM_FALSE = \"F\", Lt.SYM_TRUE = \"T\", Lt.SYM_DONTCARE = \"*\", Lt.SYM_P = \"0\", Lt.SYM_L = \"1\", Lt.SYM_A = \"2\";\n  var Ct = function () {\n      return s(function t() {\n        n(this, t);\n      }, [{\n        key: \"filter\",\n        value: function (t) {}\n      }]);\n    }(),\n    Rt = function () {\n      return s(function t() {\n        n(this, t);\n      }, [{\n        key: \"filter\",\n        value: function (t, e) {}\n      }, {\n        key: \"isDone\",\n        value: function () {}\n      }, {\n        key: \"isGeometryChanged\",\n        value: function () {}\n      }]);\n    }(),\n    wt = function (t) {\n      function i() {\n        var t;\n        return n(this, i), t = e(this, i), i.constructor_.apply(t, arguments), t;\n      }\n      return l(i, t), s(i, [{\n        key: \"computeEnvelopeInternal\",\n        value: function () {\n          return this.isEmpty() ? new U() : this._points.expandEnvelope(new U());\n        }\n      }, {\n        key: \"isRing\",\n        value: function () {\n          return this.isClosed() && this.isSimple();\n        }\n      }, {\n        key: \"getCoordinates\",\n        value: function () {\n          return this._points.toCoordinateArray();\n        }\n      }, {\n        key: \"copyInternal\",\n        value: function () {\n          return new i(this._points.copy(), this._factory);\n        }\n      }, {\n        key: \"equalsExact\",\n        value: function () {\n          if (2 === arguments.length && \"number\" == typeof arguments[1] && arguments[0] instanceof V) {\n            var t = arguments[0],\n              e = arguments[1];\n            if (!this.isEquivalentClass(t)) return !1;\n            var n = t;\n            if (this._points.size() !== n._points.size()) return !1;\n            for (var r = 0; r < this._points.size(); r++) if (!this.equal(this._points.getCoordinate(r), n._points.getCoordinate(r), e)) return !1;\n            return !0;\n          }\n          return f(i, \"equalsExact\", this, 1).apply(this, arguments);\n        }\n      }, {\n        key: \"normalize\",\n        value: function () {\n          for (var t = 0; t < Math.trunc(this._points.size() / 2); t++) {\n            var e = this._points.size() - 1 - t;\n            if (!this._points.getCoordinate(t).equals(this._points.getCoordinate(e))) {\n              if (this._points.getCoordinate(t).compareTo(this._points.getCoordinate(e)) > 0) {\n                var n = this._points.copy();\n                St.reverse(n), this._points = n;\n              }\n              return null;\n            }\n          }\n        }\n      }, {\n        key: \"getCoordinate\",\n        value: function () {\n          return this.isEmpty() ? null : this._points.getCoordinate(0);\n        }\n      }, {\n        key: \"getBoundaryDimension\",\n        value: function () {\n          return this.isClosed() ? Lt.FALSE : 0;\n        }\n      }, {\n        key: \"isClosed\",\n        value: function () {\n          return !this.isEmpty() && this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints() - 1));\n        }\n      }, {\n        key: \"reverseInternal\",\n        value: function () {\n          var t = this._points.copy();\n          return St.reverse(t), this.getFactory().createLineString(t);\n        }\n      }, {\n        key: \"getEndPoint\",\n        value: function () {\n          return this.isEmpty() ? null : this.getPointN(this.getNumPoints() - 1);\n        }\n      }, {\n        key: \"getTypeCode\",\n        value: function () {\n          return V.TYPECODE_LINESTRING;\n        }\n      }, {\n        key: \"getDimension\",\n        value: function () {\n          return 1;\n        }\n      }, {\n        key: \"getLength\",\n        value: function () {\n          return Nt.ofLine(this._points);\n        }\n      }, {\n        key: \"getNumPoints\",\n        value: function () {\n          return this._points.size();\n        }\n      }, {\n        key: \"compareToSameClass\",\n        value: function () {\n          if (1 === arguments.length) {\n            for (var t = arguments[0], e = 0, n = 0; e < this._points.size() && n < t._points.size();) {\n              var i = this._points.getCoordinate(e).compareTo(t._points.getCoordinate(n));\n              if (0 !== i) return i;\n              e++, n++;\n            }\n            return e < this._points.size() ? 1 : n < t._points.size() ? -1 : 0;\n          }\n          if (2 === arguments.length) {\n            var r = arguments[0];\n            return arguments[1].compare(this._points, r._points);\n          }\n        }\n      }, {\n        key: \"apply\",\n        value: function () {\n          if (rt(arguments[0], Et)) for (var t = arguments[0], e = 0; e < this._points.size(); e++) t.filter(this._points.getCoordinate(e));else if (rt(arguments[0], Rt)) {\n            var n = arguments[0];\n            if (0 === this._points.size()) return null;\n            for (var i = 0; i < this._points.size() && (n.filter(this._points, i), !n.isDone()); i++);\n            n.isGeometryChanged() && this.geometryChanged();\n          } else if (rt(arguments[0], Ct)) {\n            arguments[0].filter(this);\n          } else if (rt(arguments[0], k)) {\n            arguments[0].filter(this);\n          }\n        }\n      }, {\n        key: \"getBoundary\",\n        value: function () {\n          throw new W();\n        }\n      }, {\n        key: \"isEquivalentClass\",\n        value: function (t) {\n          return t instanceof i;\n        }\n      }, {\n        key: \"getCoordinateN\",\n        value: function (t) {\n          return this._points.getCoordinate(t);\n        }\n      }, {\n        key: \"getGeometryType\",\n        value: function () {\n          return V.TYPENAME_LINESTRING;\n        }\n      }, {\n        key: \"getCoordinateSequence\",\n        value: function () {\n          return this._points;\n        }\n      }, {\n        key: \"isEmpty\",\n        value: function () {\n          return 0 === this._points.size();\n        }\n      }, {\n        key: \"init\",\n        value: function (t) {\n          if (null === t && (t = this.getFactory().getCoordinateSequenceFactory().create([])), 1 === t.size()) throw new m(\"Invalid number of points in LineString (found \" + t.size() + \" - must be 0 or >= 2)\");\n          this._points = t;\n        }\n      }, {\n        key: \"isCoordinate\",\n        value: function (t) {\n          for (var e = 0; e < this._points.size(); e++) if (this._points.getCoordinate(e).equals(t)) return !0;\n          return !1;\n        }\n      }, {\n        key: \"getStartPoint\",\n        value: function () {\n          return this.isEmpty() ? null : this.getPointN(0);\n        }\n      }, {\n        key: \"getPointN\",\n        value: function (t) {\n          return this.getFactory().createPoint(this._points.getCoordinate(t));\n        }\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [Tt];\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          if (this._points = null, 0 === arguments.length) ;else if (2 === arguments.length) {\n            var t = arguments[0],\n              e = arguments[1];\n            V.constructor_.call(this, e), this.init(t);\n          }\n        }\n      }]);\n    }(V),\n    Ot = s(function t() {\n      n(this, t);\n    }),\n    bt = function (t) {\n      function i() {\n        var t;\n        return n(this, i), t = e(this, i), i.constructor_.apply(t, arguments), t;\n      }\n      return l(i, t), s(i, [{\n        key: \"computeEnvelopeInternal\",\n        value: function () {\n          if (this.isEmpty()) return new U();\n          var t = new U();\n          return t.expandToInclude(this._coordinates.getX(0), this._coordinates.getY(0)), t;\n        }\n      }, {\n        key: \"getCoordinates\",\n        value: function () {\n          return this.isEmpty() ? [] : [this.getCoordinate()];\n        }\n      }, {\n        key: \"copyInternal\",\n        value: function () {\n          return new i(this._coordinates.copy(), this._factory);\n        }\n      }, {\n        key: \"equalsExact\",\n        value: function () {\n          if (2 === arguments.length && \"number\" == typeof arguments[1] && arguments[0] instanceof V) {\n            var t = arguments[0],\n              e = arguments[1];\n            return !!this.isEquivalentClass(t) && (!(!this.isEmpty() || !t.isEmpty()) || this.isEmpty() === t.isEmpty() && this.equal(t.getCoordinate(), this.getCoordinate(), e));\n          }\n          return f(i, \"equalsExact\", this, 1).apply(this, arguments);\n        }\n      }, {\n        key: \"normalize\",\n        value: function () {}\n      }, {\n        key: \"getCoordinate\",\n        value: function () {\n          return 0 !== this._coordinates.size() ? this._coordinates.getCoordinate(0) : null;\n        }\n      }, {\n        key: \"getBoundaryDimension\",\n        value: function () {\n          return Lt.FALSE;\n        }\n      }, {\n        key: \"reverseInternal\",\n        value: function () {\n          return this.getFactory().createPoint(this._coordinates.copy());\n        }\n      }, {\n        key: \"getTypeCode\",\n        value: function () {\n          return V.TYPECODE_POINT;\n        }\n      }, {\n        key: \"getDimension\",\n        value: function () {\n          return 0;\n        }\n      }, {\n        key: \"getNumPoints\",\n        value: function () {\n          return this.isEmpty() ? 0 : 1;\n        }\n      }, {\n        key: \"getX\",\n        value: function () {\n          if (null === this.getCoordinate()) throw new IllegalStateException(\"getX called on empty Point\");\n          return this.getCoordinate().x;\n        }\n      }, {\n        key: \"compareToSameClass\",\n        value: function () {\n          if (1 === arguments.length) {\n            var t = arguments[0];\n            return this.getCoordinate().compareTo(t.getCoordinate());\n          }\n          if (2 === arguments.length) {\n            var e = arguments[0];\n            return arguments[1].compare(this._coordinates, e._coordinates);\n          }\n        }\n      }, {\n        key: \"apply\",\n        value: function () {\n          if (rt(arguments[0], Et)) {\n            var t = arguments[0];\n            if (this.isEmpty()) return null;\n            t.filter(this.getCoordinate());\n          } else if (rt(arguments[0], Rt)) {\n            var e = arguments[0];\n            if (this.isEmpty()) return null;\n            e.filter(this._coordinates, 0), e.isGeometryChanged() && this.geometryChanged();\n          } else if (rt(arguments[0], Ct)) {\n            arguments[0].filter(this);\n          } else if (rt(arguments[0], k)) {\n            arguments[0].filter(this);\n          }\n        }\n      }, {\n        key: \"getBoundary\",\n        value: function () {\n          return this.getFactory().createGeometryCollection();\n        }\n      }, {\n        key: \"getGeometryType\",\n        value: function () {\n          return V.TYPENAME_POINT;\n        }\n      }, {\n        key: \"getCoordinateSequence\",\n        value: function () {\n          return this._coordinates;\n        }\n      }, {\n        key: \"getY\",\n        value: function () {\n          if (null === this.getCoordinate()) throw new IllegalStateException(\"getY called on empty Point\");\n          return this.getCoordinate().y;\n        }\n      }, {\n        key: \"isEmpty\",\n        value: function () {\n          return 0 === this._coordinates.size();\n        }\n      }, {\n        key: \"init\",\n        value: function (t) {\n          null === t && (t = this.getFactory().getCoordinateSequenceFactory().create([])), G.isTrue(t.size() <= 1), this._coordinates = t;\n        }\n      }, {\n        key: \"isSimple\",\n        value: function () {\n          return !0;\n        }\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [Ot];\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this._coordinates = null;\n          var t = arguments[0],\n            e = arguments[1];\n          V.constructor_.call(this, e), this.init(t);\n        }\n      }]);\n    }(V),\n    Mt = function () {\n      function t() {\n        n(this, t);\n      }\n      return s(t, null, [{\n        key: \"ofRing\",\n        value: function () {\n          if (arguments[0] instanceof Array) {\n            var e = arguments[0];\n            return Math.abs(t.ofRingSigned(e));\n          }\n          if (rt(arguments[0], ht)) {\n            var n = arguments[0];\n            return Math.abs(t.ofRingSigned(n));\n          }\n        }\n      }, {\n        key: \"ofRingSigned\",\n        value: function () {\n          if (arguments[0] instanceof Array) {\n            var t = arguments[0];\n            if (t.length < 3) return 0;\n            for (var e = 0, n = t[0].x, i = 1; i < t.length - 1; i++) {\n              var r = t[i].x - n,\n                s = t[i + 1].y;\n              e += r * (t[i - 1].y - s);\n            }\n            return e / 2;\n          }\n          if (rt(arguments[0], ht)) {\n            var a = arguments[0],\n              o = a.size();\n            if (o < 3) return 0;\n            var u = new X(),\n              l = new X(),\n              h = new X();\n            a.getCoordinate(0, l), a.getCoordinate(1, h);\n            var c = l.x;\n            h.x -= c;\n            for (var f = 0, g = 1; g < o - 1; g++) u.y = l.y, l.x = h.x, l.y = h.y, a.getCoordinate(g + 1, h), h.x -= c, f += l.x * (u.y - h.y);\n            return f / 2;\n          }\n        }\n      }]);\n    }(),\n    At = function () {\n      return s(function t() {\n        n(this, t);\n      }, null, [{\n        key: \"sort\",\n        value: function () {\n          var t = arguments,\n            e = arguments[0];\n          if (1 === arguments.length) e.sort(function (t, e) {\n            return t.compareTo(e);\n          });else if (2 === arguments.length) e.sort(function (e, n) {\n            return t[1].compare(e, n);\n          });else if (3 === arguments.length) {\n            var n = e.slice(arguments[1], arguments[2]);\n            n.sort();\n            var i = e.slice(0, arguments[1]).concat(n, e.slice(arguments[2], e.length));\n            e.splice(0, e.length);\n            var r,\n              s = a(i);\n            try {\n              for (s.s(); !(r = s.n()).done;) {\n                var o = r.value;\n                e.push(o);\n              }\n            } catch (t) {\n              s.e(t);\n            } finally {\n              s.f();\n            }\n          } else if (4 === arguments.length) {\n            var u = e.slice(arguments[1], arguments[2]);\n            u.sort(function (e, n) {\n              return t[3].compare(e, n);\n            });\n            var l = e.slice(0, arguments[1]).concat(u, e.slice(arguments[2], e.length));\n            e.splice(0, e.length);\n            var h,\n              c = a(l);\n            try {\n              for (c.s(); !(h = c.n()).done;) {\n                var f = h.value;\n                e.push(f);\n              }\n            } catch (t) {\n              c.e(t);\n            } finally {\n              c.f();\n            }\n          }\n        }\n      }, {\n        key: \"asList\",\n        value: function (t) {\n          var e,\n            n = new yt(),\n            i = a(t);\n          try {\n            for (i.s(); !(e = i.n()).done;) {\n              var r = e.value;\n              n.add(r);\n            }\n          } catch (t) {\n            i.e(t);\n          } finally {\n            i.f();\n          }\n          return n;\n        }\n      }, {\n        key: \"copyOf\",\n        value: function (t, e) {\n          return t.slice(0, e);\n        }\n      }]);\n    }(),\n    Pt = s(function t() {\n      n(this, t);\n    }),\n    Dt = function (t) {\n      function i() {\n        var t;\n        return n(this, i), t = e(this, i), i.constructor_.apply(t, arguments), t;\n      }\n      return l(i, t), s(i, [{\n        key: \"computeEnvelopeInternal\",\n        value: function () {\n          return this._shell.getEnvelopeInternal();\n        }\n      }, {\n        key: \"getCoordinates\",\n        value: function () {\n          if (this.isEmpty()) return [];\n          for (var t = new Array(this.getNumPoints()).fill(null), e = -1, n = this._shell.getCoordinates(), i = 0; i < n.length; i++) t[++e] = n[i];\n          for (var r = 0; r < this._holes.length; r++) for (var s = this._holes[r].getCoordinates(), a = 0; a < s.length; a++) t[++e] = s[a];\n          return t;\n        }\n      }, {\n        key: \"getArea\",\n        value: function () {\n          var t = 0;\n          t += Mt.ofRing(this._shell.getCoordinateSequence());\n          for (var e = 0; e < this._holes.length; e++) t -= Mt.ofRing(this._holes[e].getCoordinateSequence());\n          return t;\n        }\n      }, {\n        key: \"copyInternal\",\n        value: function () {\n          for (var t = this._shell.copy(), e = new Array(this._holes.length).fill(null), n = 0; n < this._holes.length; n++) e[n] = this._holes[n].copy();\n          return new i(t, e, this._factory);\n        }\n      }, {\n        key: \"isRectangle\",\n        value: function () {\n          if (0 !== this.getNumInteriorRing()) return !1;\n          if (null === this._shell) return !1;\n          if (5 !== this._shell.getNumPoints()) return !1;\n          for (var t = this._shell.getCoordinateSequence(), e = this.getEnvelopeInternal(), n = 0; n < 5; n++) {\n            var i = t.getX(n);\n            if (i !== e.getMinX() && i !== e.getMaxX()) return !1;\n            var r = t.getY(n);\n            if (r !== e.getMinY() && r !== e.getMaxY()) return !1;\n          }\n          for (var s = t.getX(0), a = t.getY(0), o = 1; o <= 4; o++) {\n            var u = t.getX(o),\n              l = t.getY(o);\n            if (u !== s === (l !== a)) return !1;\n            s = u, a = l;\n          }\n          return !0;\n        }\n      }, {\n        key: \"equalsExact\",\n        value: function () {\n          if (2 === arguments.length && \"number\" == typeof arguments[1] && arguments[0] instanceof V) {\n            var t = arguments[0],\n              e = arguments[1];\n            if (!this.isEquivalentClass(t)) return !1;\n            var n = t,\n              r = this._shell,\n              s = n._shell;\n            if (!r.equalsExact(s, e)) return !1;\n            if (this._holes.length !== n._holes.length) return !1;\n            for (var a = 0; a < this._holes.length; a++) if (!this._holes[a].equalsExact(n._holes[a], e)) return !1;\n            return !0;\n          }\n          return f(i, \"equalsExact\", this, 1).apply(this, arguments);\n        }\n      }, {\n        key: \"normalize\",\n        value: function () {\n          if (0 === arguments.length) {\n            this._shell = this.normalized(this._shell, !0);\n            for (var t = 0; t < this._holes.length; t++) this._holes[t] = this.normalized(this._holes[t], !1);\n            At.sort(this._holes);\n          } else if (2 === arguments.length) {\n            var e = arguments[0],\n              n = arguments[1];\n            if (e.isEmpty()) return null;\n            var i = e.getCoordinateSequence(),\n              r = St.minCoordinateIndex(i, 0, i.size() - 2);\n            St.scroll(i, r, !0), ct.isCCW(i) === n && St.reverse(i);\n          }\n        }\n      }, {\n        key: \"getCoordinate\",\n        value: function () {\n          return this._shell.getCoordinate();\n        }\n      }, {\n        key: \"getNumInteriorRing\",\n        value: function () {\n          return this._holes.length;\n        }\n      }, {\n        key: \"getBoundaryDimension\",\n        value: function () {\n          return 1;\n        }\n      }, {\n        key: \"reverseInternal\",\n        value: function () {\n          for (var t = this.getExteriorRing().reverse(), e = new Array(this.getNumInteriorRing()).fill(null), n = 0; n < e.length; n++) e[n] = this.getInteriorRingN(n).reverse();\n          return this.getFactory().createPolygon(t, e);\n        }\n      }, {\n        key: \"getTypeCode\",\n        value: function () {\n          return V.TYPECODE_POLYGON;\n        }\n      }, {\n        key: \"getDimension\",\n        value: function () {\n          return 2;\n        }\n      }, {\n        key: \"getLength\",\n        value: function () {\n          var t = 0;\n          t += this._shell.getLength();\n          for (var e = 0; e < this._holes.length; e++) t += this._holes[e].getLength();\n          return t;\n        }\n      }, {\n        key: \"getNumPoints\",\n        value: function () {\n          for (var t = this._shell.getNumPoints(), e = 0; e < this._holes.length; e++) t += this._holes[e].getNumPoints();\n          return t;\n        }\n      }, {\n        key: \"convexHull\",\n        value: function () {\n          return this.getExteriorRing().convexHull();\n        }\n      }, {\n        key: \"normalized\",\n        value: function (t, e) {\n          var n = t.copy();\n          return this.normalize(n, e), n;\n        }\n      }, {\n        key: \"compareToSameClass\",\n        value: function () {\n          if (1 === arguments.length) {\n            var t = arguments[0],\n              e = this._shell,\n              n = t._shell;\n            return e.compareToSameClass(n);\n          }\n          if (2 === arguments.length) {\n            var i = arguments[1],\n              r = arguments[0],\n              s = this._shell,\n              a = r._shell,\n              o = s.compareToSameClass(a, i);\n            if (0 !== o) return o;\n            for (var u = this.getNumInteriorRing(), l = r.getNumInteriorRing(), h = 0; h < u && h < l;) {\n              var c = this.getInteriorRingN(h),\n                f = r.getInteriorRingN(h),\n                g = c.compareToSameClass(f, i);\n              if (0 !== g) return g;\n              h++;\n            }\n            return h < u ? 1 : h < l ? -1 : 0;\n          }\n        }\n      }, {\n        key: \"apply\",\n        value: function () {\n          if (rt(arguments[0], Et)) {\n            var t = arguments[0];\n            this._shell.apply(t);\n            for (var e = 0; e < this._holes.length; e++) this._holes[e].apply(t);\n          } else if (rt(arguments[0], Rt)) {\n            var n = arguments[0];\n            if (this._shell.apply(n), !n.isDone()) for (var i = 0; i < this._holes.length && (this._holes[i].apply(n), !n.isDone()); i++);\n            n.isGeometryChanged() && this.geometryChanged();\n          } else if (rt(arguments[0], Ct)) {\n            arguments[0].filter(this);\n          } else if (rt(arguments[0], k)) {\n            var r = arguments[0];\n            r.filter(this), this._shell.apply(r);\n            for (var s = 0; s < this._holes.length; s++) this._holes[s].apply(r);\n          }\n        }\n      }, {\n        key: \"getBoundary\",\n        value: function () {\n          if (this.isEmpty()) return this.getFactory().createMultiLineString();\n          var t = new Array(this._holes.length + 1).fill(null);\n          t[0] = this._shell;\n          for (var e = 0; e < this._holes.length; e++) t[e + 1] = this._holes[e];\n          return t.length <= 1 ? this.getFactory().createLinearRing(t[0].getCoordinateSequence()) : this.getFactory().createMultiLineString(t);\n        }\n      }, {\n        key: \"getGeometryType\",\n        value: function () {\n          return V.TYPENAME_POLYGON;\n        }\n      }, {\n        key: \"getExteriorRing\",\n        value: function () {\n          return this._shell;\n        }\n      }, {\n        key: \"isEmpty\",\n        value: function () {\n          return this._shell.isEmpty();\n        }\n      }, {\n        key: \"getInteriorRingN\",\n        value: function (t) {\n          return this._holes[t];\n        }\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [Pt];\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this._shell = null, this._holes = null;\n          var t = arguments[0],\n            e = arguments[1],\n            n = arguments[2];\n          if (V.constructor_.call(this, n), null === t && (t = this.getFactory().createLinearRing()), null === e && (e = []), V.hasNullElements(e)) throw new m(\"holes must not contain null elements\");\n          if (t.isEmpty() && V.hasNonEmptyElements(e)) throw new m(\"shell is empty but holes are not\");\n          this._shell = t, this._holes = e;\n        }\n      }]);\n    }(V),\n    Ft = function (t) {\n      function i() {\n        return n(this, i), e(this, i, arguments);\n      }\n      return l(i, t), s(i);\n    }(K),\n    Gt = function (t) {\n      function i(t) {\n        var r;\n        return n(this, i), (r = e(this, i)).array = [], t instanceof Z && r.addAll(t), r;\n      }\n      return l(i, t), s(i, [{\n        key: \"contains\",\n        value: function (t) {\n          var e,\n            n = a(this.array);\n          try {\n            for (n.s(); !(e = n.n()).done;) {\n              if (0 === e.value.compareTo(t)) return !0;\n            }\n          } catch (t) {\n            n.e(t);\n          } finally {\n            n.f();\n          }\n          return !1;\n        }\n      }, {\n        key: \"add\",\n        value: function (t) {\n          if (this.contains(t)) return !1;\n          for (var e = 0, n = this.array.length; e < n; e++) {\n            if (1 === this.array[e].compareTo(t)) return !!this.array.splice(e, 0, t);\n          }\n          return this.array.push(t), !0;\n        }\n      }, {\n        key: \"addAll\",\n        value: function (t) {\n          var e,\n            n = a(t);\n          try {\n            for (n.s(); !(e = n.n()).done;) {\n              var i = e.value;\n              this.add(i);\n            }\n          } catch (t) {\n            n.e(t);\n          } finally {\n            n.f();\n          }\n          return !0;\n        }\n      }, {\n        key: \"remove\",\n        value: function () {\n          throw new W();\n        }\n      }, {\n        key: \"size\",\n        value: function () {\n          return this.array.length;\n        }\n      }, {\n        key: \"isEmpty\",\n        value: function () {\n          return 0 === this.array.length;\n        }\n      }, {\n        key: \"toArray\",\n        value: function () {\n          return this.array.slice();\n        }\n      }, {\n        key: \"iterator\",\n        value: function () {\n          return new qt(this.array);\n        }\n      }]);\n    }(Ft),\n    qt = function () {\n      return s(function t(e) {\n        n(this, t), this.array = e, this.position = 0;\n      }, [{\n        key: \"next\",\n        value: function () {\n          if (this.position === this.array.length) throw new j();\n          return this.array[this.position++];\n        }\n      }, {\n        key: \"hasNext\",\n        value: function () {\n          return this.position < this.array.length;\n        }\n      }, {\n        key: \"remove\",\n        value: function () {\n          throw new W();\n        }\n      }]);\n    }(),\n    Yt = function (t) {\n      function i() {\n        var t;\n        return n(this, i), t = e(this, i), i.constructor_.apply(t, arguments), t;\n      }\n      return l(i, t), s(i, [{\n        key: \"computeEnvelopeInternal\",\n        value: function () {\n          for (var t = new U(), e = 0; e < this._geometries.length; e++) t.expandToInclude(this._geometries[e].getEnvelopeInternal());\n          return t;\n        }\n      }, {\n        key: \"getGeometryN\",\n        value: function (t) {\n          return this._geometries[t];\n        }\n      }, {\n        key: \"getCoordinates\",\n        value: function () {\n          for (var t = new Array(this.getNumPoints()).fill(null), e = -1, n = 0; n < this._geometries.length; n++) for (var i = this._geometries[n].getCoordinates(), r = 0; r < i.length; r++) t[++e] = i[r];\n          return t;\n        }\n      }, {\n        key: \"getArea\",\n        value: function () {\n          for (var t = 0, e = 0; e < this._geometries.length; e++) t += this._geometries[e].getArea();\n          return t;\n        }\n      }, {\n        key: \"copyInternal\",\n        value: function () {\n          for (var t = new Array(this._geometries.length).fill(null), e = 0; e < t.length; e++) t[e] = this._geometries[e].copy();\n          return new i(t, this._factory);\n        }\n      }, {\n        key: \"equalsExact\",\n        value: function () {\n          if (2 === arguments.length && \"number\" == typeof arguments[1] && arguments[0] instanceof V) {\n            var t = arguments[0],\n              e = arguments[1];\n            if (!this.isEquivalentClass(t)) return !1;\n            var n = t;\n            if (this._geometries.length !== n._geometries.length) return !1;\n            for (var r = 0; r < this._geometries.length; r++) if (!this._geometries[r].equalsExact(n._geometries[r], e)) return !1;\n            return !0;\n          }\n          return f(i, \"equalsExact\", this, 1).apply(this, arguments);\n        }\n      }, {\n        key: \"normalize\",\n        value: function () {\n          for (var t = 0; t < this._geometries.length; t++) this._geometries[t].normalize();\n          At.sort(this._geometries);\n        }\n      }, {\n        key: \"getCoordinate\",\n        value: function () {\n          return this.isEmpty() ? null : this._geometries[0].getCoordinate();\n        }\n      }, {\n        key: \"getBoundaryDimension\",\n        value: function () {\n          for (var t = Lt.FALSE, e = 0; e < this._geometries.length; e++) t = Math.max(t, this._geometries[e].getBoundaryDimension());\n          return t;\n        }\n      }, {\n        key: \"reverseInternal\",\n        value: function () {\n          for (var t = this._geometries.length, e = new yt(t), n = 0; n < t; n++) e.add(this._geometries[n].reverse());\n          return this.getFactory().buildGeometry(e);\n        }\n      }, {\n        key: \"getTypeCode\",\n        value: function () {\n          return V.TYPECODE_GEOMETRYCOLLECTION;\n        }\n      }, {\n        key: \"getDimension\",\n        value: function () {\n          for (var t = Lt.FALSE, e = 0; e < this._geometries.length; e++) t = Math.max(t, this._geometries[e].getDimension());\n          return t;\n        }\n      }, {\n        key: \"getLength\",\n        value: function () {\n          for (var t = 0, e = 0; e < this._geometries.length; e++) t += this._geometries[e].getLength();\n          return t;\n        }\n      }, {\n        key: \"getNumPoints\",\n        value: function () {\n          for (var t = 0, e = 0; e < this._geometries.length; e++) t += this._geometries[e].getNumPoints();\n          return t;\n        }\n      }, {\n        key: \"getNumGeometries\",\n        value: function () {\n          return this._geometries.length;\n        }\n      }, {\n        key: \"compareToSameClass\",\n        value: function () {\n          if (1 === arguments.length) {\n            var t = arguments[0],\n              e = new Gt(At.asList(this._geometries)),\n              n = new Gt(At.asList(t._geometries));\n            return this.compare(e, n);\n          }\n          if (2 === arguments.length) {\n            for (var i = arguments[1], r = arguments[0], s = this.getNumGeometries(), a = r.getNumGeometries(), o = 0; o < s && o < a;) {\n              var u = this.getGeometryN(o),\n                l = r.getGeometryN(o),\n                h = u.compareToSameClass(l, i);\n              if (0 !== h) return h;\n              o++;\n            }\n            return o < s ? 1 : o < a ? -1 : 0;\n          }\n        }\n      }, {\n        key: \"apply\",\n        value: function () {\n          if (rt(arguments[0], Et)) for (var t = arguments[0], e = 0; e < this._geometries.length; e++) this._geometries[e].apply(t);else if (rt(arguments[0], Rt)) {\n            var n = arguments[0];\n            if (0 === this._geometries.length) return null;\n            for (var i = 0; i < this._geometries.length && (this._geometries[i].apply(n), !n.isDone()); i++);\n            n.isGeometryChanged() && this.geometryChanged();\n          } else if (rt(arguments[0], Ct)) {\n            var r = arguments[0];\n            r.filter(this);\n            for (var s = 0; s < this._geometries.length; s++) this._geometries[s].apply(r);\n          } else if (rt(arguments[0], k)) {\n            var a = arguments[0];\n            a.filter(this);\n            for (var o = 0; o < this._geometries.length; o++) this._geometries[o].apply(a);\n          }\n        }\n      }, {\n        key: \"getBoundary\",\n        value: function () {\n          return V.checkNotGeometryCollection(this), G.shouldNeverReachHere(), null;\n        }\n      }, {\n        key: \"getGeometryType\",\n        value: function () {\n          return V.TYPENAME_GEOMETRYCOLLECTION;\n        }\n      }, {\n        key: \"isEmpty\",\n        value: function () {\n          for (var t = 0; t < this._geometries.length; t++) if (!this._geometries[t].isEmpty()) return !1;\n          return !0;\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          if (this._geometries = null, 0 === arguments.length) ;else if (2 === arguments.length) {\n            var t = arguments[0],\n              e = arguments[1];\n            if (V.constructor_.call(this, e), null === t && (t = []), V.hasNullElements(t)) throw new m(\"geometries must not contain null elements\");\n            this._geometries = t;\n          }\n        }\n      }]);\n    }(V),\n    zt = function (t) {\n      function i() {\n        var t;\n        return n(this, i), t = e(this, i), i.constructor_.apply(t, arguments), t;\n      }\n      return l(i, t), s(i, [{\n        key: \"copyInternal\",\n        value: function () {\n          for (var t = new Array(this._geometries.length).fill(null), e = 0; e < t.length; e++) t[e] = this._geometries[e].copy();\n          return new i(t, this._factory);\n        }\n      }, {\n        key: \"isValid\",\n        value: function () {\n          return !0;\n        }\n      }, {\n        key: \"equalsExact\",\n        value: function () {\n          if (2 === arguments.length && \"number\" == typeof arguments[1] && arguments[0] instanceof V) {\n            var t = arguments[0],\n              e = arguments[1];\n            return !!this.isEquivalentClass(t) && f(i, \"equalsExact\", this, 1).call(this, t, e);\n          }\n          return f(i, \"equalsExact\", this, 1).apply(this, arguments);\n        }\n      }, {\n        key: \"getCoordinate\",\n        value: function () {\n          if (1 === arguments.length && Number.isInteger(arguments[0])) {\n            var t = arguments[0];\n            return this._geometries[t].getCoordinate();\n          }\n          return f(i, \"getCoordinate\", this, 1).apply(this, arguments);\n        }\n      }, {\n        key: \"getBoundaryDimension\",\n        value: function () {\n          return Lt.FALSE;\n        }\n      }, {\n        key: \"getTypeCode\",\n        value: function () {\n          return V.TYPECODE_MULTIPOINT;\n        }\n      }, {\n        key: \"getDimension\",\n        value: function () {\n          return 0;\n        }\n      }, {\n        key: \"getBoundary\",\n        value: function () {\n          return this.getFactory().createGeometryCollection();\n        }\n      }, {\n        key: \"getGeometryType\",\n        value: function () {\n          return V.TYPENAME_MULTIPOINT;\n        }\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [Ot];\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          var t = arguments[0],\n            e = arguments[1];\n          Yt.constructor_.call(this, t, e);\n        }\n      }]);\n    }(Yt),\n    Xt = function (t) {\n      function i() {\n        var t;\n        return n(this, i), t = e(this, i), i.constructor_.apply(t, arguments), t;\n      }\n      return l(i, t), s(i, [{\n        key: \"copyInternal\",\n        value: function () {\n          return new i(this._points.copy(), this._factory);\n        }\n      }, {\n        key: \"getBoundaryDimension\",\n        value: function () {\n          return Lt.FALSE;\n        }\n      }, {\n        key: \"isClosed\",\n        value: function () {\n          return !!this.isEmpty() || f(i, \"isClosed\", this, 1).call(this);\n        }\n      }, {\n        key: \"reverseInternal\",\n        value: function () {\n          var t = this._points.copy();\n          return St.reverse(t), this.getFactory().createLinearRing(t);\n        }\n      }, {\n        key: \"getTypeCode\",\n        value: function () {\n          return V.TYPECODE_LINEARRING;\n        }\n      }, {\n        key: \"validateConstruction\",\n        value: function () {\n          if (!this.isEmpty() && !f(i, \"isClosed\", this, 1).call(this)) throw new m(\"Points of LinearRing do not form a closed linestring\");\n          if (this.getCoordinateSequence().size() >= 1 && this.getCoordinateSequence().size() < i.MINIMUM_VALID_SIZE) throw new m(\"Invalid number of points in LinearRing (found \" + this.getCoordinateSequence().size() + \" - must be 0 or >= 4)\");\n        }\n      }, {\n        key: \"getGeometryType\",\n        value: function () {\n          return V.TYPENAME_LINEARRING;\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          var t = arguments[0],\n            e = arguments[1];\n          wt.constructor_.call(this, t, e), this.validateConstruction();\n        }\n      }]);\n    }(wt);\n  Xt.MINIMUM_VALID_SIZE = 4;\n  var Bt = function (t) {\n    function i() {\n      var t;\n      return n(this, i), t = e(this, i), i.constructor_.apply(t, arguments), t;\n    }\n    return l(i, t), s(i, [{\n      key: \"setOrdinate\",\n      value: function (t, e) {\n        switch (t) {\n          case i.X:\n            this.x = e;\n            break;\n          case i.Y:\n            this.y = e;\n            break;\n          default:\n            throw new m(\"Invalid ordinate index: \" + t);\n        }\n      }\n    }, {\n      key: \"getZ\",\n      value: function () {\n        return X.NULL_ORDINATE;\n      }\n    }, {\n      key: \"getOrdinate\",\n      value: function (t) {\n        switch (t) {\n          case i.X:\n            return this.x;\n          case i.Y:\n            return this.y;\n        }\n        throw new m(\"Invalid ordinate index: \" + t);\n      }\n    }, {\n      key: \"setZ\",\n      value: function (t) {\n        throw new m(\"CoordinateXY dimension 2 does not support z-ordinate\");\n      }\n    }, {\n      key: \"copy\",\n      value: function () {\n        return new i(this);\n      }\n    }, {\n      key: \"toString\",\n      value: function () {\n        return \"(\" + this.x + \", \" + this.y + \")\";\n      }\n    }, {\n      key: \"setCoordinate\",\n      value: function (t) {\n        this.x = t.x, this.y = t.y, this.z = t.getZ();\n      }\n    }], [{\n      key: \"constructor_\",\n      value: function () {\n        if (0 === arguments.length) X.constructor_.call(this);else if (1 === arguments.length) {\n          if (arguments[0] instanceof i) {\n            var t = arguments[0];\n            X.constructor_.call(this, t.x, t.y);\n          } else if (arguments[0] instanceof X) {\n            var e = arguments[0];\n            X.constructor_.call(this, e.x, e.y);\n          }\n        } else if (2 === arguments.length) {\n          var n = arguments[0],\n            r = arguments[1];\n          X.constructor_.call(this, n, r, X.NULL_ORDINATE);\n        }\n      }\n    }]);\n  }(X);\n  Bt.X = 0, Bt.Y = 1, Bt.Z = -1, Bt.M = -1;\n  var Ut = function (t) {\n    function i() {\n      var t;\n      return n(this, i), t = e(this, i), i.constructor_.apply(t, arguments), t;\n    }\n    return l(i, t), s(i, [{\n      key: \"getM\",\n      value: function () {\n        return this._m;\n      }\n    }, {\n      key: \"setOrdinate\",\n      value: function (t, e) {\n        switch (t) {\n          case i.X:\n            this.x = e;\n            break;\n          case i.Y:\n            this.y = e;\n            break;\n          case i.M:\n            this._m = e;\n            break;\n          default:\n            throw new m(\"Invalid ordinate index: \" + t);\n        }\n      }\n    }, {\n      key: \"setM\",\n      value: function (t) {\n        this._m = t;\n      }\n    }, {\n      key: \"getZ\",\n      value: function () {\n        return X.NULL_ORDINATE;\n      }\n    }, {\n      key: \"getOrdinate\",\n      value: function (t) {\n        switch (t) {\n          case i.X:\n            return this.x;\n          case i.Y:\n            return this.y;\n          case i.M:\n            return this._m;\n        }\n        throw new m(\"Invalid ordinate index: \" + t);\n      }\n    }, {\n      key: \"setZ\",\n      value: function (t) {\n        throw new m(\"CoordinateXY dimension 2 does not support z-ordinate\");\n      }\n    }, {\n      key: \"copy\",\n      value: function () {\n        return new i(this);\n      }\n    }, {\n      key: \"toString\",\n      value: function () {\n        return \"(\" + this.x + \", \" + this.y + \" m=\" + this.getM() + \")\";\n      }\n    }, {\n      key: \"setCoordinate\",\n      value: function (t) {\n        this.x = t.x, this.y = t.y, this.z = t.getZ(), this._m = t.getM();\n      }\n    }], [{\n      key: \"constructor_\",\n      value: function () {\n        if (this._m = null, 0 === arguments.length) X.constructor_.call(this), this._m = 0;else if (1 === arguments.length) {\n          if (arguments[0] instanceof i) {\n            var t = arguments[0];\n            X.constructor_.call(this, t.x, t.y), this._m = t._m;\n          } else if (arguments[0] instanceof X) {\n            var e = arguments[0];\n            X.constructor_.call(this, e.x, e.y), this._m = this.getM();\n          }\n        } else if (3 === arguments.length) {\n          var n = arguments[0],\n            r = arguments[1],\n            s = arguments[2];\n          X.constructor_.call(this, n, r, X.NULL_ORDINATE), this._m = s;\n        }\n      }\n    }]);\n  }(X);\n  Ut.X = 0, Ut.Y = 1, Ut.Z = -1, Ut.M = 2;\n  var Vt = function (t) {\n      function i() {\n        var t;\n        return n(this, i), t = e(this, i), i.constructor_.apply(t, arguments), t;\n      }\n      return l(i, t), s(i, [{\n        key: \"getM\",\n        value: function () {\n          return this._m;\n        }\n      }, {\n        key: \"setOrdinate\",\n        value: function (t, e) {\n          switch (t) {\n            case X.X:\n              this.x = e;\n              break;\n            case X.Y:\n              this.y = e;\n              break;\n            case X.Z:\n              this.z = e;\n              break;\n            case X.M:\n              this._m = e;\n              break;\n            default:\n              throw new m(\"Invalid ordinate index: \" + t);\n          }\n        }\n      }, {\n        key: \"setM\",\n        value: function (t) {\n          this._m = t;\n        }\n      }, {\n        key: \"getOrdinate\",\n        value: function (t) {\n          switch (t) {\n            case X.X:\n              return this.x;\n            case X.Y:\n              return this.y;\n            case X.Z:\n              return this.getZ();\n            case X.M:\n              return this.getM();\n          }\n          throw new m(\"Invalid ordinate index: \" + t);\n        }\n      }, {\n        key: \"copy\",\n        value: function () {\n          return new i(this);\n        }\n      }, {\n        key: \"toString\",\n        value: function () {\n          return \"(\" + this.x + \", \" + this.y + \", \" + this.getZ() + \" m=\" + this.getM() + \")\";\n        }\n      }, {\n        key: \"setCoordinate\",\n        value: function (t) {\n          this.x = t.x, this.y = t.y, this.z = t.getZ(), this._m = t.getM();\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          if (this._m = null, 0 === arguments.length) X.constructor_.call(this), this._m = 0;else if (1 === arguments.length) {\n            if (arguments[0] instanceof i) {\n              var t = arguments[0];\n              X.constructor_.call(this, t), this._m = t._m;\n            } else if (arguments[0] instanceof X) {\n              var e = arguments[0];\n              X.constructor_.call(this, e), this._m = this.getM();\n            }\n          } else if (4 === arguments.length) {\n            var n = arguments[0],\n              r = arguments[1],\n              s = arguments[2],\n              a = arguments[3];\n            X.constructor_.call(this, n, r, s), this._m = a;\n          }\n        }\n      }]);\n    }(X),\n    Ht = function () {\n      function t() {\n        n(this, t);\n      }\n      return s(t, null, [{\n        key: \"measures\",\n        value: function (t) {\n          return t instanceof Bt ? 0 : t instanceof Ut || t instanceof Vt ? 1 : 0;\n        }\n      }, {\n        key: \"dimension\",\n        value: function (t) {\n          return t instanceof Bt ? 2 : t instanceof Ut ? 3 : t instanceof Vt ? 4 : 3;\n        }\n      }, {\n        key: \"create\",\n        value: function () {\n          if (1 === arguments.length) {\n            var e = arguments[0];\n            return t.create(e, 0);\n          }\n          if (2 === arguments.length) {\n            var n = arguments[0],\n              i = arguments[1];\n            return 2 === n ? new Bt() : 3 === n && 0 === i ? new X() : 3 === n && 1 === i ? new Ut() : 4 === n && 1 === i ? new Vt() : new X();\n          }\n        }\n      }]);\n    }(),\n    Zt = function (t) {\n      function i() {\n        var t;\n        return n(this, i), t = e(this, i), i.constructor_.apply(t, arguments), t;\n      }\n      return l(i, t), s(i, [{\n        key: \"getCoordinate\",\n        value: function (t) {\n          return this.get(t);\n        }\n      }, {\n        key: \"addAll\",\n        value: function () {\n          if (2 === arguments.length && \"boolean\" == typeof arguments[1] && rt(arguments[0], Z)) {\n            for (var t = arguments[1], e = !1, n = arguments[0].iterator(); n.hasNext();) this.add(n.next(), t), e = !0;\n            return e;\n          }\n          return f(i, \"addAll\", this, 1).apply(this, arguments);\n        }\n      }, {\n        key: \"clone\",\n        value: function () {\n          for (var t = f(i, \"clone\", this, 1).call(this), e = 0; e < this.size(); e++) t.add(e, this.get(e).clone());\n          return t;\n        }\n      }, {\n        key: \"toCoordinateArray\",\n        value: function () {\n          if (0 === arguments.length) return this.toArray(i.coordArrayType);\n          if (1 === arguments.length) {\n            if (arguments[0]) return this.toArray(i.coordArrayType);\n            for (var t = this.size(), e = new Array(t).fill(null), n = 0; n < t; n++) e[n] = this.get(t - n - 1);\n            return e;\n          }\n        }\n      }, {\n        key: \"add\",\n        value: function () {\n          if (1 === arguments.length) {\n            var t = arguments[0];\n            return f(i, \"add\", this, 1).call(this, t);\n          }\n          if (2 === arguments.length) {\n            if (arguments[0] instanceof Array && \"boolean\" == typeof arguments[1]) {\n              var e = arguments[0],\n                n = arguments[1];\n              return this.add(e, n, !0), !0;\n            }\n            if (arguments[0] instanceof X && \"boolean\" == typeof arguments[1]) {\n              var r = arguments[0];\n              if (!arguments[1] && this.size() >= 1) if (this.get(this.size() - 1).equals2D(r)) return null;\n              f(i, \"add\", this, 1).call(this, r);\n            } else if (arguments[0] instanceof Object && \"boolean\" == typeof arguments[1]) {\n              var s = arguments[0],\n                a = arguments[1];\n              return this.add(s, a), !0;\n            }\n          } else if (3 === arguments.length) {\n            if (\"boolean\" == typeof arguments[2] && arguments[0] instanceof Array && \"boolean\" == typeof arguments[1]) {\n              var o = arguments[0],\n                u = arguments[1];\n              if (arguments[2]) for (var l = 0; l < o.length; l++) this.add(o[l], u);else for (var h = o.length - 1; h >= 0; h--) this.add(o[h], u);\n              return !0;\n            }\n            if (\"boolean\" == typeof arguments[2] && Number.isInteger(arguments[0]) && arguments[1] instanceof X) {\n              var c = arguments[0],\n                g = arguments[1];\n              if (!arguments[2]) {\n                var v = this.size();\n                if (v > 0) {\n                  if (c > 0) if (this.get(c - 1).equals2D(g)) return null;\n                  if (c < v) if (this.get(c).equals2D(g)) return null;\n                }\n              }\n              f(i, \"add\", this, 1).call(this, c, g);\n            }\n          } else if (4 === arguments.length) {\n            var y = arguments[0],\n              d = arguments[1],\n              _ = arguments[2],\n              p = arguments[3],\n              m = 1;\n            _ > p && (m = -1);\n            for (var k = _; k !== p; k += m) this.add(y[k], d);\n            return !0;\n          }\n        }\n      }, {\n        key: \"closeRing\",\n        value: function () {\n          if (this.size() > 0) {\n            var t = this.get(0).copy();\n            this.add(t, !1);\n          }\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          if (0 === arguments.length) ;else if (1 === arguments.length) {\n            var t = arguments[0];\n            this.ensureCapacity(t.length), this.add(t, !0);\n          } else if (2 === arguments.length) {\n            var e = arguments[0],\n              n = arguments[1];\n            this.ensureCapacity(e.length), this.add(e, n);\n          }\n        }\n      }]);\n    }(yt);\n  Zt.coordArrayType = new Array(0).fill(null);\n  var jt = function () {\n      function t() {\n        n(this, t);\n      }\n      return s(t, null, [{\n        key: \"isRing\",\n        value: function (t) {\n          return !(t.length < 4) && !!t[0].equals2D(t[t.length - 1]);\n        }\n      }, {\n        key: \"ptNotInList\",\n        value: function (e, n) {\n          for (var i = 0; i < e.length; i++) {\n            var r = e[i];\n            if (t.indexOf(r, n) < 0) return r;\n          }\n          return null;\n        }\n      }, {\n        key: \"scroll\",\n        value: function (e, n) {\n          var i = t.indexOf(n, e);\n          if (i < 0) return null;\n          var r = new Array(e.length).fill(null);\n          mt.arraycopy(e, i, r, 0, e.length - i), mt.arraycopy(e, 0, r, e.length - i, i), mt.arraycopy(r, 0, e, 0, e.length);\n        }\n      }, {\n        key: \"equals\",\n        value: function () {\n          if (2 === arguments.length) {\n            var t = arguments[0],\n              e = arguments[1];\n            if (t === e) return !0;\n            if (null === t || null === e) return !1;\n            if (t.length !== e.length) return !1;\n            for (var n = 0; n < t.length; n++) if (!t[n].equals(e[n])) return !1;\n            return !0;\n          }\n          if (3 === arguments.length) {\n            var i = arguments[0],\n              r = arguments[1],\n              s = arguments[2];\n            if (i === r) return !0;\n            if (null === i || null === r) return !1;\n            if (i.length !== r.length) return !1;\n            for (var a = 0; a < i.length; a++) if (0 !== s.compare(i[a], r[a])) return !1;\n            return !0;\n          }\n        }\n      }, {\n        key: \"intersection\",\n        value: function (t, e) {\n          for (var n = new Zt(), i = 0; i < t.length; i++) e.intersects(t[i]) && n.add(t[i], !0);\n          return n.toCoordinateArray();\n        }\n      }, {\n        key: \"measures\",\n        value: function (t) {\n          if (null === t || 0 === t.length) return 0;\n          var e,\n            n = 0,\n            i = a(t);\n          try {\n            for (i.s(); !(e = i.n()).done;) {\n              var r = e.value;\n              n = Math.max(n, Ht.measures(r));\n            }\n          } catch (t) {\n            i.e(t);\n          } finally {\n            i.f();\n          }\n          return n;\n        }\n      }, {\n        key: \"hasRepeatedPoints\",\n        value: function (t) {\n          for (var e = 1; e < t.length; e++) if (t[e - 1].equals(t[e])) return !0;\n          return !1;\n        }\n      }, {\n        key: \"removeRepeatedPoints\",\n        value: function (e) {\n          return t.hasRepeatedPoints(e) ? new Zt(e, !1).toCoordinateArray() : e;\n        }\n      }, {\n        key: \"reverse\",\n        value: function (t) {\n          for (var e = t.length - 1, n = Math.trunc(e / 2), i = 0; i <= n; i++) {\n            var r = t[i];\n            t[i] = t[e - i], t[e - i] = r;\n          }\n        }\n      }, {\n        key: \"removeNull\",\n        value: function (t) {\n          for (var e = 0, n = 0; n < t.length; n++) null !== t[n] && e++;\n          var i = new Array(e).fill(null);\n          if (0 === e) return i;\n          for (var r = 0, s = 0; s < t.length; s++) null !== t[s] && (i[r++] = t[s]);\n          return i;\n        }\n      }, {\n        key: \"copyDeep\",\n        value: function () {\n          if (1 === arguments.length) {\n            for (var t = arguments[0], e = new Array(t.length).fill(null), n = 0; n < t.length; n++) e[n] = t[n].copy();\n            return e;\n          }\n          if (5 === arguments.length) for (var i = arguments[0], r = arguments[1], s = arguments[2], a = arguments[3], o = arguments[4], u = 0; u < o; u++) s[a + u] = i[r + u].copy();\n        }\n      }, {\n        key: \"isEqualReversed\",\n        value: function (t, e) {\n          for (var n = 0; n < t.length; n++) {\n            var i = t[n],\n              r = e[t.length - n - 1];\n            if (0 !== i.compareTo(r)) return !1;\n          }\n          return !0;\n        }\n      }, {\n        key: \"envelope\",\n        value: function (t) {\n          for (var e = new U(), n = 0; n < t.length; n++) e.expandToInclude(t[n]);\n          return e;\n        }\n      }, {\n        key: \"toCoordinateArray\",\n        value: function (e) {\n          return e.toArray(t.coordArrayType);\n        }\n      }, {\n        key: \"dimension\",\n        value: function (t) {\n          if (null === t || 0 === t.length) return 3;\n          var e,\n            n = 0,\n            i = a(t);\n          try {\n            for (i.s(); !(e = i.n()).done;) {\n              var r = e.value;\n              n = Math.max(n, Ht.dimension(r));\n            }\n          } catch (t) {\n            i.e(t);\n          } finally {\n            i.f();\n          }\n          return n;\n        }\n      }, {\n        key: \"atLeastNCoordinatesOrNothing\",\n        value: function (t, e) {\n          return e.length >= t ? e : [];\n        }\n      }, {\n        key: \"indexOf\",\n        value: function (t, e) {\n          for (var n = 0; n < e.length; n++) if (t.equals(e[n])) return n;\n          return -1;\n        }\n      }, {\n        key: \"increasingDirection\",\n        value: function (t) {\n          for (var e = 0; e < Math.trunc(t.length / 2); e++) {\n            var n = t.length - 1 - e,\n              i = t[e].compareTo(t[n]);\n            if (0 !== i) return i;\n          }\n          return 1;\n        }\n      }, {\n        key: \"compare\",\n        value: function (t, e) {\n          for (var n = 0; n < t.length && n < e.length;) {\n            var i = t[n].compareTo(e[n]);\n            if (0 !== i) return i;\n            n++;\n          }\n          return n < e.length ? -1 : n < t.length ? 1 : 0;\n        }\n      }, {\n        key: \"minCoordinate\",\n        value: function (t) {\n          for (var e = null, n = 0; n < t.length; n++) (null === e || e.compareTo(t[n]) > 0) && (e = t[n]);\n          return e;\n        }\n      }, {\n        key: \"extract\",\n        value: function (t, e, n) {\n          e = kt.clamp(e, 0, t.length);\n          var i = (n = kt.clamp(n, -1, t.length)) - e + 1;\n          n < 0 && (i = 0), e >= t.length && (i = 0), n < e && (i = 0);\n          var r = new Array(i).fill(null);\n          if (0 === i) return r;\n          for (var s = 0, a = e; a <= n; a++) r[s++] = t[a];\n          return r;\n        }\n      }]);\n    }(),\n    Wt = function () {\n      return s(function t() {\n        n(this, t);\n      }, [{\n        key: \"compare\",\n        value: function (t, e) {\n          var n = t,\n            i = e;\n          return jt.compare(n, i);\n        }\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [P];\n        }\n      }]);\n    }(),\n    Kt = function () {\n      return s(function t() {\n        n(this, t);\n      }, [{\n        key: \"compare\",\n        value: function (t, e) {\n          var n = t,\n            i = e;\n          if (n.length < i.length) return -1;\n          if (n.length > i.length) return 1;\n          if (0 === n.length) return 0;\n          var r = jt.compare(n, i);\n          return jt.isEqualReversed(n, i) ? 0 : r;\n        }\n      }, {\n        key: \"OLDcompare\",\n        value: function (t, e) {\n          var n = t,\n            i = e;\n          if (n.length < i.length) return -1;\n          if (n.length > i.length) return 1;\n          if (0 === n.length) return 0;\n          for (var r = jt.increasingDirection(n), s = jt.increasingDirection(i), a = r > 0 ? 0 : n.length - 1, o = s > 0 ? 0 : n.length - 1, u = 0; u < n.length; u++) {\n            var l = n[a].compareTo(i[o]);\n            if (0 !== l) return l;\n            a += r, o += s;\n          }\n          return 0;\n        }\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [P];\n        }\n      }]);\n    }();\n  jt.ForwardComparator = Wt, jt.BidirectionalComparator = Kt, jt.coordArrayType = new Array(0).fill(null);\n  var Jt = function () {\n      return s(function t(e) {\n        n(this, t), this.str = e;\n      }, [{\n        key: \"append\",\n        value: function (t) {\n          this.str += t;\n        }\n      }, {\n        key: \"setCharAt\",\n        value: function (t, e) {\n          this.str = this.str.substr(0, t) + e + this.str.substr(t + 1);\n        }\n      }, {\n        key: \"toString\",\n        value: function () {\n          return this.str;\n        }\n      }]);\n    }(),\n    Qt = function () {\n      function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }\n      return s(t, [{\n        key: \"getM\",\n        value: function (t) {\n          return this.hasM() ? this._coordinates[t].getM() : A.NaN;\n        }\n      }, {\n        key: \"setOrdinate\",\n        value: function (t, e, n) {\n          switch (e) {\n            case ht.X:\n              this._coordinates[t].x = n;\n              break;\n            case ht.Y:\n              this._coordinates[t].y = n;\n              break;\n            default:\n              this._coordinates[t].setOrdinate(e, n);\n          }\n        }\n      }, {\n        key: \"getZ\",\n        value: function (t) {\n          return this.hasZ() ? this._coordinates[t].getZ() : A.NaN;\n        }\n      }, {\n        key: \"size\",\n        value: function () {\n          return this._coordinates.length;\n        }\n      }, {\n        key: \"getOrdinate\",\n        value: function (t, e) {\n          switch (e) {\n            case ht.X:\n              return this._coordinates[t].x;\n            case ht.Y:\n              return this._coordinates[t].y;\n            default:\n              return this._coordinates[t].getOrdinate(e);\n          }\n        }\n      }, {\n        key: \"getCoordinate\",\n        value: function () {\n          if (1 === arguments.length) {\n            var t = arguments[0];\n            return this._coordinates[t];\n          }\n          if (2 === arguments.length) {\n            var e = arguments[0];\n            arguments[1].setCoordinate(this._coordinates[e]);\n          }\n        }\n      }, {\n        key: \"getCoordinateCopy\",\n        value: function (t) {\n          var e = this.createCoordinate();\n          return e.setCoordinate(this._coordinates[t]), e;\n        }\n      }, {\n        key: \"createCoordinate\",\n        value: function () {\n          return Ht.create(this.getDimension(), this.getMeasures());\n        }\n      }, {\n        key: \"getDimension\",\n        value: function () {\n          return this._dimension;\n        }\n      }, {\n        key: \"getX\",\n        value: function (t) {\n          return this._coordinates[t].x;\n        }\n      }, {\n        key: \"getMeasures\",\n        value: function () {\n          return this._measures;\n        }\n      }, {\n        key: \"expandEnvelope\",\n        value: function (t) {\n          for (var e = 0; e < this._coordinates.length; e++) t.expandToInclude(this._coordinates[e]);\n          return t;\n        }\n      }, {\n        key: \"copy\",\n        value: function () {\n          for (var e = new Array(this.size()).fill(null), n = 0; n < this._coordinates.length; n++) {\n            var i = this.createCoordinate();\n            i.setCoordinate(this._coordinates[n]), e[n] = i;\n          }\n          return new t(e, this._dimension, this._measures);\n        }\n      }, {\n        key: \"toString\",\n        value: function () {\n          if (this._coordinates.length > 0) {\n            var t = new Jt(17 * this._coordinates.length);\n            t.append(\"(\"), t.append(this._coordinates[0]);\n            for (var e = 1; e < this._coordinates.length; e++) t.append(\", \"), t.append(this._coordinates[e]);\n            return t.append(\")\"), t.toString();\n          }\n          return \"()\";\n        }\n      }, {\n        key: \"getY\",\n        value: function (t) {\n          return this._coordinates[t].y;\n        }\n      }, {\n        key: \"toCoordinateArray\",\n        value: function () {\n          return this._coordinates;\n        }\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [ht, E];\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          if (this._dimension = 3, this._measures = 0, this._coordinates = null, 1 === arguments.length) {\n            if (arguments[0] instanceof Array) {\n              var e = arguments[0];\n              t.constructor_.call(this, e, jt.dimension(e), jt.measures(e));\n            } else if (Number.isInteger(arguments[0])) {\n              var n = arguments[0];\n              this._coordinates = new Array(n).fill(null);\n              for (var i = 0; i < n; i++) this._coordinates[i] = new X();\n            } else if (rt(arguments[0], ht)) {\n              var r = arguments[0];\n              if (null === r) return this._coordinates = new Array(0).fill(null), null;\n              this._dimension = r.getDimension(), this._measures = r.getMeasures(), this._coordinates = new Array(r.size()).fill(null);\n              for (var s = 0; s < this._coordinates.length; s++) this._coordinates[s] = r.getCoordinateCopy(s);\n            }\n          } else if (2 === arguments.length) {\n            if (arguments[0] instanceof Array && Number.isInteger(arguments[1])) {\n              var a = arguments[0],\n                o = arguments[1];\n              t.constructor_.call(this, a, o, jt.measures(a));\n            } else if (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {\n              var u = arguments[0],\n                l = arguments[1];\n              this._coordinates = new Array(u).fill(null), this._dimension = l;\n              for (var h = 0; h < u; h++) this._coordinates[h] = Ht.create(l);\n            }\n          } else if (3 === arguments.length) if (Number.isInteger(arguments[2]) && arguments[0] instanceof Array && Number.isInteger(arguments[1])) {\n            var c = arguments[0],\n              f = arguments[1],\n              g = arguments[2];\n            this._dimension = f, this._measures = g, this._coordinates = null === c ? new Array(0).fill(null) : c;\n          } else if (Number.isInteger(arguments[2]) && Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {\n            var v = arguments[0],\n              y = arguments[1],\n              d = arguments[2];\n            this._coordinates = new Array(v).fill(null), this._dimension = y, this._measures = d;\n            for (var _ = 0; _ < v; _++) this._coordinates[_] = this.createCoordinate();\n          }\n        }\n      }]);\n    }(),\n    $t = function () {\n      function t() {\n        n(this, t);\n      }\n      return s(t, [{\n        key: \"readResolve\",\n        value: function () {\n          return t.instance();\n        }\n      }, {\n        key: \"create\",\n        value: function () {\n          if (1 === arguments.length) {\n            if (arguments[0] instanceof Array) return new Qt(arguments[0]);\n            if (rt(arguments[0], ht)) return new Qt(arguments[0]);\n          } else {\n            if (2 === arguments.length) {\n              var t = arguments[1];\n              return t > 3 && (t = 3), t < 2 && (t = 2), new Qt(arguments[0], t);\n            }\n            if (3 === arguments.length) {\n              var e = arguments[2],\n                n = arguments[1] - e;\n              return e > 1 && (e = 1), n > 3 && (n = 3), n < 2 && (n = 2), new Qt(arguments[0], n + e, e);\n            }\n          }\n        }\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [It, E];\n        }\n      }], [{\n        key: \"instance\",\n        value: function () {\n          return t.instanceObject;\n        }\n      }]);\n    }();\n  $t.instanceObject = new $t();\n  var te = function (t) {\n      function i() {\n        var t;\n        return n(this, i), t = e(this, i), i.constructor_.apply(t, arguments), t;\n      }\n      return l(i, t), s(i, [{\n        key: \"copyInternal\",\n        value: function () {\n          for (var t = new Array(this._geometries.length).fill(null), e = 0; e < t.length; e++) t[e] = this._geometries[e].copy();\n          return new i(t, this._factory);\n        }\n      }, {\n        key: \"equalsExact\",\n        value: function () {\n          if (2 === arguments.length && \"number\" == typeof arguments[1] && arguments[0] instanceof V) {\n            var t = arguments[0],\n              e = arguments[1];\n            return !!this.isEquivalentClass(t) && f(i, \"equalsExact\", this, 1).call(this, t, e);\n          }\n          return f(i, \"equalsExact\", this, 1).apply(this, arguments);\n        }\n      }, {\n        key: \"getBoundaryDimension\",\n        value: function () {\n          return 1;\n        }\n      }, {\n        key: \"getTypeCode\",\n        value: function () {\n          return V.TYPECODE_MULTIPOLYGON;\n        }\n      }, {\n        key: \"getDimension\",\n        value: function () {\n          return 2;\n        }\n      }, {\n        key: \"getBoundary\",\n        value: function () {\n          if (this.isEmpty()) return this.getFactory().createMultiLineString();\n          for (var t = new yt(), e = 0; e < this._geometries.length; e++) for (var n = this._geometries[e].getBoundary(), i = 0; i < n.getNumGeometries(); i++) t.add(n.getGeometryN(i));\n          var r = new Array(t.size()).fill(null);\n          return this.getFactory().createMultiLineString(t.toArray(r));\n        }\n      }, {\n        key: \"getGeometryType\",\n        value: function () {\n          return V.TYPENAME_MULTIPOLYGON;\n        }\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [Pt];\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          var t = arguments[0],\n            e = arguments[1];\n          Yt.constructor_.call(this, t, e);\n        }\n      }]);\n    }(Yt),\n    ee = function () {\n      return s(function t() {\n        n(this, t);\n      }, [{\n        key: \"get\",\n        value: function () {}\n      }, {\n        key: \"put\",\n        value: function () {}\n      }, {\n        key: \"size\",\n        value: function () {}\n      }, {\n        key: \"values\",\n        value: function () {}\n      }, {\n        key: \"entrySet\",\n        value: function () {}\n      }]);\n    }(),\n    ne = function (t) {\n      function i() {\n        var t;\n        return n(this, i), (t = e(this, i)).map = new Map(), t;\n      }\n      return l(i, t), s(i, [{\n        key: \"get\",\n        value: function (t) {\n          return this.map.get(t) || null;\n        }\n      }, {\n        key: \"put\",\n        value: function (t, e) {\n          return this.map.set(t, e), e;\n        }\n      }, {\n        key: \"values\",\n        value: function () {\n          for (var t = new yt(), e = this.map.values(), n = e.next(); !n.done;) t.add(n.value), n = e.next();\n          return t;\n        }\n      }, {\n        key: \"entrySet\",\n        value: function () {\n          var t = new J();\n          return this.map.entries().forEach(function (e) {\n            return t.add(e);\n          }), t;\n        }\n      }, {\n        key: \"size\",\n        value: function () {\n          return this.map.size();\n        }\n      }]);\n    }(ee),\n    ie = function () {\n      function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }\n      return s(t, [{\n        key: \"equals\",\n        value: function (e) {\n          if (!(e instanceof t)) return !1;\n          var n = e;\n          return this._modelType === n._modelType && this._scale === n._scale;\n        }\n      }, {\n        key: \"compareTo\",\n        value: function (t) {\n          var e = t,\n            n = this.getMaximumSignificantDigits(),\n            i = e.getMaximumSignificantDigits();\n          return at.compare(n, i);\n        }\n      }, {\n        key: \"getScale\",\n        value: function () {\n          return this._scale;\n        }\n      }, {\n        key: \"isFloating\",\n        value: function () {\n          return this._modelType === t.FLOATING || this._modelType === t.FLOATING_SINGLE;\n        }\n      }, {\n        key: \"getType\",\n        value: function () {\n          return this._modelType;\n        }\n      }, {\n        key: \"toString\",\n        value: function () {\n          var e = \"UNKNOWN\";\n          return this._modelType === t.FLOATING ? e = \"Floating\" : this._modelType === t.FLOATING_SINGLE ? e = \"Floating-Single\" : this._modelType === t.FIXED && (e = \"Fixed (Scale=\" + this.getScale() + \")\"), e;\n        }\n      }, {\n        key: \"makePrecise\",\n        value: function () {\n          if (\"number\" == typeof arguments[0]) {\n            var e = arguments[0];\n            return A.isNaN(e) || this._modelType === t.FLOATING_SINGLE ? e : this._modelType === t.FIXED ? Math.round(e * this._scale) / this._scale : e;\n          }\n          if (arguments[0] instanceof X) {\n            var n = arguments[0];\n            if (this._modelType === t.FLOATING) return null;\n            n.x = this.makePrecise(n.x), n.y = this.makePrecise(n.y);\n          }\n        }\n      }, {\n        key: \"getMaximumSignificantDigits\",\n        value: function () {\n          var e = 16;\n          return this._modelType === t.FLOATING ? e = 16 : this._modelType === t.FLOATING_SINGLE ? e = 6 : this._modelType === t.FIXED && (e = 1 + Math.trunc(Math.ceil(Math.log(this.getScale()) / Math.log(10)))), e;\n        }\n      }, {\n        key: \"setScale\",\n        value: function (t) {\n          this._scale = Math.abs(t);\n        }\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [E, x];\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          if (this._modelType = null, this._scale = null, 0 === arguments.length) this._modelType = t.FLOATING;else if (1 === arguments.length) if (arguments[0] instanceof re) {\n            var e = arguments[0];\n            this._modelType = e, e === t.FIXED && this.setScale(1);\n          } else if (\"number\" == typeof arguments[0]) {\n            var n = arguments[0];\n            this._modelType = t.FIXED, this.setScale(n);\n          } else if (arguments[0] instanceof t) {\n            var i = arguments[0];\n            this._modelType = i._modelType, this._scale = i._scale;\n          }\n        }\n      }, {\n        key: \"mostPrecise\",\n        value: function (t, e) {\n          return t.compareTo(e) >= 0 ? t : e;\n        }\n      }]);\n    }(),\n    re = function () {\n      function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }\n      return s(t, [{\n        key: \"readResolve\",\n        value: function () {\n          return t.nameToTypeMap.get(this._name);\n        }\n      }, {\n        key: \"toString\",\n        value: function () {\n          return this._name;\n        }\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [E];\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this._name = null;\n          var e = arguments[0];\n          this._name = e, t.nameToTypeMap.put(e, this);\n        }\n      }]);\n    }();\n  re.nameToTypeMap = new ne(), ie.Type = re, ie.FIXED = new re(\"FIXED\"), ie.FLOATING = new re(\"FLOATING\"), ie.FLOATING_SINGLE = new re(\"FLOATING SINGLE\"), ie.maximumPreciseValue = 9007199254740992;\n  var se = function (t) {\n      function i() {\n        var t;\n        return n(this, i), t = e(this, i), i.constructor_.apply(t, arguments), t;\n      }\n      return l(i, t), s(i, [{\n        key: \"copyInternal\",\n        value: function () {\n          for (var t = new Array(this._geometries.length).fill(null), e = 0; e < t.length; e++) t[e] = this._geometries[e].copy();\n          return new i(t, this._factory);\n        }\n      }, {\n        key: \"equalsExact\",\n        value: function () {\n          if (2 === arguments.length && \"number\" == typeof arguments[1] && arguments[0] instanceof V) {\n            var t = arguments[0],\n              e = arguments[1];\n            return !!this.isEquivalentClass(t) && f(i, \"equalsExact\", this, 1).call(this, t, e);\n          }\n          return f(i, \"equalsExact\", this, 1).apply(this, arguments);\n        }\n      }, {\n        key: \"getBoundaryDimension\",\n        value: function () {\n          return this.isClosed() ? Lt.FALSE : 0;\n        }\n      }, {\n        key: \"isClosed\",\n        value: function () {\n          if (this.isEmpty()) return !1;\n          for (var t = 0; t < this._geometries.length; t++) if (!this._geometries[t].isClosed()) return !1;\n          return !0;\n        }\n      }, {\n        key: \"getTypeCode\",\n        value: function () {\n          return V.TYPECODE_MULTILINESTRING;\n        }\n      }, {\n        key: \"getDimension\",\n        value: function () {\n          return 1;\n        }\n      }, {\n        key: \"getBoundary\",\n        value: function () {\n          throw new W();\n        }\n      }, {\n        key: \"getGeometryType\",\n        value: function () {\n          return V.TYPENAME_MULTILINESTRING;\n        }\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [Tt];\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          var t = arguments[0],\n            e = arguments[1];\n          Yt.constructor_.call(this, t, e);\n        }\n      }]);\n    }(Yt),\n    ae = function () {\n      function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }\n      return s(t, [{\n        key: \"createEmpty\",\n        value: function (t) {\n          switch (t) {\n            case -1:\n              return this.createGeometryCollection();\n            case 0:\n              return this.createPoint();\n            case 1:\n              return this.createLineString();\n            case 2:\n              return this.createPolygon();\n            default:\n              throw new m(\"Invalid dimension: \" + t);\n          }\n        }\n      }, {\n        key: \"toGeometry\",\n        value: function (t) {\n          return t.isNull() ? this.createPoint() : t.getMinX() === t.getMaxX() && t.getMinY() === t.getMaxY() ? this.createPoint(new X(t.getMinX(), t.getMinY())) : t.getMinX() === t.getMaxX() || t.getMinY() === t.getMaxY() ? this.createLineString([new X(t.getMinX(), t.getMinY()), new X(t.getMaxX(), t.getMaxY())]) : this.createPolygon(this.createLinearRing([new X(t.getMinX(), t.getMinY()), new X(t.getMinX(), t.getMaxY()), new X(t.getMaxX(), t.getMaxY()), new X(t.getMaxX(), t.getMinY()), new X(t.getMinX(), t.getMinY())]), null);\n        }\n      }, {\n        key: \"createLineString\",\n        value: function () {\n          if (0 === arguments.length) return this.createLineString(this.getCoordinateSequenceFactory().create([]));\n          if (1 === arguments.length) {\n            if (arguments[0] instanceof Array) {\n              var t = arguments[0];\n              return this.createLineString(null !== t ? this.getCoordinateSequenceFactory().create(t) : null);\n            }\n            if (rt(arguments[0], ht)) return new wt(arguments[0], this);\n          }\n        }\n      }, {\n        key: \"createMultiLineString\",\n        value: function () {\n          return 0 === arguments.length ? new se(null, this) : 1 === arguments.length ? new se(arguments[0], this) : void 0;\n        }\n      }, {\n        key: \"buildGeometry\",\n        value: function (e) {\n          for (var n = null, i = !1, r = !1, s = e.iterator(); s.hasNext();) {\n            var a = s.next(),\n              o = a.getTypeCode();\n            null === n && (n = o), o !== n && (i = !0), a instanceof Yt && (r = !0);\n          }\n          if (null === n) return this.createGeometryCollection();\n          if (i || r) return this.createGeometryCollection(t.toGeometryArray(e));\n          var u = e.iterator().next();\n          if (e.size() > 1) {\n            if (u instanceof Dt) return this.createMultiPolygon(t.toPolygonArray(e));\n            if (u instanceof wt) return this.createMultiLineString(t.toLineStringArray(e));\n            if (u instanceof bt) return this.createMultiPoint(t.toPointArray(e));\n            G.shouldNeverReachHere(\"Unhandled geometry type: \" + u.getGeometryType());\n          }\n          return u;\n        }\n      }, {\n        key: \"createMultiPointFromCoords\",\n        value: function (t) {\n          return this.createMultiPoint(null !== t ? this.getCoordinateSequenceFactory().create(t) : null);\n        }\n      }, {\n        key: \"createPoint\",\n        value: function () {\n          if (0 === arguments.length) return this.createPoint(this.getCoordinateSequenceFactory().create([]));\n          if (1 === arguments.length) {\n            if (arguments[0] instanceof X) {\n              var t = arguments[0];\n              return this.createPoint(null !== t ? this.getCoordinateSequenceFactory().create([t]) : null);\n            }\n            if (rt(arguments[0], ht)) return new bt(arguments[0], this);\n          }\n        }\n      }, {\n        key: \"getCoordinateSequenceFactory\",\n        value: function () {\n          return this._coordinateSequenceFactory;\n        }\n      }, {\n        key: \"createPolygon\",\n        value: function () {\n          if (0 === arguments.length) return this.createPolygon(null, null);\n          if (1 === arguments.length) {\n            if (rt(arguments[0], ht)) {\n              var t = arguments[0];\n              return this.createPolygon(this.createLinearRing(t));\n            }\n            if (arguments[0] instanceof Array) {\n              var e = arguments[0];\n              return this.createPolygon(this.createLinearRing(e));\n            }\n            if (arguments[0] instanceof Xt) {\n              var n = arguments[0];\n              return this.createPolygon(n, null);\n            }\n          } else if (2 === arguments.length) {\n            return new Dt(arguments[0], arguments[1], this);\n          }\n        }\n      }, {\n        key: \"getSRID\",\n        value: function () {\n          return this._SRID;\n        }\n      }, {\n        key: \"createGeometryCollection\",\n        value: function () {\n          return 0 === arguments.length ? new Yt(null, this) : 1 === arguments.length ? new Yt(arguments[0], this) : void 0;\n        }\n      }, {\n        key: \"getPrecisionModel\",\n        value: function () {\n          return this._precisionModel;\n        }\n      }, {\n        key: \"createLinearRing\",\n        value: function () {\n          if (0 === arguments.length) return this.createLinearRing(this.getCoordinateSequenceFactory().create([]));\n          if (1 === arguments.length) {\n            if (arguments[0] instanceof Array) {\n              var t = arguments[0];\n              return this.createLinearRing(null !== t ? this.getCoordinateSequenceFactory().create(t) : null);\n            }\n            if (rt(arguments[0], ht)) return new Xt(arguments[0], this);\n          }\n        }\n      }, {\n        key: \"createMultiPolygon\",\n        value: function () {\n          return 0 === arguments.length ? new te(null, this) : 1 === arguments.length ? new te(arguments[0], this) : void 0;\n        }\n      }, {\n        key: \"createMultiPoint\",\n        value: function () {\n          if (0 === arguments.length) return new zt(null, this);\n          if (1 === arguments.length) {\n            if (arguments[0] instanceof Array) return new zt(arguments[0], this);\n            if (rt(arguments[0], ht)) {\n              var t = arguments[0];\n              if (null === t) return this.createMultiPoint(new Array(0).fill(null));\n              for (var e = new Array(t.size()).fill(null), n = 0; n < t.size(); n++) {\n                var i = this.getCoordinateSequenceFactory().create(1, t.getDimension(), t.getMeasures());\n                St.copy(t, n, i, 0, 1), e[n] = this.createPoint(i);\n              }\n              return this.createMultiPoint(e);\n            }\n          }\n        }\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [E];\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          if (this._precisionModel = null, this._coordinateSequenceFactory = null, this._SRID = null, 0 === arguments.length) t.constructor_.call(this, new ie(), 0);else if (1 === arguments.length) {\n            if (rt(arguments[0], It)) {\n              var e = arguments[0];\n              t.constructor_.call(this, new ie(), 0, e);\n            } else if (arguments[0] instanceof ie) {\n              var n = arguments[0];\n              t.constructor_.call(this, n, 0, t.getDefaultCoordinateSequenceFactory());\n            }\n          } else if (2 === arguments.length) {\n            var i = arguments[0],\n              r = arguments[1];\n            t.constructor_.call(this, i, r, t.getDefaultCoordinateSequenceFactory());\n          } else if (3 === arguments.length) {\n            var s = arguments[0],\n              a = arguments[1],\n              o = arguments[2];\n            this._precisionModel = s, this._coordinateSequenceFactory = o, this._SRID = a;\n          }\n        }\n      }, {\n        key: \"toMultiPolygonArray\",\n        value: function (t) {\n          var e = new Array(t.size()).fill(null);\n          return t.toArray(e);\n        }\n      }, {\n        key: \"toGeometryArray\",\n        value: function (t) {\n          if (null === t) return null;\n          var e = new Array(t.size()).fill(null);\n          return t.toArray(e);\n        }\n      }, {\n        key: \"getDefaultCoordinateSequenceFactory\",\n        value: function () {\n          return $t.instance();\n        }\n      }, {\n        key: \"toMultiLineStringArray\",\n        value: function (t) {\n          var e = new Array(t.size()).fill(null);\n          return t.toArray(e);\n        }\n      }, {\n        key: \"toLineStringArray\",\n        value: function (t) {\n          var e = new Array(t.size()).fill(null);\n          return t.toArray(e);\n        }\n      }, {\n        key: \"toMultiPointArray\",\n        value: function (t) {\n          var e = new Array(t.size()).fill(null);\n          return t.toArray(e);\n        }\n      }, {\n        key: \"toLinearRingArray\",\n        value: function (t) {\n          var e = new Array(t.size()).fill(null);\n          return t.toArray(e);\n        }\n      }, {\n        key: \"toPointArray\",\n        value: function (t) {\n          var e = new Array(t.size()).fill(null);\n          return t.toArray(e);\n        }\n      }, {\n        key: \"toPolygonArray\",\n        value: function (t) {\n          var e = new Array(t.size()).fill(null);\n          return t.toArray(e);\n        }\n      }, {\n        key: \"createPointFromInternalCoord\",\n        value: function (t, e) {\n          return e.getPrecisionModel().makePrecise(t), e.getFactory().createPoint(t);\n        }\n      }]);\n    }(),\n    oe = \"XY\",\n    ue = \"XYZ\",\n    le = \"XYM\",\n    he = \"XYZM\",\n    ce = {\n      POINT: \"Point\",\n      LINE_STRING: \"LineString\",\n      LINEAR_RING: \"LinearRing\",\n      POLYGON: \"Polygon\",\n      MULTI_POINT: \"MultiPoint\",\n      MULTI_LINE_STRING: \"MultiLineString\",\n      MULTI_POLYGON: \"MultiPolygon\",\n      GEOMETRY_COLLECTION: \"GeometryCollection\",\n      CIRCLE: \"Circle\"\n    },\n    fe = \"EMPTY\",\n    ge = 1,\n    ve = 2,\n    ye = 3,\n    de = 4,\n    _e = 5,\n    pe = 6;\n  for (var me in ce) ce[me].toUpperCase();\n  var ke = function () {\n      return s(function t(e) {\n        n(this, t), this.wkt = e, this.index_ = -1;\n      }, [{\n        key: \"isAlpha_\",\n        value: function (t) {\n          return t >= \"a\" && t <= \"z\" || t >= \"A\" && t <= \"Z\";\n        }\n      }, {\n        key: \"isNumeric_\",\n        value: function (t, e) {\n          return t >= \"0\" && t <= \"9\" || \".\" == t && !(void 0 !== e && e);\n        }\n      }, {\n        key: \"isWhiteSpace_\",\n        value: function (t) {\n          return \" \" == t || \"\\t\" == t || \"\\r\" == t || \"\\n\" == t;\n        }\n      }, {\n        key: \"nextChar_\",\n        value: function () {\n          return this.wkt.charAt(++this.index_);\n        }\n      }, {\n        key: \"nextToken\",\n        value: function () {\n          var t,\n            e = this.nextChar_(),\n            n = this.index_,\n            i = e;\n          if (\"(\" == e) t = ve;else if (\",\" == e) t = _e;else if (\")\" == e) t = ye;else if (this.isNumeric_(e) || \"-\" == e) t = de, i = this.readNumber_();else if (this.isAlpha_(e)) t = ge, i = this.readText_();else {\n            if (this.isWhiteSpace_(e)) return this.nextToken();\n            if (\"\" !== e) throw new Error(\"Unexpected character: \" + e);\n            t = pe;\n          }\n          return {\n            position: n,\n            value: i,\n            type: t\n          };\n        }\n      }, {\n        key: \"readNumber_\",\n        value: function () {\n          var t,\n            e = this.index_,\n            n = !1,\n            i = !1;\n          do {\n            \".\" == t ? n = !0 : \"e\" != t && \"E\" != t || (i = !0), t = this.nextChar_();\n          } while (this.isNumeric_(t, n) || !i && (\"e\" == t || \"E\" == t) || i && (\"-\" == t || \"+\" == t));\n          return parseFloat(this.wkt.substring(e, this.index_--));\n        }\n      }, {\n        key: \"readText_\",\n        value: function () {\n          var t,\n            e = this.index_;\n          do {\n            t = this.nextChar_();\n          } while (this.isAlpha_(t));\n          return this.wkt.substring(e, this.index_--).toUpperCase();\n        }\n      }]);\n    }(),\n    xe = function () {\n      return s(function t(e, i) {\n        n(this, t), this.lexer_ = e, this.token_, this.layout_ = oe, this.factory = i;\n      }, [{\n        key: \"consume_\",\n        value: function () {\n          this.token_ = this.lexer_.nextToken();\n        }\n      }, {\n        key: \"isTokenType\",\n        value: function (t) {\n          return this.token_.type == t;\n        }\n      }, {\n        key: \"match\",\n        value: function (t) {\n          var e = this.isTokenType(t);\n          return e && this.consume_(), e;\n        }\n      }, {\n        key: \"parse\",\n        value: function () {\n          return this.consume_(), this.parseGeometry_();\n        }\n      }, {\n        key: \"parseGeometryLayout_\",\n        value: function () {\n          var t = oe,\n            e = this.token_;\n          if (this.isTokenType(ge)) {\n            var n = e.value;\n            \"Z\" === n ? t = ue : \"M\" === n ? t = le : \"ZM\" === n && (t = he), t !== oe && this.consume_();\n          }\n          return t;\n        }\n      }, {\n        key: \"parseGeometryCollectionText_\",\n        value: function () {\n          if (this.match(ve)) {\n            var t = [];\n            do {\n              t.push(this.parseGeometry_());\n            } while (this.match(_e));\n            if (this.match(ye)) return t;\n          } else if (this.isEmptyGeometry_()) return [];\n          throw new Error(this.formatErrorMessage_());\n        }\n      }, {\n        key: \"parsePointText_\",\n        value: function () {\n          if (this.match(ve)) {\n            var t = this.parsePoint_();\n            if (this.match(ye)) return t;\n          } else if (this.isEmptyGeometry_()) return null;\n          throw new Error(this.formatErrorMessage_());\n        }\n      }, {\n        key: \"parseLineStringText_\",\n        value: function () {\n          if (this.match(ve)) {\n            var t = this.parsePointList_();\n            if (this.match(ye)) return t;\n          } else if (this.isEmptyGeometry_()) return [];\n          throw new Error(this.formatErrorMessage_());\n        }\n      }, {\n        key: \"parsePolygonText_\",\n        value: function () {\n          if (this.match(ve)) {\n            var t = this.parseLineStringTextList_();\n            if (this.match(ye)) return t;\n          } else if (this.isEmptyGeometry_()) return [];\n          throw new Error(this.formatErrorMessage_());\n        }\n      }, {\n        key: \"parseMultiPointText_\",\n        value: function () {\n          var t;\n          if (this.match(ve)) {\n            if (t = this.token_.type == ve ? this.parsePointTextList_() : this.parsePointList_(), this.match(ye)) return t;\n          } else if (this.isEmptyGeometry_()) return [];\n          throw new Error(this.formatErrorMessage_());\n        }\n      }, {\n        key: \"parseMultiLineStringText_\",\n        value: function () {\n          if (this.match(ve)) {\n            var t = this.parseLineStringTextList_();\n            if (this.match(ye)) return t;\n          } else if (this.isEmptyGeometry_()) return [];\n          throw new Error(this.formatErrorMessage_());\n        }\n      }, {\n        key: \"parseMultiPolygonText_\",\n        value: function () {\n          if (this.match(ve)) {\n            var t = this.parsePolygonTextList_();\n            if (this.match(ye)) return t;\n          } else if (this.isEmptyGeometry_()) return [];\n          throw new Error(this.formatErrorMessage_());\n        }\n      }, {\n        key: \"parsePoint_\",\n        value: function () {\n          for (var t = [], e = this.layout_.length, n = 0; n < e; ++n) {\n            var i = this.token_;\n            if (!this.match(de)) break;\n            t.push(i.value);\n          }\n          if (t.length == e) return t;\n          throw new Error(this.formatErrorMessage_());\n        }\n      }, {\n        key: \"parsePointList_\",\n        value: function () {\n          for (var t = [this.parsePoint_()]; this.match(_e);) t.push(this.parsePoint_());\n          return t;\n        }\n      }, {\n        key: \"parsePointTextList_\",\n        value: function () {\n          for (var t = [this.parsePointText_()]; this.match(_e);) t.push(this.parsePointText_());\n          return t;\n        }\n      }, {\n        key: \"parseLineStringTextList_\",\n        value: function () {\n          for (var t = [this.parseLineStringText_()]; this.match(_e);) t.push(this.parseLineStringText_());\n          return t;\n        }\n      }, {\n        key: \"parsePolygonTextList_\",\n        value: function () {\n          for (var t = [this.parsePolygonText_()]; this.match(_e);) t.push(this.parsePolygonText_());\n          return t;\n        }\n      }, {\n        key: \"isEmptyGeometry_\",\n        value: function () {\n          var t = this.isTokenType(ge) && this.token_.value == fe;\n          return t && this.consume_(), t;\n        }\n      }, {\n        key: \"formatErrorMessage_\",\n        value: function () {\n          return \"Unexpected `\" + this.token_.value + \"` at position \" + this.token_.position + \" in `\" + this.lexer_.wkt + \"`\";\n        }\n      }, {\n        key: \"parseGeometry_\",\n        value: function () {\n          var t = this.factory,\n            e = function (t) {\n              return i(X, g(t));\n            },\n            n = function (n) {\n              var i = n.map(function (n) {\n                return t.createLinearRing(n.map(e));\n              });\n              return i.length > 1 ? t.createPolygon(i[0], i.slice(1)) : t.createPolygon(i[0]);\n            },\n            r = this.token_;\n          if (this.match(ge)) {\n            var s = r.value;\n            if (this.layout_ = this.parseGeometryLayout_(), \"GEOMETRYCOLLECTION\" == s) {\n              var a = this.parseGeometryCollectionText_();\n              return t.createGeometryCollection(a);\n            }\n            switch (s) {\n              case \"POINT\":\n                var o = this.parsePointText_();\n                return o ? t.createPoint(i(X, g(o))) : t.createPoint();\n              case \"LINESTRING\":\n                var u = this.parseLineStringText_().map(e);\n                return t.createLineString(u);\n              case \"LINEARRING\":\n                var l = this.parseLineStringText_().map(e);\n                return t.createLinearRing(l);\n              case \"POLYGON\":\n                var h = this.parsePolygonText_();\n                return h && 0 !== h.length ? n(h) : t.createPolygon();\n              case \"MULTIPOINT\":\n                var c = this.parseMultiPointText_();\n                if (!c || 0 === c.length) return t.createMultiPoint();\n                var f = c.map(e).map(function (e) {\n                  return t.createPoint(e);\n                });\n                return t.createMultiPoint(f);\n              case \"MULTILINESTRING\":\n                var v = this.parseMultiLineStringText_().map(function (n) {\n                  return t.createLineString(n.map(e));\n                });\n                return t.createMultiLineString(v);\n              case \"MULTIPOLYGON\":\n                var y = this.parseMultiPolygonText_();\n                if (!y || 0 === y.length) return t.createMultiPolygon();\n                var d = y.map(n);\n                return t.createMultiPolygon(d);\n              default:\n                throw new Error(\"Invalid geometry type: \" + s);\n            }\n          }\n          throw new Error(this.formatErrorMessage_());\n        }\n      }]);\n    }();\n  function Ie(t) {\n    if (t.isEmpty()) return \"\";\n    var e = t.getCoordinate(),\n      n = [e.x, e.y];\n    return void 0 === e.z || Number.isNaN(e.z) || n.push(e.z), void 0 === e.m || Number.isNaN(e.m) || n.push(e.m), n.join(\" \");\n  }\n  function Ee(t) {\n    for (var e = t.getCoordinates().map(function (t) {\n        var e = [t.x, t.y];\n        return void 0 === t.z || Number.isNaN(t.z) || e.push(t.z), void 0 === t.m || Number.isNaN(t.m) || e.push(t.m), e;\n      }), n = [], i = 0, r = e.length; i < r; ++i) n.push(e[i].join(\" \"));\n    return n.join(\", \");\n  }\n  function Ne(t) {\n    var e = [];\n    e.push(\"(\" + Ee(t.getExteriorRing()) + \")\");\n    for (var n = 0, i = t.getNumInteriorRing(); n < i; ++n) e.push(\"(\" + Ee(t.getInteriorRingN(n)) + \")\");\n    return e.join(\", \");\n  }\n  var Te = {\n    Point: Ie,\n    LineString: Ee,\n    LinearRing: Ee,\n    Polygon: Ne,\n    MultiPoint: function (t) {\n      for (var e = [], n = 0, i = t.getNumGeometries(); n < i; ++n) e.push(\"(\" + Ie(t.getGeometryN(n)) + \")\");\n      return e.join(\", \");\n    },\n    MultiLineString: function (t) {\n      for (var e = [], n = 0, i = t.getNumGeometries(); n < i; ++n) e.push(\"(\" + Ee(t.getGeometryN(n)) + \")\");\n      return e.join(\", \");\n    },\n    MultiPolygon: function (t) {\n      for (var e = [], n = 0, i = t.getNumGeometries(); n < i; ++n) e.push(\"(\" + Ne(t.getGeometryN(n)) + \")\");\n      return e.join(\", \");\n    },\n    GeometryCollection: function (t) {\n      for (var e = [], n = 0, i = t.getNumGeometries(); n < i; ++n) e.push(Se(t.getGeometryN(n)));\n      return e.join(\", \");\n    }\n  };\n  function Se(t) {\n    var e = t.getGeometryType(),\n      n = Te[e];\n    e = e.toUpperCase();\n    var i = function (t) {\n      var e = \"\";\n      if (t.isEmpty()) return e;\n      var n = t.getCoordinate();\n      return void 0 === n.z || Number.isNaN(n.z) || (e += \"Z\"), void 0 === n.m || Number.isNaN(n.m) || (e += \"M\"), e;\n    }(t);\n    return i.length > 0 && (e += \" \" + i), t.isEmpty() ? e + \" \" + fe : e + \" (\" + n(t) + \")\";\n  }\n  var Le = function () {\n      return s(function t(e) {\n        n(this, t), this.geometryFactory = e || new ae(), this.precisionModel = this.geometryFactory.getPrecisionModel();\n      }, [{\n        key: \"read\",\n        value: function (t) {\n          var e = new ke(t);\n          return new xe(e, this.geometryFactory).parse();\n        }\n      }, {\n        key: \"write\",\n        value: function (t) {\n          return Se(t);\n        }\n      }]);\n    }(),\n    Ce = function () {\n      return s(function t(e) {\n        n(this, t), this.parser = new Le(e);\n      }, [{\n        key: \"write\",\n        value: function (t) {\n          return this.parser.write(t);\n        }\n      }], [{\n        key: \"toLineString\",\n        value: function (t, e) {\n          if (2 !== arguments.length) throw new Error(\"Not implemented\");\n          return \"LINESTRING ( \" + t.x + \" \" + t.y + \", \" + e.x + \" \" + e.y + \" )\";\n        }\n      }]);\n    }(),\n    Re = function () {\n      function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }\n      return s(t, [{\n        key: \"getIndexAlongSegment\",\n        value: function (t, e) {\n          return this.computeIntLineIndex(), this._intLineIndex[t][e];\n        }\n      }, {\n        key: \"getTopologySummary\",\n        value: function () {\n          var t = new Jt();\n          return this.isEndPoint() && t.append(\" endpoint\"), this._isProper && t.append(\" proper\"), this.isCollinear() && t.append(\" collinear\"), t.toString();\n        }\n      }, {\n        key: \"computeIntersection\",\n        value: function (t, e, n, i) {\n          this._inputLines[0][0] = t, this._inputLines[0][1] = e, this._inputLines[1][0] = n, this._inputLines[1][1] = i, this._result = this.computeIntersect(t, e, n, i);\n        }\n      }, {\n        key: \"getIntersectionNum\",\n        value: function () {\n          return this._result;\n        }\n      }, {\n        key: \"computeIntLineIndex\",\n        value: function () {\n          if (0 === arguments.length) null === this._intLineIndex && (this._intLineIndex = Array(2).fill().map(function () {\n            return Array(2);\n          }), this.computeIntLineIndex(0), this.computeIntLineIndex(1));else if (1 === arguments.length) {\n            var t = arguments[0];\n            this.getEdgeDistance(t, 0) > this.getEdgeDistance(t, 1) ? (this._intLineIndex[t][0] = 0, this._intLineIndex[t][1] = 1) : (this._intLineIndex[t][0] = 1, this._intLineIndex[t][1] = 0);\n          }\n        }\n      }, {\n        key: \"isProper\",\n        value: function () {\n          return this.hasIntersection() && this._isProper;\n        }\n      }, {\n        key: \"setPrecisionModel\",\n        value: function (t) {\n          this._precisionModel = t;\n        }\n      }, {\n        key: \"isInteriorIntersection\",\n        value: function () {\n          if (0 === arguments.length) return !!this.isInteriorIntersection(0) || !!this.isInteriorIntersection(1);\n          if (1 === arguments.length) {\n            for (var t = arguments[0], e = 0; e < this._result; e++) if (!this._intPt[e].equals2D(this._inputLines[t][0]) && !this._intPt[e].equals2D(this._inputLines[t][1])) return !0;\n            return !1;\n          }\n        }\n      }, {\n        key: \"getIntersection\",\n        value: function (t) {\n          return this._intPt[t];\n        }\n      }, {\n        key: \"isEndPoint\",\n        value: function () {\n          return this.hasIntersection() && !this._isProper;\n        }\n      }, {\n        key: \"hasIntersection\",\n        value: function () {\n          return this._result !== t.NO_INTERSECTION;\n        }\n      }, {\n        key: \"getEdgeDistance\",\n        value: function (e, n) {\n          return t.computeEdgeDistance(this._intPt[n], this._inputLines[e][0], this._inputLines[e][1]);\n        }\n      }, {\n        key: \"isCollinear\",\n        value: function () {\n          return this._result === t.COLLINEAR_INTERSECTION;\n        }\n      }, {\n        key: \"toString\",\n        value: function () {\n          return Ce.toLineString(this._inputLines[0][0], this._inputLines[0][1]) + \" - \" + Ce.toLineString(this._inputLines[1][0], this._inputLines[1][1]) + this.getTopologySummary();\n        }\n      }, {\n        key: \"getEndpoint\",\n        value: function (t, e) {\n          return this._inputLines[t][e];\n        }\n      }, {\n        key: \"isIntersection\",\n        value: function (t) {\n          for (var e = 0; e < this._result; e++) if (this._intPt[e].equals2D(t)) return !0;\n          return !1;\n        }\n      }, {\n        key: \"getIntersectionAlongSegment\",\n        value: function (t, e) {\n          return this.computeIntLineIndex(), this._intPt[this._intLineIndex[t][e]];\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this._result = null, this._inputLines = Array(2).fill().map(function () {\n            return Array(2);\n          }), this._intPt = new Array(2).fill(null), this._intLineIndex = null, this._isProper = null, this._pa = null, this._pb = null, this._precisionModel = null, this._intPt[0] = new X(), this._intPt[1] = new X(), this._pa = this._intPt[0], this._pb = this._intPt[1], this._result = 0;\n        }\n      }, {\n        key: \"computeEdgeDistance\",\n        value: function (t, e, n) {\n          var i = Math.abs(n.x - e.x),\n            r = Math.abs(n.y - e.y),\n            s = -1;\n          if (t.equals(e)) s = 0;else if (t.equals(n)) s = i > r ? i : r;else {\n            var a = Math.abs(t.x - e.x),\n              o = Math.abs(t.y - e.y);\n            0 !== (s = i > r ? a : o) || t.equals(e) || (s = Math.max(a, o));\n          }\n          return G.isTrue(!(0 === s && !t.equals(e)), \"Bad distance calculation\"), s;\n        }\n      }, {\n        key: \"nonRobustComputeEdgeDistance\",\n        value: function (t, e, n) {\n          var i = t.x - e.x,\n            r = t.y - e.y,\n            s = Math.sqrt(i * i + r * r);\n          return G.isTrue(!(0 === s && !t.equals(e)), \"Invalid distance calculation\"), s;\n        }\n      }]);\n    }();\n  Re.DONT_INTERSECT = 0, Re.DO_INTERSECT = 1, Re.COLLINEAR = 2, Re.NO_INTERSECTION = 0, Re.POINT_INTERSECTION = 1, Re.COLLINEAR_INTERSECTION = 2;\n  var we = function (t) {\n      function i() {\n        return n(this, i), e(this, i);\n      }\n      return l(i, t), s(i, [{\n        key: \"isInSegmentEnvelopes\",\n        value: function (t) {\n          var e = new U(this._inputLines[0][0], this._inputLines[0][1]),\n            n = new U(this._inputLines[1][0], this._inputLines[1][1]);\n          return e.contains(t) && n.contains(t);\n        }\n      }, {\n        key: \"computeIntersection\",\n        value: function () {\n          if (3 !== arguments.length) return f(i, \"computeIntersection\", this, 1).apply(this, arguments);\n          var t = arguments[0],\n            e = arguments[1],\n            n = arguments[2];\n          if (this._isProper = !1, U.intersects(e, n, t) && 0 === ct.index(e, n, t) && 0 === ct.index(n, e, t)) return this._isProper = !0, (t.equals(e) || t.equals(n)) && (this._isProper = !1), this._result = Re.POINT_INTERSECTION, null;\n          this._result = Re.NO_INTERSECTION;\n        }\n      }, {\n        key: \"intersection\",\n        value: function (t, e, n, r) {\n          var s = this.intersectionSafe(t, e, n, r);\n          return this.isInSegmentEnvelopes(s) || (s = new X(i.nearestEndpoint(t, e, n, r))), null !== this._precisionModel && this._precisionModel.makePrecise(s), s;\n        }\n      }, {\n        key: \"checkDD\",\n        value: function (t, e, n, i, r) {\n          var s = lt.intersection(t, e, n, i),\n            a = this.isInSegmentEnvelopes(s);\n          mt.out.println(\"DD in env = \" + a + \"  --------------------- \" + s), r.distance(s) > 1e-4 && mt.out.println(\"Distance = \" + r.distance(s));\n        }\n      }, {\n        key: \"intersectionSafe\",\n        value: function (t, e, n, r) {\n          var s = pt.intersection(t, e, n, r);\n          return null === s && (s = i.nearestEndpoint(t, e, n, r)), s;\n        }\n      }, {\n        key: \"computeCollinearIntersection\",\n        value: function (t, e, n, i) {\n          var r = U.intersects(t, e, n),\n            s = U.intersects(t, e, i),\n            a = U.intersects(n, i, t),\n            o = U.intersects(n, i, e);\n          return r && s ? (this._intPt[0] = n, this._intPt[1] = i, Re.COLLINEAR_INTERSECTION) : a && o ? (this._intPt[0] = t, this._intPt[1] = e, Re.COLLINEAR_INTERSECTION) : r && a ? (this._intPt[0] = n, this._intPt[1] = t, !n.equals(t) || s || o ? Re.COLLINEAR_INTERSECTION : Re.POINT_INTERSECTION) : r && o ? (this._intPt[0] = n, this._intPt[1] = e, !n.equals(e) || s || a ? Re.COLLINEAR_INTERSECTION : Re.POINT_INTERSECTION) : s && a ? (this._intPt[0] = i, this._intPt[1] = t, !i.equals(t) || r || o ? Re.COLLINEAR_INTERSECTION : Re.POINT_INTERSECTION) : s && o ? (this._intPt[0] = i, this._intPt[1] = e, !i.equals(e) || r || a ? Re.COLLINEAR_INTERSECTION : Re.POINT_INTERSECTION) : Re.NO_INTERSECTION;\n        }\n      }, {\n        key: \"computeIntersect\",\n        value: function (t, e, n, i) {\n          if (this._isProper = !1, !U.intersects(t, e, n, i)) return Re.NO_INTERSECTION;\n          var r = ct.index(t, e, n),\n            s = ct.index(t, e, i);\n          if (r > 0 && s > 0 || r < 0 && s < 0) return Re.NO_INTERSECTION;\n          var a = ct.index(n, i, t),\n            o = ct.index(n, i, e);\n          return a > 0 && o > 0 || a < 0 && o < 0 ? Re.NO_INTERSECTION : 0 === r && 0 === s && 0 === a && 0 === o ? this.computeCollinearIntersection(t, e, n, i) : (0 === r || 0 === s || 0 === a || 0 === o ? (this._isProper = !1, t.equals2D(n) || t.equals2D(i) ? this._intPt[0] = t : e.equals2D(n) || e.equals2D(i) ? this._intPt[0] = e : 0 === r ? this._intPt[0] = new X(n) : 0 === s ? this._intPt[0] = new X(i) : 0 === a ? this._intPt[0] = new X(t) : 0 === o && (this._intPt[0] = new X(e))) : (this._isProper = !0, this._intPt[0] = this.intersection(t, e, n, i)), Re.POINT_INTERSECTION);\n        }\n      }], [{\n        key: \"nearestEndpoint\",\n        value: function (t, e, n, i) {\n          var r = t,\n            s = xt.pointToSegment(t, n, i),\n            a = xt.pointToSegment(e, n, i);\n          return a < s && (s = a, r = e), (a = xt.pointToSegment(n, t, e)) < s && (s = a, r = n), (a = xt.pointToSegment(i, t, e)) < s && (s = a, r = i), r;\n        }\n      }]);\n    }(Re),\n    Oe = function () {\n      function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }\n      return s(t, [{\n        key: \"countSegment\",\n        value: function (t, e) {\n          if (t.x < this._p.x && e.x < this._p.x) return null;\n          if (this._p.x === e.x && this._p.y === e.y) return this._isPointOnSegment = !0, null;\n          if (t.y === this._p.y && e.y === this._p.y) {\n            var n = t.x,\n              i = e.x;\n            return n > i && (n = e.x, i = t.x), this._p.x >= n && this._p.x <= i && (this._isPointOnSegment = !0), null;\n          }\n          if (t.y > this._p.y && e.y <= this._p.y || e.y > this._p.y && t.y <= this._p.y) {\n            var r = ct.index(t, e, this._p);\n            if (r === ct.COLLINEAR) return this._isPointOnSegment = !0, null;\n            e.y < t.y && (r = -r), r === ct.LEFT && this._crossingCount++;\n          }\n        }\n      }, {\n        key: \"isPointInPolygon\",\n        value: function () {\n          return this.getLocation() !== H.EXTERIOR;\n        }\n      }, {\n        key: \"getLocation\",\n        value: function () {\n          return this._isPointOnSegment ? H.BOUNDARY : this._crossingCount % 2 == 1 ? H.INTERIOR : H.EXTERIOR;\n        }\n      }, {\n        key: \"isOnSegment\",\n        value: function () {\n          return this._isPointOnSegment;\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this._p = null, this._crossingCount = 0, this._isPointOnSegment = !1;\n          var t = arguments[0];\n          this._p = t;\n        }\n      }, {\n        key: \"locatePointInRing\",\n        value: function () {\n          if (arguments[0] instanceof X && rt(arguments[1], ht)) {\n            for (var e = arguments[1], n = new t(arguments[0]), i = new X(), r = new X(), s = 1; s < e.size(); s++) if (e.getCoordinate(s, i), e.getCoordinate(s - 1, r), n.countSegment(i, r), n.isOnSegment()) return n.getLocation();\n            return n.getLocation();\n          }\n          if (arguments[0] instanceof X && arguments[1] instanceof Array) {\n            for (var a = arguments[1], o = new t(arguments[0]), u = 1; u < a.length; u++) {\n              var l = a[u],\n                h = a[u - 1];\n              if (o.countSegment(l, h), o.isOnSegment()) return o.getLocation();\n            }\n            return o.getLocation();\n          }\n        }\n      }]);\n    }(),\n    be = function () {\n      function t() {\n        n(this, t);\n      }\n      return s(t, null, [{\n        key: \"isOnLine\",\n        value: function () {\n          if (arguments[0] instanceof X && rt(arguments[1], ht)) {\n            for (var t = arguments[0], e = arguments[1], n = new we(), i = new X(), r = new X(), s = e.size(), a = 1; a < s; a++) if (e.getCoordinate(a - 1, i), e.getCoordinate(a, r), n.computeIntersection(t, i, r), n.hasIntersection()) return !0;\n            return !1;\n          }\n          if (arguments[0] instanceof X && arguments[1] instanceof Array) {\n            for (var o = arguments[0], u = arguments[1], l = new we(), h = 1; h < u.length; h++) {\n              var c = u[h - 1],\n                f = u[h];\n              if (l.computeIntersection(o, c, f), l.hasIntersection()) return !0;\n            }\n            return !1;\n          }\n        }\n      }, {\n        key: \"locateInRing\",\n        value: function (t, e) {\n          return Oe.locatePointInRing(t, e);\n        }\n      }, {\n        key: \"isInRing\",\n        value: function (e, n) {\n          return t.locateInRing(e, n) !== H.EXTERIOR;\n        }\n      }]);\n    }(),\n    Me = function () {\n      function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }\n      return s(t, [{\n        key: \"setAllLocations\",\n        value: function (t) {\n          for (var e = 0; e < this.location.length; e++) this.location[e] = t;\n        }\n      }, {\n        key: \"isNull\",\n        value: function () {\n          for (var t = 0; t < this.location.length; t++) if (this.location[t] !== H.NONE) return !1;\n          return !0;\n        }\n      }, {\n        key: \"setAllLocationsIfNull\",\n        value: function (t) {\n          for (var e = 0; e < this.location.length; e++) this.location[e] === H.NONE && (this.location[e] = t);\n        }\n      }, {\n        key: \"isLine\",\n        value: function () {\n          return 1 === this.location.length;\n        }\n      }, {\n        key: \"merge\",\n        value: function (t) {\n          if (t.location.length > this.location.length) {\n            var e = new Array(3).fill(null);\n            e[$.ON] = this.location[$.ON], e[$.LEFT] = H.NONE, e[$.RIGHT] = H.NONE, this.location = e;\n          }\n          for (var n = 0; n < this.location.length; n++) this.location[n] === H.NONE && n < t.location.length && (this.location[n] = t.location[n]);\n        }\n      }, {\n        key: \"getLocations\",\n        value: function () {\n          return this.location;\n        }\n      }, {\n        key: \"flip\",\n        value: function () {\n          if (this.location.length <= 1) return null;\n          var t = this.location[$.LEFT];\n          this.location[$.LEFT] = this.location[$.RIGHT], this.location[$.RIGHT] = t;\n        }\n      }, {\n        key: \"toString\",\n        value: function () {\n          var t = new st();\n          return this.location.length > 1 && t.append(H.toLocationSymbol(this.location[$.LEFT])), t.append(H.toLocationSymbol(this.location[$.ON])), this.location.length > 1 && t.append(H.toLocationSymbol(this.location[$.RIGHT])), t.toString();\n        }\n      }, {\n        key: \"setLocations\",\n        value: function (t, e, n) {\n          this.location[$.ON] = t, this.location[$.LEFT] = e, this.location[$.RIGHT] = n;\n        }\n      }, {\n        key: \"get\",\n        value: function (t) {\n          return t < this.location.length ? this.location[t] : H.NONE;\n        }\n      }, {\n        key: \"isArea\",\n        value: function () {\n          return this.location.length > 1;\n        }\n      }, {\n        key: \"isAnyNull\",\n        value: function () {\n          for (var t = 0; t < this.location.length; t++) if (this.location[t] === H.NONE) return !0;\n          return !1;\n        }\n      }, {\n        key: \"setLocation\",\n        value: function () {\n          if (1 === arguments.length) {\n            var t = arguments[0];\n            this.setLocation($.ON, t);\n          } else if (2 === arguments.length) {\n            var e = arguments[0],\n              n = arguments[1];\n            this.location[e] = n;\n          }\n        }\n      }, {\n        key: \"init\",\n        value: function (t) {\n          this.location = new Array(t).fill(null), this.setAllLocations(H.NONE);\n        }\n      }, {\n        key: \"isEqualOnSide\",\n        value: function (t, e) {\n          return this.location[e] === t.location[e];\n        }\n      }, {\n        key: \"allPositionsEqual\",\n        value: function (t) {\n          for (var e = 0; e < this.location.length; e++) if (this.location[e] !== t) return !1;\n          return !0;\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          if (this.location = null, 1 === arguments.length) {\n            if (arguments[0] instanceof Array) {\n              var e = arguments[0];\n              this.init(e.length);\n            } else if (Number.isInteger(arguments[0])) {\n              var n = arguments[0];\n              this.init(1), this.location[$.ON] = n;\n            } else if (arguments[0] instanceof t) {\n              var i = arguments[0];\n              if (this.init(i.location.length), null !== i) for (var r = 0; r < this.location.length; r++) this.location[r] = i.location[r];\n            }\n          } else if (3 === arguments.length) {\n            var s = arguments[0],\n              a = arguments[1],\n              o = arguments[2];\n            this.init(3), this.location[$.ON] = s, this.location[$.LEFT] = a, this.location[$.RIGHT] = o;\n          }\n        }\n      }]);\n    }(),\n    Ae = function () {\n      function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }\n      return s(t, [{\n        key: \"getGeometryCount\",\n        value: function () {\n          var t = 0;\n          return this.elt[0].isNull() || t++, this.elt[1].isNull() || t++, t;\n        }\n      }, {\n        key: \"setAllLocations\",\n        value: function (t, e) {\n          this.elt[t].setAllLocations(e);\n        }\n      }, {\n        key: \"isNull\",\n        value: function (t) {\n          return this.elt[t].isNull();\n        }\n      }, {\n        key: \"setAllLocationsIfNull\",\n        value: function () {\n          if (1 === arguments.length) {\n            var t = arguments[0];\n            this.setAllLocationsIfNull(0, t), this.setAllLocationsIfNull(1, t);\n          } else if (2 === arguments.length) {\n            var e = arguments[0],\n              n = arguments[1];\n            this.elt[e].setAllLocationsIfNull(n);\n          }\n        }\n      }, {\n        key: \"isLine\",\n        value: function (t) {\n          return this.elt[t].isLine();\n        }\n      }, {\n        key: \"merge\",\n        value: function (t) {\n          for (var e = 0; e < 2; e++) null === this.elt[e] && null !== t.elt[e] ? this.elt[e] = new Me(t.elt[e]) : this.elt[e].merge(t.elt[e]);\n        }\n      }, {\n        key: \"flip\",\n        value: function () {\n          this.elt[0].flip(), this.elt[1].flip();\n        }\n      }, {\n        key: \"getLocation\",\n        value: function () {\n          if (1 === arguments.length) {\n            var t = arguments[0];\n            return this.elt[t].get($.ON);\n          }\n          if (2 === arguments.length) {\n            var e = arguments[0],\n              n = arguments[1];\n            return this.elt[e].get(n);\n          }\n        }\n      }, {\n        key: \"toString\",\n        value: function () {\n          var t = new st();\n          return null !== this.elt[0] && (t.append(\"A:\"), t.append(this.elt[0].toString())), null !== this.elt[1] && (t.append(\" B:\"), t.append(this.elt[1].toString())), t.toString();\n        }\n      }, {\n        key: \"isArea\",\n        value: function () {\n          if (0 === arguments.length) return this.elt[0].isArea() || this.elt[1].isArea();\n          if (1 === arguments.length) {\n            var t = arguments[0];\n            return this.elt[t].isArea();\n          }\n        }\n      }, {\n        key: \"isAnyNull\",\n        value: function (t) {\n          return this.elt[t].isAnyNull();\n        }\n      }, {\n        key: \"setLocation\",\n        value: function () {\n          if (2 === arguments.length) {\n            var t = arguments[0],\n              e = arguments[1];\n            this.elt[t].setLocation($.ON, e);\n          } else if (3 === arguments.length) {\n            var n = arguments[0],\n              i = arguments[1],\n              r = arguments[2];\n            this.elt[n].setLocation(i, r);\n          }\n        }\n      }, {\n        key: \"isEqualOnSide\",\n        value: function (t, e) {\n          return this.elt[0].isEqualOnSide(t.elt[0], e) && this.elt[1].isEqualOnSide(t.elt[1], e);\n        }\n      }, {\n        key: \"allPositionsEqual\",\n        value: function (t, e) {\n          return this.elt[t].allPositionsEqual(e);\n        }\n      }, {\n        key: \"toLine\",\n        value: function (t) {\n          this.elt[t].isArea() && (this.elt[t] = new Me(this.elt[t].location[0]));\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          if (this.elt = new Array(2).fill(null), 1 === arguments.length) {\n            if (Number.isInteger(arguments[0])) {\n              var e = arguments[0];\n              this.elt[0] = new Me(e), this.elt[1] = new Me(e);\n            } else if (arguments[0] instanceof t) {\n              var n = arguments[0];\n              this.elt[0] = new Me(n.elt[0]), this.elt[1] = new Me(n.elt[1]);\n            }\n          } else if (2 === arguments.length) {\n            var i = arguments[0],\n              r = arguments[1];\n            this.elt[0] = new Me(H.NONE), this.elt[1] = new Me(H.NONE), this.elt[i].setLocation(r);\n          } else if (3 === arguments.length) {\n            var s = arguments[0],\n              a = arguments[1],\n              o = arguments[2];\n            this.elt[0] = new Me(s, a, o), this.elt[1] = new Me(s, a, o);\n          } else if (4 === arguments.length) {\n            var u = arguments[0],\n              l = arguments[1],\n              h = arguments[2],\n              c = arguments[3];\n            this.elt[0] = new Me(H.NONE, H.NONE, H.NONE), this.elt[1] = new Me(H.NONE, H.NONE, H.NONE), this.elt[u].setLocations(l, h, c);\n          }\n        }\n      }, {\n        key: \"toLineLabel\",\n        value: function (e) {\n          for (var n = new t(H.NONE), i = 0; i < 2; i++) n.setLocation(i, e.getLocation(i));\n          return n;\n        }\n      }]);\n    }(),\n    Pe = function () {\n      return s(function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }, [{\n        key: \"computeRing\",\n        value: function () {\n          if (null !== this._ring) return null;\n          for (var t = new Array(this._pts.size()).fill(null), e = 0; e < this._pts.size(); e++) t[e] = this._pts.get(e);\n          this._ring = this._geometryFactory.createLinearRing(t), this._isHole = ct.isCCW(this._ring.getCoordinates());\n        }\n      }, {\n        key: \"isIsolated\",\n        value: function () {\n          return 1 === this._label.getGeometryCount();\n        }\n      }, {\n        key: \"computePoints\",\n        value: function (t) {\n          this._startDe = t;\n          var e = t,\n            n = !0;\n          do {\n            if (null === e) throw new gt(\"Found null DirectedEdge\");\n            if (e.getEdgeRing() === this) throw new gt(\"Directed Edge visited twice during ring-building at \" + e.getCoordinate());\n            this._edges.add(e);\n            var i = e.getLabel();\n            G.isTrue(i.isArea()), this.mergeLabel(i), this.addPoints(e.getEdge(), e.isForward(), n), n = !1, this.setEdgeRing(e, this), e = this.getNext(e);\n          } while (e !== this._startDe);\n        }\n      }, {\n        key: \"getLinearRing\",\n        value: function () {\n          return this._ring;\n        }\n      }, {\n        key: \"getCoordinate\",\n        value: function (t) {\n          return this._pts.get(t);\n        }\n      }, {\n        key: \"computeMaxNodeDegree\",\n        value: function () {\n          this._maxNodeDegree = 0;\n          var t = this._startDe;\n          do {\n            var e = t.getNode().getEdges().getOutgoingDegree(this);\n            e > this._maxNodeDegree && (this._maxNodeDegree = e), t = this.getNext(t);\n          } while (t !== this._startDe);\n          this._maxNodeDegree *= 2;\n        }\n      }, {\n        key: \"addPoints\",\n        value: function (t, e, n) {\n          var i = t.getCoordinates();\n          if (e) {\n            var r = 1;\n            n && (r = 0);\n            for (var s = r; s < i.length; s++) this._pts.add(i[s]);\n          } else {\n            var a = i.length - 2;\n            n && (a = i.length - 1);\n            for (var o = a; o >= 0; o--) this._pts.add(i[o]);\n          }\n        }\n      }, {\n        key: \"isHole\",\n        value: function () {\n          return this._isHole;\n        }\n      }, {\n        key: \"setInResult\",\n        value: function () {\n          var t = this._startDe;\n          do {\n            t.getEdge().setInResult(!0), t = t.getNext();\n          } while (t !== this._startDe);\n        }\n      }, {\n        key: \"containsPoint\",\n        value: function (t) {\n          var e = this.getLinearRing();\n          if (!e.getEnvelopeInternal().contains(t)) return !1;\n          if (!be.isInRing(t, e.getCoordinates())) return !1;\n          for (var n = this._holes.iterator(); n.hasNext();) {\n            if (n.next().containsPoint(t)) return !1;\n          }\n          return !0;\n        }\n      }, {\n        key: \"addHole\",\n        value: function (t) {\n          this._holes.add(t);\n        }\n      }, {\n        key: \"isShell\",\n        value: function () {\n          return null === this._shell;\n        }\n      }, {\n        key: \"getLabel\",\n        value: function () {\n          return this._label;\n        }\n      }, {\n        key: \"getEdges\",\n        value: function () {\n          return this._edges;\n        }\n      }, {\n        key: \"getMaxNodeDegree\",\n        value: function () {\n          return this._maxNodeDegree < 0 && this.computeMaxNodeDegree(), this._maxNodeDegree;\n        }\n      }, {\n        key: \"getShell\",\n        value: function () {\n          return this._shell;\n        }\n      }, {\n        key: \"mergeLabel\",\n        value: function () {\n          if (1 === arguments.length) {\n            var t = arguments[0];\n            this.mergeLabel(t, 0), this.mergeLabel(t, 1);\n          } else if (2 === arguments.length) {\n            var e = arguments[1],\n              n = arguments[0].getLocation(e, $.RIGHT);\n            if (n === H.NONE) return null;\n            if (this._label.getLocation(e) === H.NONE) return this._label.setLocation(e, n), null;\n          }\n        }\n      }, {\n        key: \"setShell\",\n        value: function (t) {\n          this._shell = t, null !== t && t.addHole(this);\n        }\n      }, {\n        key: \"toPolygon\",\n        value: function (t) {\n          for (var e = new Array(this._holes.size()).fill(null), n = 0; n < this._holes.size(); n++) e[n] = this._holes.get(n).getLinearRing();\n          return t.createPolygon(this.getLinearRing(), e);\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          if (this._startDe = null, this._maxNodeDegree = -1, this._edges = new yt(), this._pts = new yt(), this._label = new Ae(H.NONE), this._ring = null, this._isHole = null, this._shell = null, this._holes = new yt(), this._geometryFactory = null, 0 === arguments.length) ;else if (2 === arguments.length) {\n            var t = arguments[0],\n              e = arguments[1];\n            this._geometryFactory = e, this.computePoints(t), this.computeRing();\n          }\n        }\n      }]);\n    }(),\n    De = function (t) {\n      function i() {\n        var t;\n        return n(this, i), t = e(this, i), i.constructor_.apply(t, arguments), t;\n      }\n      return l(i, t), s(i, [{\n        key: \"setEdgeRing\",\n        value: function (t, e) {\n          t.setMinEdgeRing(e);\n        }\n      }, {\n        key: \"getNext\",\n        value: function (t) {\n          return t.getNextMin();\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          var t = arguments[0],\n            e = arguments[1];\n          Pe.constructor_.call(this, t, e);\n        }\n      }]);\n    }(Pe),\n    Fe = function (t) {\n      function i() {\n        var t;\n        return n(this, i), t = e(this, i), i.constructor_.apply(t, arguments), t;\n      }\n      return l(i, t), s(i, [{\n        key: \"buildMinimalRings\",\n        value: function () {\n          var t = new yt(),\n            e = this._startDe;\n          do {\n            if (null === e.getMinEdgeRing()) {\n              var n = new De(e, this._geometryFactory);\n              t.add(n);\n            }\n            e = e.getNext();\n          } while (e !== this._startDe);\n          return t;\n        }\n      }, {\n        key: \"setEdgeRing\",\n        value: function (t, e) {\n          t.setEdgeRing(e);\n        }\n      }, {\n        key: \"linkDirectedEdgesForMinimalEdgeRings\",\n        value: function () {\n          var t = this._startDe;\n          do {\n            t.getNode().getEdges().linkMinimalDirectedEdges(this), t = t.getNext();\n          } while (t !== this._startDe);\n        }\n      }, {\n        key: \"getNext\",\n        value: function (t) {\n          return t.getNext();\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          var t = arguments[0],\n            e = arguments[1];\n          Pe.constructor_.call(this, t, e);\n        }\n      }]);\n    }(Pe),\n    Ge = function () {\n      return s(function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }, [{\n        key: \"setVisited\",\n        value: function (t) {\n          this._isVisited = t;\n        }\n      }, {\n        key: \"setInResult\",\n        value: function (t) {\n          this._isInResult = t;\n        }\n      }, {\n        key: \"isCovered\",\n        value: function () {\n          return this._isCovered;\n        }\n      }, {\n        key: \"isCoveredSet\",\n        value: function () {\n          return this._isCoveredSet;\n        }\n      }, {\n        key: \"setLabel\",\n        value: function (t) {\n          this._label = t;\n        }\n      }, {\n        key: \"getLabel\",\n        value: function () {\n          return this._label;\n        }\n      }, {\n        key: \"setCovered\",\n        value: function (t) {\n          this._isCovered = t, this._isCoveredSet = !0;\n        }\n      }, {\n        key: \"updateIM\",\n        value: function (t) {\n          G.isTrue(this._label.getGeometryCount() >= 2, \"found partial label\"), this.computeIM(t);\n        }\n      }, {\n        key: \"isInResult\",\n        value: function () {\n          return this._isInResult;\n        }\n      }, {\n        key: \"isVisited\",\n        value: function () {\n          return this._isVisited;\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          if (this._label = null, this._isInResult = !1, this._isCovered = !1, this._isCoveredSet = !1, this._isVisited = !1, 0 === arguments.length) ;else if (1 === arguments.length) {\n            var t = arguments[0];\n            this._label = t;\n          }\n        }\n      }]);\n    }(),\n    qe = function (t) {\n      function i() {\n        var t;\n        return n(this, i), t = e(this, i), i.constructor_.apply(t, arguments), t;\n      }\n      return l(i, t), s(i, [{\n        key: \"isIncidentEdgeInResult\",\n        value: function () {\n          for (var t = this.getEdges().getEdges().iterator(); t.hasNext();) {\n            if (t.next().getEdge().isInResult()) return !0;\n          }\n          return !1;\n        }\n      }, {\n        key: \"isIsolated\",\n        value: function () {\n          return 1 === this._label.getGeometryCount();\n        }\n      }, {\n        key: \"getCoordinate\",\n        value: function () {\n          return this._coord;\n        }\n      }, {\n        key: \"print\",\n        value: function (t) {\n          t.println(\"node \" + this._coord + \" lbl: \" + this._label);\n        }\n      }, {\n        key: \"computeIM\",\n        value: function (t) {}\n      }, {\n        key: \"computeMergedLocation\",\n        value: function (t, e) {\n          var n = H.NONE;\n          if (n = this._label.getLocation(e), !t.isNull(e)) {\n            var i = t.getLocation(e);\n            n !== H.BOUNDARY && (n = i);\n          }\n          return n;\n        }\n      }, {\n        key: \"setLabel\",\n        value: function () {\n          if (2 !== arguments.length || !Number.isInteger(arguments[1]) || !Number.isInteger(arguments[0])) return f(i, \"setLabel\", this, 1).apply(this, arguments);\n          var t = arguments[0],\n            e = arguments[1];\n          null === this._label ? this._label = new Ae(t, e) : this._label.setLocation(t, e);\n        }\n      }, {\n        key: \"getEdges\",\n        value: function () {\n          return this._edges;\n        }\n      }, {\n        key: \"mergeLabel\",\n        value: function () {\n          if (arguments[0] instanceof i) {\n            var t = arguments[0];\n            this.mergeLabel(t._label);\n          } else if (arguments[0] instanceof Ae) for (var e = arguments[0], n = 0; n < 2; n++) {\n            var r = this.computeMergedLocation(e, n);\n            this._label.getLocation(n) === H.NONE && this._label.setLocation(n, r);\n          }\n        }\n      }, {\n        key: \"add\",\n        value: function (t) {\n          this._edges.insert(t), t.setNode(this);\n        }\n      }, {\n        key: \"setLabelBoundary\",\n        value: function (t) {\n          if (null === this._label) return null;\n          var e = H.NONE;\n          null !== this._label && (e = this._label.getLocation(t));\n          var n = null;\n          switch (e) {\n            case H.BOUNDARY:\n              n = H.INTERIOR;\n              break;\n            case H.INTERIOR:\n            default:\n              n = H.BOUNDARY;\n          }\n          this._label.setLocation(t, n);\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this._coord = null, this._edges = null;\n          var t = arguments[0],\n            e = arguments[1];\n          this._coord = t, this._edges = e, this._label = new Ae(0, H.NONE);\n        }\n      }]);\n    }(Ge),\n    Ye = function (t) {\n      function i() {\n        return n(this, i), e(this, i, arguments);\n      }\n      return l(i, t), s(i);\n    }(ee);\n  function ze(t) {\n    return null == t ? 0 : t.color;\n  }\n  function Xe(t) {\n    return null == t ? null : t.parent;\n  }\n  function Be(t, e) {\n    null !== t && (t.color = e);\n  }\n  function Ue(t) {\n    return null == t ? null : t.left;\n  }\n  function Ve(t) {\n    return null == t ? null : t.right;\n  }\n  var He = function (t) {\n      function i() {\n        var t;\n        return n(this, i), (t = e(this, i)).root_ = null, t.size_ = 0, t;\n      }\n      return l(i, t), s(i, [{\n        key: \"get\",\n        value: function (t) {\n          for (var e = this.root_; null !== e;) {\n            var n = t.compareTo(e.key);\n            if (n < 0) e = e.left;else {\n              if (!(n > 0)) return e.value;\n              e = e.right;\n            }\n          }\n          return null;\n        }\n      }, {\n        key: \"put\",\n        value: function (t, e) {\n          if (null === this.root_) return this.root_ = {\n            key: t,\n            value: e,\n            left: null,\n            right: null,\n            parent: null,\n            color: 0,\n            getValue: function () {\n              return this.value;\n            },\n            getKey: function () {\n              return this.key;\n            }\n          }, this.size_ = 1, null;\n          var n,\n            i,\n            r = this.root_;\n          do {\n            if (n = r, (i = t.compareTo(r.key)) < 0) r = r.left;else {\n              if (!(i > 0)) {\n                var s = r.value;\n                return r.value = e, s;\n              }\n              r = r.right;\n            }\n          } while (null !== r);\n          var a = {\n            key: t,\n            left: null,\n            right: null,\n            value: e,\n            parent: n,\n            color: 0,\n            getValue: function () {\n              return this.value;\n            },\n            getKey: function () {\n              return this.key;\n            }\n          };\n          return i < 0 ? n.left = a : n.right = a, this.fixAfterInsertion(a), this.size_++, null;\n        }\n      }, {\n        key: \"fixAfterInsertion\",\n        value: function (t) {\n          var e;\n          for (t.color = 1; null != t && t !== this.root_ && 1 === t.parent.color;) Xe(t) === Ue(Xe(Xe(t))) ? 1 === ze(e = Ve(Xe(Xe(t)))) ? (Be(Xe(t), 0), Be(e, 0), Be(Xe(Xe(t)), 1), t = Xe(Xe(t))) : (t === Ve(Xe(t)) && (t = Xe(t), this.rotateLeft(t)), Be(Xe(t), 0), Be(Xe(Xe(t)), 1), this.rotateRight(Xe(Xe(t)))) : 1 === ze(e = Ue(Xe(Xe(t)))) ? (Be(Xe(t), 0), Be(e, 0), Be(Xe(Xe(t)), 1), t = Xe(Xe(t))) : (t === Ue(Xe(t)) && (t = Xe(t), this.rotateRight(t)), Be(Xe(t), 0), Be(Xe(Xe(t)), 1), this.rotateLeft(Xe(Xe(t))));\n          this.root_.color = 0;\n        }\n      }, {\n        key: \"values\",\n        value: function () {\n          var t = new yt(),\n            e = this.getFirstEntry();\n          if (null !== e) for (t.add(e.value); null !== (e = i.successor(e));) t.add(e.value);\n          return t;\n        }\n      }, {\n        key: \"entrySet\",\n        value: function () {\n          var t = new J(),\n            e = this.getFirstEntry();\n          if (null !== e) for (t.add(e); null !== (e = i.successor(e));) t.add(e);\n          return t;\n        }\n      }, {\n        key: \"rotateLeft\",\n        value: function (t) {\n          if (null != t) {\n            var e = t.right;\n            t.right = e.left, null != e.left && (e.left.parent = t), e.parent = t.parent, null == t.parent ? this.root_ = e : t.parent.left === t ? t.parent.left = e : t.parent.right = e, e.left = t, t.parent = e;\n          }\n        }\n      }, {\n        key: \"rotateRight\",\n        value: function (t) {\n          if (null != t) {\n            var e = t.left;\n            t.left = e.right, null != e.right && (e.right.parent = t), e.parent = t.parent, null == t.parent ? this.root_ = e : t.parent.right === t ? t.parent.right = e : t.parent.left = e, e.right = t, t.parent = e;\n          }\n        }\n      }, {\n        key: \"getFirstEntry\",\n        value: function () {\n          var t = this.root_;\n          if (null != t) for (; null != t.left;) t = t.left;\n          return t;\n        }\n      }, {\n        key: \"size\",\n        value: function () {\n          return this.size_;\n        }\n      }, {\n        key: \"containsKey\",\n        value: function (t) {\n          for (var e = this.root_; null !== e;) {\n            var n = t.compareTo(e.key);\n            if (n < 0) e = e.left;else {\n              if (!(n > 0)) return !0;\n              e = e.right;\n            }\n          }\n          return !1;\n        }\n      }], [{\n        key: \"successor\",\n        value: function (t) {\n          var e;\n          if (null === t) return null;\n          if (null !== t.right) {\n            for (e = t.right; null !== e.left;) e = e.left;\n            return e;\n          }\n          e = t.parent;\n          for (var n = t; null !== e && n === e.right;) n = e, e = e.parent;\n          return e;\n        }\n      }]);\n    }(Ye),\n    Ze = function () {\n      return s(function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }, [{\n        key: \"find\",\n        value: function (t) {\n          return this.nodeMap.get(t);\n        }\n      }, {\n        key: \"addNode\",\n        value: function () {\n          if (arguments[0] instanceof X) {\n            var t = arguments[0],\n              e = this.nodeMap.get(t);\n            return null === e && (e = this.nodeFact.createNode(t), this.nodeMap.put(t, e)), e;\n          }\n          if (arguments[0] instanceof qe) {\n            var n = arguments[0],\n              i = this.nodeMap.get(n.getCoordinate());\n            return null === i ? (this.nodeMap.put(n.getCoordinate(), n), n) : (i.mergeLabel(n), i);\n          }\n        }\n      }, {\n        key: \"print\",\n        value: function (t) {\n          for (var e = this.iterator(); e.hasNext();) {\n            e.next().print(t);\n          }\n        }\n      }, {\n        key: \"iterator\",\n        value: function () {\n          return this.nodeMap.values().iterator();\n        }\n      }, {\n        key: \"values\",\n        value: function () {\n          return this.nodeMap.values();\n        }\n      }, {\n        key: \"getBoundaryNodes\",\n        value: function (t) {\n          for (var e = new yt(), n = this.iterator(); n.hasNext();) {\n            var i = n.next();\n            i.getLabel().getLocation(t) === H.BOUNDARY && e.add(i);\n          }\n          return e;\n        }\n      }, {\n        key: \"add\",\n        value: function (t) {\n          var e = t.getCoordinate();\n          this.addNode(e).add(t);\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this.nodeMap = new He(), this.nodeFact = null;\n          var t = arguments[0];\n          this.nodeFact = t;\n        }\n      }]);\n    }(),\n    je = function () {\n      function t() {\n        n(this, t);\n      }\n      return s(t, null, [{\n        key: \"isNorthern\",\n        value: function (e) {\n          return e === t.NE || e === t.NW;\n        }\n      }, {\n        key: \"isOpposite\",\n        value: function (t, e) {\n          return t !== e && 2 === (t - e + 4) % 4;\n        }\n      }, {\n        key: \"commonHalfPlane\",\n        value: function (t, e) {\n          if (t === e) return t;\n          if (2 === (t - e + 4) % 4) return -1;\n          var n = t < e ? t : e;\n          return 0 === n && 3 === (t > e ? t : e) ? 3 : n;\n        }\n      }, {\n        key: \"isInHalfPlane\",\n        value: function (e, n) {\n          return n === t.SE ? e === t.SE || e === t.SW : e === n || e === n + 1;\n        }\n      }, {\n        key: \"quadrant\",\n        value: function () {\n          if (\"number\" == typeof arguments[0] && \"number\" == typeof arguments[1]) {\n            var e = arguments[0],\n              n = arguments[1];\n            if (0 === e && 0 === n) throw new m(\"Cannot compute the quadrant for point ( \" + e + \", \" + n + \" )\");\n            return e >= 0 ? n >= 0 ? t.NE : t.SE : n >= 0 ? t.NW : t.SW;\n          }\n          if (arguments[0] instanceof X && arguments[1] instanceof X) {\n            var i = arguments[0],\n              r = arguments[1];\n            if (r.x === i.x && r.y === i.y) throw new m(\"Cannot compute the quadrant for two identical points \" + i);\n            return r.x >= i.x ? r.y >= i.y ? t.NE : t.SE : r.y >= i.y ? t.NW : t.SW;\n          }\n        }\n      }]);\n    }();\n  je.NE = 0, je.NW = 1, je.SW = 2, je.SE = 3;\n  var We = function () {\n      function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }\n      return s(t, [{\n        key: \"compareDirection\",\n        value: function (t) {\n          return this._dx === t._dx && this._dy === t._dy ? 0 : this._quadrant > t._quadrant ? 1 : this._quadrant < t._quadrant ? -1 : ct.index(t._p0, t._p1, this._p1);\n        }\n      }, {\n        key: \"getDy\",\n        value: function () {\n          return this._dy;\n        }\n      }, {\n        key: \"getCoordinate\",\n        value: function () {\n          return this._p0;\n        }\n      }, {\n        key: \"setNode\",\n        value: function (t) {\n          this._node = t;\n        }\n      }, {\n        key: \"print\",\n        value: function (t) {\n          var e = Math.atan2(this._dy, this._dx),\n            n = this.getClass().getName(),\n            i = n.lastIndexOf(\".\"),\n            r = n.substring(i + 1);\n          t.print(\"  \" + r + \": \" + this._p0 + \" - \" + this._p1 + \" \" + this._quadrant + \":\" + e + \"   \" + this._label);\n        }\n      }, {\n        key: \"compareTo\",\n        value: function (t) {\n          var e = t;\n          return this.compareDirection(e);\n        }\n      }, {\n        key: \"getDirectedCoordinate\",\n        value: function () {\n          return this._p1;\n        }\n      }, {\n        key: \"getDx\",\n        value: function () {\n          return this._dx;\n        }\n      }, {\n        key: \"getLabel\",\n        value: function () {\n          return this._label;\n        }\n      }, {\n        key: \"getEdge\",\n        value: function () {\n          return this._edge;\n        }\n      }, {\n        key: \"getQuadrant\",\n        value: function () {\n          return this._quadrant;\n        }\n      }, {\n        key: \"getNode\",\n        value: function () {\n          return this._node;\n        }\n      }, {\n        key: \"toString\",\n        value: function () {\n          var t = Math.atan2(this._dy, this._dx),\n            e = this.getClass().getName(),\n            n = e.lastIndexOf(\".\");\n          return \"  \" + e.substring(n + 1) + \": \" + this._p0 + \" - \" + this._p1 + \" \" + this._quadrant + \":\" + t + \"   \" + this._label;\n        }\n      }, {\n        key: \"computeLabel\",\n        value: function (t) {}\n      }, {\n        key: \"init\",\n        value: function (t, e) {\n          this._p0 = t, this._p1 = e, this._dx = e.x - t.x, this._dy = e.y - t.y, this._quadrant = je.quadrant(this._dx, this._dy), G.isTrue(!(0 === this._dx && 0 === this._dy), \"EdgeEnd with identical endpoints found\");\n        }\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [x];\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          if (this._edge = null, this._label = null, this._node = null, this._p0 = null, this._p1 = null, this._dx = null, this._dy = null, this._quadrant = null, 1 === arguments.length) {\n            var e = arguments[0];\n            this._edge = e;\n          } else if (3 === arguments.length) {\n            var n = arguments[0],\n              i = arguments[1],\n              r = arguments[2];\n            t.constructor_.call(this, n, i, r, null);\n          } else if (4 === arguments.length) {\n            var s = arguments[0],\n              a = arguments[1],\n              o = arguments[2],\n              u = arguments[3];\n            t.constructor_.call(this, s), this.init(a, o), this._label = u;\n          }\n        }\n      }]);\n    }(),\n    Ke = function (t) {\n      function i() {\n        var t;\n        return n(this, i), t = e(this, i), i.constructor_.apply(t, arguments), t;\n      }\n      return l(i, t), s(i, [{\n        key: \"getNextMin\",\n        value: function () {\n          return this._nextMin;\n        }\n      }, {\n        key: \"getDepth\",\n        value: function (t) {\n          return this._depth[t];\n        }\n      }, {\n        key: \"setVisited\",\n        value: function (t) {\n          this._isVisited = t;\n        }\n      }, {\n        key: \"computeDirectedLabel\",\n        value: function () {\n          this._label = new Ae(this._edge.getLabel()), this._isForward || this._label.flip();\n        }\n      }, {\n        key: \"getNext\",\n        value: function () {\n          return this._next;\n        }\n      }, {\n        key: \"setDepth\",\n        value: function (t, e) {\n          if (-999 !== this._depth[t] && this._depth[t] !== e) throw new gt(\"assigned depths do not match\", this.getCoordinate());\n          this._depth[t] = e;\n        }\n      }, {\n        key: \"isInteriorAreaEdge\",\n        value: function () {\n          for (var t = !0, e = 0; e < 2; e++) this._label.isArea(e) && this._label.getLocation(e, $.LEFT) === H.INTERIOR && this._label.getLocation(e, $.RIGHT) === H.INTERIOR || (t = !1);\n          return t;\n        }\n      }, {\n        key: \"setNextMin\",\n        value: function (t) {\n          this._nextMin = t;\n        }\n      }, {\n        key: \"print\",\n        value: function (t) {\n          f(i, \"print\", this, 1).call(this, t), t.print(\" \" + this._depth[$.LEFT] + \"/\" + this._depth[$.RIGHT]), t.print(\" (\" + this.getDepthDelta() + \")\"), this._isInResult && t.print(\" inResult\");\n        }\n      }, {\n        key: \"setMinEdgeRing\",\n        value: function (t) {\n          this._minEdgeRing = t;\n        }\n      }, {\n        key: \"isLineEdge\",\n        value: function () {\n          var t = this._label.isLine(0) || this._label.isLine(1),\n            e = !this._label.isArea(0) || this._label.allPositionsEqual(0, H.EXTERIOR),\n            n = !this._label.isArea(1) || this._label.allPositionsEqual(1, H.EXTERIOR);\n          return t && e && n;\n        }\n      }, {\n        key: \"setEdgeRing\",\n        value: function (t) {\n          this._edgeRing = t;\n        }\n      }, {\n        key: \"getMinEdgeRing\",\n        value: function () {\n          return this._minEdgeRing;\n        }\n      }, {\n        key: \"getDepthDelta\",\n        value: function () {\n          var t = this._edge.getDepthDelta();\n          return this._isForward || (t = -t), t;\n        }\n      }, {\n        key: \"setInResult\",\n        value: function (t) {\n          this._isInResult = t;\n        }\n      }, {\n        key: \"getSym\",\n        value: function () {\n          return this._sym;\n        }\n      }, {\n        key: \"isForward\",\n        value: function () {\n          return this._isForward;\n        }\n      }, {\n        key: \"getEdge\",\n        value: function () {\n          return this._edge;\n        }\n      }, {\n        key: \"printEdge\",\n        value: function (t) {\n          this.print(t), t.print(\" \"), this._isForward ? this._edge.print(t) : this._edge.printReverse(t);\n        }\n      }, {\n        key: \"setSym\",\n        value: function (t) {\n          this._sym = t;\n        }\n      }, {\n        key: \"setVisitedEdge\",\n        value: function (t) {\n          this.setVisited(t), this._sym.setVisited(t);\n        }\n      }, {\n        key: \"setEdgeDepths\",\n        value: function (t, e) {\n          var n = this.getEdge().getDepthDelta();\n          this._isForward || (n = -n);\n          var i = 1;\n          t === $.LEFT && (i = -1);\n          var r = $.opposite(t),\n            s = e + n * i;\n          this.setDepth(t, e), this.setDepth(r, s);\n        }\n      }, {\n        key: \"getEdgeRing\",\n        value: function () {\n          return this._edgeRing;\n        }\n      }, {\n        key: \"isInResult\",\n        value: function () {\n          return this._isInResult;\n        }\n      }, {\n        key: \"setNext\",\n        value: function (t) {\n          this._next = t;\n        }\n      }, {\n        key: \"isVisited\",\n        value: function () {\n          return this._isVisited;\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this._isForward = null, this._isInResult = !1, this._isVisited = !1, this._sym = null, this._next = null, this._nextMin = null, this._edgeRing = null, this._minEdgeRing = null, this._depth = [0, -999, -999];\n          var t = arguments[0],\n            e = arguments[1];\n          if (We.constructor_.call(this, t), this._isForward = e, e) this.init(t.getCoordinate(0), t.getCoordinate(1));else {\n            var n = t.getNumPoints() - 1;\n            this.init(t.getCoordinate(n), t.getCoordinate(n - 1));\n          }\n          this.computeDirectedLabel();\n        }\n      }, {\n        key: \"depthFactor\",\n        value: function (t, e) {\n          return t === H.EXTERIOR && e === H.INTERIOR ? 1 : t === H.INTERIOR && e === H.EXTERIOR ? -1 : 0;\n        }\n      }]);\n    }(We),\n    Je = function () {\n      return s(function t() {\n        n(this, t);\n      }, [{\n        key: \"createNode\",\n        value: function (t) {\n          return new qe(t, null);\n        }\n      }]);\n    }(),\n    Qe = function () {\n      return s(function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }, [{\n        key: \"printEdges\",\n        value: function (t) {\n          t.println(\"Edges:\");\n          for (var e = 0; e < this._edges.size(); e++) {\n            t.println(\"edge \" + e + \":\");\n            var n = this._edges.get(e);\n            n.print(t), n.eiList.print(t);\n          }\n        }\n      }, {\n        key: \"find\",\n        value: function (t) {\n          return this._nodes.find(t);\n        }\n      }, {\n        key: \"addNode\",\n        value: function () {\n          if (arguments[0] instanceof qe) {\n            var t = arguments[0];\n            return this._nodes.addNode(t);\n          }\n          if (arguments[0] instanceof X) {\n            var e = arguments[0];\n            return this._nodes.addNode(e);\n          }\n        }\n      }, {\n        key: \"getNodeIterator\",\n        value: function () {\n          return this._nodes.iterator();\n        }\n      }, {\n        key: \"linkResultDirectedEdges\",\n        value: function () {\n          for (var t = this._nodes.iterator(); t.hasNext();) {\n            t.next().getEdges().linkResultDirectedEdges();\n          }\n        }\n      }, {\n        key: \"debugPrintln\",\n        value: function (t) {\n          mt.out.println(t);\n        }\n      }, {\n        key: \"isBoundaryNode\",\n        value: function (t, e) {\n          var n = this._nodes.find(e);\n          if (null === n) return !1;\n          var i = n.getLabel();\n          return null !== i && i.getLocation(t) === H.BOUNDARY;\n        }\n      }, {\n        key: \"linkAllDirectedEdges\",\n        value: function () {\n          for (var t = this._nodes.iterator(); t.hasNext();) {\n            t.next().getEdges().linkAllDirectedEdges();\n          }\n        }\n      }, {\n        key: \"matchInSameDirection\",\n        value: function (t, e, n, i) {\n          return !!t.equals(n) && ct.index(t, e, i) === ct.COLLINEAR && je.quadrant(t, e) === je.quadrant(n, i);\n        }\n      }, {\n        key: \"getEdgeEnds\",\n        value: function () {\n          return this._edgeEndList;\n        }\n      }, {\n        key: \"debugPrint\",\n        value: function (t) {\n          mt.out.print(t);\n        }\n      }, {\n        key: \"getEdgeIterator\",\n        value: function () {\n          return this._edges.iterator();\n        }\n      }, {\n        key: \"findEdgeInSameDirection\",\n        value: function (t, e) {\n          for (var n = 0; n < this._edges.size(); n++) {\n            var i = this._edges.get(n),\n              r = i.getCoordinates();\n            if (this.matchInSameDirection(t, e, r[0], r[1])) return i;\n            if (this.matchInSameDirection(t, e, r[r.length - 1], r[r.length - 2])) return i;\n          }\n          return null;\n        }\n      }, {\n        key: \"insertEdge\",\n        value: function (t) {\n          this._edges.add(t);\n        }\n      }, {\n        key: \"findEdgeEnd\",\n        value: function (t) {\n          for (var e = this.getEdgeEnds().iterator(); e.hasNext();) {\n            var n = e.next();\n            if (n.getEdge() === t) return n;\n          }\n          return null;\n        }\n      }, {\n        key: \"addEdges\",\n        value: function (t) {\n          for (var e = t.iterator(); e.hasNext();) {\n            var n = e.next();\n            this._edges.add(n);\n            var i = new Ke(n, !0),\n              r = new Ke(n, !1);\n            i.setSym(r), r.setSym(i), this.add(i), this.add(r);\n          }\n        }\n      }, {\n        key: \"add\",\n        value: function (t) {\n          this._nodes.add(t), this._edgeEndList.add(t);\n        }\n      }, {\n        key: \"getNodes\",\n        value: function () {\n          return this._nodes.values();\n        }\n      }, {\n        key: \"findEdge\",\n        value: function (t, e) {\n          for (var n = 0; n < this._edges.size(); n++) {\n            var i = this._edges.get(n),\n              r = i.getCoordinates();\n            if (t.equals(r[0]) && e.equals(r[1])) return i;\n          }\n          return null;\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          if (this._edges = new yt(), this._nodes = null, this._edgeEndList = new yt(), 0 === arguments.length) this._nodes = new Ze(new Je());else if (1 === arguments.length) {\n            var t = arguments[0];\n            this._nodes = new Ze(t);\n          }\n        }\n      }, {\n        key: \"linkResultDirectedEdges\",\n        value: function (t) {\n          for (var e = t.iterator(); e.hasNext();) {\n            e.next().getEdges().linkResultDirectedEdges();\n          }\n        }\n      }]);\n    }(),\n    $e = function () {\n      function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }\n      return s(t, [{\n        key: \"sortShellsAndHoles\",\n        value: function (t, e, n) {\n          for (var i = t.iterator(); i.hasNext();) {\n            var r = i.next();\n            r.isHole() ? n.add(r) : e.add(r);\n          }\n        }\n      }, {\n        key: \"computePolygons\",\n        value: function (t) {\n          for (var e = new yt(), n = t.iterator(); n.hasNext();) {\n            var i = n.next().toPolygon(this._geometryFactory);\n            e.add(i);\n          }\n          return e;\n        }\n      }, {\n        key: \"placeFreeHoles\",\n        value: function (e, n) {\n          for (var i = n.iterator(); i.hasNext();) {\n            var r = i.next();\n            if (null === r.getShell()) {\n              var s = t.findEdgeRingContaining(r, e);\n              if (null === s) throw new gt(\"unable to assign hole to a shell\", r.getCoordinate(0));\n              r.setShell(s);\n            }\n          }\n        }\n      }, {\n        key: \"buildMinimalEdgeRings\",\n        value: function (t, e, n) {\n          for (var i = new yt(), r = t.iterator(); r.hasNext();) {\n            var s = r.next();\n            if (s.getMaxNodeDegree() > 2) {\n              s.linkDirectedEdgesForMinimalEdgeRings();\n              var a = s.buildMinimalRings(),\n                o = this.findShell(a);\n              null !== o ? (this.placePolygonHoles(o, a), e.add(o)) : n.addAll(a);\n            } else i.add(s);\n          }\n          return i;\n        }\n      }, {\n        key: \"buildMaximalEdgeRings\",\n        value: function (t) {\n          for (var e = new yt(), n = t.iterator(); n.hasNext();) {\n            var i = n.next();\n            if (i.isInResult() && i.getLabel().isArea() && null === i.getEdgeRing()) {\n              var r = new Fe(i, this._geometryFactory);\n              e.add(r), r.setInResult();\n            }\n          }\n          return e;\n        }\n      }, {\n        key: \"placePolygonHoles\",\n        value: function (t, e) {\n          for (var n = e.iterator(); n.hasNext();) {\n            var i = n.next();\n            i.isHole() && i.setShell(t);\n          }\n        }\n      }, {\n        key: \"getPolygons\",\n        value: function () {\n          return this.computePolygons(this._shellList);\n        }\n      }, {\n        key: \"findShell\",\n        value: function (t) {\n          for (var e = 0, n = null, i = t.iterator(); i.hasNext();) {\n            var r = i.next();\n            r.isHole() || (n = r, e++);\n          }\n          return G.isTrue(e <= 1, \"found two shells in MinimalEdgeRing list\"), n;\n        }\n      }, {\n        key: \"add\",\n        value: function () {\n          if (1 === arguments.length) {\n            var t = arguments[0];\n            this.add(t.getEdgeEnds(), t.getNodes());\n          } else if (2 === arguments.length) {\n            var e = arguments[0],\n              n = arguments[1];\n            Qe.linkResultDirectedEdges(n);\n            var i = this.buildMaximalEdgeRings(e),\n              r = new yt(),\n              s = this.buildMinimalEdgeRings(i, this._shellList, r);\n            this.sortShellsAndHoles(s, this._shellList, r), this.placeFreeHoles(this._shellList, r);\n          }\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this._geometryFactory = null, this._shellList = new yt();\n          var t = arguments[0];\n          this._geometryFactory = t;\n        }\n      }, {\n        key: \"findEdgeRingContaining\",\n        value: function (t, e) {\n          for (var n = t.getLinearRing(), i = n.getEnvelopeInternal(), r = n.getCoordinateN(0), s = null, a = null, o = e.iterator(); o.hasNext();) {\n            var u = o.next(),\n              l = u.getLinearRing(),\n              h = l.getEnvelopeInternal();\n            if (!h.equals(i) && h.contains(i)) {\n              r = jt.ptNotInList(n.getCoordinates(), l.getCoordinates());\n              var c = !1;\n              be.isInRing(r, l.getCoordinates()) && (c = !0), c && (null === s || a.contains(h)) && (a = (s = u).getLinearRing().getEnvelopeInternal());\n            }\n          }\n          return s;\n        }\n      }]);\n    }(),\n    tn = function () {\n      return s(function t() {\n        n(this, t);\n      }, [{\n        key: \"getBounds\",\n        value: function () {}\n      }]);\n    }(),\n    en = function () {\n      return s(function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }, [{\n        key: \"getItem\",\n        value: function () {\n          return this._item;\n        }\n      }, {\n        key: \"getBounds\",\n        value: function () {\n          return this._bounds;\n        }\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [tn, E];\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this._bounds = null, this._item = null;\n          var t = arguments[0],\n            e = arguments[1];\n          this._bounds = t, this._item = e;\n        }\n      }]);\n    }(),\n    nn = function () {\n      return s(function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }, [{\n        key: \"poll\",\n        value: function () {\n          if (this.isEmpty()) return null;\n          var t = this._items.get(1);\n          return this._items.set(1, this._items.get(this._size)), this._size -= 1, this.reorder(1), t;\n        }\n      }, {\n        key: \"size\",\n        value: function () {\n          return this._size;\n        }\n      }, {\n        key: \"reorder\",\n        value: function (t) {\n          for (var e = null, n = this._items.get(t); 2 * t <= this._size && ((e = 2 * t) !== this._size && this._items.get(e + 1).compareTo(this._items.get(e)) < 0 && e++, this._items.get(e).compareTo(n) < 0); t = e) this._items.set(t, this._items.get(e));\n          this._items.set(t, n);\n        }\n      }, {\n        key: \"clear\",\n        value: function () {\n          this._size = 0, this._items.clear();\n        }\n      }, {\n        key: \"peek\",\n        value: function () {\n          return this.isEmpty() ? null : this._items.get(1);\n        }\n      }, {\n        key: \"isEmpty\",\n        value: function () {\n          return 0 === this._size;\n        }\n      }, {\n        key: \"add\",\n        value: function (t) {\n          this._items.add(null), this._size += 1;\n          var e = this._size;\n          for (this._items.set(0, t); t.compareTo(this._items.get(Math.trunc(e / 2))) < 0; e /= 2) this._items.set(e, this._items.get(Math.trunc(e / 2)));\n          this._items.set(e, t);\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this._size = null, this._items = null, this._size = 0, this._items = new yt(), this._items.add(null);\n        }\n      }]);\n    }(),\n    rn = function () {\n      return s(function t() {\n        n(this, t);\n      }, [{\n        key: \"insert\",\n        value: function (t, e) {}\n      }, {\n        key: \"remove\",\n        value: function (t, e) {}\n      }, {\n        key: \"query\",\n        value: function () {}\n      }]);\n    }(),\n    sn = function () {\n      return s(function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }, [{\n        key: \"getLevel\",\n        value: function () {\n          return this._level;\n        }\n      }, {\n        key: \"size\",\n        value: function () {\n          return this._childBoundables.size();\n        }\n      }, {\n        key: \"getChildBoundables\",\n        value: function () {\n          return this._childBoundables;\n        }\n      }, {\n        key: \"addChildBoundable\",\n        value: function (t) {\n          G.isTrue(null === this._bounds), this._childBoundables.add(t);\n        }\n      }, {\n        key: \"isEmpty\",\n        value: function () {\n          return this._childBoundables.isEmpty();\n        }\n      }, {\n        key: \"getBounds\",\n        value: function () {\n          return null === this._bounds && (this._bounds = this.computeBounds()), this._bounds;\n        }\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [tn, E];\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          if (this._childBoundables = new yt(), this._bounds = null, this._level = null, 0 === arguments.length) ;else if (1 === arguments.length) {\n            var t = arguments[0];\n            this._level = t;\n          }\n        }\n      }]);\n    }(),\n    an = {\n      reverseOrder: function () {\n        return {\n          compare: function (t, e) {\n            return e.compareTo(t);\n          }\n        };\n      },\n      min: function (t) {\n        return an.sort(t), t.get(0);\n      },\n      sort: function (t, e) {\n        var n = t.toArray();\n        e ? At.sort(n, e) : At.sort(n);\n        for (var i = t.iterator(), r = 0, s = n.length; r < s; r++) i.next(), i.set(n[r]);\n      },\n      singletonList: function (t) {\n        var e = new yt();\n        return e.add(t), e;\n      }\n    },\n    on = function () {\n      function t() {\n        n(this, t);\n      }\n      return s(t, null, [{\n        key: \"maxDistance\",\n        value: function (e, n, i, r, s, a, o, u) {\n          var l = t.distance(e, n, s, a);\n          return l = Math.max(l, t.distance(e, n, o, u)), l = Math.max(l, t.distance(i, r, s, a)), l = Math.max(l, t.distance(i, r, o, u));\n        }\n      }, {\n        key: \"distance\",\n        value: function (t, e, n, i) {\n          var r = n - t,\n            s = i - e;\n          return Math.sqrt(r * r + s * s);\n        }\n      }, {\n        key: \"maximumDistance\",\n        value: function (e, n) {\n          var i = Math.min(e.getMinX(), n.getMinX()),\n            r = Math.min(e.getMinY(), n.getMinY()),\n            s = Math.max(e.getMaxX(), n.getMaxX()),\n            a = Math.max(e.getMaxY(), n.getMaxY());\n          return t.distance(i, r, s, a);\n        }\n      }, {\n        key: \"minMaxDistance\",\n        value: function (e, n) {\n          var i = e.getMinX(),\n            r = e.getMinY(),\n            s = e.getMaxX(),\n            a = e.getMaxY(),\n            o = n.getMinX(),\n            u = n.getMinY(),\n            l = n.getMaxX(),\n            h = n.getMaxY(),\n            c = t.maxDistance(i, r, i, a, o, u, o, h);\n          return c = Math.min(c, t.maxDistance(i, r, i, a, o, u, l, u)), c = Math.min(c, t.maxDistance(i, r, i, a, l, h, o, h)), c = Math.min(c, t.maxDistance(i, r, i, a, l, h, l, u)), c = Math.min(c, t.maxDistance(i, r, s, r, o, u, o, h)), c = Math.min(c, t.maxDistance(i, r, s, r, o, u, l, u)), c = Math.min(c, t.maxDistance(i, r, s, r, l, h, o, h)), c = Math.min(c, t.maxDistance(i, r, s, r, l, h, l, u)), c = Math.min(c, t.maxDistance(s, a, i, a, o, u, o, h)), c = Math.min(c, t.maxDistance(s, a, i, a, o, u, l, u)), c = Math.min(c, t.maxDistance(s, a, i, a, l, h, o, h)), c = Math.min(c, t.maxDistance(s, a, i, a, l, h, l, u)), c = Math.min(c, t.maxDistance(s, a, s, r, o, u, o, h)), c = Math.min(c, t.maxDistance(s, a, s, r, o, u, l, u)), c = Math.min(c, t.maxDistance(s, a, s, r, l, h, o, h)), c = Math.min(c, t.maxDistance(s, a, s, r, l, h, l, u));\n        }\n      }]);\n    }(),\n    un = function () {\n      function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }\n      return s(t, [{\n        key: \"maximumDistance\",\n        value: function () {\n          return on.maximumDistance(this._boundable1.getBounds(), this._boundable2.getBounds());\n        }\n      }, {\n        key: \"expandToQueue\",\n        value: function (e, n) {\n          var i = t.isComposite(this._boundable1),\n            r = t.isComposite(this._boundable2);\n          if (i && r) return t.area(this._boundable1) > t.area(this._boundable2) ? (this.expand(this._boundable1, this._boundable2, !1, e, n), null) : (this.expand(this._boundable2, this._boundable1, !0, e, n), null);\n          if (i) return this.expand(this._boundable1, this._boundable2, !1, e, n), null;\n          if (r) return this.expand(this._boundable2, this._boundable1, !0, e, n), null;\n          throw new m(\"neither boundable is composite\");\n        }\n      }, {\n        key: \"isLeaves\",\n        value: function () {\n          return !(t.isComposite(this._boundable1) || t.isComposite(this._boundable2));\n        }\n      }, {\n        key: \"compareTo\",\n        value: function (t) {\n          var e = t;\n          return this._distance < e._distance ? -1 : this._distance > e._distance ? 1 : 0;\n        }\n      }, {\n        key: \"expand\",\n        value: function (e, n, i, r, s) {\n          for (var a = e.getChildBoundables().iterator(); a.hasNext();) {\n            var o = a.next(),\n              u = null;\n            (u = i ? new t(n, o, this._itemDistance) : new t(o, n, this._itemDistance)).getDistance() < s && r.add(u);\n          }\n        }\n      }, {\n        key: \"getBoundable\",\n        value: function (t) {\n          return 0 === t ? this._boundable1 : this._boundable2;\n        }\n      }, {\n        key: \"getDistance\",\n        value: function () {\n          return this._distance;\n        }\n      }, {\n        key: \"distance\",\n        value: function () {\n          return this.isLeaves() ? this._itemDistance.distance(this._boundable1, this._boundable2) : this._boundable1.getBounds().distance(this._boundable2.getBounds());\n        }\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [x];\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this._boundable1 = null, this._boundable2 = null, this._distance = null, this._itemDistance = null;\n          var t = arguments[0],\n            e = arguments[1],\n            n = arguments[2];\n          this._boundable1 = t, this._boundable2 = e, this._itemDistance = n, this._distance = this.distance();\n        }\n      }, {\n        key: \"area\",\n        value: function (t) {\n          return t.getBounds().getArea();\n        }\n      }, {\n        key: \"isComposite\",\n        value: function (t) {\n          return t instanceof sn;\n        }\n      }]);\n    }(),\n    ln = function () {\n      return s(function t() {\n        n(this, t);\n      }, [{\n        key: \"visitItem\",\n        value: function (t) {}\n      }]);\n    }(),\n    hn = function () {\n      function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }\n      return s(t, [{\n        key: \"queryInternal\",\n        value: function () {\n          if (rt(arguments[2], ln) && arguments[0] instanceof Object && arguments[1] instanceof sn) for (var t = arguments[0], e = arguments[2], n = arguments[1].getChildBoundables(), i = 0; i < n.size(); i++) {\n            var r = n.get(i);\n            this.getIntersectsOp().intersects(r.getBounds(), t) && (r instanceof sn ? this.queryInternal(t, r, e) : r instanceof en ? e.visitItem(r.getItem()) : G.shouldNeverReachHere());\n          } else if (rt(arguments[2], nt) && arguments[0] instanceof Object && arguments[1] instanceof sn) for (var s = arguments[0], a = arguments[2], o = arguments[1].getChildBoundables(), u = 0; u < o.size(); u++) {\n            var l = o.get(u);\n            this.getIntersectsOp().intersects(l.getBounds(), s) && (l instanceof sn ? this.queryInternal(s, l, a) : l instanceof en ? a.add(l.getItem()) : G.shouldNeverReachHere());\n          }\n        }\n      }, {\n        key: \"getNodeCapacity\",\n        value: function () {\n          return this._nodeCapacity;\n        }\n      }, {\n        key: \"lastNode\",\n        value: function (t) {\n          return t.get(t.size() - 1);\n        }\n      }, {\n        key: \"size\",\n        value: function () {\n          if (0 === arguments.length) return this.isEmpty() ? 0 : (this.build(), this.size(this._root));\n          if (1 === arguments.length) {\n            for (var t = 0, e = arguments[0].getChildBoundables().iterator(); e.hasNext();) {\n              var n = e.next();\n              n instanceof sn ? t += this.size(n) : n instanceof en && (t += 1);\n            }\n            return t;\n          }\n        }\n      }, {\n        key: \"removeItem\",\n        value: function (t, e) {\n          for (var n = null, i = t.getChildBoundables().iterator(); i.hasNext();) {\n            var r = i.next();\n            r instanceof en && r.getItem() === e && (n = r);\n          }\n          return null !== n && (t.getChildBoundables().remove(n), !0);\n        }\n      }, {\n        key: \"itemsTree\",\n        value: function () {\n          if (0 === arguments.length) {\n            this.build();\n            var t = this.itemsTree(this._root);\n            return null === t ? new yt() : t;\n          }\n          if (1 === arguments.length) {\n            for (var e = arguments[0], n = new yt(), i = e.getChildBoundables().iterator(); i.hasNext();) {\n              var r = i.next();\n              if (r instanceof sn) {\n                var s = this.itemsTree(r);\n                null !== s && n.add(s);\n              } else r instanceof en ? n.add(r.getItem()) : G.shouldNeverReachHere();\n            }\n            return n.size() <= 0 ? null : n;\n          }\n        }\n      }, {\n        key: \"insert\",\n        value: function (t, e) {\n          G.isTrue(!this._built, \"Cannot insert items into an STR packed R-tree after it has been built.\"), this._itemBoundables.add(new en(t, e));\n        }\n      }, {\n        key: \"boundablesAtLevel\",\n        value: function () {\n          if (1 === arguments.length) {\n            var t = arguments[0],\n              e = new yt();\n            return this.boundablesAtLevel(t, this._root, e), e;\n          }\n          if (3 === arguments.length) {\n            var n = arguments[0],\n              i = arguments[1],\n              r = arguments[2];\n            if (G.isTrue(n > -2), i.getLevel() === n) return r.add(i), null;\n            for (var s = i.getChildBoundables().iterator(); s.hasNext();) {\n              var a = s.next();\n              a instanceof sn ? this.boundablesAtLevel(n, a, r) : (G.isTrue(a instanceof en), -1 === n && r.add(a));\n            }\n            return null;\n          }\n        }\n      }, {\n        key: \"query\",\n        value: function () {\n          if (1 === arguments.length) {\n            var t = arguments[0];\n            this.build();\n            var e = new yt();\n            return this.isEmpty() || this.getIntersectsOp().intersects(this._root.getBounds(), t) && this.queryInternal(t, this._root, e), e;\n          }\n          if (2 === arguments.length) {\n            var n = arguments[0],\n              i = arguments[1];\n            if (this.build(), this.isEmpty()) return null;\n            this.getIntersectsOp().intersects(this._root.getBounds(), n) && this.queryInternal(n, this._root, i);\n          }\n        }\n      }, {\n        key: \"build\",\n        value: function () {\n          if (this._built) return null;\n          this._root = this._itemBoundables.isEmpty() ? this.createNode(0) : this.createHigherLevels(this._itemBoundables, -1), this._itemBoundables = null, this._built = !0;\n        }\n      }, {\n        key: \"getRoot\",\n        value: function () {\n          return this.build(), this._root;\n        }\n      }, {\n        key: \"remove\",\n        value: function () {\n          if (2 === arguments.length) {\n            var t = arguments[0],\n              e = arguments[1];\n            return this.build(), !!this.getIntersectsOp().intersects(this._root.getBounds(), t) && this.remove(t, this._root, e);\n          }\n          if (3 === arguments.length) {\n            var n = arguments[0],\n              i = arguments[1],\n              r = arguments[2],\n              s = this.removeItem(i, r);\n            if (s) return !0;\n            for (var a = null, o = i.getChildBoundables().iterator(); o.hasNext();) {\n              var u = o.next();\n              if (this.getIntersectsOp().intersects(u.getBounds(), n) && u instanceof sn && (s = this.remove(n, u, r))) {\n                a = u;\n                break;\n              }\n            }\n            return null !== a && a.getChildBoundables().isEmpty() && i.getChildBoundables().remove(a), s;\n          }\n        }\n      }, {\n        key: \"createHigherLevels\",\n        value: function (t, e) {\n          G.isTrue(!t.isEmpty());\n          var n = this.createParentBoundables(t, e + 1);\n          return 1 === n.size() ? n.get(0) : this.createHigherLevels(n, e + 1);\n        }\n      }, {\n        key: \"depth\",\n        value: function () {\n          if (0 === arguments.length) return this.isEmpty() ? 0 : (this.build(), this.depth(this._root));\n          if (1 === arguments.length) {\n            for (var t = 0, e = arguments[0].getChildBoundables().iterator(); e.hasNext();) {\n              var n = e.next();\n              if (n instanceof sn) {\n                var i = this.depth(n);\n                i > t && (t = i);\n              }\n            }\n            return t + 1;\n          }\n        }\n      }, {\n        key: \"createParentBoundables\",\n        value: function (t, e) {\n          G.isTrue(!t.isEmpty());\n          var n = new yt();\n          n.add(this.createNode(e));\n          var i = new yt(t);\n          an.sort(i, this.getComparator());\n          for (var r = i.iterator(); r.hasNext();) {\n            var s = r.next();\n            this.lastNode(n).getChildBoundables().size() === this.getNodeCapacity() && n.add(this.createNode(e)), this.lastNode(n).addChildBoundable(s);\n          }\n          return n;\n        }\n      }, {\n        key: \"isEmpty\",\n        value: function () {\n          return this._built ? this._root.isEmpty() : this._itemBoundables.isEmpty();\n        }\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [E];\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          if (this._root = null, this._built = !1, this._itemBoundables = new yt(), this._nodeCapacity = null, 0 === arguments.length) t.constructor_.call(this, t.DEFAULT_NODE_CAPACITY);else if (1 === arguments.length) {\n            var e = arguments[0];\n            G.isTrue(e > 1, \"Node capacity must be greater than 1\"), this._nodeCapacity = e;\n          }\n        }\n      }, {\n        key: \"compareDoubles\",\n        value: function (t, e) {\n          return t > e ? 1 : t < e ? -1 : 0;\n        }\n      }]);\n    }();\n  hn.IntersectsOp = function () {}, hn.DEFAULT_NODE_CAPACITY = 10;\n  var cn = function () {\n      return s(function t() {\n        n(this, t);\n      }, [{\n        key: \"distance\",\n        value: function (t, e) {}\n      }]);\n    }(),\n    fn = function (t) {\n      function i() {\n        var t;\n        return n(this, i), t = e(this, i), i.constructor_.apply(t, arguments), t;\n      }\n      return l(i, t), s(i, [{\n        key: \"createParentBoundablesFromVerticalSlices\",\n        value: function (t, e) {\n          G.isTrue(t.length > 0);\n          for (var n = new yt(), i = 0; i < t.length; i++) n.addAll(this.createParentBoundablesFromVerticalSlice(t[i], e));\n          return n;\n        }\n      }, {\n        key: \"nearestNeighbourK\",\n        value: function () {\n          if (2 === arguments.length) {\n            var t = arguments[0],\n              e = arguments[1];\n            return this.nearestNeighbourK(t, A.POSITIVE_INFINITY, e);\n          }\n          if (3 === arguments.length) {\n            var n = arguments[0],\n              r = arguments[2],\n              s = arguments[1],\n              a = new nn();\n            a.add(n);\n            for (var o = new nn(); !a.isEmpty() && s >= 0;) {\n              var u = a.poll(),\n                l = u.getDistance();\n              if (l >= s) break;\n              if (u.isLeaves()) {\n                if (o.size() < r) o.add(u);else o.peek().getDistance() > l && (o.poll(), o.add(u)), s = o.peek().getDistance();\n              } else u.expandToQueue(a, s);\n            }\n            return i.getItems(o);\n          }\n        }\n      }, {\n        key: \"createNode\",\n        value: function (t) {\n          return new gn(t);\n        }\n      }, {\n        key: \"size\",\n        value: function () {\n          return 0 === arguments.length ? f(i, \"size\", this, 1).call(this) : f(i, \"size\", this, 1).apply(this, arguments);\n        }\n      }, {\n        key: \"insert\",\n        value: function () {\n          if (!(2 === arguments.length && arguments[1] instanceof Object && arguments[0] instanceof U)) return f(i, \"insert\", this, 1).apply(this, arguments);\n          var t = arguments[0],\n            e = arguments[1];\n          if (t.isNull()) return null;\n          f(i, \"insert\", this, 1).call(this, t, e);\n        }\n      }, {\n        key: \"getIntersectsOp\",\n        value: function () {\n          return i.intersectsOp;\n        }\n      }, {\n        key: \"verticalSlices\",\n        value: function (t, e) {\n          for (var n = Math.trunc(Math.ceil(t.size() / e)), i = new Array(e).fill(null), r = t.iterator(), s = 0; s < e; s++) {\n            i[s] = new yt();\n            for (var a = 0; r.hasNext() && a < n;) {\n              var o = r.next();\n              i[s].add(o), a++;\n            }\n          }\n          return i;\n        }\n      }, {\n        key: \"query\",\n        value: function () {\n          if (1 === arguments.length) {\n            var t = arguments[0];\n            return f(i, \"query\", this, 1).call(this, t);\n          }\n          if (2 === arguments.length) {\n            var e = arguments[0],\n              n = arguments[1];\n            f(i, \"query\", this, 1).call(this, e, n);\n          }\n        }\n      }, {\n        key: \"getComparator\",\n        value: function () {\n          return i.yComparator;\n        }\n      }, {\n        key: \"createParentBoundablesFromVerticalSlice\",\n        value: function (t, e) {\n          return f(i, \"createParentBoundables\", this, 1).call(this, t, e);\n        }\n      }, {\n        key: \"remove\",\n        value: function () {\n          if (2 === arguments.length && arguments[1] instanceof Object && arguments[0] instanceof U) {\n            var t = arguments[0],\n              e = arguments[1];\n            return f(i, \"remove\", this, 1).call(this, t, e);\n          }\n          return f(i, \"remove\", this, 1).apply(this, arguments);\n        }\n      }, {\n        key: \"depth\",\n        value: function () {\n          return 0 === arguments.length ? f(i, \"depth\", this, 1).call(this) : f(i, \"depth\", this, 1).apply(this, arguments);\n        }\n      }, {\n        key: \"createParentBoundables\",\n        value: function (t, e) {\n          G.isTrue(!t.isEmpty());\n          var n = Math.trunc(Math.ceil(t.size() / this.getNodeCapacity())),\n            r = new yt(t);\n          an.sort(r, i.xComparator);\n          var s = this.verticalSlices(r, Math.trunc(Math.ceil(Math.sqrt(n))));\n          return this.createParentBoundablesFromVerticalSlices(s, e);\n        }\n      }, {\n        key: \"nearestNeighbour\",\n        value: function () {\n          if (1 === arguments.length) {\n            if (rt(arguments[0], cn)) {\n              var t = arguments[0];\n              if (this.isEmpty()) return null;\n              var e = new un(this.getRoot(), this.getRoot(), t);\n              return this.nearestNeighbour(e);\n            }\n            if (arguments[0] instanceof un) {\n              var n = arguments[0],\n                i = A.POSITIVE_INFINITY,\n                r = null,\n                s = new nn();\n              for (s.add(n); !s.isEmpty() && i > 0;) {\n                var a = s.poll(),\n                  o = a.getDistance();\n                if (o >= i) break;\n                a.isLeaves() ? (i = o, r = a) : a.expandToQueue(s, i);\n              }\n              return null === r ? null : [r.getBoundable(0).getItem(), r.getBoundable(1).getItem()];\n            }\n          } else {\n            if (2 === arguments.length) {\n              var u = arguments[0],\n                l = arguments[1];\n              if (this.isEmpty() || u.isEmpty()) return null;\n              var h = new un(this.getRoot(), u.getRoot(), l);\n              return this.nearestNeighbour(h);\n            }\n            if (3 === arguments.length) {\n              var c = arguments[2],\n                f = new en(arguments[0], arguments[1]),\n                g = new un(this.getRoot(), f, c);\n              return this.nearestNeighbour(g)[0];\n            }\n            if (4 === arguments.length) {\n              var v = arguments[2],\n                y = arguments[3],\n                d = new en(arguments[0], arguments[1]),\n                _ = new un(this.getRoot(), d, v);\n              return this.nearestNeighbourK(_, y);\n            }\n          }\n        }\n      }, {\n        key: \"isWithinDistance\",\n        value: function () {\n          if (2 === arguments.length) {\n            var t = arguments[0],\n              e = arguments[1],\n              n = A.POSITIVE_INFINITY,\n              i = new nn();\n            for (i.add(t); !i.isEmpty();) {\n              var r = i.poll(),\n                s = r.getDistance();\n              if (s > e) return !1;\n              if (r.maximumDistance() <= e) return !0;\n              if (r.isLeaves()) {\n                if ((n = s) <= e) return !0;\n              } else r.expandToQueue(i, n);\n            }\n            return !1;\n          }\n          if (3 === arguments.length) {\n            var a = arguments[0],\n              o = arguments[1],\n              u = arguments[2],\n              l = new un(this.getRoot(), a.getRoot(), o);\n            return this.isWithinDistance(l, u);\n          }\n        }\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [rn, E];\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          if (0 === arguments.length) i.constructor_.call(this, i.DEFAULT_NODE_CAPACITY);else if (1 === arguments.length) {\n            var t = arguments[0];\n            hn.constructor_.call(this, t);\n          }\n        }\n      }, {\n        key: \"centreX\",\n        value: function (t) {\n          return i.avg(t.getMinX(), t.getMaxX());\n        }\n      }, {\n        key: \"avg\",\n        value: function (t, e) {\n          return (t + e) / 2;\n        }\n      }, {\n        key: \"getItems\",\n        value: function (t) {\n          for (var e = new Array(t.size()).fill(null), n = 0; !t.isEmpty();) {\n            var i = t.poll();\n            e[n] = i.getBoundable(0).getItem(), n++;\n          }\n          return e;\n        }\n      }, {\n        key: \"centreY\",\n        value: function (t) {\n          return i.avg(t.getMinY(), t.getMaxY());\n        }\n      }]);\n    }(hn),\n    gn = function (t) {\n      function i() {\n        var t;\n        return n(this, i), t = e(this, i), i.constructor_.apply(t, arguments), t;\n      }\n      return l(i, t), s(i, [{\n        key: \"computeBounds\",\n        value: function () {\n          for (var t = null, e = this.getChildBoundables().iterator(); e.hasNext();) {\n            var n = e.next();\n            null === t ? t = new U(n.getBounds()) : t.expandToInclude(n.getBounds());\n          }\n          return t;\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          var t = arguments[0];\n          sn.constructor_.call(this, t);\n        }\n      }]);\n    }(sn);\n  fn.STRtreeNode = gn, fn.xComparator = new (function () {\n    return s(function t() {\n      n(this, t);\n    }, [{\n      key: \"interfaces_\",\n      get: function () {\n        return [P];\n      }\n    }, {\n      key: \"compare\",\n      value: function (t, e) {\n        return hn.compareDoubles(fn.centreX(t.getBounds()), fn.centreX(e.getBounds()));\n      }\n    }]);\n  }())(), fn.yComparator = new (function () {\n    return s(function t() {\n      n(this, t);\n    }, [{\n      key: \"interfaces_\",\n      get: function () {\n        return [P];\n      }\n    }, {\n      key: \"compare\",\n      value: function (t, e) {\n        return hn.compareDoubles(fn.centreY(t.getBounds()), fn.centreY(e.getBounds()));\n      }\n    }]);\n  }())(), fn.intersectsOp = new (function () {\n    return s(function t() {\n      n(this, t);\n    }, [{\n      key: \"interfaces_\",\n      get: function () {\n        return [IntersectsOp];\n      }\n    }, {\n      key: \"intersects\",\n      value: function (t, e) {\n        return t.intersects(e);\n      }\n    }]);\n  }())(), fn.DEFAULT_NODE_CAPACITY = 10;\n  var vn = function () {\n      function t() {\n        n(this, t);\n      }\n      return s(t, null, [{\n        key: \"relativeSign\",\n        value: function (t, e) {\n          return t < e ? -1 : t > e ? 1 : 0;\n        }\n      }, {\n        key: \"compare\",\n        value: function (e, n, i) {\n          if (n.equals2D(i)) return 0;\n          var r = t.relativeSign(n.x, i.x),\n            s = t.relativeSign(n.y, i.y);\n          switch (e) {\n            case 0:\n              return t.compareValue(r, s);\n            case 1:\n              return t.compareValue(s, r);\n            case 2:\n              return t.compareValue(s, -r);\n            case 3:\n              return t.compareValue(-r, s);\n            case 4:\n              return t.compareValue(-r, -s);\n            case 5:\n              return t.compareValue(-s, -r);\n            case 6:\n              return t.compareValue(-s, r);\n            case 7:\n              return t.compareValue(r, -s);\n          }\n          return G.shouldNeverReachHere(\"invalid octant value\"), 0;\n        }\n      }, {\n        key: \"compareValue\",\n        value: function (t, e) {\n          return t < 0 ? -1 : t > 0 ? 1 : e < 0 ? -1 : e > 0 ? 1 : 0;\n        }\n      }]);\n    }(),\n    yn = function () {\n      return s(function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }, [{\n        key: \"getCoordinate\",\n        value: function () {\n          return this.coord;\n        }\n      }, {\n        key: \"print\",\n        value: function (t) {\n          t.print(this.coord), t.print(\" seg # = \" + this.segmentIndex);\n        }\n      }, {\n        key: \"compareTo\",\n        value: function (t) {\n          var e = t;\n          return this.segmentIndex < e.segmentIndex ? -1 : this.segmentIndex > e.segmentIndex ? 1 : this.coord.equals2D(e.coord) ? 0 : this._isInterior ? e._isInterior ? vn.compare(this._segmentOctant, this.coord, e.coord) : 1 : -1;\n        }\n      }, {\n        key: \"isEndPoint\",\n        value: function (t) {\n          return 0 === this.segmentIndex && !this._isInterior || this.segmentIndex === t;\n        }\n      }, {\n        key: \"toString\",\n        value: function () {\n          return this.segmentIndex + \":\" + this.coord.toString();\n        }\n      }, {\n        key: \"isInterior\",\n        value: function () {\n          return this._isInterior;\n        }\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [x];\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this._segString = null, this.coord = null, this.segmentIndex = null, this._segmentOctant = null, this._isInterior = null;\n          var t = arguments[0],\n            e = arguments[1],\n            n = arguments[2],\n            i = arguments[3];\n          this._segString = t, this.coord = new X(e), this.segmentIndex = n, this._segmentOctant = i, this._isInterior = !e.equals2D(t.getCoordinate(n));\n        }\n      }]);\n    }(),\n    dn = function () {\n      return s(function t() {\n        n(this, t);\n      }, [{\n        key: \"hasNext\",\n        value: function () {}\n      }, {\n        key: \"next\",\n        value: function () {}\n      }, {\n        key: \"remove\",\n        value: function () {}\n      }]);\n    }(),\n    _n = function () {\n      return s(function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }, [{\n        key: \"getSplitCoordinates\",\n        value: function () {\n          var t = new Zt();\n          this.addEndpoints();\n          for (var e = this.iterator(), n = e.next(); e.hasNext();) {\n            var i = e.next();\n            this.addEdgeCoordinates(n, i, t), n = i;\n          }\n          return t.toCoordinateArray();\n        }\n      }, {\n        key: \"addCollapsedNodes\",\n        value: function () {\n          var t = new yt();\n          this.findCollapsesFromInsertedNodes(t), this.findCollapsesFromExistingVertices(t);\n          for (var e = t.iterator(); e.hasNext();) {\n            var n = e.next().intValue();\n            this.add(this._edge.getCoordinate(n), n);\n          }\n        }\n      }, {\n        key: \"createSplitEdgePts\",\n        value: function (t, e) {\n          var n = e.segmentIndex - t.segmentIndex + 2;\n          if (2 === n) return [new X(t.coord), new X(e.coord)];\n          var i = this._edge.getCoordinate(e.segmentIndex),\n            r = e.isInterior() || !e.coord.equals2D(i);\n          r || n--;\n          var s = new Array(n).fill(null),\n            a = 0;\n          s[a++] = new X(t.coord);\n          for (var o = t.segmentIndex + 1; o <= e.segmentIndex; o++) s[a++] = this._edge.getCoordinate(o);\n          return r && (s[a] = new X(e.coord)), s;\n        }\n      }, {\n        key: \"print\",\n        value: function (t) {\n          t.println(\"Intersections:\");\n          for (var e = this.iterator(); e.hasNext();) {\n            e.next().print(t);\n          }\n        }\n      }, {\n        key: \"findCollapsesFromExistingVertices\",\n        value: function (t) {\n          for (var e = 0; e < this._edge.size() - 2; e++) {\n            var n = this._edge.getCoordinate(e);\n            this._edge.getCoordinate(e + 1);\n            var i = this._edge.getCoordinate(e + 2);\n            n.equals2D(i) && t.add(at.valueOf(e + 1));\n          }\n        }\n      }, {\n        key: \"addEdgeCoordinates\",\n        value: function (t, e, n) {\n          var i = this.createSplitEdgePts(t, e);\n          n.add(i, !1);\n        }\n      }, {\n        key: \"iterator\",\n        value: function () {\n          return this._nodeMap.values().iterator();\n        }\n      }, {\n        key: \"addSplitEdges\",\n        value: function (t) {\n          this.addEndpoints(), this.addCollapsedNodes();\n          for (var e = this.iterator(), n = e.next(); e.hasNext();) {\n            var i = e.next(),\n              r = this.createSplitEdge(n, i);\n            t.add(r), n = i;\n          }\n        }\n      }, {\n        key: \"findCollapseIndex\",\n        value: function (t, e, n) {\n          if (!t.coord.equals2D(e.coord)) return !1;\n          var i = e.segmentIndex - t.segmentIndex;\n          return e.isInterior() || i--, 1 === i && (n[0] = t.segmentIndex + 1, !0);\n        }\n      }, {\n        key: \"findCollapsesFromInsertedNodes\",\n        value: function (t) {\n          for (var e = new Array(1).fill(null), n = this.iterator(), i = n.next(); n.hasNext();) {\n            var r = n.next();\n            this.findCollapseIndex(i, r, e) && t.add(at.valueOf(e[0])), i = r;\n          }\n        }\n      }, {\n        key: \"getEdge\",\n        value: function () {\n          return this._edge;\n        }\n      }, {\n        key: \"addEndpoints\",\n        value: function () {\n          var t = this._edge.size() - 1;\n          this.add(this._edge.getCoordinate(0), 0), this.add(this._edge.getCoordinate(t), t);\n        }\n      }, {\n        key: \"createSplitEdge\",\n        value: function (t, e) {\n          var n = this.createSplitEdgePts(t, e);\n          return new xn(n, this._edge.getData());\n        }\n      }, {\n        key: \"add\",\n        value: function (t, e) {\n          var n = new yn(this._edge, t, e, this._edge.getSegmentOctant(e)),\n            i = this._nodeMap.get(n);\n          return null !== i ? (G.isTrue(i.coord.equals2D(t), \"Found equal nodes with different coordinates\"), i) : (this._nodeMap.put(n, n), n);\n        }\n      }, {\n        key: \"checkSplitEdgesCorrectness\",\n        value: function (t) {\n          var e = this._edge.getCoordinates(),\n            n = t.get(0).getCoordinate(0);\n          if (!n.equals2D(e[0])) throw new D(\"bad split edge start point at \" + n);\n          var i = t.get(t.size() - 1).getCoordinates(),\n            r = i[i.length - 1];\n          if (!r.equals2D(e[e.length - 1])) throw new D(\"bad split edge end point at \" + r);\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this._nodeMap = new He(), this._edge = null;\n          var t = arguments[0];\n          this._edge = t;\n        }\n      }]);\n    }(),\n    pn = function () {\n      function t() {\n        n(this, t);\n      }\n      return s(t, null, [{\n        key: \"octant\",\n        value: function () {\n          if (\"number\" == typeof arguments[0] && \"number\" == typeof arguments[1]) {\n            var e = arguments[0],\n              n = arguments[1];\n            if (0 === e && 0 === n) throw new m(\"Cannot compute the octant for point ( \" + e + \", \" + n + \" )\");\n            var i = Math.abs(e),\n              r = Math.abs(n);\n            return e >= 0 ? n >= 0 ? i >= r ? 0 : 1 : i >= r ? 7 : 6 : n >= 0 ? i >= r ? 3 : 2 : i >= r ? 4 : 5;\n          }\n          if (arguments[0] instanceof X && arguments[1] instanceof X) {\n            var s = arguments[0],\n              a = arguments[1],\n              o = a.x - s.x,\n              u = a.y - s.y;\n            if (0 === o && 0 === u) throw new m(\"Cannot compute the octant for two identical points \" + s);\n            return t.octant(o, u);\n          }\n        }\n      }]);\n    }(),\n    mn = function () {\n      return s(function t() {\n        n(this, t);\n      }, [{\n        key: \"getCoordinates\",\n        value: function () {}\n      }, {\n        key: \"size\",\n        value: function () {}\n      }, {\n        key: \"getCoordinate\",\n        value: function (t) {}\n      }, {\n        key: \"isClosed\",\n        value: function () {}\n      }, {\n        key: \"setData\",\n        value: function (t) {}\n      }, {\n        key: \"getData\",\n        value: function () {}\n      }]);\n    }(),\n    kn = function () {\n      return s(function t() {\n        n(this, t);\n      }, [{\n        key: \"addIntersection\",\n        value: function (t, e) {}\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [mn];\n        }\n      }]);\n    }(),\n    xn = function () {\n      function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }\n      return s(t, [{\n        key: \"getCoordinates\",\n        value: function () {\n          return this._pts;\n        }\n      }, {\n        key: \"size\",\n        value: function () {\n          return this._pts.length;\n        }\n      }, {\n        key: \"getCoordinate\",\n        value: function (t) {\n          return this._pts[t];\n        }\n      }, {\n        key: \"isClosed\",\n        value: function () {\n          return this._pts[0].equals(this._pts[this._pts.length - 1]);\n        }\n      }, {\n        key: \"getSegmentOctant\",\n        value: function (t) {\n          return t === this._pts.length - 1 ? -1 : this.safeOctant(this.getCoordinate(t), this.getCoordinate(t + 1));\n        }\n      }, {\n        key: \"setData\",\n        value: function (t) {\n          this._data = t;\n        }\n      }, {\n        key: \"safeOctant\",\n        value: function (t, e) {\n          return t.equals2D(e) ? 0 : pn.octant(t, e);\n        }\n      }, {\n        key: \"getData\",\n        value: function () {\n          return this._data;\n        }\n      }, {\n        key: \"addIntersection\",\n        value: function () {\n          if (2 === arguments.length) {\n            var t = arguments[0],\n              e = arguments[1];\n            this.addIntersectionNode(t, e);\n          } else if (4 === arguments.length) {\n            var n = arguments[1],\n              i = arguments[3],\n              r = new X(arguments[0].getIntersection(i));\n            this.addIntersection(r, n);\n          }\n        }\n      }, {\n        key: \"toString\",\n        value: function () {\n          return Ce.toLineString(new Qt(this._pts));\n        }\n      }, {\n        key: \"getNodeList\",\n        value: function () {\n          return this._nodeList;\n        }\n      }, {\n        key: \"addIntersectionNode\",\n        value: function (t, e) {\n          var n = e,\n            i = n + 1;\n          if (i < this._pts.length) {\n            var r = this._pts[i];\n            t.equals2D(r) && (n = i);\n          }\n          return this._nodeList.add(t, n);\n        }\n      }, {\n        key: \"addIntersections\",\n        value: function (t, e, n) {\n          for (var i = 0; i < t.getIntersectionNum(); i++) this.addIntersection(t, e, n, i);\n        }\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [kn];\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this._nodeList = new _n(this), this._pts = null, this._data = null;\n          var t = arguments[0],\n            e = arguments[1];\n          this._pts = t, this._data = e;\n        }\n      }, {\n        key: \"getNodedSubstrings\",\n        value: function () {\n          if (1 === arguments.length) {\n            var e = arguments[0],\n              n = new yt();\n            return t.getNodedSubstrings(e, n), n;\n          }\n          if (2 === arguments.length) for (var i = arguments[1], r = arguments[0].iterator(); r.hasNext();) {\n            r.next().getNodeList().addSplitEdges(i);\n          }\n        }\n      }]);\n    }(),\n    In = function () {\n      function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }\n      return s(t, [{\n        key: \"minX\",\n        value: function () {\n          return Math.min(this.p0.x, this.p1.x);\n        }\n      }, {\n        key: \"orientationIndex\",\n        value: function () {\n          if (arguments[0] instanceof t) {\n            var e = arguments[0],\n              n = ct.index(this.p0, this.p1, e.p0),\n              i = ct.index(this.p0, this.p1, e.p1);\n            return n >= 0 && i >= 0 || n <= 0 && i <= 0 ? Math.max(n, i) : 0;\n          }\n          if (arguments[0] instanceof X) {\n            var r = arguments[0];\n            return ct.index(this.p0, this.p1, r);\n          }\n        }\n      }, {\n        key: \"toGeometry\",\n        value: function (t) {\n          return t.createLineString([this.p0, this.p1]);\n        }\n      }, {\n        key: \"isVertical\",\n        value: function () {\n          return this.p0.x === this.p1.x;\n        }\n      }, {\n        key: \"equals\",\n        value: function (e) {\n          if (!(e instanceof t)) return !1;\n          var n = e;\n          return this.p0.equals(n.p0) && this.p1.equals(n.p1);\n        }\n      }, {\n        key: \"intersection\",\n        value: function (t) {\n          var e = new we();\n          return e.computeIntersection(this.p0, this.p1, t.p0, t.p1), e.hasIntersection() ? e.getIntersection(0) : null;\n        }\n      }, {\n        key: \"project\",\n        value: function () {\n          if (arguments[0] instanceof X) {\n            var e = arguments[0];\n            if (e.equals(this.p0) || e.equals(this.p1)) return new X(e);\n            var n = this.projectionFactor(e),\n              i = new X();\n            return i.x = this.p0.x + n * (this.p1.x - this.p0.x), i.y = this.p0.y + n * (this.p1.y - this.p0.y), i;\n          }\n          if (arguments[0] instanceof t) {\n            var r = arguments[0],\n              s = this.projectionFactor(r.p0),\n              a = this.projectionFactor(r.p1);\n            if (s >= 1 && a >= 1) return null;\n            if (s <= 0 && a <= 0) return null;\n            var o = this.project(r.p0);\n            s < 0 && (o = this.p0), s > 1 && (o = this.p1);\n            var u = this.project(r.p1);\n            return a < 0 && (u = this.p0), a > 1 && (u = this.p1), new t(o, u);\n          }\n        }\n      }, {\n        key: \"normalize\",\n        value: function () {\n          this.p1.compareTo(this.p0) < 0 && this.reverse();\n        }\n      }, {\n        key: \"angle\",\n        value: function () {\n          return Math.atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x);\n        }\n      }, {\n        key: \"getCoordinate\",\n        value: function (t) {\n          return 0 === t ? this.p0 : this.p1;\n        }\n      }, {\n        key: \"distancePerpendicular\",\n        value: function (t) {\n          return xt.pointToLinePerpendicular(t, this.p0, this.p1);\n        }\n      }, {\n        key: \"minY\",\n        value: function () {\n          return Math.min(this.p0.y, this.p1.y);\n        }\n      }, {\n        key: \"midPoint\",\n        value: function () {\n          return t.midPoint(this.p0, this.p1);\n        }\n      }, {\n        key: \"projectionFactor\",\n        value: function (t) {\n          if (t.equals(this.p0)) return 0;\n          if (t.equals(this.p1)) return 1;\n          var e = this.p1.x - this.p0.x,\n            n = this.p1.y - this.p0.y,\n            i = e * e + n * n;\n          return i <= 0 ? A.NaN : ((t.x - this.p0.x) * e + (t.y - this.p0.y) * n) / i;\n        }\n      }, {\n        key: \"closestPoints\",\n        value: function (t) {\n          var e = this.intersection(t);\n          if (null !== e) return [e, e];\n          var n = new Array(2).fill(null),\n            i = A.MAX_VALUE,\n            r = null,\n            s = this.closestPoint(t.p0);\n          i = s.distance(t.p0), n[0] = s, n[1] = t.p0;\n          var a = this.closestPoint(t.p1);\n          (r = a.distance(t.p1)) < i && (i = r, n[0] = a, n[1] = t.p1);\n          var o = t.closestPoint(this.p0);\n          (r = o.distance(this.p0)) < i && (i = r, n[0] = this.p0, n[1] = o);\n          var u = t.closestPoint(this.p1);\n          return (r = u.distance(this.p1)) < i && (i = r, n[0] = this.p1, n[1] = u), n;\n        }\n      }, {\n        key: \"closestPoint\",\n        value: function (t) {\n          var e = this.projectionFactor(t);\n          return e > 0 && e < 1 ? this.project(t) : this.p0.distance(t) < this.p1.distance(t) ? this.p0 : this.p1;\n        }\n      }, {\n        key: \"maxX\",\n        value: function () {\n          return Math.max(this.p0.x, this.p1.x);\n        }\n      }, {\n        key: \"getLength\",\n        value: function () {\n          return this.p0.distance(this.p1);\n        }\n      }, {\n        key: \"compareTo\",\n        value: function (t) {\n          var e = t,\n            n = this.p0.compareTo(e.p0);\n          return 0 !== n ? n : this.p1.compareTo(e.p1);\n        }\n      }, {\n        key: \"reverse\",\n        value: function () {\n          var t = this.p0;\n          this.p0 = this.p1, this.p1 = t;\n        }\n      }, {\n        key: \"equalsTopo\",\n        value: function (t) {\n          return this.p0.equals(t.p0) && this.p1.equals(t.p1) || this.p0.equals(t.p1) && this.p1.equals(t.p0);\n        }\n      }, {\n        key: \"lineIntersection\",\n        value: function (t) {\n          return pt.intersection(this.p0, this.p1, t.p0, t.p1);\n        }\n      }, {\n        key: \"maxY\",\n        value: function () {\n          return Math.max(this.p0.y, this.p1.y);\n        }\n      }, {\n        key: \"pointAlongOffset\",\n        value: function (t, e) {\n          var n = this.p0.x + t * (this.p1.x - this.p0.x),\n            i = this.p0.y + t * (this.p1.y - this.p0.y),\n            r = this.p1.x - this.p0.x,\n            s = this.p1.y - this.p0.y,\n            a = Math.sqrt(r * r + s * s),\n            o = 0,\n            u = 0;\n          if (0 !== e) {\n            if (a <= 0) throw new IllegalStateException(\"Cannot compute offset from zero-length line segment\");\n            o = e * r / a, u = e * s / a;\n          }\n          return new X(n - u, i + o);\n        }\n      }, {\n        key: \"setCoordinates\",\n        value: function () {\n          if (1 === arguments.length) {\n            var t = arguments[0];\n            this.setCoordinates(t.p0, t.p1);\n          } else if (2 === arguments.length) {\n            var e = arguments[0],\n              n = arguments[1];\n            this.p0.x = e.x, this.p0.y = e.y, this.p1.x = n.x, this.p1.y = n.y;\n          }\n        }\n      }, {\n        key: \"segmentFraction\",\n        value: function (t) {\n          var e = this.projectionFactor(t);\n          return e < 0 ? e = 0 : (e > 1 || A.isNaN(e)) && (e = 1), e;\n        }\n      }, {\n        key: \"toString\",\n        value: function () {\n          return \"LINESTRING( \" + this.p0.x + \" \" + this.p0.y + \", \" + this.p1.x + \" \" + this.p1.y + \")\";\n        }\n      }, {\n        key: \"isHorizontal\",\n        value: function () {\n          return this.p0.y === this.p1.y;\n        }\n      }, {\n        key: \"reflect\",\n        value: function (t) {\n          var e = this.p1.getY() - this.p0.getY(),\n            n = this.p0.getX() - this.p1.getX(),\n            i = this.p0.getY() * (this.p1.getX() - this.p0.getX()) - this.p0.getX() * (this.p1.getY() - this.p0.getY()),\n            r = e * e + n * n,\n            s = e * e - n * n,\n            a = t.getX(),\n            o = t.getY();\n          return new X((-s * a - 2 * e * n * o - 2 * e * i) / r, (s * o - 2 * e * n * a - 2 * n * i) / r);\n        }\n      }, {\n        key: \"distance\",\n        value: function () {\n          if (arguments[0] instanceof t) {\n            var e = arguments[0];\n            return xt.segmentToSegment(this.p0, this.p1, e.p0, e.p1);\n          }\n          if (arguments[0] instanceof X) {\n            var n = arguments[0];\n            return xt.pointToSegment(n, this.p0, this.p1);\n          }\n        }\n      }, {\n        key: \"pointAlong\",\n        value: function (t) {\n          var e = new X();\n          return e.x = this.p0.x + t * (this.p1.x - this.p0.x), e.y = this.p0.y + t * (this.p1.y - this.p0.y), e;\n        }\n      }, {\n        key: \"hashCode\",\n        value: function () {\n          var t = A.doubleToLongBits(this.p0.x);\n          t ^= 31 * A.doubleToLongBits(this.p0.y);\n          var e = Math.trunc(t) ^ Math.trunc(t >> 32),\n            n = A.doubleToLongBits(this.p1.x);\n          return n ^= 31 * A.doubleToLongBits(this.p1.y), e ^ (Math.trunc(n) ^ Math.trunc(n >> 32));\n        }\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [x, E];\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          if (this.p0 = null, this.p1 = null, 0 === arguments.length) t.constructor_.call(this, new X(), new X());else if (1 === arguments.length) {\n            var e = arguments[0];\n            t.constructor_.call(this, e.p0, e.p1);\n          } else if (2 === arguments.length) {\n            var n = arguments[0],\n              i = arguments[1];\n            this.p0 = n, this.p1 = i;\n          } else if (4 === arguments.length) {\n            var r = arguments[0],\n              s = arguments[1],\n              a = arguments[2],\n              o = arguments[3];\n            t.constructor_.call(this, new X(r, s), new X(a, o));\n          }\n        }\n      }, {\n        key: \"midPoint\",\n        value: function (t, e) {\n          return new X((t.x + e.x) / 2, (t.y + e.y) / 2);\n        }\n      }]);\n    }(),\n    En = function () {\n      return s(function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }, [{\n        key: \"overlap\",\n        value: function () {\n          if (2 === arguments.length) ;else if (4 === arguments.length) {\n            var t = arguments[1],\n              e = arguments[2],\n              n = arguments[3];\n            arguments[0].getLineSegment(t, this._overlapSeg1), e.getLineSegment(n, this._overlapSeg2), this.overlap(this._overlapSeg1, this._overlapSeg2);\n          }\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this._overlapSeg1 = new In(), this._overlapSeg2 = new In();\n        }\n      }]);\n    }(),\n    Nn = function () {\n      return s(function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }, [{\n        key: \"getLineSegment\",\n        value: function (t, e) {\n          e.p0 = this._pts[t], e.p1 = this._pts[t + 1];\n        }\n      }, {\n        key: \"computeSelect\",\n        value: function (t, e, n, i) {\n          var r = this._pts[e],\n            s = this._pts[n];\n          if (n - e == 1) return i.select(this, e), null;\n          if (!t.intersects(r, s)) return null;\n          var a = Math.trunc((e + n) / 2);\n          e < a && this.computeSelect(t, e, a, i), a < n && this.computeSelect(t, a, n, i);\n        }\n      }, {\n        key: \"getCoordinates\",\n        value: function () {\n          for (var t = new Array(this._end - this._start + 1).fill(null), e = 0, n = this._start; n <= this._end; n++) t[e++] = this._pts[n];\n          return t;\n        }\n      }, {\n        key: \"computeOverlaps\",\n        value: function () {\n          if (2 === arguments.length) {\n            var t = arguments[0],\n              e = arguments[1];\n            this.computeOverlaps(this._start, this._end, t, t._start, t._end, e);\n          } else if (6 === arguments.length) {\n            var n = arguments[0],\n              i = arguments[1],\n              r = arguments[2],\n              s = arguments[3],\n              a = arguments[4],\n              o = arguments[5];\n            if (i - n == 1 && a - s == 1) return o.overlap(this, n, r, s), null;\n            if (!this.overlaps(n, i, r, s, a)) return null;\n            var u = Math.trunc((n + i) / 2),\n              l = Math.trunc((s + a) / 2);\n            n < u && (s < l && this.computeOverlaps(n, u, r, s, l, o), l < a && this.computeOverlaps(n, u, r, l, a, o)), u < i && (s < l && this.computeOverlaps(u, i, r, s, l, o), l < a && this.computeOverlaps(u, i, r, l, a, o));\n          }\n        }\n      }, {\n        key: \"setId\",\n        value: function (t) {\n          this._id = t;\n        }\n      }, {\n        key: \"select\",\n        value: function (t, e) {\n          this.computeSelect(t, this._start, this._end, e);\n        }\n      }, {\n        key: \"getEnvelope\",\n        value: function () {\n          if (null === this._env) {\n            var t = this._pts[this._start],\n              e = this._pts[this._end];\n            this._env = new U(t, e);\n          }\n          return this._env;\n        }\n      }, {\n        key: \"overlaps\",\n        value: function (t, e, n, i, r) {\n          return U.intersects(this._pts[t], this._pts[e], n._pts[i], n._pts[r]);\n        }\n      }, {\n        key: \"getEndIndex\",\n        value: function () {\n          return this._end;\n        }\n      }, {\n        key: \"getStartIndex\",\n        value: function () {\n          return this._start;\n        }\n      }, {\n        key: \"getContext\",\n        value: function () {\n          return this._context;\n        }\n      }, {\n        key: \"getId\",\n        value: function () {\n          return this._id;\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this._pts = null, this._start = null, this._end = null, this._env = null, this._context = null, this._id = null;\n          var t = arguments[0],\n            e = arguments[1],\n            n = arguments[2],\n            i = arguments[3];\n          this._pts = t, this._start = e, this._end = n, this._context = i;\n        }\n      }]);\n    }(),\n    Tn = function () {\n      function t() {\n        n(this, t);\n      }\n      return s(t, null, [{\n        key: \"findChainEnd\",\n        value: function (t, e) {\n          for (var n = e; n < t.length - 1 && t[n].equals2D(t[n + 1]);) n++;\n          if (n >= t.length - 1) return t.length - 1;\n          for (var i = je.quadrant(t[n], t[n + 1]), r = e + 1; r < t.length;) {\n            if (!t[r - 1].equals2D(t[r])) if (je.quadrant(t[r - 1], t[r]) !== i) break;\n            r++;\n          }\n          return r - 1;\n        }\n      }, {\n        key: \"getChains\",\n        value: function () {\n          if (1 === arguments.length) {\n            var e = arguments[0];\n            return t.getChains(e, null);\n          }\n          if (2 === arguments.length) {\n            var n = arguments[0],\n              i = arguments[1],\n              r = new yt(),\n              s = 0;\n            do {\n              var a = t.findChainEnd(n, s),\n                o = new Nn(n, s, a, i);\n              r.add(o), s = a;\n            } while (s < n.length - 1);\n            return r;\n          }\n        }\n      }]);\n    }(),\n    Sn = function () {\n      return s(function t() {\n        n(this, t);\n      }, [{\n        key: \"computeNodes\",\n        value: function (t) {}\n      }, {\n        key: \"getNodedSubstrings\",\n        value: function () {}\n      }]);\n    }(),\n    Ln = function () {\n      return s(function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }, [{\n        key: \"setSegmentIntersector\",\n        value: function (t) {\n          this._segInt = t;\n        }\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [Sn];\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          if (this._segInt = null, 0 === arguments.length) ;else if (1 === arguments.length) {\n            var t = arguments[0];\n            this.setSegmentIntersector(t);\n          }\n        }\n      }]);\n    }(),\n    Cn = function (t) {\n      function i() {\n        var t;\n        return n(this, i), t = e(this, i), i.constructor_.apply(t, arguments), t;\n      }\n      return l(i, t), s(i, [{\n        key: \"getMonotoneChains\",\n        value: function () {\n          return this._monoChains;\n        }\n      }, {\n        key: \"getNodedSubstrings\",\n        value: function () {\n          return xn.getNodedSubstrings(this._nodedSegStrings);\n        }\n      }, {\n        key: \"getIndex\",\n        value: function () {\n          return this._index;\n        }\n      }, {\n        key: \"add\",\n        value: function (t) {\n          for (var e = Tn.getChains(t.getCoordinates(), t).iterator(); e.hasNext();) {\n            var n = e.next();\n            n.setId(this._idCounter++), this._index.insert(n.getEnvelope(), n), this._monoChains.add(n);\n          }\n        }\n      }, {\n        key: \"computeNodes\",\n        value: function (t) {\n          this._nodedSegStrings = t;\n          for (var e = t.iterator(); e.hasNext();) this.add(e.next());\n          this.intersectChains();\n        }\n      }, {\n        key: \"intersectChains\",\n        value: function () {\n          for (var t = new Rn(this._segInt), e = this._monoChains.iterator(); e.hasNext();) for (var n = e.next(), i = this._index.query(n.getEnvelope()).iterator(); i.hasNext();) {\n            var r = i.next();\n            if (r.getId() > n.getId() && (n.computeOverlaps(r, t), this._nOverlaps++), this._segInt.isDone()) return null;\n          }\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          if (this._monoChains = new yt(), this._index = new fn(), this._idCounter = 0, this._nodedSegStrings = null, this._nOverlaps = 0, 0 === arguments.length) ;else if (1 === arguments.length) {\n            var t = arguments[0];\n            Ln.constructor_.call(this, t);\n          }\n        }\n      }]);\n    }(Ln),\n    Rn = function (t) {\n      function i() {\n        var t;\n        return n(this, i), t = e(this, i), i.constructor_.apply(t, arguments), t;\n      }\n      return l(i, t), s(i, [{\n        key: \"overlap\",\n        value: function () {\n          if (4 !== arguments.length) return f(i, \"overlap\", this, 1).apply(this, arguments);\n          var t = arguments[1],\n            e = arguments[2],\n            n = arguments[3],\n            r = arguments[0].getContext(),\n            s = e.getContext();\n          this._si.processIntersections(r, t, s, n);\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this._si = null;\n          var t = arguments[0];\n          this._si = t;\n        }\n      }]);\n    }(En);\n  Cn.SegmentOverlapAction = Rn;\n  var wn = function () {\n    function t() {\n      n(this, t), t.constructor_.apply(this, arguments);\n    }\n    return s(t, [{\n      key: \"isDeletable\",\n      value: function (t, e, n, i) {\n        var r = this._inputLine[t],\n          s = this._inputLine[e],\n          a = this._inputLine[n];\n        return !!this.isConcave(r, s, a) && !!this.isShallow(r, s, a, i) && this.isShallowSampled(r, s, t, n, i);\n      }\n    }, {\n      key: \"deleteShallowConcavities\",\n      value: function () {\n        for (var e = 1, n = this.findNextNonDeletedIndex(e), i = this.findNextNonDeletedIndex(n), r = !1; i < this._inputLine.length;) {\n          var s = !1;\n          this.isDeletable(e, n, i, this._distanceTol) && (this._isDeleted[n] = t.DELETE, s = !0, r = !0), e = s ? i : n, n = this.findNextNonDeletedIndex(e), i = this.findNextNonDeletedIndex(n);\n        }\n        return r;\n      }\n    }, {\n      key: \"isShallowConcavity\",\n      value: function (t, e, n, i) {\n        return ct.index(t, e, n) === this._angleOrientation && xt.pointToSegment(e, t, n) < i;\n      }\n    }, {\n      key: \"isShallowSampled\",\n      value: function (e, n, i, r, s) {\n        var a = Math.trunc((r - i) / t.NUM_PTS_TO_CHECK);\n        a <= 0 && (a = 1);\n        for (var o = i; o < r; o += a) if (!this.isShallow(e, n, this._inputLine[o], s)) return !1;\n        return !0;\n      }\n    }, {\n      key: \"isConcave\",\n      value: function (t, e, n) {\n        var i = ct.index(t, e, n) === this._angleOrientation;\n        return i;\n      }\n    }, {\n      key: \"simplify\",\n      value: function (t) {\n        this._distanceTol = Math.abs(t), t < 0 && (this._angleOrientation = ct.CLOCKWISE), this._isDeleted = new Array(this._inputLine.length).fill(null);\n        var e = !1;\n        do {\n          e = this.deleteShallowConcavities();\n        } while (e);\n        return this.collapseLine();\n      }\n    }, {\n      key: \"findNextNonDeletedIndex\",\n      value: function (e) {\n        for (var n = e + 1; n < this._inputLine.length && this._isDeleted[n] === t.DELETE;) n++;\n        return n;\n      }\n    }, {\n      key: \"isShallow\",\n      value: function (t, e, n, i) {\n        return xt.pointToSegment(e, t, n) < i;\n      }\n    }, {\n      key: \"collapseLine\",\n      value: function () {\n        for (var e = new Zt(), n = 0; n < this._inputLine.length; n++) this._isDeleted[n] !== t.DELETE && e.add(this._inputLine[n]);\n        return e.toCoordinateArray();\n      }\n    }], [{\n      key: \"constructor_\",\n      value: function () {\n        this._inputLine = null, this._distanceTol = null, this._isDeleted = null, this._angleOrientation = ct.COUNTERCLOCKWISE;\n        var t = arguments[0];\n        this._inputLine = t;\n      }\n    }, {\n      key: \"simplify\",\n      value: function (e, n) {\n        return new t(e).simplify(n);\n      }\n    }]);\n  }();\n  wn.INIT = 0, wn.DELETE = 1, wn.KEEP = 1, wn.NUM_PTS_TO_CHECK = 10;\n  var On = function () {\n    function t() {\n      n(this, t), t.constructor_.apply(this, arguments);\n    }\n    return s(t, [{\n      key: \"getCoordinates\",\n      value: function () {\n        return this._ptList.toArray(t.COORDINATE_ARRAY_TYPE);\n      }\n    }, {\n      key: \"setPrecisionModel\",\n      value: function (t) {\n        this._precisionModel = t;\n      }\n    }, {\n      key: \"addPt\",\n      value: function (t) {\n        var e = new X(t);\n        if (this._precisionModel.makePrecise(e), this.isRedundant(e)) return null;\n        this._ptList.add(e);\n      }\n    }, {\n      key: \"reverse\",\n      value: function () {}\n    }, {\n      key: \"addPts\",\n      value: function (t, e) {\n        if (e) for (var n = 0; n < t.length; n++) this.addPt(t[n]);else for (var i = t.length - 1; i >= 0; i--) this.addPt(t[i]);\n      }\n    }, {\n      key: \"isRedundant\",\n      value: function (t) {\n        if (this._ptList.size() < 1) return !1;\n        var e = this._ptList.get(this._ptList.size() - 1);\n        return t.distance(e) < this._minimimVertexDistance;\n      }\n    }, {\n      key: \"toString\",\n      value: function () {\n        return new ae().createLineString(this.getCoordinates()).toString();\n      }\n    }, {\n      key: \"closeRing\",\n      value: function () {\n        if (this._ptList.size() < 1) return null;\n        var t = new X(this._ptList.get(0)),\n          e = this._ptList.get(this._ptList.size() - 1);\n        if (t.equals(e)) return null;\n        this._ptList.add(t);\n      }\n    }, {\n      key: \"setMinimumVertexDistance\",\n      value: function (t) {\n        this._minimimVertexDistance = t;\n      }\n    }], [{\n      key: \"constructor_\",\n      value: function () {\n        this._ptList = null, this._precisionModel = null, this._minimimVertexDistance = 0, this._ptList = new yt();\n      }\n    }]);\n  }();\n  On.COORDINATE_ARRAY_TYPE = new Array(0).fill(null);\n  var bn = function () {\n    function t() {\n      n(this, t);\n    }\n    return s(t, null, [{\n      key: \"toDegrees\",\n      value: function (t) {\n        return 180 * t / Math.PI;\n      }\n    }, {\n      key: \"normalize\",\n      value: function (e) {\n        for (; e > Math.PI;) e -= t.PI_TIMES_2;\n        for (; e <= -Math.PI;) e += t.PI_TIMES_2;\n        return e;\n      }\n    }, {\n      key: \"angle\",\n      value: function () {\n        if (1 === arguments.length) {\n          var t = arguments[0];\n          return Math.atan2(t.y, t.x);\n        }\n        if (2 === arguments.length) {\n          var e = arguments[0],\n            n = arguments[1],\n            i = n.x - e.x,\n            r = n.y - e.y;\n          return Math.atan2(r, i);\n        }\n      }\n    }, {\n      key: \"isAcute\",\n      value: function (t, e, n) {\n        var i = t.x - e.x,\n          r = t.y - e.y;\n        return i * (n.x - e.x) + r * (n.y - e.y) > 0;\n      }\n    }, {\n      key: \"isObtuse\",\n      value: function (t, e, n) {\n        var i = t.x - e.x,\n          r = t.y - e.y;\n        return i * (n.x - e.x) + r * (n.y - e.y) < 0;\n      }\n    }, {\n      key: \"interiorAngle\",\n      value: function (e, n, i) {\n        var r = t.angle(n, e),\n          s = t.angle(n, i);\n        return Math.abs(s - r);\n      }\n    }, {\n      key: \"normalizePositive\",\n      value: function (e) {\n        if (e < 0) {\n          for (; e < 0;) e += t.PI_TIMES_2;\n          e >= t.PI_TIMES_2 && (e = 0);\n        } else {\n          for (; e >= t.PI_TIMES_2;) e -= t.PI_TIMES_2;\n          e < 0 && (e = 0);\n        }\n        return e;\n      }\n    }, {\n      key: \"angleBetween\",\n      value: function (e, n, i) {\n        var r = t.angle(n, e),\n          s = t.angle(n, i);\n        return t.diff(r, s);\n      }\n    }, {\n      key: \"diff\",\n      value: function (t, e) {\n        var n = null;\n        return (n = t < e ? e - t : t - e) > Math.PI && (n = 2 * Math.PI - n), n;\n      }\n    }, {\n      key: \"toRadians\",\n      value: function (t) {\n        return t * Math.PI / 180;\n      }\n    }, {\n      key: \"getTurn\",\n      value: function (e, n) {\n        var i = Math.sin(n - e);\n        return i > 0 ? t.COUNTERCLOCKWISE : i < 0 ? t.CLOCKWISE : t.NONE;\n      }\n    }, {\n      key: \"angleBetweenOriented\",\n      value: function (e, n, i) {\n        var r = t.angle(n, e),\n          s = t.angle(n, i) - r;\n        return s <= -Math.PI ? s + t.PI_TIMES_2 : s > Math.PI ? s - t.PI_TIMES_2 : s;\n      }\n    }]);\n  }();\n  bn.PI_TIMES_2 = 2 * Math.PI, bn.PI_OVER_2 = Math.PI / 2, bn.PI_OVER_4 = Math.PI / 4, bn.COUNTERCLOCKWISE = ct.COUNTERCLOCKWISE, bn.CLOCKWISE = ct.CLOCKWISE, bn.NONE = ct.COLLINEAR;\n  var Mn = function () {\n    function t() {\n      n(this, t), t.constructor_.apply(this, arguments);\n    }\n    return s(t, [{\n      key: \"addNextSegment\",\n      value: function (t, e) {\n        if (this._s0 = this._s1, this._s1 = this._s2, this._s2 = t, this._seg0.setCoordinates(this._s0, this._s1), this.computeOffsetSegment(this._seg0, this._side, this._distance, this._offset0), this._seg1.setCoordinates(this._s1, this._s2), this.computeOffsetSegment(this._seg1, this._side, this._distance, this._offset1), this._s1.equals(this._s2)) return null;\n        var n = ct.index(this._s0, this._s1, this._s2),\n          i = n === ct.CLOCKWISE && this._side === $.LEFT || n === ct.COUNTERCLOCKWISE && this._side === $.RIGHT;\n        0 === n ? this.addCollinear(e) : i ? this.addOutsideTurn(n, e) : this.addInsideTurn(n, e);\n      }\n    }, {\n      key: \"addLineEndCap\",\n      value: function (t, e) {\n        var n = new In(t, e),\n          i = new In();\n        this.computeOffsetSegment(n, $.LEFT, this._distance, i);\n        var r = new In();\n        this.computeOffsetSegment(n, $.RIGHT, this._distance, r);\n        var s = e.x - t.x,\n          a = e.y - t.y,\n          o = Math.atan2(a, s);\n        switch (this._bufParams.getEndCapStyle()) {\n          case _.CAP_ROUND:\n            this._segList.addPt(i.p1), this.addDirectedFillet(e, o + Math.PI / 2, o - Math.PI / 2, ct.CLOCKWISE, this._distance), this._segList.addPt(r.p1);\n            break;\n          case _.CAP_FLAT:\n            this._segList.addPt(i.p1), this._segList.addPt(r.p1);\n            break;\n          case _.CAP_SQUARE:\n            var u = new X();\n            u.x = Math.abs(this._distance) * Math.cos(o), u.y = Math.abs(this._distance) * Math.sin(o);\n            var l = new X(i.p1.x + u.x, i.p1.y + u.y),\n              h = new X(r.p1.x + u.x, r.p1.y + u.y);\n            this._segList.addPt(l), this._segList.addPt(h);\n        }\n      }\n    }, {\n      key: \"getCoordinates\",\n      value: function () {\n        return this._segList.getCoordinates();\n      }\n    }, {\n      key: \"addMitreJoin\",\n      value: function (t, e, n, i) {\n        var r = pt.intersection(e.p0, e.p1, n.p0, n.p1);\n        if (null !== r && (i <= 0 ? 1 : r.distance(t) / Math.abs(i)) <= this._bufParams.getMitreLimit()) return this._segList.addPt(r), null;\n        this.addLimitedMitreJoin(e, n, i, this._bufParams.getMitreLimit());\n      }\n    }, {\n      key: \"addOutsideTurn\",\n      value: function (e, n) {\n        if (this._offset0.p1.distance(this._offset1.p0) < this._distance * t.OFFSET_SEGMENT_SEPARATION_FACTOR) return this._segList.addPt(this._offset0.p1), null;\n        this._bufParams.getJoinStyle() === _.JOIN_MITRE ? this.addMitreJoin(this._s1, this._offset0, this._offset1, this._distance) : this._bufParams.getJoinStyle() === _.JOIN_BEVEL ? this.addBevelJoin(this._offset0, this._offset1) : (n && this._segList.addPt(this._offset0.p1), this.addCornerFillet(this._s1, this._offset0.p1, this._offset1.p0, e, this._distance), this._segList.addPt(this._offset1.p0));\n      }\n    }, {\n      key: \"createSquare\",\n      value: function (t) {\n        this._segList.addPt(new X(t.x + this._distance, t.y + this._distance)), this._segList.addPt(new X(t.x + this._distance, t.y - this._distance)), this._segList.addPt(new X(t.x - this._distance, t.y - this._distance)), this._segList.addPt(new X(t.x - this._distance, t.y + this._distance)), this._segList.closeRing();\n      }\n    }, {\n      key: \"addSegments\",\n      value: function (t, e) {\n        this._segList.addPts(t, e);\n      }\n    }, {\n      key: \"addFirstSegment\",\n      value: function () {\n        this._segList.addPt(this._offset1.p0);\n      }\n    }, {\n      key: \"addCornerFillet\",\n      value: function (t, e, n, i, r) {\n        var s = e.x - t.x,\n          a = e.y - t.y,\n          o = Math.atan2(a, s),\n          u = n.x - t.x,\n          l = n.y - t.y,\n          h = Math.atan2(l, u);\n        i === ct.CLOCKWISE ? o <= h && (o += 2 * Math.PI) : o >= h && (o -= 2 * Math.PI), this._segList.addPt(e), this.addDirectedFillet(t, o, h, i, r), this._segList.addPt(n);\n      }\n    }, {\n      key: \"addLastSegment\",\n      value: function () {\n        this._segList.addPt(this._offset1.p1);\n      }\n    }, {\n      key: \"initSideSegments\",\n      value: function (t, e, n) {\n        this._s1 = t, this._s2 = e, this._side = n, this._seg1.setCoordinates(t, e), this.computeOffsetSegment(this._seg1, n, this._distance, this._offset1);\n      }\n    }, {\n      key: \"addLimitedMitreJoin\",\n      value: function (t, e, n, i) {\n        var r = this._seg0.p1,\n          s = bn.angle(r, this._seg0.p0),\n          a = bn.angleBetweenOriented(this._seg0.p0, r, this._seg1.p1) / 2,\n          o = bn.normalize(s + a),\n          u = bn.normalize(o + Math.PI),\n          l = i * n,\n          h = n - l * Math.abs(Math.sin(a)),\n          c = r.x + l * Math.cos(u),\n          f = r.y + l * Math.sin(u),\n          g = new X(c, f),\n          v = new In(r, g),\n          y = v.pointAlongOffset(1, h),\n          d = v.pointAlongOffset(1, -h);\n        this._side === $.LEFT ? (this._segList.addPt(y), this._segList.addPt(d)) : (this._segList.addPt(d), this._segList.addPt(y));\n      }\n    }, {\n      key: \"addDirectedFillet\",\n      value: function (t, e, n, i, r) {\n        var s = i === ct.CLOCKWISE ? -1 : 1,\n          a = Math.abs(e - n),\n          o = Math.trunc(a / this._filletAngleQuantum + .5);\n        if (o < 1) return null;\n        for (var u = a / o, l = new X(), h = 0; h < o; h++) {\n          var c = e + s * h * u;\n          l.x = t.x + r * Math.cos(c), l.y = t.y + r * Math.sin(c), this._segList.addPt(l);\n        }\n      }\n    }, {\n      key: \"computeOffsetSegment\",\n      value: function (t, e, n, i) {\n        var r = e === $.LEFT ? 1 : -1,\n          s = t.p1.x - t.p0.x,\n          a = t.p1.y - t.p0.y,\n          o = Math.sqrt(s * s + a * a),\n          u = r * n * s / o,\n          l = r * n * a / o;\n        i.p0.x = t.p0.x - l, i.p0.y = t.p0.y + u, i.p1.x = t.p1.x - l, i.p1.y = t.p1.y + u;\n      }\n    }, {\n      key: \"addInsideTurn\",\n      value: function (e, n) {\n        if (this._li.computeIntersection(this._offset0.p0, this._offset0.p1, this._offset1.p0, this._offset1.p1), this._li.hasIntersection()) this._segList.addPt(this._li.getIntersection(0));else if (this._hasNarrowConcaveAngle = !0, this._offset0.p1.distance(this._offset1.p0) < this._distance * t.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR) this._segList.addPt(this._offset0.p1);else {\n          if (this._segList.addPt(this._offset0.p1), this._closingSegLengthFactor > 0) {\n            var i = new X((this._closingSegLengthFactor * this._offset0.p1.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset0.p1.y + this._s1.y) / (this._closingSegLengthFactor + 1));\n            this._segList.addPt(i);\n            var r = new X((this._closingSegLengthFactor * this._offset1.p0.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset1.p0.y + this._s1.y) / (this._closingSegLengthFactor + 1));\n            this._segList.addPt(r);\n          } else this._segList.addPt(this._s1);\n          this._segList.addPt(this._offset1.p0);\n        }\n      }\n    }, {\n      key: \"createCircle\",\n      value: function (t) {\n        var e = new X(t.x + this._distance, t.y);\n        this._segList.addPt(e), this.addDirectedFillet(t, 0, 2 * Math.PI, -1, this._distance), this._segList.closeRing();\n      }\n    }, {\n      key: \"addBevelJoin\",\n      value: function (t, e) {\n        this._segList.addPt(t.p1), this._segList.addPt(e.p0);\n      }\n    }, {\n      key: \"init\",\n      value: function (e) {\n        this._distance = e, this._maxCurveSegmentError = e * (1 - Math.cos(this._filletAngleQuantum / 2)), this._segList = new On(), this._segList.setPrecisionModel(this._precisionModel), this._segList.setMinimumVertexDistance(e * t.CURVE_VERTEX_SNAP_DISTANCE_FACTOR);\n      }\n    }, {\n      key: \"addCollinear\",\n      value: function (t) {\n        this._li.computeIntersection(this._s0, this._s1, this._s1, this._s2), this._li.getIntersectionNum() >= 2 && (this._bufParams.getJoinStyle() === _.JOIN_BEVEL || this._bufParams.getJoinStyle() === _.JOIN_MITRE ? (t && this._segList.addPt(this._offset0.p1), this._segList.addPt(this._offset1.p0)) : this.addCornerFillet(this._s1, this._offset0.p1, this._offset1.p0, ct.CLOCKWISE, this._distance));\n      }\n    }, {\n      key: \"closeRing\",\n      value: function () {\n        this._segList.closeRing();\n      }\n    }, {\n      key: \"hasNarrowConcaveAngle\",\n      value: function () {\n        return this._hasNarrowConcaveAngle;\n      }\n    }], [{\n      key: \"constructor_\",\n      value: function () {\n        this._maxCurveSegmentError = 0, this._filletAngleQuantum = null, this._closingSegLengthFactor = 1, this._segList = null, this._distance = 0, this._precisionModel = null, this._bufParams = null, this._li = null, this._s0 = null, this._s1 = null, this._s2 = null, this._seg0 = new In(), this._seg1 = new In(), this._offset0 = new In(), this._offset1 = new In(), this._side = 0, this._hasNarrowConcaveAngle = !1;\n        var e = arguments[0],\n          n = arguments[1],\n          i = arguments[2];\n        this._precisionModel = e, this._bufParams = n, this._li = new we(), this._filletAngleQuantum = Math.PI / 2 / n.getQuadrantSegments(), n.getQuadrantSegments() >= 8 && n.getJoinStyle() === _.JOIN_ROUND && (this._closingSegLengthFactor = t.MAX_CLOSING_SEG_LEN_FACTOR), this.init(i);\n      }\n    }]);\n  }();\n  Mn.OFFSET_SEGMENT_SEPARATION_FACTOR = .001, Mn.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR = .001, Mn.CURVE_VERTEX_SNAP_DISTANCE_FACTOR = 1e-6, Mn.MAX_CLOSING_SEG_LEN_FACTOR = 80;\n  var An = function () {\n      function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }\n      return s(t, [{\n        key: \"getOffsetCurve\",\n        value: function (t, e) {\n          if (this._distance = e, 0 === e) return null;\n          var n = e < 0,\n            i = Math.abs(e),\n            r = this.getSegGen(i);\n          t.length <= 1 ? this.computePointCurve(t[0], r) : this.computeOffsetCurve(t, n, r);\n          var s = r.getCoordinates();\n          return n && jt.reverse(s), s;\n        }\n      }, {\n        key: \"computeSingleSidedBufferCurve\",\n        value: function (t, e, n) {\n          var i = this.simplifyTolerance(this._distance);\n          if (e) {\n            n.addSegments(t, !0);\n            var r = wn.simplify(t, -i),\n              s = r.length - 1;\n            n.initSideSegments(r[s], r[s - 1], $.LEFT), n.addFirstSegment();\n            for (var a = s - 2; a >= 0; a--) n.addNextSegment(r[a], !0);\n          } else {\n            n.addSegments(t, !1);\n            var o = wn.simplify(t, i),\n              u = o.length - 1;\n            n.initSideSegments(o[0], o[1], $.LEFT), n.addFirstSegment();\n            for (var l = 2; l <= u; l++) n.addNextSegment(o[l], !0);\n          }\n          n.addLastSegment(), n.closeRing();\n        }\n      }, {\n        key: \"computeRingBufferCurve\",\n        value: function (t, e, n) {\n          var i = this.simplifyTolerance(this._distance);\n          e === $.RIGHT && (i = -i);\n          var r = wn.simplify(t, i),\n            s = r.length - 1;\n          n.initSideSegments(r[s - 1], r[0], e);\n          for (var a = 1; a <= s; a++) {\n            var o = 1 !== a;\n            n.addNextSegment(r[a], o);\n          }\n          n.closeRing();\n        }\n      }, {\n        key: \"computeLineBufferCurve\",\n        value: function (t, e) {\n          var n = this.simplifyTolerance(this._distance),\n            i = wn.simplify(t, n),\n            r = i.length - 1;\n          e.initSideSegments(i[0], i[1], $.LEFT);\n          for (var s = 2; s <= r; s++) e.addNextSegment(i[s], !0);\n          e.addLastSegment(), e.addLineEndCap(i[r - 1], i[r]);\n          var a = wn.simplify(t, -n),\n            o = a.length - 1;\n          e.initSideSegments(a[o], a[o - 1], $.LEFT);\n          for (var u = o - 2; u >= 0; u--) e.addNextSegment(a[u], !0);\n          e.addLastSegment(), e.addLineEndCap(a[1], a[0]), e.closeRing();\n        }\n      }, {\n        key: \"computePointCurve\",\n        value: function (t, e) {\n          switch (this._bufParams.getEndCapStyle()) {\n            case _.CAP_ROUND:\n              e.createCircle(t);\n              break;\n            case _.CAP_SQUARE:\n              e.createSquare(t);\n          }\n        }\n      }, {\n        key: \"getLineCurve\",\n        value: function (t, e) {\n          if (this._distance = e, this.isLineOffsetEmpty(e)) return null;\n          var n = Math.abs(e),\n            i = this.getSegGen(n);\n          if (t.length <= 1) this.computePointCurve(t[0], i);else if (this._bufParams.isSingleSided()) {\n            var r = e < 0;\n            this.computeSingleSidedBufferCurve(t, r, i);\n          } else this.computeLineBufferCurve(t, i);\n          return i.getCoordinates();\n        }\n      }, {\n        key: \"getBufferParameters\",\n        value: function () {\n          return this._bufParams;\n        }\n      }, {\n        key: \"simplifyTolerance\",\n        value: function (t) {\n          return t * this._bufParams.getSimplifyFactor();\n        }\n      }, {\n        key: \"getRingCurve\",\n        value: function (e, n, i) {\n          if (this._distance = i, e.length <= 2) return this.getLineCurve(e, i);\n          if (0 === i) return t.copyCoordinates(e);\n          var r = this.getSegGen(i);\n          return this.computeRingBufferCurve(e, n, r), r.getCoordinates();\n        }\n      }, {\n        key: \"computeOffsetCurve\",\n        value: function (t, e, n) {\n          var i = this.simplifyTolerance(this._distance);\n          if (e) {\n            var r = wn.simplify(t, -i),\n              s = r.length - 1;\n            n.initSideSegments(r[s], r[s - 1], $.LEFT), n.addFirstSegment();\n            for (var a = s - 2; a >= 0; a--) n.addNextSegment(r[a], !0);\n          } else {\n            var o = wn.simplify(t, i),\n              u = o.length - 1;\n            n.initSideSegments(o[0], o[1], $.LEFT), n.addFirstSegment();\n            for (var l = 2; l <= u; l++) n.addNextSegment(o[l], !0);\n          }\n          n.addLastSegment();\n        }\n      }, {\n        key: \"isLineOffsetEmpty\",\n        value: function (t) {\n          return 0 === t || t < 0 && !this._bufParams.isSingleSided();\n        }\n      }, {\n        key: \"getSegGen\",\n        value: function (t) {\n          return new Mn(this._precisionModel, this._bufParams, t);\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this._distance = 0, this._precisionModel = null, this._bufParams = null;\n          var t = arguments[0],\n            e = arguments[1];\n          this._precisionModel = t, this._bufParams = e;\n        }\n      }, {\n        key: \"copyCoordinates\",\n        value: function (t) {\n          for (var e = new Array(t.length).fill(null), n = 0; n < e.length; n++) e[n] = new X(t[n]);\n          return e;\n        }\n      }]);\n    }(),\n    Pn = function () {\n      return s(function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }, [{\n        key: \"findStabbedSegments\",\n        value: function () {\n          if (1 === arguments.length) {\n            for (var t = arguments[0], e = new yt(), n = this._subgraphs.iterator(); n.hasNext();) {\n              var i = n.next(),\n                r = i.getEnvelope();\n              t.y < r.getMinY() || t.y > r.getMaxY() || this.findStabbedSegments(t, i.getDirectedEdges(), e);\n            }\n            return e;\n          }\n          if (3 === arguments.length) if (rt(arguments[2], nt) && arguments[0] instanceof X && arguments[1] instanceof Ke) for (var s = arguments[0], a = arguments[1], o = arguments[2], u = a.getEdge().getCoordinates(), l = 0; l < u.length - 1; l++) {\n            if (this._seg.p0 = u[l], this._seg.p1 = u[l + 1], this._seg.p0.y > this._seg.p1.y && this._seg.reverse(), !(Math.max(this._seg.p0.x, this._seg.p1.x) < s.x || this._seg.isHorizontal() || s.y < this._seg.p0.y || s.y > this._seg.p1.y || ct.index(this._seg.p0, this._seg.p1, s) === ct.RIGHT)) {\n              var h = a.getDepth($.LEFT);\n              this._seg.p0.equals(u[l]) || (h = a.getDepth($.RIGHT));\n              var c = new Dn(this._seg, h);\n              o.add(c);\n            }\n          } else if (rt(arguments[2], nt) && arguments[0] instanceof X && rt(arguments[1], nt)) for (var f = arguments[0], g = arguments[2], v = arguments[1].iterator(); v.hasNext();) {\n            var y = v.next();\n            y.isForward() && this.findStabbedSegments(f, y, g);\n          }\n        }\n      }, {\n        key: \"getDepth\",\n        value: function (t) {\n          var e = this.findStabbedSegments(t);\n          return 0 === e.size() ? 0 : an.min(e)._leftDepth;\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this._subgraphs = null, this._seg = new In();\n          var t = arguments[0];\n          this._subgraphs = t;\n        }\n      }]);\n    }(),\n    Dn = function () {\n      return s(function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }, [{\n        key: \"compareTo\",\n        value: function (t) {\n          var e = t;\n          if (this._upwardSeg.minX() >= e._upwardSeg.maxX()) return 1;\n          if (this._upwardSeg.maxX() <= e._upwardSeg.minX()) return -1;\n          var n = this._upwardSeg.orientationIndex(e._upwardSeg);\n          return 0 !== n || 0 !== (n = -1 * e._upwardSeg.orientationIndex(this._upwardSeg)) ? n : this._upwardSeg.compareTo(e._upwardSeg);\n        }\n      }, {\n        key: \"compareX\",\n        value: function (t, e) {\n          var n = t.p0.compareTo(e.p0);\n          return 0 !== n ? n : t.p1.compareTo(e.p1);\n        }\n      }, {\n        key: \"toString\",\n        value: function () {\n          return this._upwardSeg.toString();\n        }\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [x];\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this._upwardSeg = null, this._leftDepth = null;\n          var t = arguments[0],\n            e = arguments[1];\n          this._upwardSeg = new In(t), this._leftDepth = e;\n        }\n      }]);\n    }();\n  Pn.DepthSegment = Dn;\n  var Fn = function (t) {\n      function i() {\n        var t;\n        return n(this, i), t = e(this, i), i.constructor_.apply(t, arguments), t;\n      }\n      return l(i, t), s(i, null, [{\n        key: \"constructor_\",\n        value: function () {\n          p.constructor_.call(this, \"Projective point not representable on the Cartesian plane.\");\n        }\n      }]);\n    }(p),\n    Gn = function () {\n      function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }\n      return s(t, [{\n        key: \"getY\",\n        value: function () {\n          var t = this.y / this.w;\n          if (A.isNaN(t) || A.isInfinite(t)) throw new Fn();\n          return t;\n        }\n      }, {\n        key: \"getX\",\n        value: function () {\n          var t = this.x / this.w;\n          if (A.isNaN(t) || A.isInfinite(t)) throw new Fn();\n          return t;\n        }\n      }, {\n        key: \"getCoordinate\",\n        value: function () {\n          var t = new X();\n          return t.x = this.getX(), t.y = this.getY(), t;\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          if (this.x = null, this.y = null, this.w = null, 0 === arguments.length) this.x = 0, this.y = 0, this.w = 1;else if (1 === arguments.length) {\n            var e = arguments[0];\n            this.x = e.x, this.y = e.y, this.w = 1;\n          } else if (2 === arguments.length) {\n            if (\"number\" == typeof arguments[0] && \"number\" == typeof arguments[1]) {\n              var n = arguments[0],\n                i = arguments[1];\n              this.x = n, this.y = i, this.w = 1;\n            } else if (arguments[0] instanceof t && arguments[1] instanceof t) {\n              var r = arguments[0],\n                s = arguments[1];\n              this.x = r.y * s.w - s.y * r.w, this.y = s.x * r.w - r.x * s.w, this.w = r.x * s.y - s.x * r.y;\n            } else if (arguments[0] instanceof X && arguments[1] instanceof X) {\n              var a = arguments[0],\n                o = arguments[1];\n              this.x = a.y - o.y, this.y = o.x - a.x, this.w = a.x * o.y - o.x * a.y;\n            }\n          } else if (3 === arguments.length) {\n            var u = arguments[0],\n              l = arguments[1],\n              h = arguments[2];\n            this.x = u, this.y = l, this.w = h;\n          } else if (4 === arguments.length) {\n            var c = arguments[0],\n              f = arguments[1],\n              g = arguments[2],\n              v = arguments[3],\n              y = c.y - f.y,\n              d = f.x - c.x,\n              _ = c.x * f.y - f.x * c.y,\n              p = g.y - v.y,\n              m = v.x - g.x,\n              k = g.x * v.y - v.x * g.y;\n            this.x = d * k - m * _, this.y = p * _ - y * k, this.w = y * m - p * d;\n          }\n        }\n      }]);\n    }(),\n    qn = function () {\n      function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }\n      return s(t, [{\n        key: \"area\",\n        value: function () {\n          return t.area(this.p0, this.p1, this.p2);\n        }\n      }, {\n        key: \"signedArea\",\n        value: function () {\n          return t.signedArea(this.p0, this.p1, this.p2);\n        }\n      }, {\n        key: \"interpolateZ\",\n        value: function (e) {\n          if (null === e) throw new m(\"Supplied point is null.\");\n          return t.interpolateZ(e, this.p0, this.p1, this.p2);\n        }\n      }, {\n        key: \"longestSideLength\",\n        value: function () {\n          return t.longestSideLength(this.p0, this.p1, this.p2);\n        }\n      }, {\n        key: \"isAcute\",\n        value: function () {\n          return t.isAcute(this.p0, this.p1, this.p2);\n        }\n      }, {\n        key: \"circumcentre\",\n        value: function () {\n          return t.circumcentre(this.p0, this.p1, this.p2);\n        }\n      }, {\n        key: \"area3D\",\n        value: function () {\n          return t.area3D(this.p0, this.p1, this.p2);\n        }\n      }, {\n        key: \"centroid\",\n        value: function () {\n          return t.centroid(this.p0, this.p1, this.p2);\n        }\n      }, {\n        key: \"inCentre\",\n        value: function () {\n          return t.inCentre(this.p0, this.p1, this.p2);\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this.p0 = null, this.p1 = null, this.p2 = null;\n          var t = arguments[0],\n            e = arguments[1],\n            n = arguments[2];\n          this.p0 = t, this.p1 = e, this.p2 = n;\n        }\n      }, {\n        key: \"area\",\n        value: function (t, e, n) {\n          return Math.abs(((n.x - t.x) * (e.y - t.y) - (e.x - t.x) * (n.y - t.y)) / 2);\n        }\n      }, {\n        key: \"signedArea\",\n        value: function (t, e, n) {\n          return ((n.x - t.x) * (e.y - t.y) - (e.x - t.x) * (n.y - t.y)) / 2;\n        }\n      }, {\n        key: \"det\",\n        value: function (t, e, n, i) {\n          return t * i - e * n;\n        }\n      }, {\n        key: \"interpolateZ\",\n        value: function (t, e, n, i) {\n          var r = e.x,\n            s = e.y,\n            a = n.x - r,\n            o = i.x - r,\n            u = n.y - s,\n            l = i.y - s,\n            h = a * l - o * u,\n            c = t.x - r,\n            f = t.y - s,\n            g = (l * c - o * f) / h,\n            v = (-u * c + a * f) / h;\n          return e.getZ() + g * (n.getZ() - e.getZ()) + v * (i.getZ() - e.getZ());\n        }\n      }, {\n        key: \"longestSideLength\",\n        value: function (t, e, n) {\n          var i = t.distance(e),\n            r = e.distance(n),\n            s = n.distance(t),\n            a = i;\n          return r > a && (a = r), s > a && (a = s), a;\n        }\n      }, {\n        key: \"circumcentreDD\",\n        value: function (t, e, n) {\n          var i = ut.valueOf(t.x).subtract(n.x),\n            r = ut.valueOf(t.y).subtract(n.y),\n            s = ut.valueOf(e.x).subtract(n.x),\n            a = ut.valueOf(e.y).subtract(n.y),\n            o = ut.determinant(i, r, s, a).multiply(2),\n            u = i.sqr().add(r.sqr()),\n            l = s.sqr().add(a.sqr()),\n            h = ut.determinant(r, u, a, l),\n            c = ut.determinant(i, u, s, l),\n            f = ut.valueOf(n.x).subtract(h.divide(o)).doubleValue(),\n            g = ut.valueOf(n.y).add(c.divide(o)).doubleValue();\n          return new X(f, g);\n        }\n      }, {\n        key: \"isAcute\",\n        value: function (t, e, n) {\n          return !!bn.isAcute(t, e, n) && !!bn.isAcute(e, n, t) && !!bn.isAcute(n, t, e);\n        }\n      }, {\n        key: \"circumcentre\",\n        value: function (e, n, i) {\n          var r = i.x,\n            s = i.y,\n            a = e.x - r,\n            o = e.y - s,\n            u = n.x - r,\n            l = n.y - s,\n            h = 2 * t.det(a, o, u, l),\n            c = t.det(o, a * a + o * o, l, u * u + l * l),\n            f = t.det(a, a * a + o * o, u, u * u + l * l);\n          return new X(r - c / h, s + f / h);\n        }\n      }, {\n        key: \"perpendicularBisector\",\n        value: function (t, e) {\n          var n = e.x - t.x,\n            i = e.y - t.y,\n            r = new Gn(t.x + n / 2, t.y + i / 2, 1),\n            s = new Gn(t.x - i + n / 2, t.y + n + i / 2, 1);\n          return new Gn(r, s);\n        }\n      }, {\n        key: \"angleBisector\",\n        value: function (t, e, n) {\n          var i = e.distance(t),\n            r = i / (i + e.distance(n)),\n            s = n.x - t.x,\n            a = n.y - t.y;\n          return new X(t.x + r * s, t.y + r * a);\n        }\n      }, {\n        key: \"area3D\",\n        value: function (t, e, n) {\n          var i = e.x - t.x,\n            r = e.y - t.y,\n            s = e.getZ() - t.getZ(),\n            a = n.x - t.x,\n            o = n.y - t.y,\n            u = n.getZ() - t.getZ(),\n            l = r * u - s * o,\n            h = s * a - i * u,\n            c = i * o - r * a,\n            f = l * l + h * h + c * c,\n            g = Math.sqrt(f) / 2;\n          return g;\n        }\n      }, {\n        key: \"centroid\",\n        value: function (t, e, n) {\n          var i = (t.x + e.x + n.x) / 3,\n            r = (t.y + e.y + n.y) / 3;\n          return new X(i, r);\n        }\n      }, {\n        key: \"inCentre\",\n        value: function (t, e, n) {\n          var i = e.distance(n),\n            r = t.distance(n),\n            s = t.distance(e),\n            a = i + r + s,\n            o = (i * t.x + r * e.x + s * n.x) / a,\n            u = (i * t.y + r * e.y + s * n.y) / a;\n          return new X(o, u);\n        }\n      }]);\n    }(),\n    Yn = function () {\n      return s(function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }, [{\n        key: \"addRingSide\",\n        value: function (t, e, n, i, r) {\n          if (0 === e && t.length < Xt.MINIMUM_VALID_SIZE) return null;\n          var s = i,\n            a = r;\n          t.length >= Xt.MINIMUM_VALID_SIZE && ct.isCCW(t) && (s = r, a = i, n = $.opposite(n));\n          var o = this._curveBuilder.getRingCurve(t, n, e);\n          this.addCurve(o, s, a);\n        }\n      }, {\n        key: \"addRingBothSides\",\n        value: function (t, e) {\n          this.addRingSide(t, e, $.LEFT, H.EXTERIOR, H.INTERIOR), this.addRingSide(t, e, $.RIGHT, H.INTERIOR, H.EXTERIOR);\n        }\n      }, {\n        key: \"addPoint\",\n        value: function (t) {\n          if (this._distance <= 0) return null;\n          var e = t.getCoordinates(),\n            n = this._curveBuilder.getLineCurve(e, this._distance);\n          this.addCurve(n, H.EXTERIOR, H.INTERIOR);\n        }\n      }, {\n        key: \"addPolygon\",\n        value: function (t) {\n          var e = this._distance,\n            n = $.LEFT;\n          this._distance < 0 && (e = -this._distance, n = $.RIGHT);\n          var i = t.getExteriorRing(),\n            r = jt.removeRepeatedPoints(i.getCoordinates());\n          if (this._distance < 0 && this.isErodedCompletely(i, this._distance)) return null;\n          if (this._distance <= 0 && r.length < 3) return null;\n          this.addRingSide(r, e, n, H.EXTERIOR, H.INTERIOR);\n          for (var s = 0; s < t.getNumInteriorRing(); s++) {\n            var a = t.getInteriorRingN(s),\n              o = jt.removeRepeatedPoints(a.getCoordinates());\n            this._distance > 0 && this.isErodedCompletely(a, -this._distance) || this.addRingSide(o, e, $.opposite(n), H.INTERIOR, H.EXTERIOR);\n          }\n        }\n      }, {\n        key: \"isTriangleErodedCompletely\",\n        value: function (t, e) {\n          var n = new qn(t[0], t[1], t[2]),\n            i = n.inCentre();\n          return xt.pointToSegment(i, n.p0, n.p1) < Math.abs(e);\n        }\n      }, {\n        key: \"addLineString\",\n        value: function (t) {\n          if (this._curveBuilder.isLineOffsetEmpty(this._distance)) return null;\n          var e = jt.removeRepeatedPoints(t.getCoordinates());\n          if (jt.isRing(e) && !this._curveBuilder.getBufferParameters().isSingleSided()) this.addRingBothSides(e, this._distance);else {\n            var n = this._curveBuilder.getLineCurve(e, this._distance);\n            this.addCurve(n, H.EXTERIOR, H.INTERIOR);\n          }\n        }\n      }, {\n        key: \"addCurve\",\n        value: function (t, e, n) {\n          if (null === t || t.length < 2) return null;\n          var i = new xn(t, new Ae(0, H.BOUNDARY, e, n));\n          this._curveList.add(i);\n        }\n      }, {\n        key: \"getCurves\",\n        value: function () {\n          return this.add(this._inputGeom), this._curveList;\n        }\n      }, {\n        key: \"add\",\n        value: function (t) {\n          if (t.isEmpty()) return null;\n          if (t instanceof Dt) this.addPolygon(t);else if (t instanceof wt) this.addLineString(t);else if (t instanceof bt) this.addPoint(t);else if (t instanceof zt) this.addCollection(t);else if (t instanceof se) this.addCollection(t);else if (t instanceof te) this.addCollection(t);else {\n            if (!(t instanceof Yt)) throw new W(t.getGeometryType());\n            this.addCollection(t);\n          }\n        }\n      }, {\n        key: \"isErodedCompletely\",\n        value: function (t, e) {\n          var n = t.getCoordinates();\n          if (n.length < 4) return e < 0;\n          if (4 === n.length) return this.isTriangleErodedCompletely(n, e);\n          var i = t.getEnvelopeInternal(),\n            r = Math.min(i.getHeight(), i.getWidth());\n          return e < 0 && 2 * Math.abs(e) > r;\n        }\n      }, {\n        key: \"addCollection\",\n        value: function (t) {\n          for (var e = 0; e < t.getNumGeometries(); e++) {\n            var n = t.getGeometryN(e);\n            this.add(n);\n          }\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this._inputGeom = null, this._distance = null, this._curveBuilder = null, this._curveList = new yt();\n          var t = arguments[0],\n            e = arguments[1],\n            n = arguments[2];\n          this._inputGeom = t, this._distance = e, this._curveBuilder = n;\n        }\n      }]);\n    }(),\n    zn = function () {\n      return s(function t() {\n        n(this, t);\n      }, [{\n        key: \"locate\",\n        value: function (t) {}\n      }]);\n    }(),\n    Xn = function () {\n      function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }\n      return s(t, [{\n        key: \"next\",\n        value: function () {\n          if (this._atStart) return this._atStart = !1, t.isAtomic(this._parent) && this._index++, this._parent;\n          if (null !== this._subcollectionIterator) {\n            if (this._subcollectionIterator.hasNext()) return this._subcollectionIterator.next();\n            this._subcollectionIterator = null;\n          }\n          if (this._index >= this._max) throw new j();\n          var e = this._parent.getGeometryN(this._index++);\n          return e instanceof Yt ? (this._subcollectionIterator = new t(e), this._subcollectionIterator.next()) : e;\n        }\n      }, {\n        key: \"remove\",\n        value: function () {\n          throw new W(this.getClass().getName());\n        }\n      }, {\n        key: \"hasNext\",\n        value: function () {\n          if (this._atStart) return !0;\n          if (null !== this._subcollectionIterator) {\n            if (this._subcollectionIterator.hasNext()) return !0;\n            this._subcollectionIterator = null;\n          }\n          return !(this._index >= this._max);\n        }\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [dn];\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this._parent = null, this._atStart = null, this._max = null, this._index = null, this._subcollectionIterator = null;\n          var t = arguments[0];\n          this._parent = t, this._atStart = !0, this._index = 0, this._max = t.getNumGeometries();\n        }\n      }, {\n        key: \"isAtomic\",\n        value: function (t) {\n          return !(t instanceof Yt);\n        }\n      }]);\n    }(),\n    Bn = function () {\n      function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }\n      return s(t, [{\n        key: \"locate\",\n        value: function (e) {\n          return t.locate(e, this._geom);\n        }\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [zn];\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this._geom = null;\n          var t = arguments[0];\n          this._geom = t;\n        }\n      }, {\n        key: \"locatePointInPolygon\",\n        value: function (e, n) {\n          if (n.isEmpty()) return H.EXTERIOR;\n          var i = n.getExteriorRing(),\n            r = t.locatePointInRing(e, i);\n          if (r !== H.INTERIOR) return r;\n          for (var s = 0; s < n.getNumInteriorRing(); s++) {\n            var a = n.getInteriorRingN(s),\n              o = t.locatePointInRing(e, a);\n            if (o === H.BOUNDARY) return H.BOUNDARY;\n            if (o === H.INTERIOR) return H.EXTERIOR;\n          }\n          return H.INTERIOR;\n        }\n      }, {\n        key: \"locatePointInRing\",\n        value: function (t, e) {\n          return e.getEnvelopeInternal().intersects(t) ? be.locateInRing(t, e.getCoordinates()) : H.EXTERIOR;\n        }\n      }, {\n        key: \"containsPointInPolygon\",\n        value: function (e, n) {\n          return H.EXTERIOR !== t.locatePointInPolygon(e, n);\n        }\n      }, {\n        key: \"locateInGeometry\",\n        value: function (e, n) {\n          if (n instanceof Dt) return t.locatePointInPolygon(e, n);\n          if (n instanceof Yt) for (var i = new Xn(n); i.hasNext();) {\n            var r = i.next();\n            if (r !== n) {\n              var s = t.locateInGeometry(e, r);\n              if (s !== H.EXTERIOR) return s;\n            }\n          }\n          return H.EXTERIOR;\n        }\n      }, {\n        key: \"isContained\",\n        value: function (e, n) {\n          return H.EXTERIOR !== t.locate(e, n);\n        }\n      }, {\n        key: \"locate\",\n        value: function (e, n) {\n          return n.isEmpty() ? H.EXTERIOR : n.getEnvelopeInternal().intersects(e) ? t.locateInGeometry(e, n) : H.EXTERIOR;\n        }\n      }]);\n    }(),\n    Un = function () {\n      return s(function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }, [{\n        key: \"getNextCW\",\n        value: function (t) {\n          this.getEdges();\n          var e = this._edgeList.indexOf(t),\n            n = e - 1;\n          return 0 === e && (n = this._edgeList.size() - 1), this._edgeList.get(n);\n        }\n      }, {\n        key: \"propagateSideLabels\",\n        value: function (t) {\n          for (var e = H.NONE, n = this.iterator(); n.hasNext();) {\n            var i = n.next().getLabel();\n            i.isArea(t) && i.getLocation(t, $.LEFT) !== H.NONE && (e = i.getLocation(t, $.LEFT));\n          }\n          if (e === H.NONE) return null;\n          for (var r = e, s = this.iterator(); s.hasNext();) {\n            var a = s.next(),\n              o = a.getLabel();\n            if (o.getLocation(t, $.ON) === H.NONE && o.setLocation(t, $.ON, r), o.isArea(t)) {\n              var u = o.getLocation(t, $.LEFT),\n                l = o.getLocation(t, $.RIGHT);\n              if (l !== H.NONE) {\n                if (l !== r) throw new gt(\"side location conflict\", a.getCoordinate());\n                u === H.NONE && G.shouldNeverReachHere(\"found single null side (at \" + a.getCoordinate() + \")\"), r = u;\n              } else G.isTrue(o.getLocation(t, $.LEFT) === H.NONE, \"found single null side\"), o.setLocation(t, $.RIGHT, r), o.setLocation(t, $.LEFT, r);\n            }\n          }\n        }\n      }, {\n        key: \"getCoordinate\",\n        value: function () {\n          var t = this.iterator();\n          return t.hasNext() ? t.next().getCoordinate() : null;\n        }\n      }, {\n        key: \"print\",\n        value: function (t) {\n          mt.out.println(\"EdgeEndStar:   \" + this.getCoordinate());\n          for (var e = this.iterator(); e.hasNext();) {\n            e.next().print(t);\n          }\n        }\n      }, {\n        key: \"isAreaLabelsConsistent\",\n        value: function (t) {\n          return this.computeEdgeEndLabels(t.getBoundaryNodeRule()), this.checkAreaLabelsConsistent(0);\n        }\n      }, {\n        key: \"checkAreaLabelsConsistent\",\n        value: function (t) {\n          var e = this.getEdges();\n          if (e.size() <= 0) return !0;\n          var n = e.size() - 1,\n            i = e.get(n).getLabel().getLocation(t, $.LEFT);\n          G.isTrue(i !== H.NONE, \"Found unlabelled area edge\");\n          for (var r = i, s = this.iterator(); s.hasNext();) {\n            var a = s.next().getLabel();\n            G.isTrue(a.isArea(t), \"Found non-area edge\");\n            var o = a.getLocation(t, $.LEFT),\n              u = a.getLocation(t, $.RIGHT);\n            if (o === u) return !1;\n            if (u !== r) return !1;\n            r = o;\n          }\n          return !0;\n        }\n      }, {\n        key: \"findIndex\",\n        value: function (t) {\n          this.iterator();\n          for (var e = 0; e < this._edgeList.size(); e++) {\n            if (this._edgeList.get(e) === t) return e;\n          }\n          return -1;\n        }\n      }, {\n        key: \"iterator\",\n        value: function () {\n          return this.getEdges().iterator();\n        }\n      }, {\n        key: \"getEdges\",\n        value: function () {\n          return null === this._edgeList && (this._edgeList = new yt(this._edgeMap.values())), this._edgeList;\n        }\n      }, {\n        key: \"getLocation\",\n        value: function (t, e, n) {\n          return this._ptInAreaLocation[t] === H.NONE && (this._ptInAreaLocation[t] = Bn.locate(e, n[t].getGeometry())), this._ptInAreaLocation[t];\n        }\n      }, {\n        key: \"toString\",\n        value: function () {\n          var t = new st();\n          t.append(\"EdgeEndStar:   \" + this.getCoordinate()), t.append(\"\\n\");\n          for (var e = this.iterator(); e.hasNext();) {\n            var n = e.next();\n            t.append(n), t.append(\"\\n\");\n          }\n          return t.toString();\n        }\n      }, {\n        key: \"computeEdgeEndLabels\",\n        value: function (t) {\n          for (var e = this.iterator(); e.hasNext();) {\n            e.next().computeLabel(t);\n          }\n        }\n      }, {\n        key: \"computeLabelling\",\n        value: function (t) {\n          this.computeEdgeEndLabels(t[0].getBoundaryNodeRule()), this.propagateSideLabels(0), this.propagateSideLabels(1);\n          for (var e = [!1, !1], n = this.iterator(); n.hasNext();) for (var i = n.next().getLabel(), r = 0; r < 2; r++) i.isLine(r) && i.getLocation(r) === H.BOUNDARY && (e[r] = !0);\n          for (var s = this.iterator(); s.hasNext();) for (var a = s.next(), o = a.getLabel(), u = 0; u < 2; u++) if (o.isAnyNull(u)) {\n            var l = H.NONE;\n            if (e[u]) l = H.EXTERIOR;else {\n              var h = a.getCoordinate();\n              l = this.getLocation(u, h, t);\n            }\n            o.setAllLocationsIfNull(u, l);\n          }\n        }\n      }, {\n        key: \"getDegree\",\n        value: function () {\n          return this._edgeMap.size();\n        }\n      }, {\n        key: \"insertEdgeEnd\",\n        value: function (t, e) {\n          this._edgeMap.put(t, e), this._edgeList = null;\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this._edgeMap = new He(), this._edgeList = null, this._ptInAreaLocation = [H.NONE, H.NONE];\n        }\n      }]);\n    }(),\n    Vn = function (t) {\n      function i() {\n        var t;\n        return n(this, i), t = e(this, i), i.constructor_.apply(t, arguments), t;\n      }\n      return l(i, t), s(i, [{\n        key: \"linkResultDirectedEdges\",\n        value: function () {\n          this.getResultAreaEdges();\n          for (var t = null, e = null, n = this._SCANNING_FOR_INCOMING, i = 0; i < this._resultAreaEdgeList.size(); i++) {\n            var r = this._resultAreaEdgeList.get(i),\n              s = r.getSym();\n            if (r.getLabel().isArea()) switch (null === t && r.isInResult() && (t = r), n) {\n              case this._SCANNING_FOR_INCOMING:\n                if (!s.isInResult()) continue;\n                e = s, n = this._LINKING_TO_OUTGOING;\n                break;\n              case this._LINKING_TO_OUTGOING:\n                if (!r.isInResult()) continue;\n                e.setNext(r), n = this._SCANNING_FOR_INCOMING;\n            }\n          }\n          if (n === this._LINKING_TO_OUTGOING) {\n            if (null === t) throw new gt(\"no outgoing dirEdge found\", this.getCoordinate());\n            G.isTrue(t.isInResult(), \"unable to link last incoming dirEdge\"), e.setNext(t);\n          }\n        }\n      }, {\n        key: \"insert\",\n        value: function (t) {\n          var e = t;\n          this.insertEdgeEnd(e, e);\n        }\n      }, {\n        key: \"getRightmostEdge\",\n        value: function () {\n          var t = this.getEdges(),\n            e = t.size();\n          if (e < 1) return null;\n          var n = t.get(0);\n          if (1 === e) return n;\n          var i = t.get(e - 1),\n            r = n.getQuadrant(),\n            s = i.getQuadrant();\n          return je.isNorthern(r) && je.isNorthern(s) ? n : je.isNorthern(r) || je.isNorthern(s) ? 0 !== n.getDy() ? n : 0 !== i.getDy() ? i : (G.shouldNeverReachHere(\"found two horizontal edges incident on node\"), null) : i;\n        }\n      }, {\n        key: \"print\",\n        value: function (t) {\n          mt.out.println(\"DirectedEdgeStar: \" + this.getCoordinate());\n          for (var e = this.iterator(); e.hasNext();) {\n            var n = e.next();\n            t.print(\"out \"), n.print(t), t.println(), t.print(\"in \"), n.getSym().print(t), t.println();\n          }\n        }\n      }, {\n        key: \"getResultAreaEdges\",\n        value: function () {\n          if (null !== this._resultAreaEdgeList) return this._resultAreaEdgeList;\n          this._resultAreaEdgeList = new yt();\n          for (var t = this.iterator(); t.hasNext();) {\n            var e = t.next();\n            (e.isInResult() || e.getSym().isInResult()) && this._resultAreaEdgeList.add(e);\n          }\n          return this._resultAreaEdgeList;\n        }\n      }, {\n        key: \"updateLabelling\",\n        value: function (t) {\n          for (var e = this.iterator(); e.hasNext();) {\n            var n = e.next().getLabel();\n            n.setAllLocationsIfNull(0, t.getLocation(0)), n.setAllLocationsIfNull(1, t.getLocation(1));\n          }\n        }\n      }, {\n        key: \"linkAllDirectedEdges\",\n        value: function () {\n          this.getEdges();\n          for (var t = null, e = null, n = this._edgeList.size() - 1; n >= 0; n--) {\n            var i = this._edgeList.get(n),\n              r = i.getSym();\n            null === e && (e = r), null !== t && r.setNext(t), t = i;\n          }\n          e.setNext(t);\n        }\n      }, {\n        key: \"computeDepths\",\n        value: function () {\n          if (1 === arguments.length) {\n            var t = arguments[0],\n              e = this.findIndex(t),\n              n = t.getDepth($.LEFT),\n              i = t.getDepth($.RIGHT),\n              r = this.computeDepths(e + 1, this._edgeList.size(), n);\n            if (this.computeDepths(0, e, r) !== i) throw new gt(\"depth mismatch at \" + t.getCoordinate());\n          } else if (3 === arguments.length) {\n            for (var s = arguments[1], a = arguments[2], o = arguments[0]; o < s; o++) {\n              var u = this._edgeList.get(o);\n              u.setEdgeDepths($.RIGHT, a), a = u.getDepth($.LEFT);\n            }\n            return a;\n          }\n        }\n      }, {\n        key: \"mergeSymLabels\",\n        value: function () {\n          for (var t = this.iterator(); t.hasNext();) {\n            var e = t.next();\n            e.getLabel().merge(e.getSym().getLabel());\n          }\n        }\n      }, {\n        key: \"linkMinimalDirectedEdges\",\n        value: function (t) {\n          for (var e = null, n = null, i = this._SCANNING_FOR_INCOMING, r = this._resultAreaEdgeList.size() - 1; r >= 0; r--) {\n            var s = this._resultAreaEdgeList.get(r),\n              a = s.getSym();\n            switch (null === e && s.getEdgeRing() === t && (e = s), i) {\n              case this._SCANNING_FOR_INCOMING:\n                if (a.getEdgeRing() !== t) continue;\n                n = a, i = this._LINKING_TO_OUTGOING;\n                break;\n              case this._LINKING_TO_OUTGOING:\n                if (s.getEdgeRing() !== t) continue;\n                n.setNextMin(s), i = this._SCANNING_FOR_INCOMING;\n            }\n          }\n          i === this._LINKING_TO_OUTGOING && (G.isTrue(null !== e, \"found null for first outgoing dirEdge\"), G.isTrue(e.getEdgeRing() === t, \"unable to link last incoming dirEdge\"), n.setNextMin(e));\n        }\n      }, {\n        key: \"getOutgoingDegree\",\n        value: function () {\n          if (0 === arguments.length) {\n            for (var t = 0, e = this.iterator(); e.hasNext();) {\n              e.next().isInResult() && t++;\n            }\n            return t;\n          }\n          if (1 === arguments.length) {\n            for (var n = arguments[0], i = 0, r = this.iterator(); r.hasNext();) {\n              r.next().getEdgeRing() === n && i++;\n            }\n            return i;\n          }\n        }\n      }, {\n        key: \"getLabel\",\n        value: function () {\n          return this._label;\n        }\n      }, {\n        key: \"findCoveredLineEdges\",\n        value: function () {\n          for (var t = H.NONE, e = this.iterator(); e.hasNext();) {\n            var n = e.next(),\n              i = n.getSym();\n            if (!n.isLineEdge()) {\n              if (n.isInResult()) {\n                t = H.INTERIOR;\n                break;\n              }\n              if (i.isInResult()) {\n                t = H.EXTERIOR;\n                break;\n              }\n            }\n          }\n          if (t === H.NONE) return null;\n          for (var r = t, s = this.iterator(); s.hasNext();) {\n            var a = s.next(),\n              o = a.getSym();\n            a.isLineEdge() ? a.getEdge().setCovered(r === H.INTERIOR) : (a.isInResult() && (r = H.EXTERIOR), o.isInResult() && (r = H.INTERIOR));\n          }\n        }\n      }, {\n        key: \"computeLabelling\",\n        value: function (t) {\n          f(i, \"computeLabelling\", this, 1).call(this, t), this._label = new Ae(H.NONE);\n          for (var e = this.iterator(); e.hasNext();) for (var n = e.next().getEdge().getLabel(), r = 0; r < 2; r++) {\n            var s = n.getLocation(r);\n            s !== H.INTERIOR && s !== H.BOUNDARY || this._label.setLocation(r, H.INTERIOR);\n          }\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this._resultAreaEdgeList = null, this._label = null, this._SCANNING_FOR_INCOMING = 1, this._LINKING_TO_OUTGOING = 2;\n        }\n      }]);\n    }(Un),\n    Hn = function (t) {\n      function i() {\n        return n(this, i), e(this, i);\n      }\n      return l(i, t), s(i, [{\n        key: \"createNode\",\n        value: function (t) {\n          return new qe(t, new Vn());\n        }\n      }]);\n    }(Je),\n    Zn = function () {\n      function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }\n      return s(t, [{\n        key: \"compareTo\",\n        value: function (e) {\n          var n = e;\n          return t.compareOriented(this._pts, this._orientation, n._pts, n._orientation);\n        }\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [x];\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this._pts = null, this._orientation = null;\n          var e = arguments[0];\n          this._pts = e, this._orientation = t.orientation(e);\n        }\n      }, {\n        key: \"orientation\",\n        value: function (t) {\n          return 1 === jt.increasingDirection(t);\n        }\n      }, {\n        key: \"compareOriented\",\n        value: function (t, e, n, i) {\n          for (var r = e ? 1 : -1, s = i ? 1 : -1, a = e ? t.length : -1, o = i ? n.length : -1, u = e ? 0 : t.length - 1, l = i ? 0 : n.length - 1;;) {\n            var h = t[u].compareTo(n[l]);\n            if (0 !== h) return h;\n            var c = (u += r) === a,\n              f = (l += s) === o;\n            if (c && !f) return -1;\n            if (!c && f) return 1;\n            if (c && f) return 0;\n          }\n        }\n      }]);\n    }(),\n    jn = function () {\n      return s(function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }, [{\n        key: \"print\",\n        value: function (t) {\n          t.print(\"MULTILINESTRING ( \");\n          for (var e = 0; e < this._edges.size(); e++) {\n            var n = this._edges.get(e);\n            e > 0 && t.print(\",\"), t.print(\"(\");\n            for (var i = n.getCoordinates(), r = 0; r < i.length; r++) r > 0 && t.print(\",\"), t.print(i[r].x + \" \" + i[r].y);\n            t.println(\")\");\n          }\n          t.print(\")  \");\n        }\n      }, {\n        key: \"addAll\",\n        value: function (t) {\n          for (var e = t.iterator(); e.hasNext();) this.add(e.next());\n        }\n      }, {\n        key: \"findEdgeIndex\",\n        value: function (t) {\n          for (var e = 0; e < this._edges.size(); e++) if (this._edges.get(e).equals(t)) return e;\n          return -1;\n        }\n      }, {\n        key: \"iterator\",\n        value: function () {\n          return this._edges.iterator();\n        }\n      }, {\n        key: \"getEdges\",\n        value: function () {\n          return this._edges;\n        }\n      }, {\n        key: \"get\",\n        value: function (t) {\n          return this._edges.get(t);\n        }\n      }, {\n        key: \"findEqualEdge\",\n        value: function (t) {\n          var e = new Zn(t.getCoordinates());\n          return this._ocaMap.get(e);\n        }\n      }, {\n        key: \"add\",\n        value: function (t) {\n          this._edges.add(t);\n          var e = new Zn(t.getCoordinates());\n          this._ocaMap.put(e, t);\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this._edges = new yt(), this._ocaMap = new He();\n        }\n      }]);\n    }(),\n    Wn = function () {\n      return s(function t() {\n        n(this, t);\n      }, [{\n        key: \"processIntersections\",\n        value: function (t, e, n, i) {}\n      }, {\n        key: \"isDone\",\n        value: function () {}\n      }]);\n    }(),\n    Kn = function () {\n      function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }\n      return s(t, [{\n        key: \"isTrivialIntersection\",\n        value: function (e, n, i, r) {\n          if (e === i && 1 === this._li.getIntersectionNum()) {\n            if (t.isAdjacentSegments(n, r)) return !0;\n            if (e.isClosed()) {\n              var s = e.size() - 1;\n              if (0 === n && r === s || 0 === r && n === s) return !0;\n            }\n          }\n          return !1;\n        }\n      }, {\n        key: \"getProperIntersectionPoint\",\n        value: function () {\n          return this._properIntersectionPoint;\n        }\n      }, {\n        key: \"hasProperInteriorIntersection\",\n        value: function () {\n          return this._hasProperInterior;\n        }\n      }, {\n        key: \"getLineIntersector\",\n        value: function () {\n          return this._li;\n        }\n      }, {\n        key: \"hasProperIntersection\",\n        value: function () {\n          return this._hasProper;\n        }\n      }, {\n        key: \"processIntersections\",\n        value: function (t, e, n, i) {\n          if (t === n && e === i) return null;\n          this.numTests++;\n          var r = t.getCoordinates()[e],\n            s = t.getCoordinates()[e + 1],\n            a = n.getCoordinates()[i],\n            o = n.getCoordinates()[i + 1];\n          this._li.computeIntersection(r, s, a, o), this._li.hasIntersection() && (this.numIntersections++, this._li.isInteriorIntersection() && (this.numInteriorIntersections++, this._hasInterior = !0), this.isTrivialIntersection(t, e, n, i) || (this._hasIntersection = !0, t.addIntersections(this._li, e, 0), n.addIntersections(this._li, i, 1), this._li.isProper() && (this.numProperIntersections++, this._hasProper = !0, this._hasProperInterior = !0)));\n        }\n      }, {\n        key: \"hasIntersection\",\n        value: function () {\n          return this._hasIntersection;\n        }\n      }, {\n        key: \"isDone\",\n        value: function () {\n          return !1;\n        }\n      }, {\n        key: \"hasInteriorIntersection\",\n        value: function () {\n          return this._hasInterior;\n        }\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [Wn];\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this._hasIntersection = !1, this._hasProper = !1, this._hasProperInterior = !1, this._hasInterior = !1, this._properIntersectionPoint = null, this._li = null, this._isSelfIntersection = null, this.numIntersections = 0, this.numInteriorIntersections = 0, this.numProperIntersections = 0, this.numTests = 0;\n          var t = arguments[0];\n          this._li = t;\n        }\n      }, {\n        key: \"isAdjacentSegments\",\n        value: function (t, e) {\n          return 1 === Math.abs(t - e);\n        }\n      }]);\n    }(),\n    Jn = function () {\n      return s(function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }, [{\n        key: \"getSegmentIndex\",\n        value: function () {\n          return this.segmentIndex;\n        }\n      }, {\n        key: \"getCoordinate\",\n        value: function () {\n          return this.coord;\n        }\n      }, {\n        key: \"print\",\n        value: function (t) {\n          t.print(this.coord), t.print(\" seg # = \" + this.segmentIndex), t.println(\" dist = \" + this.dist);\n        }\n      }, {\n        key: \"compareTo\",\n        value: function (t) {\n          var e = t;\n          return this.compare(e.segmentIndex, e.dist);\n        }\n      }, {\n        key: \"isEndPoint\",\n        value: function (t) {\n          return 0 === this.segmentIndex && 0 === this.dist || this.segmentIndex === t;\n        }\n      }, {\n        key: \"toString\",\n        value: function () {\n          return this.coord + \" seg # = \" + this.segmentIndex + \" dist = \" + this.dist;\n        }\n      }, {\n        key: \"getDistance\",\n        value: function () {\n          return this.dist;\n        }\n      }, {\n        key: \"compare\",\n        value: function (t, e) {\n          return this.segmentIndex < t ? -1 : this.segmentIndex > t ? 1 : this.dist < e ? -1 : this.dist > e ? 1 : 0;\n        }\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [x];\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this.coord = null, this.segmentIndex = null, this.dist = null;\n          var t = arguments[0],\n            e = arguments[1],\n            n = arguments[2];\n          this.coord = new X(t), this.segmentIndex = e, this.dist = n;\n        }\n      }]);\n    }(),\n    Qn = function () {\n      return s(function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }, [{\n        key: \"print\",\n        value: function (t) {\n          t.println(\"Intersections:\");\n          for (var e = this.iterator(); e.hasNext();) {\n            e.next().print(t);\n          }\n        }\n      }, {\n        key: \"iterator\",\n        value: function () {\n          return this._nodeMap.values().iterator();\n        }\n      }, {\n        key: \"addSplitEdges\",\n        value: function (t) {\n          this.addEndpoints();\n          for (var e = this.iterator(), n = e.next(); e.hasNext();) {\n            var i = e.next(),\n              r = this.createSplitEdge(n, i);\n            t.add(r), n = i;\n          }\n        }\n      }, {\n        key: \"addEndpoints\",\n        value: function () {\n          var t = this.edge.pts.length - 1;\n          this.add(this.edge.pts[0], 0, 0), this.add(this.edge.pts[t], t, 0);\n        }\n      }, {\n        key: \"createSplitEdge\",\n        value: function (t, e) {\n          var n = e.segmentIndex - t.segmentIndex + 2,\n            i = this.edge.pts[e.segmentIndex],\n            r = e.dist > 0 || !e.coord.equals2D(i);\n          r || n--;\n          var s = new Array(n).fill(null),\n            a = 0;\n          s[a++] = new X(t.coord);\n          for (var o = t.segmentIndex + 1; o <= e.segmentIndex; o++) s[a++] = this.edge.pts[o];\n          return r && (s[a] = e.coord), new ri(s, new Ae(this.edge._label));\n        }\n      }, {\n        key: \"add\",\n        value: function (t, e, n) {\n          var i = new Jn(t, e, n),\n            r = this._nodeMap.get(i);\n          return null !== r ? r : (this._nodeMap.put(i, i), i);\n        }\n      }, {\n        key: \"isIntersection\",\n        value: function (t) {\n          for (var e = this.iterator(); e.hasNext();) {\n            if (e.next().coord.equals(t)) return !0;\n          }\n          return !1;\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this._nodeMap = new He(), this.edge = null;\n          var t = arguments[0];\n          this.edge = t;\n        }\n      }]);\n    }(),\n    $n = function () {\n      function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }\n      return s(t, [{\n        key: \"isIntersects\",\n        value: function () {\n          return !this.isDisjoint();\n        }\n      }, {\n        key: \"isCovers\",\n        value: function () {\n          return (t.isTrue(this._matrix[H.INTERIOR][H.INTERIOR]) || t.isTrue(this._matrix[H.INTERIOR][H.BOUNDARY]) || t.isTrue(this._matrix[H.BOUNDARY][H.INTERIOR]) || t.isTrue(this._matrix[H.BOUNDARY][H.BOUNDARY])) && this._matrix[H.EXTERIOR][H.INTERIOR] === Lt.FALSE && this._matrix[H.EXTERIOR][H.BOUNDARY] === Lt.FALSE;\n        }\n      }, {\n        key: \"isCoveredBy\",\n        value: function () {\n          return (t.isTrue(this._matrix[H.INTERIOR][H.INTERIOR]) || t.isTrue(this._matrix[H.INTERIOR][H.BOUNDARY]) || t.isTrue(this._matrix[H.BOUNDARY][H.INTERIOR]) || t.isTrue(this._matrix[H.BOUNDARY][H.BOUNDARY])) && this._matrix[H.INTERIOR][H.EXTERIOR] === Lt.FALSE && this._matrix[H.BOUNDARY][H.EXTERIOR] === Lt.FALSE;\n        }\n      }, {\n        key: \"set\",\n        value: function () {\n          if (1 === arguments.length) for (var t = arguments[0], e = 0; e < t.length; e++) {\n            var n = Math.trunc(e / 3),\n              i = e % 3;\n            this._matrix[n][i] = Lt.toDimensionValue(t.charAt(e));\n          } else if (3 === arguments.length) {\n            var r = arguments[0],\n              s = arguments[1],\n              a = arguments[2];\n            this._matrix[r][s] = a;\n          }\n        }\n      }, {\n        key: \"isContains\",\n        value: function () {\n          return t.isTrue(this._matrix[H.INTERIOR][H.INTERIOR]) && this._matrix[H.EXTERIOR][H.INTERIOR] === Lt.FALSE && this._matrix[H.EXTERIOR][H.BOUNDARY] === Lt.FALSE;\n        }\n      }, {\n        key: \"setAtLeast\",\n        value: function () {\n          if (1 === arguments.length) for (var t = arguments[0], e = 0; e < t.length; e++) {\n            var n = Math.trunc(e / 3),\n              i = e % 3;\n            this.setAtLeast(n, i, Lt.toDimensionValue(t.charAt(e)));\n          } else if (3 === arguments.length) {\n            var r = arguments[0],\n              s = arguments[1],\n              a = arguments[2];\n            this._matrix[r][s] < a && (this._matrix[r][s] = a);\n          }\n        }\n      }, {\n        key: \"setAtLeastIfValid\",\n        value: function (t, e, n) {\n          t >= 0 && e >= 0 && this.setAtLeast(t, e, n);\n        }\n      }, {\n        key: \"isWithin\",\n        value: function () {\n          return t.isTrue(this._matrix[H.INTERIOR][H.INTERIOR]) && this._matrix[H.INTERIOR][H.EXTERIOR] === Lt.FALSE && this._matrix[H.BOUNDARY][H.EXTERIOR] === Lt.FALSE;\n        }\n      }, {\n        key: \"isTouches\",\n        value: function (e, n) {\n          return e > n ? this.isTouches(n, e) : (e === Lt.A && n === Lt.A || e === Lt.L && n === Lt.L || e === Lt.L && n === Lt.A || e === Lt.P && n === Lt.A || e === Lt.P && n === Lt.L) && this._matrix[H.INTERIOR][H.INTERIOR] === Lt.FALSE && (t.isTrue(this._matrix[H.INTERIOR][H.BOUNDARY]) || t.isTrue(this._matrix[H.BOUNDARY][H.INTERIOR]) || t.isTrue(this._matrix[H.BOUNDARY][H.BOUNDARY]));\n        }\n      }, {\n        key: \"isOverlaps\",\n        value: function (e, n) {\n          return e === Lt.P && n === Lt.P || e === Lt.A && n === Lt.A ? t.isTrue(this._matrix[H.INTERIOR][H.INTERIOR]) && t.isTrue(this._matrix[H.INTERIOR][H.EXTERIOR]) && t.isTrue(this._matrix[H.EXTERIOR][H.INTERIOR]) : e === Lt.L && n === Lt.L && 1 === this._matrix[H.INTERIOR][H.INTERIOR] && t.isTrue(this._matrix[H.INTERIOR][H.EXTERIOR]) && t.isTrue(this._matrix[H.EXTERIOR][H.INTERIOR]);\n        }\n      }, {\n        key: \"isEquals\",\n        value: function (e, n) {\n          return e === n && t.isTrue(this._matrix[H.INTERIOR][H.INTERIOR]) && this._matrix[H.INTERIOR][H.EXTERIOR] === Lt.FALSE && this._matrix[H.BOUNDARY][H.EXTERIOR] === Lt.FALSE && this._matrix[H.EXTERIOR][H.INTERIOR] === Lt.FALSE && this._matrix[H.EXTERIOR][H.BOUNDARY] === Lt.FALSE;\n        }\n      }, {\n        key: \"toString\",\n        value: function () {\n          for (var t = new Jt(\"123456789\"), e = 0; e < 3; e++) for (var n = 0; n < 3; n++) t.setCharAt(3 * e + n, Lt.toDimensionSymbol(this._matrix[e][n]));\n          return t.toString();\n        }\n      }, {\n        key: \"setAll\",\n        value: function (t) {\n          for (var e = 0; e < 3; e++) for (var n = 0; n < 3; n++) this._matrix[e][n] = t;\n        }\n      }, {\n        key: \"get\",\n        value: function (t, e) {\n          return this._matrix[t][e];\n        }\n      }, {\n        key: \"transpose\",\n        value: function () {\n          var t = this._matrix[1][0];\n          return this._matrix[1][0] = this._matrix[0][1], this._matrix[0][1] = t, t = this._matrix[2][0], this._matrix[2][0] = this._matrix[0][2], this._matrix[0][2] = t, t = this._matrix[2][1], this._matrix[2][1] = this._matrix[1][2], this._matrix[1][2] = t, this;\n        }\n      }, {\n        key: \"matches\",\n        value: function (e) {\n          if (9 !== e.length) throw new m(\"Should be length 9: \" + e);\n          for (var n = 0; n < 3; n++) for (var i = 0; i < 3; i++) if (!t.matches(this._matrix[n][i], e.charAt(3 * n + i))) return !1;\n          return !0;\n        }\n      }, {\n        key: \"add\",\n        value: function (t) {\n          for (var e = 0; e < 3; e++) for (var n = 0; n < 3; n++) this.setAtLeast(e, n, t.get(e, n));\n        }\n      }, {\n        key: \"isDisjoint\",\n        value: function () {\n          return this._matrix[H.INTERIOR][H.INTERIOR] === Lt.FALSE && this._matrix[H.INTERIOR][H.BOUNDARY] === Lt.FALSE && this._matrix[H.BOUNDARY][H.INTERIOR] === Lt.FALSE && this._matrix[H.BOUNDARY][H.BOUNDARY] === Lt.FALSE;\n        }\n      }, {\n        key: \"isCrosses\",\n        value: function (e, n) {\n          return e === Lt.P && n === Lt.L || e === Lt.P && n === Lt.A || e === Lt.L && n === Lt.A ? t.isTrue(this._matrix[H.INTERIOR][H.INTERIOR]) && t.isTrue(this._matrix[H.INTERIOR][H.EXTERIOR]) : e === Lt.L && n === Lt.P || e === Lt.A && n === Lt.P || e === Lt.A && n === Lt.L ? t.isTrue(this._matrix[H.INTERIOR][H.INTERIOR]) && t.isTrue(this._matrix[H.EXTERIOR][H.INTERIOR]) : e === Lt.L && n === Lt.L && 0 === this._matrix[H.INTERIOR][H.INTERIOR];\n        }\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [I];\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          if (this._matrix = null, 0 === arguments.length) this._matrix = Array(3).fill().map(function () {\n            return Array(3);\n          }), this.setAll(Lt.FALSE);else if (1 === arguments.length) if (\"string\" == typeof arguments[0]) {\n            var e = arguments[0];\n            t.constructor_.call(this), this.set(e);\n          } else if (arguments[0] instanceof t) {\n            var n = arguments[0];\n            t.constructor_.call(this), this._matrix[H.INTERIOR][H.INTERIOR] = n._matrix[H.INTERIOR][H.INTERIOR], this._matrix[H.INTERIOR][H.BOUNDARY] = n._matrix[H.INTERIOR][H.BOUNDARY], this._matrix[H.INTERIOR][H.EXTERIOR] = n._matrix[H.INTERIOR][H.EXTERIOR], this._matrix[H.BOUNDARY][H.INTERIOR] = n._matrix[H.BOUNDARY][H.INTERIOR], this._matrix[H.BOUNDARY][H.BOUNDARY] = n._matrix[H.BOUNDARY][H.BOUNDARY], this._matrix[H.BOUNDARY][H.EXTERIOR] = n._matrix[H.BOUNDARY][H.EXTERIOR], this._matrix[H.EXTERIOR][H.INTERIOR] = n._matrix[H.EXTERIOR][H.INTERIOR], this._matrix[H.EXTERIOR][H.BOUNDARY] = n._matrix[H.EXTERIOR][H.BOUNDARY], this._matrix[H.EXTERIOR][H.EXTERIOR] = n._matrix[H.EXTERIOR][H.EXTERIOR];\n          }\n        }\n      }, {\n        key: \"matches\",\n        value: function () {\n          if (Number.isInteger(arguments[0]) && \"string\" == typeof arguments[1]) {\n            var e = arguments[0],\n              n = arguments[1];\n            return n === Lt.SYM_DONTCARE || n === Lt.SYM_TRUE && (e >= 0 || e === Lt.TRUE) || n === Lt.SYM_FALSE && e === Lt.FALSE || n === Lt.SYM_P && e === Lt.P || n === Lt.SYM_L && e === Lt.L || n === Lt.SYM_A && e === Lt.A;\n          }\n          if (\"string\" == typeof arguments[0] && \"string\" == typeof arguments[1]) {\n            var i = arguments[1];\n            return new t(arguments[0]).matches(i);\n          }\n        }\n      }, {\n        key: \"isTrue\",\n        value: function (t) {\n          return t >= 0 || t === Lt.TRUE;\n        }\n      }]);\n    }(),\n    ti = function () {\n      function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }\n      return s(t, [{\n        key: \"size\",\n        value: function () {\n          return this._size;\n        }\n      }, {\n        key: \"addAll\",\n        value: function (t) {\n          return null === t || 0 === t.length ? null : (this.ensureCapacity(this._size + t.length), mt.arraycopy(t, 0, this._data, this._size, t.length), void (this._size += t.length));\n        }\n      }, {\n        key: \"ensureCapacity\",\n        value: function (t) {\n          if (t <= this._data.length) return null;\n          var e = Math.max(t, 2 * this._data.length);\n          this._data = At.copyOf(this._data, e);\n        }\n      }, {\n        key: \"toArray\",\n        value: function () {\n          var t = new Array(this._size).fill(null);\n          return mt.arraycopy(this._data, 0, t, 0, this._size), t;\n        }\n      }, {\n        key: \"add\",\n        value: function (t) {\n          this.ensureCapacity(this._size + 1), this._data[this._size] = t, ++this._size;\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          if (this._data = null, this._size = 0, 0 === arguments.length) t.constructor_.call(this, 10);else if (1 === arguments.length) {\n            var e = arguments[0];\n            this._data = new Array(e).fill(null);\n          }\n        }\n      }]);\n    }(),\n    ei = function () {\n      function t() {\n        n(this, t);\n      }\n      return s(t, [{\n        key: \"getChainStartIndices\",\n        value: function (t) {\n          var e = 0,\n            n = new ti(Math.trunc(t.length / 2));\n          n.add(e);\n          do {\n            var i = this.findChainEnd(t, e);\n            n.add(i), e = i;\n          } while (e < t.length - 1);\n          return n.toArray();\n        }\n      }, {\n        key: \"findChainEnd\",\n        value: function (t, e) {\n          for (var n = je.quadrant(t[e], t[e + 1]), i = e + 1; i < t.length;) {\n            if (je.quadrant(t[i - 1], t[i]) !== n) break;\n            i++;\n          }\n          return i - 1;\n        }\n      }, {\n        key: \"OLDgetChainStartIndices\",\n        value: function (e) {\n          var n = 0,\n            i = new yt();\n          i.add(n);\n          do {\n            var r = this.findChainEnd(e, n);\n            i.add(r), n = r;\n          } while (n < e.length - 1);\n          return t.toIntArray(i);\n        }\n      }], [{\n        key: \"toIntArray\",\n        value: function (t) {\n          for (var e = new Array(t.size()).fill(null), n = 0; n < e.length; n++) e[n] = t.get(n).intValue();\n          return e;\n        }\n      }]);\n    }(),\n    ni = function () {\n      return s(function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }, [{\n        key: \"getCoordinates\",\n        value: function () {\n          return this.pts;\n        }\n      }, {\n        key: \"getMaxX\",\n        value: function (t) {\n          var e = this.pts[this.startIndex[t]].x,\n            n = this.pts[this.startIndex[t + 1]].x;\n          return e > n ? e : n;\n        }\n      }, {\n        key: \"getMinX\",\n        value: function (t) {\n          var e = this.pts[this.startIndex[t]].x,\n            n = this.pts[this.startIndex[t + 1]].x;\n          return e < n ? e : n;\n        }\n      }, {\n        key: \"computeIntersectsForChain\",\n        value: function () {\n          if (4 === arguments.length) {\n            var t = arguments[0],\n              e = arguments[1],\n              n = arguments[2],\n              i = arguments[3];\n            this.computeIntersectsForChain(this.startIndex[t], this.startIndex[t + 1], e, e.startIndex[n], e.startIndex[n + 1], i);\n          } else if (6 === arguments.length) {\n            var r = arguments[0],\n              s = arguments[1],\n              a = arguments[2],\n              o = arguments[3],\n              u = arguments[4],\n              l = arguments[5];\n            if (s - r == 1 && u - o == 1) return l.addIntersections(this.e, r, a.e, o), null;\n            if (!this.overlaps(r, s, a, o, u)) return null;\n            var h = Math.trunc((r + s) / 2),\n              c = Math.trunc((o + u) / 2);\n            r < h && (o < c && this.computeIntersectsForChain(r, h, a, o, c, l), c < u && this.computeIntersectsForChain(r, h, a, c, u, l)), h < s && (o < c && this.computeIntersectsForChain(h, s, a, o, c, l), c < u && this.computeIntersectsForChain(h, s, a, c, u, l));\n          }\n        }\n      }, {\n        key: \"overlaps\",\n        value: function (t, e, n, i, r) {\n          return U.intersects(this.pts[t], this.pts[e], n.pts[i], n.pts[r]);\n        }\n      }, {\n        key: \"getStartIndexes\",\n        value: function () {\n          return this.startIndex;\n        }\n      }, {\n        key: \"computeIntersects\",\n        value: function (t, e) {\n          for (var n = 0; n < this.startIndex.length - 1; n++) for (var i = 0; i < t.startIndex.length - 1; i++) this.computeIntersectsForChain(n, t, i, e);\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this.e = null, this.pts = null, this.startIndex = null;\n          var t = arguments[0];\n          this.e = t, this.pts = t.getCoordinates();\n          var e = new ei();\n          this.startIndex = e.getChainStartIndices(this.pts);\n        }\n      }]);\n    }(),\n    ii = function () {\n      function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }\n      return s(t, [{\n        key: \"getDepth\",\n        value: function (t, e) {\n          return this._depth[t][e];\n        }\n      }, {\n        key: \"setDepth\",\n        value: function (t, e, n) {\n          this._depth[t][e] = n;\n        }\n      }, {\n        key: \"isNull\",\n        value: function () {\n          if (0 === arguments.length) {\n            for (var e = 0; e < 2; e++) for (var n = 0; n < 3; n++) if (this._depth[e][n] !== t.NULL_VALUE) return !1;\n            return !0;\n          }\n          if (1 === arguments.length) {\n            var i = arguments[0];\n            return this._depth[i][1] === t.NULL_VALUE;\n          }\n          if (2 === arguments.length) {\n            var r = arguments[0],\n              s = arguments[1];\n            return this._depth[r][s] === t.NULL_VALUE;\n          }\n        }\n      }, {\n        key: \"normalize\",\n        value: function () {\n          for (var t = 0; t < 2; t++) if (!this.isNull(t)) {\n            var e = this._depth[t][1];\n            this._depth[t][2] < e && (e = this._depth[t][2]), e < 0 && (e = 0);\n            for (var n = 1; n < 3; n++) {\n              var i = 0;\n              this._depth[t][n] > e && (i = 1), this._depth[t][n] = i;\n            }\n          }\n        }\n      }, {\n        key: \"getDelta\",\n        value: function (t) {\n          return this._depth[t][$.RIGHT] - this._depth[t][$.LEFT];\n        }\n      }, {\n        key: \"getLocation\",\n        value: function (t, e) {\n          return this._depth[t][e] <= 0 ? H.EXTERIOR : H.INTERIOR;\n        }\n      }, {\n        key: \"toString\",\n        value: function () {\n          return \"A: \" + this._depth[0][1] + \",\" + this._depth[0][2] + \" B: \" + this._depth[1][1] + \",\" + this._depth[1][2];\n        }\n      }, {\n        key: \"add\",\n        value: function () {\n          if (1 === arguments.length) for (var e = arguments[0], n = 0; n < 2; n++) for (var i = 1; i < 3; i++) {\n            var r = e.getLocation(n, i);\n            r !== H.EXTERIOR && r !== H.INTERIOR || (this.isNull(n, i) ? this._depth[n][i] = t.depthAtLocation(r) : this._depth[n][i] += t.depthAtLocation(r));\n          } else if (3 === arguments.length) {\n            var s = arguments[0],\n              a = arguments[1];\n            arguments[2] === H.INTERIOR && this._depth[s][a]++;\n          }\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this._depth = Array(2).fill().map(function () {\n            return Array(3);\n          });\n          for (var e = 0; e < 2; e++) for (var n = 0; n < 3; n++) this._depth[e][n] = t.NULL_VALUE;\n        }\n      }, {\n        key: \"depthAtLocation\",\n        value: function (e) {\n          return e === H.EXTERIOR ? 0 : e === H.INTERIOR ? 1 : t.NULL_VALUE;\n        }\n      }]);\n    }();\n  ii.NULL_VALUE = -1;\n  var ri = function (t) {\n      function i() {\n        var t;\n        return n(this, i), t = e(this, i), i.constructor_.apply(t, arguments), t;\n      }\n      return l(i, t), s(i, [{\n        key: \"getDepth\",\n        value: function () {\n          return this._depth;\n        }\n      }, {\n        key: \"getCollapsedEdge\",\n        value: function () {\n          var t = new Array(2).fill(null);\n          return t[0] = this.pts[0], t[1] = this.pts[1], new i(t, Ae.toLineLabel(this._label));\n        }\n      }, {\n        key: \"isIsolated\",\n        value: function () {\n          return this._isIsolated;\n        }\n      }, {\n        key: \"getCoordinates\",\n        value: function () {\n          return this.pts;\n        }\n      }, {\n        key: \"setIsolated\",\n        value: function (t) {\n          this._isIsolated = t;\n        }\n      }, {\n        key: \"setName\",\n        value: function (t) {\n          this._name = t;\n        }\n      }, {\n        key: \"equals\",\n        value: function (t) {\n          if (!(t instanceof i)) return !1;\n          var e = t;\n          if (this.pts.length !== e.pts.length) return !1;\n          for (var n = !0, r = !0, s = this.pts.length, a = 0; a < this.pts.length; a++) if (this.pts[a].equals2D(e.pts[a]) || (n = !1), this.pts[a].equals2D(e.pts[--s]) || (r = !1), !n && !r) return !1;\n          return !0;\n        }\n      }, {\n        key: \"getCoordinate\",\n        value: function () {\n          if (0 === arguments.length) return this.pts.length > 0 ? this.pts[0] : null;\n          if (1 === arguments.length) {\n            var t = arguments[0];\n            return this.pts[t];\n          }\n        }\n      }, {\n        key: \"print\",\n        value: function (t) {\n          t.print(\"edge \" + this._name + \": \"), t.print(\"LINESTRING (\");\n          for (var e = 0; e < this.pts.length; e++) e > 0 && t.print(\",\"), t.print(this.pts[e].x + \" \" + this.pts[e].y);\n          t.print(\")  \" + this._label + \" \" + this._depthDelta);\n        }\n      }, {\n        key: \"computeIM\",\n        value: function (t) {\n          i.updateIM(this._label, t);\n        }\n      }, {\n        key: \"isCollapsed\",\n        value: function () {\n          return !!this._label.isArea() && 3 === this.pts.length && !!this.pts[0].equals(this.pts[2]);\n        }\n      }, {\n        key: \"isClosed\",\n        value: function () {\n          return this.pts[0].equals(this.pts[this.pts.length - 1]);\n        }\n      }, {\n        key: \"getMaximumSegmentIndex\",\n        value: function () {\n          return this.pts.length - 1;\n        }\n      }, {\n        key: \"getDepthDelta\",\n        value: function () {\n          return this._depthDelta;\n        }\n      }, {\n        key: \"getNumPoints\",\n        value: function () {\n          return this.pts.length;\n        }\n      }, {\n        key: \"printReverse\",\n        value: function (t) {\n          t.print(\"edge \" + this._name + \": \");\n          for (var e = this.pts.length - 1; e >= 0; e--) t.print(this.pts[e] + \" \");\n          t.println(\"\");\n        }\n      }, {\n        key: \"getMonotoneChainEdge\",\n        value: function () {\n          return null === this._mce && (this._mce = new ni(this)), this._mce;\n        }\n      }, {\n        key: \"getEnvelope\",\n        value: function () {\n          if (null === this._env) {\n            this._env = new U();\n            for (var t = 0; t < this.pts.length; t++) this._env.expandToInclude(this.pts[t]);\n          }\n          return this._env;\n        }\n      }, {\n        key: \"addIntersection\",\n        value: function (t, e, n, i) {\n          var r = new X(t.getIntersection(i)),\n            s = e,\n            a = t.getEdgeDistance(n, i),\n            o = s + 1;\n          if (o < this.pts.length) {\n            var u = this.pts[o];\n            r.equals2D(u) && (s = o, a = 0);\n          }\n          this.eiList.add(r, s, a);\n        }\n      }, {\n        key: \"toString\",\n        value: function () {\n          var t = new Jt();\n          t.append(\"edge \" + this._name + \": \"), t.append(\"LINESTRING (\");\n          for (var e = 0; e < this.pts.length; e++) e > 0 && t.append(\",\"), t.append(this.pts[e].x + \" \" + this.pts[e].y);\n          return t.append(\")  \" + this._label + \" \" + this._depthDelta), t.toString();\n        }\n      }, {\n        key: \"isPointwiseEqual\",\n        value: function (t) {\n          if (this.pts.length !== t.pts.length) return !1;\n          for (var e = 0; e < this.pts.length; e++) if (!this.pts[e].equals2D(t.pts[e])) return !1;\n          return !0;\n        }\n      }, {\n        key: \"setDepthDelta\",\n        value: function (t) {\n          this._depthDelta = t;\n        }\n      }, {\n        key: \"getEdgeIntersectionList\",\n        value: function () {\n          return this.eiList;\n        }\n      }, {\n        key: \"addIntersections\",\n        value: function (t, e, n) {\n          for (var i = 0; i < t.getIntersectionNum(); i++) this.addIntersection(t, e, n, i);\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          if (this.pts = null, this._env = null, this.eiList = new Qn(this), this._name = null, this._mce = null, this._isIsolated = !0, this._depth = new ii(), this._depthDelta = 0, 1 === arguments.length) {\n            var t = arguments[0];\n            i.constructor_.call(this, t, null);\n          } else if (2 === arguments.length) {\n            var e = arguments[0],\n              n = arguments[1];\n            this.pts = e, this._label = n;\n          }\n        }\n      }, {\n        key: \"updateIM\",\n        value: function () {\n          if (!(2 === arguments.length && arguments[1] instanceof $n && arguments[0] instanceof Ae)) return f(i, \"updateIM\", this).apply(this, arguments);\n          var t = arguments[0],\n            e = arguments[1];\n          e.setAtLeastIfValid(t.getLocation(0, $.ON), t.getLocation(1, $.ON), 1), t.isArea() && (e.setAtLeastIfValid(t.getLocation(0, $.LEFT), t.getLocation(1, $.LEFT), 2), e.setAtLeastIfValid(t.getLocation(0, $.RIGHT), t.getLocation(1, $.RIGHT), 2));\n        }\n      }]);\n    }(Ge),\n    si = function () {\n      function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }\n      return s(t, [{\n        key: \"setWorkingPrecisionModel\",\n        value: function (t) {\n          this._workingPrecisionModel = t;\n        }\n      }, {\n        key: \"insertUniqueEdge\",\n        value: function (e) {\n          var n = this._edgeList.findEqualEdge(e);\n          if (null !== n) {\n            var i = n.getLabel(),\n              r = e.getLabel();\n            n.isPointwiseEqual(e) || (r = new Ae(e.getLabel())).flip(), i.merge(r);\n            var s = t.depthDelta(r),\n              a = n.getDepthDelta() + s;\n            n.setDepthDelta(a);\n          } else this._edgeList.add(e), e.setDepthDelta(t.depthDelta(e.getLabel()));\n        }\n      }, {\n        key: \"buildSubgraphs\",\n        value: function (t, e) {\n          for (var n = new yt(), i = t.iterator(); i.hasNext();) {\n            var r = i.next(),\n              s = r.getRightmostCoordinate(),\n              a = new Pn(n).getDepth(s);\n            r.computeDepth(a), r.findResultEdges(), n.add(r), e.add(r.getDirectedEdges(), r.getNodes());\n          }\n        }\n      }, {\n        key: \"createSubgraphs\",\n        value: function (t) {\n          for (var e = new yt(), n = t.getNodes().iterator(); n.hasNext();) {\n            var i = n.next();\n            if (!i.isVisited()) {\n              var r = new _t();\n              r.create(i), e.add(r);\n            }\n          }\n          return an.sort(e, an.reverseOrder()), e;\n        }\n      }, {\n        key: \"createEmptyResultGeometry\",\n        value: function () {\n          return this._geomFact.createPolygon();\n        }\n      }, {\n        key: \"getNoder\",\n        value: function (t) {\n          if (null !== this._workingNoder) return this._workingNoder;\n          var e = new Cn(),\n            n = new we();\n          return n.setPrecisionModel(t), e.setSegmentIntersector(new Kn(n)), e;\n        }\n      }, {\n        key: \"buffer\",\n        value: function (t, e) {\n          var n = this._workingPrecisionModel;\n          null === n && (n = t.getPrecisionModel()), this._geomFact = t.getFactory();\n          var i = new An(n, this._bufParams),\n            r = new Yn(t, e, i).getCurves();\n          if (r.size() <= 0) return this.createEmptyResultGeometry();\n          this.computeNodedEdges(r, n), this._graph = new Qe(new Hn()), this._graph.addEdges(this._edgeList.getEdges());\n          var s = this.createSubgraphs(this._graph),\n            a = new $e(this._geomFact);\n          this.buildSubgraphs(s, a);\n          var o = a.getPolygons();\n          return o.size() <= 0 ? this.createEmptyResultGeometry() : this._geomFact.buildGeometry(o);\n        }\n      }, {\n        key: \"computeNodedEdges\",\n        value: function (t, e) {\n          var n = this.getNoder(e);\n          n.computeNodes(t);\n          for (var i = n.getNodedSubstrings().iterator(); i.hasNext();) {\n            var r = i.next(),\n              s = r.getCoordinates();\n            if (2 !== s.length || !s[0].equals2D(s[1])) {\n              var a = r.getData(),\n                o = new ri(r.getCoordinates(), new Ae(a));\n              this.insertUniqueEdge(o);\n            }\n          }\n        }\n      }, {\n        key: \"setNoder\",\n        value: function (t) {\n          this._workingNoder = t;\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this._bufParams = null, this._workingPrecisionModel = null, this._workingNoder = null, this._geomFact = null, this._graph = null, this._edgeList = new jn();\n          var t = arguments[0];\n          this._bufParams = t;\n        }\n      }, {\n        key: \"depthDelta\",\n        value: function (t) {\n          var e = t.getLocation(0, $.LEFT),\n            n = t.getLocation(0, $.RIGHT);\n          return e === H.INTERIOR && n === H.EXTERIOR ? 1 : e === H.EXTERIOR && n === H.INTERIOR ? -1 : 0;\n        }\n      }, {\n        key: \"convertSegStrings\",\n        value: function (t) {\n          for (var e = new ae(), n = new yt(); t.hasNext();) {\n            var i = t.next(),\n              r = e.createLineString(i.getCoordinates());\n            n.add(r);\n          }\n          return e.buildGeometry(n);\n        }\n      }]);\n    }(),\n    ai = function () {\n      function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }\n      return s(t, [{\n        key: \"rescale\",\n        value: function () {\n          if (rt(arguments[0], Z)) for (var t = arguments[0].iterator(); t.hasNext();) {\n            var e = t.next();\n            this.rescale(e.getCoordinates());\n          } else if (arguments[0] instanceof Array) {\n            for (var n = arguments[0], i = 0; i < n.length; i++) n[i].x = n[i].x / this._scaleFactor + this._offsetX, n[i].y = n[i].y / this._scaleFactor + this._offsetY;\n            2 === n.length && n[0].equals2D(n[1]) && mt.out.println(n);\n          }\n        }\n      }, {\n        key: \"scale\",\n        value: function () {\n          if (rt(arguments[0], Z)) {\n            for (var t = arguments[0], e = new yt(t.size()), n = t.iterator(); n.hasNext();) {\n              var i = n.next();\n              e.add(new xn(this.scale(i.getCoordinates()), i.getData()));\n            }\n            return e;\n          }\n          if (arguments[0] instanceof Array) {\n            for (var r = arguments[0], s = new Array(r.length).fill(null), a = 0; a < r.length; a++) s[a] = new X(Math.round((r[a].x - this._offsetX) * this._scaleFactor), Math.round((r[a].y - this._offsetY) * this._scaleFactor), r[a].getZ());\n            return jt.removeRepeatedPoints(s);\n          }\n        }\n      }, {\n        key: \"isIntegerPrecision\",\n        value: function () {\n          return 1 === this._scaleFactor;\n        }\n      }, {\n        key: \"getNodedSubstrings\",\n        value: function () {\n          var t = this._noder.getNodedSubstrings();\n          return this._isScaled && this.rescale(t), t;\n        }\n      }, {\n        key: \"computeNodes\",\n        value: function (t) {\n          var e = t;\n          this._isScaled && (e = this.scale(t)), this._noder.computeNodes(e);\n        }\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [Sn];\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          if (this._noder = null, this._scaleFactor = null, this._offsetX = null, this._offsetY = null, this._isScaled = !1, 2 === arguments.length) {\n            var e = arguments[0],\n              n = arguments[1];\n            t.constructor_.call(this, e, n, 0, 0);\n          } else if (4 === arguments.length) {\n            var i = arguments[0],\n              r = arguments[1];\n            this._noder = i, this._scaleFactor = r, this._isScaled = !this.isIntegerPrecision();\n          }\n        }\n      }]);\n    }(),\n    oi = function () {\n      function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }\n      return s(t, [{\n        key: \"checkEndPtVertexIntersections\",\n        value: function () {\n          if (0 === arguments.length) for (var t = this._segStrings.iterator(); t.hasNext();) {\n            var e = t.next().getCoordinates();\n            this.checkEndPtVertexIntersections(e[0], this._segStrings), this.checkEndPtVertexIntersections(e[e.length - 1], this._segStrings);\n          } else if (2 === arguments.length) for (var n = arguments[0], i = arguments[1].iterator(); i.hasNext();) for (var r = i.next().getCoordinates(), s = 1; s < r.length - 1; s++) if (r[s].equals(n)) throw new D(\"found endpt/interior pt intersection at index \" + s + \" :pt \" + n);\n        }\n      }, {\n        key: \"checkInteriorIntersections\",\n        value: function () {\n          if (0 === arguments.length) for (var t = this._segStrings.iterator(); t.hasNext();) for (var e = t.next(), n = this._segStrings.iterator(); n.hasNext();) {\n            var i = n.next();\n            this.checkInteriorIntersections(e, i);\n          } else if (2 === arguments.length) for (var r = arguments[0], s = arguments[1], a = r.getCoordinates(), o = s.getCoordinates(), u = 0; u < a.length - 1; u++) for (var l = 0; l < o.length - 1; l++) this.checkInteriorIntersections(r, u, s, l);else if (4 === arguments.length) {\n            var h = arguments[0],\n              c = arguments[1],\n              f = arguments[2],\n              g = arguments[3];\n            if (h === f && c === g) return null;\n            var v = h.getCoordinates()[c],\n              y = h.getCoordinates()[c + 1],\n              d = f.getCoordinates()[g],\n              _ = f.getCoordinates()[g + 1];\n            if (this._li.computeIntersection(v, y, d, _), this._li.hasIntersection() && (this._li.isProper() || this.hasInteriorIntersection(this._li, v, y) || this.hasInteriorIntersection(this._li, d, _))) throw new D(\"found non-noded intersection at \" + v + \"-\" + y + \" and \" + d + \"-\" + _);\n          }\n        }\n      }, {\n        key: \"checkValid\",\n        value: function () {\n          this.checkEndPtVertexIntersections(), this.checkInteriorIntersections(), this.checkCollapses();\n        }\n      }, {\n        key: \"checkCollapses\",\n        value: function () {\n          if (0 === arguments.length) for (var t = this._segStrings.iterator(); t.hasNext();) {\n            var e = t.next();\n            this.checkCollapses(e);\n          } else if (1 === arguments.length) for (var n = arguments[0].getCoordinates(), i = 0; i < n.length - 2; i++) this.checkCollapse(n[i], n[i + 1], n[i + 2]);\n        }\n      }, {\n        key: \"hasInteriorIntersection\",\n        value: function (t, e, n) {\n          for (var i = 0; i < t.getIntersectionNum(); i++) {\n            var r = t.getIntersection(i);\n            if (!r.equals(e) && !r.equals(n)) return !0;\n          }\n          return !1;\n        }\n      }, {\n        key: \"checkCollapse\",\n        value: function (e, n, i) {\n          if (e.equals(i)) throw new D(\"found non-noded collapse at \" + t.fact.createLineString([e, n, i]));\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this._li = new we(), this._segStrings = null;\n          var t = arguments[0];\n          this._segStrings = t;\n        }\n      }]);\n    }();\n  oi.fact = new ae();\n  var ui = function () {\n    function t() {\n      n(this, t), t.constructor_.apply(this, arguments);\n    }\n    return s(t, [{\n      key: \"intersectsScaled\",\n      value: function (t, e) {\n        var n = Math.min(t.x, e.x),\n          i = Math.max(t.x, e.x),\n          r = Math.min(t.y, e.y),\n          s = Math.max(t.y, e.y),\n          a = this._maxx < n || this._minx > i || this._maxy < r || this._miny > s;\n        if (a) return !1;\n        var o = this.intersectsToleranceSquare(t, e);\n        return G.isTrue(!(a && o), \"Found bad envelope test\"), o;\n      }\n    }, {\n      key: \"initCorners\",\n      value: function (t) {\n        var e = .5;\n        this._minx = t.x - e, this._maxx = t.x + e, this._miny = t.y - e, this._maxy = t.y + e, this._corner[0] = new X(this._maxx, this._maxy), this._corner[1] = new X(this._minx, this._maxy), this._corner[2] = new X(this._minx, this._miny), this._corner[3] = new X(this._maxx, this._miny);\n      }\n    }, {\n      key: \"intersects\",\n      value: function (t, e) {\n        return 1 === this._scaleFactor ? this.intersectsScaled(t, e) : (this.copyScaled(t, this._p0Scaled), this.copyScaled(e, this._p1Scaled), this.intersectsScaled(this._p0Scaled, this._p1Scaled));\n      }\n    }, {\n      key: \"scale\",\n      value: function (t) {\n        return Math.round(t * this._scaleFactor);\n      }\n    }, {\n      key: \"getCoordinate\",\n      value: function () {\n        return this._originalPt;\n      }\n    }, {\n      key: \"copyScaled\",\n      value: function (t, e) {\n        e.x = this.scale(t.x), e.y = this.scale(t.y);\n      }\n    }, {\n      key: \"getSafeEnvelope\",\n      value: function () {\n        if (null === this._safeEnv) {\n          var e = t.SAFE_ENV_EXPANSION_FACTOR / this._scaleFactor;\n          this._safeEnv = new U(this._originalPt.x - e, this._originalPt.x + e, this._originalPt.y - e, this._originalPt.y + e);\n        }\n        return this._safeEnv;\n      }\n    }, {\n      key: \"intersectsPixelClosure\",\n      value: function (t, e) {\n        return this._li.computeIntersection(t, e, this._corner[0], this._corner[1]), !!this._li.hasIntersection() || (this._li.computeIntersection(t, e, this._corner[1], this._corner[2]), !!this._li.hasIntersection() || (this._li.computeIntersection(t, e, this._corner[2], this._corner[3]), !!this._li.hasIntersection() || (this._li.computeIntersection(t, e, this._corner[3], this._corner[0]), !!this._li.hasIntersection())));\n      }\n    }, {\n      key: \"intersectsToleranceSquare\",\n      value: function (t, e) {\n        var n = !1,\n          i = !1;\n        return this._li.computeIntersection(t, e, this._corner[0], this._corner[1]), !!this._li.isProper() || (this._li.computeIntersection(t, e, this._corner[1], this._corner[2]), !!this._li.isProper() || (this._li.hasIntersection() && (n = !0), this._li.computeIntersection(t, e, this._corner[2], this._corner[3]), !!this._li.isProper() || (this._li.hasIntersection() && (i = !0), this._li.computeIntersection(t, e, this._corner[3], this._corner[0]), !!this._li.isProper() || !(!n || !i) || !!t.equals(this._pt) || !!e.equals(this._pt))));\n      }\n    }, {\n      key: \"addSnappedNode\",\n      value: function (t, e) {\n        var n = t.getCoordinate(e),\n          i = t.getCoordinate(e + 1);\n        return !!this.intersects(n, i) && (t.addIntersection(this.getCoordinate(), e), !0);\n      }\n    }], [{\n      key: \"constructor_\",\n      value: function () {\n        this._li = null, this._pt = null, this._originalPt = null, this._ptScaled = null, this._p0Scaled = null, this._p1Scaled = null, this._scaleFactor = null, this._minx = null, this._maxx = null, this._miny = null, this._maxy = null, this._corner = new Array(4).fill(null), this._safeEnv = null;\n        var t = arguments[0],\n          e = arguments[1],\n          n = arguments[2];\n        if (this._originalPt = t, this._pt = t, this._scaleFactor = e, this._li = n, e <= 0) throw new m(\"Scale factor must be non-zero\");\n        1 !== e && (this._pt = new X(this.scale(t.x), this.scale(t.y)), this._p0Scaled = new X(), this._p1Scaled = new X()), this.initCorners(this._pt);\n      }\n    }]);\n  }();\n  ui.SAFE_ENV_EXPANSION_FACTOR = .75;\n  var li = function () {\n      return s(function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }, [{\n        key: \"select\",\n        value: function () {\n          if (1 === arguments.length) ;else if (2 === arguments.length) {\n            var t = arguments[1];\n            arguments[0].getLineSegment(t, this.selectedSegment), this.select(this.selectedSegment);\n          }\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this.selectedSegment = new In();\n        }\n      }]);\n    }(),\n    hi = function () {\n      return s(function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }, [{\n        key: \"snap\",\n        value: function () {\n          if (1 === arguments.length) {\n            var t = arguments[0];\n            return this.snap(t, null, -1);\n          }\n          if (3 === arguments.length) {\n            var e = arguments[0],\n              i = arguments[1],\n              r = arguments[2],\n              a = e.getSafeEnvelope(),\n              o = new ci(e, i, r);\n            return this._index.query(a, new (function () {\n              return s(function t() {\n                n(this, t);\n              }, [{\n                key: \"interfaces_\",\n                get: function () {\n                  return [ln];\n                }\n              }, {\n                key: \"visitItem\",\n                value: function (t) {\n                  t.select(a, o);\n                }\n              }]);\n            }())()), o.isNodeAdded();\n          }\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this._index = null;\n          var t = arguments[0];\n          this._index = t;\n        }\n      }]);\n    }(),\n    ci = function (t) {\n      function i() {\n        var t;\n        return n(this, i), t = e(this, i), i.constructor_.apply(t, arguments), t;\n      }\n      return l(i, t), s(i, [{\n        key: \"isNodeAdded\",\n        value: function () {\n          return this._isNodeAdded;\n        }\n      }, {\n        key: \"select\",\n        value: function () {\n          if (!(2 === arguments.length && Number.isInteger(arguments[1]) && arguments[0] instanceof Nn)) return f(i, \"select\", this, 1).apply(this, arguments);\n          var t = arguments[1],\n            e = arguments[0].getContext();\n          if (this._parentEdge === e && (t === this._hotPixelVertexIndex || t + 1 === this._hotPixelVertexIndex)) return null;\n          this._isNodeAdded |= this._hotPixel.addSnappedNode(e, t);\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this._hotPixel = null, this._parentEdge = null, this._hotPixelVertexIndex = null, this._isNodeAdded = !1;\n          var t = arguments[0],\n            e = arguments[1],\n            n = arguments[2];\n          this._hotPixel = t, this._parentEdge = e, this._hotPixelVertexIndex = n;\n        }\n      }]);\n    }(li);\n  hi.HotPixelSnapAction = ci;\n  var fi = function () {\n      return s(function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }, [{\n        key: \"processIntersections\",\n        value: function (t, e, n, i) {\n          if (t === n && e === i) return null;\n          var r = t.getCoordinates()[e],\n            s = t.getCoordinates()[e + 1],\n            a = n.getCoordinates()[i],\n            o = n.getCoordinates()[i + 1];\n          if (this._li.computeIntersection(r, s, a, o), this._li.hasIntersection() && this._li.isInteriorIntersection()) {\n            for (var u = 0; u < this._li.getIntersectionNum(); u++) this._interiorIntersections.add(this._li.getIntersection(u));\n            t.addIntersections(this._li, e, 0), n.addIntersections(this._li, i, 1);\n          }\n        }\n      }, {\n        key: \"isDone\",\n        value: function () {\n          return !1;\n        }\n      }, {\n        key: \"getInteriorIntersections\",\n        value: function () {\n          return this._interiorIntersections;\n        }\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [Wn];\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this._li = null, this._interiorIntersections = null;\n          var t = arguments[0];\n          this._li = t, this._interiorIntersections = new yt();\n        }\n      }]);\n    }(),\n    gi = function () {\n      return s(function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }, [{\n        key: \"checkCorrectness\",\n        value: function (t) {\n          var e = xn.getNodedSubstrings(t),\n            n = new oi(e);\n          try {\n            n.checkValid();\n          } catch (t) {\n            if (!(t instanceof p)) throw t;\n            t.printStackTrace();\n          }\n        }\n      }, {\n        key: \"getNodedSubstrings\",\n        value: function () {\n          return xn.getNodedSubstrings(this._nodedSegStrings);\n        }\n      }, {\n        key: \"snapRound\",\n        value: function (t, e) {\n          var n = this.findInteriorIntersections(t, e);\n          this.computeIntersectionSnaps(n), this.computeVertexSnaps(t);\n        }\n      }, {\n        key: \"findInteriorIntersections\",\n        value: function (t, e) {\n          var n = new fi(e);\n          return this._noder.setSegmentIntersector(n), this._noder.computeNodes(t), n.getInteriorIntersections();\n        }\n      }, {\n        key: \"computeVertexSnaps\",\n        value: function () {\n          if (rt(arguments[0], Z)) for (var t = arguments[0].iterator(); t.hasNext();) {\n            var e = t.next();\n            this.computeVertexSnaps(e);\n          } else if (arguments[0] instanceof xn) for (var n = arguments[0], i = n.getCoordinates(), r = 0; r < i.length; r++) {\n            var s = new ui(i[r], this._scaleFactor, this._li);\n            this._pointSnapper.snap(s, n, r) && n.addIntersection(i[r], r);\n          }\n        }\n      }, {\n        key: \"computeNodes\",\n        value: function (t) {\n          this._nodedSegStrings = t, this._noder = new Cn(), this._pointSnapper = new hi(this._noder.getIndex()), this.snapRound(t, this._li);\n        }\n      }, {\n        key: \"computeIntersectionSnaps\",\n        value: function (t) {\n          for (var e = t.iterator(); e.hasNext();) {\n            var n = e.next(),\n              i = new ui(n, this._scaleFactor, this._li);\n            this._pointSnapper.snap(i);\n          }\n        }\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [Sn];\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this._pm = null, this._li = null, this._scaleFactor = null, this._noder = null, this._pointSnapper = null, this._nodedSegStrings = null;\n          var t = arguments[0];\n          this._pm = t, this._li = new we(), this._li.setPrecisionModel(t), this._scaleFactor = t.getScale();\n        }\n      }]);\n    }(),\n    vi = function () {\n      function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }\n      return s(t, [{\n        key: \"bufferFixedPrecision\",\n        value: function (t) {\n          var e = new ai(new gi(new ie(1)), t.getScale()),\n            n = new si(this._bufParams);\n          n.setWorkingPrecisionModel(t), n.setNoder(e), this._resultGeometry = n.buffer(this._argGeom, this._distance);\n        }\n      }, {\n        key: \"bufferReducedPrecision\",\n        value: function () {\n          if (0 === arguments.length) {\n            for (var e = t.MAX_PRECISION_DIGITS; e >= 0; e--) {\n              try {\n                this.bufferReducedPrecision(e);\n              } catch (t) {\n                if (!(t instanceof gt)) throw t;\n                this._saveException = t;\n              }\n              if (null !== this._resultGeometry) return null;\n            }\n            throw this._saveException;\n          }\n          if (1 === arguments.length) {\n            var n = arguments[0],\n              i = t.precisionScaleFactor(this._argGeom, this._distance, n),\n              r = new ie(i);\n            this.bufferFixedPrecision(r);\n          }\n        }\n      }, {\n        key: \"computeGeometry\",\n        value: function () {\n          if (this.bufferOriginalPrecision(), null !== this._resultGeometry) return null;\n          var t = this._argGeom.getFactory().getPrecisionModel();\n          t.getType() === ie.FIXED ? this.bufferFixedPrecision(t) : this.bufferReducedPrecision();\n        }\n      }, {\n        key: \"setQuadrantSegments\",\n        value: function (t) {\n          this._bufParams.setQuadrantSegments(t);\n        }\n      }, {\n        key: \"bufferOriginalPrecision\",\n        value: function () {\n          try {\n            var t = new si(this._bufParams);\n            this._resultGeometry = t.buffer(this._argGeom, this._distance);\n          } catch (t) {\n            if (!(t instanceof D)) throw t;\n            this._saveException = t;\n          }\n        }\n      }, {\n        key: \"getResultGeometry\",\n        value: function (t) {\n          return this._distance = t, this.computeGeometry(), this._resultGeometry;\n        }\n      }, {\n        key: \"setEndCapStyle\",\n        value: function (t) {\n          this._bufParams.setEndCapStyle(t);\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          if (this._argGeom = null, this._distance = null, this._bufParams = new _(), this._resultGeometry = null, this._saveException = null, 1 === arguments.length) {\n            var t = arguments[0];\n            this._argGeom = t;\n          } else if (2 === arguments.length) {\n            var e = arguments[0],\n              n = arguments[1];\n            this._argGeom = e, this._bufParams = n;\n          }\n        }\n      }, {\n        key: \"bufferOp\",\n        value: function () {\n          if (2 === arguments.length) {\n            var e = arguments[1];\n            return new t(arguments[0]).getResultGeometry(e);\n          }\n          if (3 === arguments.length) {\n            if (Number.isInteger(arguments[2]) && arguments[0] instanceof V && \"number\" == typeof arguments[1]) {\n              var n = arguments[1],\n                i = arguments[2],\n                r = new t(arguments[0]);\n              return r.setQuadrantSegments(i), r.getResultGeometry(n);\n            }\n            if (arguments[2] instanceof _ && arguments[0] instanceof V && \"number\" == typeof arguments[1]) {\n              var s = arguments[1];\n              return new t(arguments[0], arguments[2]).getResultGeometry(s);\n            }\n          } else if (4 === arguments.length) {\n            var a = arguments[1],\n              o = arguments[2],\n              u = arguments[3],\n              l = new t(arguments[0]);\n            return l.setQuadrantSegments(o), l.setEndCapStyle(u), l.getResultGeometry(a);\n          }\n        }\n      }, {\n        key: \"precisionScaleFactor\",\n        value: function (t, e, n) {\n          var i = t.getEnvelopeInternal(),\n            r = kt.max(Math.abs(i.getMaxX()), Math.abs(i.getMaxY()), Math.abs(i.getMinX()), Math.abs(i.getMinY())) + 2 * (e > 0 ? e : 0),\n            s = n - Math.trunc(Math.log(r) / Math.log(10) + 1);\n          return Math.pow(10, s);\n        }\n      }]);\n    }();\n  vi.CAP_ROUND = _.CAP_ROUND, vi.CAP_BUTT = _.CAP_FLAT, vi.CAP_FLAT = _.CAP_FLAT, vi.CAP_SQUARE = _.CAP_SQUARE, vi.MAX_PRECISION_DIGITS = 12;\n  var yi = [\"Point\", \"MultiPoint\", \"LineString\", \"MultiLineString\", \"Polygon\", \"MultiPolygon\"],\n    di = function () {\n      return s(function t(e) {\n        n(this, t), this.geometryFactory = e || new ae();\n      }, [{\n        key: \"read\",\n        value: function (t) {\n          var e,\n            n = (e = \"string\" == typeof t ? JSON.parse(t) : t).type;\n          if (!_i[n]) throw new Error(\"Unknown GeoJSON type: \" + e.type);\n          return -1 !== yi.indexOf(n) ? _i[n].call(this, e.coordinates) : \"GeometryCollection\" === n ? _i[n].call(this, e.geometries) : _i[n].call(this, e);\n        }\n      }, {\n        key: \"write\",\n        value: function (t) {\n          var e = t.getGeometryType();\n          if (!pi[e]) throw new Error(\"Geometry is not supported\");\n          return pi[e].call(this, t);\n        }\n      }]);\n    }(),\n    _i = {\n      Feature: function (t) {\n        var e = {};\n        for (var n in t) e[n] = t[n];\n        if (t.geometry) {\n          var i = t.geometry.type;\n          if (!_i[i]) throw new Error(\"Unknown GeoJSON type: \" + t.type);\n          e.geometry = this.read(t.geometry);\n        }\n        return t.bbox && (e.bbox = _i.bbox.call(this, t.bbox)), e;\n      },\n      FeatureCollection: function (t) {\n        var e = {};\n        if (t.features) {\n          e.features = [];\n          for (var n = 0; n < t.features.length; ++n) e.features.push(this.read(t.features[n]));\n        }\n        return t.bbox && (e.bbox = this.parse.bbox.call(this, t.bbox)), e;\n      },\n      coordinates: function (t) {\n        for (var e = [], n = 0; n < t.length; ++n) {\n          var r = t[n];\n          e.push(i(X, g(r)));\n        }\n        return e;\n      },\n      bbox: function (t) {\n        return this.geometryFactory.createLinearRing([new X(t[0], t[1]), new X(t[2], t[1]), new X(t[2], t[3]), new X(t[0], t[3]), new X(t[0], t[1])]);\n      },\n      Point: function (t) {\n        var e = i(X, g(t));\n        return this.geometryFactory.createPoint(e);\n      },\n      MultiPoint: function (t) {\n        for (var e = [], n = 0; n < t.length; ++n) e.push(_i.Point.call(this, t[n]));\n        return this.geometryFactory.createMultiPoint(e);\n      },\n      LineString: function (t) {\n        var e = _i.coordinates.call(this, t);\n        return this.geometryFactory.createLineString(e);\n      },\n      MultiLineString: function (t) {\n        for (var e = [], n = 0; n < t.length; ++n) e.push(_i.LineString.call(this, t[n]));\n        return this.geometryFactory.createMultiLineString(e);\n      },\n      Polygon: function (t) {\n        for (var e = _i.coordinates.call(this, t[0]), n = this.geometryFactory.createLinearRing(e), i = [], r = 1; r < t.length; ++r) {\n          var s = t[r],\n            a = _i.coordinates.call(this, s),\n            o = this.geometryFactory.createLinearRing(a);\n          i.push(o);\n        }\n        return this.geometryFactory.createPolygon(n, i);\n      },\n      MultiPolygon: function (t) {\n        for (var e = [], n = 0; n < t.length; ++n) {\n          var i = t[n];\n          e.push(_i.Polygon.call(this, i));\n        }\n        return this.geometryFactory.createMultiPolygon(e);\n      },\n      GeometryCollection: function (t) {\n        for (var e = [], n = 0; n < t.length; ++n) {\n          var i = t[n];\n          e.push(this.read(i));\n        }\n        return this.geometryFactory.createGeometryCollection(e);\n      }\n    },\n    pi = {\n      coordinate: function (t) {\n        var e = [t.x, t.y];\n        return t.z && e.push(t.z), t.m && e.push(t.m), e;\n      },\n      Point: function (t) {\n        return {\n          type: \"Point\",\n          coordinates: pi.coordinate.call(this, t.getCoordinate())\n        };\n      },\n      MultiPoint: function (t) {\n        for (var e = [], n = 0; n < t._geometries.length; ++n) {\n          var i = t._geometries[n],\n            r = pi.Point.call(this, i);\n          e.push(r.coordinates);\n        }\n        return {\n          type: \"MultiPoint\",\n          coordinates: e\n        };\n      },\n      LineString: function (t) {\n        for (var e = [], n = t.getCoordinates(), i = 0; i < n.length; ++i) {\n          var r = n[i];\n          e.push(pi.coordinate.call(this, r));\n        }\n        return {\n          type: \"LineString\",\n          coordinates: e\n        };\n      },\n      MultiLineString: function (t) {\n        for (var e = [], n = 0; n < t._geometries.length; ++n) {\n          var i = t._geometries[n],\n            r = pi.LineString.call(this, i);\n          e.push(r.coordinates);\n        }\n        return {\n          type: \"MultiLineString\",\n          coordinates: e\n        };\n      },\n      Polygon: function (t) {\n        var e = [],\n          n = pi.LineString.call(this, t._shell);\n        e.push(n.coordinates);\n        for (var i = 0; i < t._holes.length; ++i) {\n          var r = t._holes[i],\n            s = pi.LineString.call(this, r);\n          e.push(s.coordinates);\n        }\n        return {\n          type: \"Polygon\",\n          coordinates: e\n        };\n      },\n      MultiPolygon: function (t) {\n        for (var e = [], n = 0; n < t._geometries.length; ++n) {\n          var i = t._geometries[n],\n            r = pi.Polygon.call(this, i);\n          e.push(r.coordinates);\n        }\n        return {\n          type: \"MultiPolygon\",\n          coordinates: e\n        };\n      },\n      GeometryCollection: function (t) {\n        for (var e = [], n = 0; n < t._geometries.length; ++n) {\n          var i = t._geometries[n],\n            r = i.getGeometryType();\n          e.push(pi[r].call(this, i));\n        }\n        return {\n          type: \"GeometryCollection\",\n          geometries: e\n        };\n      }\n    };\n  return {\n    BufferOp: vi,\n    GeoJSONReader: function () {\n      return s(function t(e) {\n        n(this, t), this.parser = new di(e || new ae());\n      }, [{\n        key: \"read\",\n        value: function (t) {\n          return this.parser.read(t);\n        }\n      }]);\n    }(),\n    GeoJSONWriter: function () {\n      return s(function t() {\n        n(this, t), this.parser = new di(this.geometryFactory);\n      }, [{\n        key: \"write\",\n        value: function (t) {\n          return this.parser.write(t);\n        }\n      }]);\n    }()\n  };\n});","map":{"version":3,"names":["_","t","n","constructor_","apply","arguments","s","key","value","_endCapStyle","_isSingleSided","e","_quadrantSegments","_joinStyle","JOIN_BEVEL","JOIN_MITRE","_mitreLimit","Math","abs","JOIN_ROUND","DEFAULT_QUADRANT_SEGMENTS","_simplifyFactor","CAP_ROUND","DEFAULT_MITRE_LIMIT","DEFAULT_SIMPLIFY_FACTOR","length","setQuadrantSegments","i","setEndCapStyle","r","a","o","setJoinStyle","setMitreLimit","PI","cos","CAP_FLAT","CAP_SQUARE","p","name","Object","keys","Exception","l","message","d","Error","m","IllegalArgumentException","k","x","I","E","N","T","S","L","C","R","w","O","b","M","low","high","A","P","NaN","isNaN","Number","isInfinite","isFinite","MAX_VALUE","POSITIVE_INFINITY","NEGATIVE_INFINITY","Float64Array","Int32Array","buffer","doubleToLongBits","longBitsToDouble","log2","floor","pow","u","D","RuntimeException","F","call","G","shouldNeverReachHere","isTrue","equals","q","ArrayBuffer","Y","z","X","y","Z","setZ","equalsWithTolerance","getZ","equals2D","CloneNotSupportedException","sqrt","hashCode","get","NULL_ORDINATE","B","compare","_dimensionsToTest","DimensionalComparator","U","getWidth","getHeight","isNull","_maxx","getMaxX","_maxy","getMaxY","_minx","getMinX","_miny","getMinY","intersects","covers","expandToInclude","init","expandBy","setToNull","min","max","h","V","getTypeCode","TYPECODE_GEOMETRYCOLLECTION","_factory","equalsExact","geometryChangedFilter","_envelope","norm","isEmpty","compareToSameClass","_userData","_SRID","getFactory","toGeometry","getEnvelopeInternal","distance","copy","normalize","reverseInternal","envelope","setSRID","getSRID","copyInternal","getPrecisionModel","computeEnvelopeInternal","iterator","hasNext","next","compareTo","getClass","TYPECODE_MULTIPOINT","TYPECODE_MULTILINESTRING","TYPECODE_MULTIPOLYGON","TYPECODE_POINT","TYPECODE_LINESTRING","TYPECODE_LINEARRING","TYPECODE_POLYGON","TYPENAME_POINT","TYPENAME_MULTIPOINT","TYPENAME_LINESTRING","TYPENAME_LINEARRING","TYPENAME_MULTILINESTRING","TYPENAME_POLYGON","TYPENAME_MULTIPOLYGON","TYPENAME_GEOMETRYCOLLECTION","interfaces_","filter","geometryChangedAction","H","EXTERIOR","BOUNDARY","INTERIOR","NONE","j","NoSuchElementException","W","UnsupportedOperationException","K","J","map","Map","addAll","has","set","done","add","f","size","Array","from","values","Q","Symbol","$","LEFT","RIGHT","ON","tt","EmptyStackException","et","IndexOutOfBoundsException","nt","it","array","push","pop","empty","indexOf","slice","rt","st","str","substr","at","ot","toUpperCase","ut","_hi","_lo","magnitude","TEN","divide","gt","lt","ONE","multiply","MAX_PRINT_DIGITS","append","trunc","c","subtract","valueOf","selfAdd","g","v","toString","negate","isZero","le","selfDivide","SPLIT","createNaN","selfMultiply","sqr","reciprocal","ceil","ge","isNegative","toStandardNotation","toSciNotation","getSpecialNumberString","fill","extractSignificantDigits","charAt","stringOfChar","SCI_NOT_ZERO","SCI_NOT_EXPONENT_CHAR","IllegalStateException","substring","isPositive","parse","determinant","selfSubtract","isWhitespace","isDigit","parseInt","NumberFormatException","log","TWO_PI","PI_2","EPS","orientationIndexFilter","signum","doubleValue","DP_SAFE_EPSILON","ht","hasM","getDimension","getMeasures","getOrdinate","hasZ","ct","orientationIndex","index","getCoordinate","CLOCKWISE","COUNTERCLOCKWISE","COLLINEAR","STRAIGHT","ft","_minCoord","getRightmostSideOfSegment","checkForRightmostCoordinate","_minDe","getEdge","getCoordinates","_minIndex","_orientedDe","getNode","getEdges","getRightmostEdge","isForward","getSym","findRightmostEdgeAtNode","findRightmostEdgeAtVertex","getRightmostSide","pt","TopologyException","vt","shift","yt","splice","dt","sort","arrayList","position","remove","_t","_dirEdgeList","setVisited","_rightMostCoord","isVisited","computeDepths","copySymDepths","clearVisitedEdges","_finder","getLabel","setEdgeDepths","addReachable","findEdge","getDepth","isInteriorAreaEdge","setInResult","addLast","removeFirst","computeNodeDepth","contains","_env","setDepth","_nodes","mt","kt","LOG_10","isInteger","xt","pointToSegment","It","create","Et","Nt","Tt","St","setOrdinate","scroll","isRing","minCoordinateIndex","swap","copyCoord","createClosedRing","Lt","FALSE","SYM_FALSE","TRUE","SYM_TRUE","DONTCARE","SYM_DONTCARE","SYM_P","SYM_L","SYM_A","Ct","Rt","wt","_points","expandEnvelope","isClosed","isSimple","toCoordinateArray","isEquivalentClass","equal","reverse","getCoordinateN","getNumPoints","createLineString","getPointN","ofLine","isDone","isGeometryChanged","geometryChanged","getCoordinateSequenceFactory","createPoint","Ot","bt","_coordinates","getX","getY","createGeometryCollection","Mt","ofRingSigned","At","concat","Pt","Dt","_shell","_holes","ofRing","getCoordinateSequence","getNumInteriorRing","normalized","isCCW","getExteriorRing","getInteriorRingN","createPolygon","getLength","convexHull","createMultiLineString","createLinearRing","hasNullElements","hasNonEmptyElements","Ft","Gt","qt","Yt","_geometries","getArea","getBoundaryDimension","buildGeometry","asList","getNumGeometries","getGeometryN","checkNotGeometryCollection","zt","Xt","MINIMUM_VALID_SIZE","validateConstruction","Bt","Ut","_m","getM","Vt","Ht","Zt","clone","toArray","coordArrayType","ensureCapacity","jt","arraycopy","measures","hasRepeatedPoints","dimension","clamp","Wt","Kt","isEqualReversed","increasingDirection","ForwardComparator","BidirectionalComparator","Jt","Qt","setCoordinate","createCoordinate","_dimension","_measures","getCoordinateCopy","$t","instance","instanceObject","te","getBoundary","ee","ne","entries","forEach","ie","_modelType","_scale","getMaximumSignificantDigits","FLOATING","FLOATING_SINGLE","FIXED","getScale","round","makePrecise","re","setScale","nameToTypeMap","_name","put","Type","maximumPreciseValue","se","ae","toGeometryArray","createMultiPolygon","toPolygonArray","toLineStringArray","createMultiPoint","toPointArray","getGeometryType","_coordinateSequenceFactory","_precisionModel","getDefaultCoordinateSequenceFactory","oe","ue","he","ce","POINT","LINE_STRING","LINEAR_RING","POLYGON","MULTI_POINT","MULTI_LINE_STRING","MULTI_POLYGON","GEOMETRY_COLLECTION","CIRCLE","fe","ve","ye","de","_e","pe","me","ke","wkt","index_","nextChar_","isNumeric_","readNumber_","isAlpha_","readText_","isWhiteSpace_","nextToken","type","parseFloat","xe","lexer_","token_","layout_","factory","isTokenType","consume_","parseGeometry_","match","isEmptyGeometry_","formatErrorMessage_","parsePoint_","parsePointList_","parseLineStringTextList_","parsePointTextList_","parsePolygonTextList_","parsePointText_","parseLineStringText_","parsePolygonText_","o2c","ca2p","parseGeometryLayout_","parseGeometryCollectionText_","parseMultiPointText_","parseMultiLineStringText_","parseMultiPolygonText_","Ie","join","Ee","Ne","Te","Point","LineString","LinearRing","Polygon","MultiPoint","MultiLineString","MultiPolygon","GeometryCollection","Se","Le","geometryFactory","precisionModel","Ce","parser","write","Re","computeIntLineIndex","_intLineIndex","isEndPoint","_isProper","isCollinear","_inputLines","_result","computeIntersect","getEdgeDistance","hasIntersection","isInteriorIntersection","_intPt","NO_INTERSECTION","computeEdgeDistance","COLLINEAR_INTERSECTION","toLineString","getTopologySummary","_pa","_pb","DONT_INTERSECT","DO_INTERSECT","POINT_INTERSECTION","we","intersectionSafe","isInSegmentEnvelopes","nearestEndpoint","intersection","out","println","computeCollinearIntersection","Oe","_p","_isPointOnSegment","_crossingCount","getLocation","countSegment","isOnSegment","be","computeIntersection","locatePointInRing","locateInRing","Me","location","toLocationSymbol","setLocation","setAllLocations","Ae","elt","setAllLocationsIfNull","isLine","merge","flip","isArea","isAnyNull","isEqualOnSide","allPositionsEqual","setLocations","Pe","_ring","_pts","_geometryFactory","_isHole","_label","getGeometryCount","_startDe","getEdgeRing","_edges","mergeLabel","addPoints","setEdgeRing","getNext","_maxNodeDegree","getOutgoingDegree","getLinearRing","isInRing","containsPoint","computeMaxNodeDegree","addHole","computePoints","computeRing","De","setMinEdgeRing","getNextMin","Fe","getMinEdgeRing","linkMinimalDirectedEdges","Ge","_isVisited","_isInResult","_isCovered","_isCoveredSet","computeIM","qe","isInResult","_coord","computeMergedLocation","insert","setNode","Ye","ze","color","Xe","parent","Be","Ue","left","Ve","right","He","root_","size_","getValue","getKey","fixAfterInsertion","rotateLeft","rotateRight","getFirstEntry","successor","Ze","nodeMap","nodeFact","createNode","print","addNode","je","NE","NW","SE","SW","We","_dx","_dy","_quadrant","_p0","_p1","_node","atan2","getName","lastIndexOf","compareDirection","_edge","quadrant","Ke","_nextMin","_depth","_isForward","_next","getDepthDelta","_minEdgeRing","_edgeRing","_sym","printReverse","opposite","computeDirectedLabel","Je","Qe","eiList","find","linkResultDirectedEdges","linkAllDirectedEdges","_edgeEndList","matchInSameDirection","getEdgeEnds","setSym","$e","isHole","toPolygon","getShell","findEdgeRingContaining","setShell","getMaxNodeDegree","linkDirectedEdgesForMinimalEdgeRings","buildMinimalRings","findShell","placePolygonHoles","computePolygons","_shellList","getNodes","buildMaximalEdgeRings","buildMinimalEdgeRings","sortShellsAndHoles","placeFreeHoles","ptNotInList","tn","en","_item","_bounds","nn","_items","_size","reorder","clear","rn","sn","_level","_childBoundables","computeBounds","an","reverseOrder","singletonList","on","maxDistance","un","maximumDistance","_boundable1","getBounds","_boundable2","isComposite","area","expand","_distance","getChildBoundables","_itemDistance","getDistance","isLeaves","ln","hn","getIntersectsOp","queryInternal","visitItem","getItem","_nodeCapacity","build","_root","itemsTree","_built","_itemBoundables","boundablesAtLevel","getLevel","createHigherLevels","removeItem","createParentBoundables","depth","getComparator","lastNode","getNodeCapacity","addChildBoundable","DEFAULT_NODE_CAPACITY","IntersectsOp","cn","fn","createParentBoundablesFromVerticalSlice","nearestNeighbourK","poll","peek","expandToQueue","getItems","gn","intersectsOp","yComparator","xComparator","verticalSlices","createParentBoundablesFromVerticalSlices","getRoot","nearestNeighbour","getBoundable","isWithinDistance","avg","STRtreeNode","compareDoubles","centreX","centreY","vn","relativeSign","compareValue","yn","coord","segmentIndex","_isInterior","_segmentOctant","_segString","dn","_n","addEndpoints","addEdgeCoordinates","findCollapsesFromInsertedNodes","findCollapsesFromExistingVertices","intValue","isInterior","createSplitEdgePts","_nodeMap","addCollapsedNodes","createSplitEdge","findCollapseIndex","xn","getData","getSegmentOctant","pn","octant","mn","kn","safeOctant","_data","addIntersectionNode","getIntersection","addIntersection","_nodeList","getIntersectionNum","getNodedSubstrings","getNodeList","addSplitEdges","In","p0","p1","projectionFactor","project","pointToLinePerpendicular","midPoint","closestPoint","setCoordinates","segmentToSegment","En","getLineSegment","_overlapSeg1","_overlapSeg2","overlap","Nn","select","computeSelect","_end","_start","computeOverlaps","overlaps","_id","_context","Tn","getChains","findChainEnd","Sn","Ln","_segInt","setSegmentIntersector","Cn","_monoChains","_nodedSegStrings","_index","setId","_idCounter","getEnvelope","intersectChains","Rn","query","getId","_nOverlaps","getContext","_si","processIntersections","SegmentOverlapAction","wn","_inputLine","isConcave","isShallow","isShallowSampled","findNextNonDeletedIndex","isDeletable","_distanceTol","_isDeleted","DELETE","_angleOrientation","NUM_PTS_TO_CHECK","deleteShallowConcavities","collapseLine","simplify","INIT","KEEP","On","_ptList","COORDINATE_ARRAY_TYPE","isRedundant","addPt","_minimimVertexDistance","bn","PI_TIMES_2","angle","diff","sin","PI_OVER_2","PI_OVER_4","Mn","_s0","_s1","_s2","_seg0","computeOffsetSegment","_side","_offset0","_seg1","_offset1","addCollinear","addOutsideTurn","addInsideTurn","_bufParams","getEndCapStyle","_segList","addDirectedFillet","getMitreLimit","addLimitedMitreJoin","OFFSET_SEGMENT_SEPARATION_FACTOR","getJoinStyle","addMitreJoin","addBevelJoin","addCornerFillet","closeRing","addPts","angleBetweenOriented","pointAlongOffset","_filletAngleQuantum","_li","_hasNarrowConcaveAngle","INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR","_closingSegLengthFactor","_maxCurveSegmentError","setPrecisionModel","setMinimumVertexDistance","CURVE_VERTEX_SNAP_DISTANCE_FACTOR","getQuadrantSegments","MAX_CLOSING_SEG_LEN_FACTOR","An","getSegGen","computePointCurve","computeOffsetCurve","simplifyTolerance","addSegments","initSideSegments","addFirstSegment","addNextSegment","addLastSegment","addLineEndCap","createCircle","createSquare","isLineOffsetEmpty","isSingleSided","computeSingleSidedBufferCurve","computeLineBufferCurve","getSimplifyFactor","getLineCurve","copyCoordinates","computeRingBufferCurve","Pn","_subgraphs","findStabbedSegments","getDirectedEdges","_seg","isHorizontal","Dn","_leftDepth","_upwardSeg","minX","maxX","DepthSegment","Fn","Gn","qn","p2","signedArea","interpolateZ","longestSideLength","isAcute","circumcentre","area3D","centroid","inCentre","det","Yn","_curveBuilder","getRingCurve","addCurve","addRingSide","removeRepeatedPoints","isErodedCompletely","getBufferParameters","addRingBothSides","_curveList","_inputGeom","addPolygon","addLineString","addPoint","addCollection","isTriangleErodedCompletely","zn","Xn","_atStart","isAtomic","_parent","_subcollectionIterator","_max","Bn","locate","_geom","locatePointInPolygon","locateInGeometry","Un","_edgeList","computeEdgeEndLabels","getBoundaryNodeRule","checkAreaLabelsConsistent","_edgeMap","_ptInAreaLocation","getGeometry","computeLabel","propagateSideLabels","Vn","getResultAreaEdges","_SCANNING_FOR_INCOMING","_resultAreaEdgeList","_LINKING_TO_OUTGOING","setNext","insertEdgeEnd","getQuadrant","isNorthern","getDy","findIndex","setNextMin","isLineEdge","setCovered","Hn","Zn","compareOriented","_orientation","orientation","jn","_ocaMap","Wn","Kn","isAdjacentSegments","_properIntersectionPoint","_hasProperInterior","_hasProper","numTests","numIntersections","numInteriorIntersections","_hasInterior","isTrivialIntersection","_hasIntersection","addIntersections","isProper","numProperIntersections","_isSelfIntersection","Jn","dist","Qn","edge","pts","ri","$n","isDisjoint","_matrix","toDimensionValue","setAtLeast","isTouches","setCharAt","toDimensionSymbol","matches","setAll","ti","copyOf","ei","toIntArray","ni","startIndex","computeIntersectsForChain","getChainStartIndices","ii","NULL_VALUE","depthAtLocation","toLineLabel","_isIsolated","_depthDelta","updateIM","_mce","setAtLeastIfValid","si","_workingPrecisionModel","findEqualEdge","isPointwiseEqual","depthDelta","setDepthDelta","getRightmostCoordinate","computeDepth","findResultEdges","_geomFact","_workingNoder","getCurves","createEmptyResultGeometry","computeNodedEdges","_graph","addEdges","createSubgraphs","buildSubgraphs","getPolygons","getNoder","computeNodes","insertUniqueEdge","ai","rescale","_scaleFactor","_offsetX","_offsetY","scale","_noder","_isScaled","isIntegerPrecision","oi","_segStrings","checkEndPtVertexIntersections","checkInteriorIntersections","hasInteriorIntersection","checkCollapses","checkCollapse","fact","ui","intersectsToleranceSquare","_corner","intersectsScaled","copyScaled","_p0Scaled","_p1Scaled","_originalPt","_safeEnv","SAFE_ENV_EXPANSION_FACTOR","_pt","_ptScaled","initCorners","li","selectedSegment","hi","snap","getSafeEnvelope","ci","isNodeAdded","_isNodeAdded","_parentEdge","_hotPixelVertexIndex","_hotPixel","addSnappedNode","HotPixelSnapAction","fi","_interiorIntersections","gi","checkValid","printStackTrace","findInteriorIntersections","computeIntersectionSnaps","computeVertexSnaps","getInteriorIntersections","_pointSnapper","getIndex","snapRound","_pm","vi","setWorkingPrecisionModel","setNoder","_resultGeometry","_argGeom","MAX_PRECISION_DIGITS","bufferReducedPrecision","_saveException","precisionScaleFactor","bufferFixedPrecision","bufferOriginalPrecision","getType","computeGeometry","getResultGeometry","CAP_BUTT","yi","di","JSON","_i","coordinates","geometries","pi","Feature","geometry","read","bbox","FeatureCollection","features","coordinate","BufferOp","GeoJSONReader","GeoJSONWriter"],"sources":["/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/operation/buffer/BufferParameters.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/java/lang/Exception.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/java/lang/IllegalArgumentException.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/geom/GeometryComponentFilter.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/java/lang/Comparable.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/java/lang/Cloneable.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/java/io/Serializable.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/java/lang/Double.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/util/NumberUtil.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/java/lang/Long.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/java/util/Comparator.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/java/lang/RuntimeException.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/util/AssertionFailedException.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/util/Assert.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/geom/Coordinate.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/geom/Envelope.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/geom/Geometry.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/geom/Location.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/java/util/Collection.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/java/util/NoSuchElementException.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/java/lang/UnsupportedOperationException.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/java/util/Set.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/java/util/HashSet.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/geomgraph/Position.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/java/util/EmptyStackException.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/java/lang/IndexOutOfBoundsException.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/java/util/List.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/java/util/Stack.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/hasInterface.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/java/lang/StringBuffer.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/java/lang/Integer.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/java/lang/Character.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/math/DD.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/algorithm/CGAlgorithmsDD.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/geom/CoordinateSequence.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/algorithm/Orientation.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/operation/buffer/RightmostEdgeFinder.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/geom/TopologyException.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/java/util/LinkedList.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/java/util/ArrayList.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/operation/buffer/BufferSubgraph.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/algorithm/Intersection.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/java/lang/System.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/math/MathUtil.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/algorithm/Distance.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/geom/CoordinateSequenceFactory.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/geom/CoordinateFilter.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/algorithm/Length.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/geom/Lineal.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/geom/CoordinateSequences.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/geom/Dimension.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/geom/GeometryFilter.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/geom/CoordinateSequenceFilter.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/geom/LineString.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/geom/Puntal.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/geom/Point.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/algorithm/Area.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/java/util/Arrays.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/geom/Polygonal.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/geom/Polygon.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/java/util/SortedSet.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/java/util/TreeSet.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/geom/GeometryCollection.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/geom/MultiPoint.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/geom/LinearRing.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/geom/CoordinateXY.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/geom/CoordinateXYM.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/geom/CoordinateXYZM.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/geom/Coordinates.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/geom/CoordinateList.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/geom/CoordinateArrays.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/java/lang/StringBuilder.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/geom/impl/CoordinateArraySequence.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/geom/impl/CoordinateArraySequenceFactory.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/geom/MultiPolygon.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/java/util/Map.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/java/util/HashMap.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/geom/PrecisionModel.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/geom/MultiLineString.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/geom/GeometryFactory.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/io/WKTParser.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/io/WKTWriter.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/algorithm/LineIntersector.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/algorithm/RobustLineIntersector.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/algorithm/RayCrossingCounter.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/algorithm/PointLocation.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/geomgraph/TopologyLocation.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/geomgraph/Label.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/geomgraph/EdgeRing.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/operation/overlay/MinimalEdgeRing.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/operation/overlay/MaximalEdgeRing.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/geomgraph/GraphComponent.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/geomgraph/Node.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/java/util/SortedMap.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/java/util/TreeMap.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/geomgraph/NodeMap.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/geomgraph/Quadrant.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/geomgraph/EdgeEnd.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/geomgraph/DirectedEdge.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/geomgraph/NodeFactory.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/geomgraph/PlanarGraph.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/operation/overlay/PolygonBuilder.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/index/strtree/Boundable.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/index/strtree/ItemBoundable.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/util/PriorityQueue.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/index/SpatialIndex.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/index/strtree/AbstractNode.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/java/util/Collections.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/index/strtree/EnvelopeDistance.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/index/strtree/BoundablePair.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/index/ItemVisitor.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/index/strtree/AbstractSTRtree.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/index/strtree/ItemDistance.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/index/strtree/STRtree.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/noding/SegmentPointComparator.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/noding/SegmentNode.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/java/util/Iterator.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/noding/SegmentNodeList.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/noding/Octant.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/noding/SegmentString.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/noding/NodableSegmentString.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/noding/NodedSegmentString.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/geom/LineSegment.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/index/chain/MonotoneChainOverlapAction.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/index/chain/MonotoneChain.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/index/chain/MonotoneChainBuilder.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/noding/Noder.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/noding/SinglePassNoder.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/noding/MCIndexNoder.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/operation/buffer/BufferInputLineSimplifier.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/operation/buffer/OffsetSegmentString.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/algorithm/Angle.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/operation/buffer/OffsetSegmentGenerator.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/operation/buffer/OffsetCurveBuilder.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/operation/buffer/SubgraphDepthLocater.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/algorithm/NotRepresentableException.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/algorithm/HCoordinate.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/geom/Triangle.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/operation/buffer/OffsetCurveSetBuilder.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/algorithm/locate/PointOnGeometryLocator.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/geom/GeometryCollectionIterator.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/algorithm/locate/SimplePointInAreaLocator.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/geomgraph/EdgeEndStar.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/geomgraph/DirectedEdgeStar.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/operation/overlay/OverlayNodeFactory.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/noding/OrientedCoordinateArray.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/geomgraph/EdgeList.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/noding/SegmentIntersector.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/noding/IntersectionAdder.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/geomgraph/EdgeIntersection.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/geomgraph/EdgeIntersectionList.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/geom/IntersectionMatrix.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/util/IntArrayList.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/geomgraph/index/MonotoneChainIndexer.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/geomgraph/index/MonotoneChainEdge.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/geomgraph/Depth.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/geomgraph/Edge.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/operation/buffer/BufferBuilder.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/noding/ScaledNoder.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/noding/NodingValidator.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/noding/snapround/HotPixel.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/index/chain/MonotoneChainSelectAction.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/noding/snapround/MCIndexPointSnapper.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/noding/InteriorIntersectionFinderAdder.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/noding/snapround/MCIndexSnapRounder.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/operation/buffer/BufferOp.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/io/GeoJSONParser.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/src/index.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/io/GeoJSONReader.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/jsts/node_modules/jsts/org/locationtech/jts/io/GeoJSONWriter.js"],"sourcesContent":["export default class BufferParameters {\n  constructor() {\n    BufferParameters.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._quadrantSegments = BufferParameters.DEFAULT_QUADRANT_SEGMENTS\n    this._endCapStyle = BufferParameters.CAP_ROUND\n    this._joinStyle = BufferParameters.JOIN_ROUND\n    this._mitreLimit = BufferParameters.DEFAULT_MITRE_LIMIT\n    this._isSingleSided = false\n    this._simplifyFactor = BufferParameters.DEFAULT_SIMPLIFY_FACTOR\n    if (arguments.length === 0) {} else if (arguments.length === 1) {\n      const quadrantSegments = arguments[0]\n      this.setQuadrantSegments(quadrantSegments)\n    } else if (arguments.length === 2) {\n      const quadrantSegments = arguments[0], endCapStyle = arguments[1]\n      this.setQuadrantSegments(quadrantSegments)\n      this.setEndCapStyle(endCapStyle)\n    } else if (arguments.length === 4) {\n      const quadrantSegments = arguments[0], endCapStyle = arguments[1], joinStyle = arguments[2], mitreLimit = arguments[3]\n      this.setQuadrantSegments(quadrantSegments)\n      this.setEndCapStyle(endCapStyle)\n      this.setJoinStyle(joinStyle)\n      this.setMitreLimit(mitreLimit)\n    }\n  }\n  static bufferDistanceError(quadSegs) {\n    const alpha = Math.PI / 2.0 / quadSegs\n    return 1 - Math.cos(alpha / 2.0)\n  }\n  getEndCapStyle() {\n    return this._endCapStyle\n  }\n  isSingleSided() {\n    return this._isSingleSided\n  }\n  setQuadrantSegments(quadSegs) {\n    this._quadrantSegments = quadSegs\n    if (this._quadrantSegments === 0) this._joinStyle = BufferParameters.JOIN_BEVEL\n    if (this._quadrantSegments < 0) {\n      this._joinStyle = BufferParameters.JOIN_MITRE\n      this._mitreLimit = Math.abs(this._quadrantSegments)\n    }\n    if (quadSegs <= 0) \n      this._quadrantSegments = 1\n    \n    if (this._joinStyle !== BufferParameters.JOIN_ROUND) \n      this._quadrantSegments = BufferParameters.DEFAULT_QUADRANT_SEGMENTS\n    \n  }\n  getJoinStyle() {\n    return this._joinStyle\n  }\n  setJoinStyle(joinStyle) {\n    this._joinStyle = joinStyle\n  }\n  setSimplifyFactor(simplifyFactor) {\n    this._simplifyFactor = simplifyFactor < 0 ? 0 : simplifyFactor\n  }\n  getSimplifyFactor() {\n    return this._simplifyFactor\n  }\n  getQuadrantSegments() {\n    return this._quadrantSegments\n  }\n  setEndCapStyle(endCapStyle) {\n    this._endCapStyle = endCapStyle\n  }\n  getMitreLimit() {\n    return this._mitreLimit\n  }\n  setMitreLimit(mitreLimit) {\n    this._mitreLimit = mitreLimit\n  }\n  setSingleSided(isSingleSided) {\n    this._isSingleSided = isSingleSided\n  }\n}\nBufferParameters.CAP_ROUND = 1\nBufferParameters.CAP_FLAT = 2\nBufferParameters.CAP_SQUARE = 3\nBufferParameters.JOIN_ROUND = 1\nBufferParameters.JOIN_MITRE = 2\nBufferParameters.JOIN_BEVEL = 3\nBufferParameters.DEFAULT_QUADRANT_SEGMENTS = 8\nBufferParameters.DEFAULT_MITRE_LIMIT = 5.0\nBufferParameters.DEFAULT_SIMPLIFY_FACTOR = 0.01\n","export default class Exception extends Error {\n  constructor(message) {\n    super(message)\n    this.name = Object.keys({ Exception })[0]\n  }\n  toString() {\n    return this.message\n  }\n}\n","import Exception from './Exception'\n\nexport default class IllegalArgumentException extends Exception {\n  constructor(message) {\n    super(message)\n    this.name = Object.keys({ IllegalArgumentException })[0]\n  }\n}\n","export default class GeometryComponentFilter {\n  filter(geom) {}\n}\n","export default function Comparable() {}\n","export default function Clonable() {}\n","export default function Serializable() {}\n","import Long from './Long'\n\nexport default function Double() { }\n\nDouble.NaN = NaN\nDouble.isNaN = n => Number.isNaN(n)\nDouble.isInfinite = n => !Number.isFinite(n)\nDouble.MAX_VALUE = Number.MAX_VALUE\nDouble.POSITIVE_INFINITY = Number.POSITIVE_INFINITY\nDouble.NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY\n\nif (typeof Float64Array === 'function' &&\n  typeof Int32Array === 'function')\n// Simple and fast conversion between double and long bits\n// using TypedArrays and ArrayViewBuffers.\n\n  (function() {\n    const EXP_BIT_MASK = 0x7ff00000\n    const SIGNIF_BIT_MASK = 0xFFFFF\n    const f64buf = new Float64Array(1)\n    const i32buf = new Int32Array(f64buf.buffer)\n    Double.doubleToLongBits = function(value) {\n      f64buf[0] = value\n      let low = i32buf[0] | 0\n      let high = i32buf[1] | 0\n      // Check for NaN based on values of bit fields, maximum\n      // exponent and nonzero significand.\n      if (((high & EXP_BIT_MASK) === EXP_BIT_MASK) &&\n        ((high & SIGNIF_BIT_MASK) !== 0) &&\n        (low !== 0)) {\n        low = 0 | 0\n        high = 0x7ff80000 | 0\n      }\n      return new Long(high, low)\n    }\n    Double.longBitsToDouble = function(bits) {\n      i32buf[0] = bits.low\n      i32buf[1] = bits.high\n      return f64buf[0]\n    }\n  })()\nelse\n// More complex and slower fallback implementation using\n// math and the divide-by-two and multiply-by-two algorithms.\n\n  (function() {\n    const BIAS = 1023\n    const log2 = Math.log2\n    const floor = Math.floor\n    const pow = Math.pow\n    const MAX_REL_BITS_INTEGER = (function() {\n      for (let i = 53; i > 0; i--) {\n        const bits = pow(2, i) - 1\n        if (floor(log2(bits)) + 1 === i) return bits\n      }\n      return 0\n    })()\n    Double.doubleToLongBits = function(value) {\n      let x, y, f, bits, skip\n      let sign, exp, high, low\n\n      // Get the sign bit and absolute value.\n      if (value < 0 || 1 / value === Number.NEGATIVE_INFINITY) {\n        sign = (1 << 31)\n        value = (-value)\n      } else {\n        sign = 0\n      }\n\n      // Handle some special values.\n      if (value === 0) {\n        // Handle zeros (+/-0).\n        low = 0 | 0\n        high = sign // exponent: 00..00, significand: 00..00\n        return new Long(high, low)\n      }\n\n      if (value === Infinity) {\n        // Handle infinity (only positive values for value possible).\n        low = 0 | 0\n        high = sign | 0x7ff00000 // exponent: 11..11, significand: 00..00\n        return new Long(high, low)\n      }\n\n      if (value !== value) { // eslint-disable-line\n        // Handle NaNs (boiled down to only one distinct NaN).\n        low = 0 | 0\n        high = 0x7ff80000 // exponent: 11..11, significand: 10..00\n        return new Long(high, low)\n      }\n\n      // Preinitialize variables, that are not neccessarily set by\n      // the algorithm.\n      bits = 0\n      low = 0 | 0\n\n      // Get the (always positive) integer part of value.\n      x = floor(value)\n\n      // Process the integer part if it's greater than 1. Zero requires\n      // no bits at all, 1 represents the implicit (hidden) leading bit,\n      // which must not be written as well.\n      if (x > 1)\n      // If we can reliably determine the number of bits required for\n      // the integer part,\n\n        if (x <= MAX_REL_BITS_INTEGER) {\n          // get the number of bits required to represent it minus 1\n          bits = floor(log2(x)) /* + 1 - 1 */\n          // and simply copy/shift the integer bits into low and high.\n          // That's much faster than the divide-by-two algorithm (saves\n          // up to ~60%).\n          // We always need to mask out the most significant bit, which\n          // is the implicit (aka hidden) bit.\n          if (bits <= 20) {\n            // The simple case in which the integer fits into the\n            // lower 20 bits of the high word is worth to be handled\n            // separately (saves ~25%).\n            low = 0 | 0\n            high = (x << (20 - bits)) & 0xfffff\n          } else {\n            // Here, the integer part is split into low and high.\n            // Since its value may require more than 32 bits, we\n            // cannot use bitwise operators (which implicitly cast\n            // to Int32), but use arithmetic operators % and / to\n            // get low and high parts. The uppper 20 bits go to high,\n            // the remaining bits (in f) to low.\n            f = bits - 20\n            // Like (1 << f) but safe with even more than 32 bits.\n            y = pow(2, f)\n            low = (x % y) << (32 - f)\n            high = (x / y) & 0xfffff\n          }\n        } else {\n          // For greater values, we must use the much slower divide-by-two\n          // algorithm. Bits are generated from right to left, that is from\n          // least to most significant bit. For each bit, we left-shift both\n          // low and high by one and carry bit #0 from high to #31 in low.\n          // The next bit is then copied into bit #19 in high, the leftmost\n          // bit of the double's significand.\n\n          // Preserve x for later user, so work with f.\n          f = x\n          low = 0 | 0\n          for (;;) {\n            y = f / 2\n            f = floor(y)\n            if (f === 0)\n            // We just found the most signigicant (1-)bit, which\n            // is the implicit bit and so, not stored in the double\n            // value. So, it's time to leave the loop.\n              break\n\n            // Count this bit, shift low and carry bit #0 from high.\n            bits++\n            low >>>= 1\n            low |= (high & 0x1) << 31\n            // Shift high.\n            high >>>= 1\n            if (y !== f)\n            // Copy the new bit into bit #19 in high (only required if 1).\n              high |= 0x80000\n          }\n        }\n\n      // Bias the exponent.\n      exp = bits + BIAS\n\n      // If the integer part is zero, we've not yet seen the implicit\n      // leading bit. Variable skip is later used while processing the\n      // fractional part (if any).\n      skip = (x === 0)\n\n      // Get fraction only into x.\n      x = value - x\n\n      // If some significand bits are still left to be filled and\n      // the fractional part is not zero, convert the fraction using\n      // the multiply-by-2 algorithm.\n      if (bits < 52 && x !== 0) {\n        // Initialize 'buffer' f, into which newly created bits get\n        // shifted from right to left.\n        f = 0\n\n        for (;;) {\n          y = x * 2\n          if (y >= 1) {\n            // This is a new 1-bit. Add and count this bit, if not\n            // prohibited by skip.\n            x = y - 1\n            if (!skip) {\n              f <<= 1\n              f |= 1\n              bits++\n            } else {\n              // Otherwise, decrement the exponent and unset\n              // skip, so that all following bits get written.\n              exp--\n              skip = false\n            }\n          } else {\n            // This is a new 0-bit. Add and count this bit, if not\n            // prohibited by skip.\n            x = y\n            if (!skip) {\n              f <<= 1\n              bits++\n            } else if (--exp === 0) {\n              // Otherwise we've just decremented the exponent. If the\n              // biased exponent is zero now (-1023), we process a\n              // subnormal number, which has no impled leading 1-bit.\n              // So, count this 0-bit and unset skip to write out\n              // all the following bits.\n              bits++\n              skip = false\n            }\n          }\n          if (bits === 20) {\n            // When 20 bits have been created in total, we're done with\n            // the high word. Copy the bits from 'buffer' f into high\n            // and reset 'buffer' f. Following bits will end up in the\n            // low word.\n            high |= f\n            f = 0\n          } else if (bits === 52) {\n            // When 52 bits have been created in total, we're done with\n            // low word as well. Copy the bits from 'buffer' f into low\n            // and exit the loop.\n            low |= f\n            break\n          }\n          if (y === 1) {\n            // When y is exactly 1, there is no remainder and the process\n            // is complete (the number is finite). Copy the bits from\n            // 'buffer' f into either low or high and exit the loop.\n            if (bits < 20)\n              high |= (f << (20 - bits))\n            else if (bits < 52) low |= (f << (52 - bits))\n\n            break\n          }\n        }\n      }\n\n      // Copy/shift the exponent and sign bits into the high word.\n      high |= (exp << 20)\n      high |= sign\n\n      return new Long(high, low)\n    }\n    Double.longBitsToDouble = function(bits) {\n      let i\n      let x, exp, fract\n      const high = bits.high\n      const low = bits.low\n\n      // Extract the sign.\n      const sign = (high & (1 << 31)) ? -1 : 1\n\n      // Extract the unbiased exponent.\n      exp = ((high & 0x7ff00000) >> 20) - BIAS\n\n      // Calculate the fraction from left to right. Start\n      // off with the 20 lower bits from the high word.\n      fract = 0\n      x = (1 << 19)\n      for (i = 1; i <= 20; i++) {\n        if (high & x) fract += pow(2, -i)\n\n        x >>>= 1\n      }\n      // Continue with all 32 bits from the low word.\n      x = (1 << 31)\n      for (i = 21; i <= 52; i++) {\n        if (low & x) fract += pow(2, -i)\n\n        x >>>= 1\n      }\n\n      // Handle special values.\n      // Check for zero and subnormal values.\n      if (exp === -BIAS) {\n        if (fract === 0)\n        // +/-1.0 * 0.0 => +/-0.0\n          return sign * 0\n\n        exp = -1022\n      } else if (exp === BIAS + 1) { // Check for +/-Infinity or NaN.\n        if (fract === 0)\n        // +/-1.0 / 0.0 => +/-Infinity\n          return sign / 0\n\n        return NaN\n      } else { // Nothing special? Seems to be a normal number.\n        // Add the implicit leading bit (1*2^0).\n        fract += 1\n      }\n\n      return sign * fract * pow(2, exp)\n    }\n  })()\n","export default class NumberUtil {\n  static equalsWithTolerance(x1, x2, tolerance) {\n    return Math.abs(x1 - x2) <= tolerance\n  }\n}\n","export default class Long {\n  constructor(high, low) {\n    this.low = low || 0\n    this.high = high || 0\n  }\n\n  static toBinaryString(i) {\n    let mask\n    let result = ''\n    for (mask = 0x80000000; mask > 0; mask >>>= 1)\n      result += (i.high & mask) === mask ? '1' : '0'\n    for (mask = 0x80000000; mask > 0; mask >>>= 1)\n      result += (i.low & mask) === mask ? '1' : '0'\n    return result\n  }\n}\n","export default function Comparator() {}\n","import Exception from './Exception'\n\nexport default class RuntimeException extends Exception {\n  constructor(message) {\n    super(message)\n    this.name = Object.keys({ RuntimeException })[0]\n  }\n}\n","import RuntimeException from '../../../../java/lang/RuntimeException'\nexport default class AssertionFailedException extends RuntimeException {\n  constructor() {\n    super()\n    AssertionFailedException.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    if (arguments.length === 0) {\n      RuntimeException.constructor_.call(this)\n    } else if (arguments.length === 1) {\n      const message = arguments[0]\n      RuntimeException.constructor_.call(this, message)\n    }\n  }\n}\n","import AssertionFailedException from './AssertionFailedException'\nexport default class Assert {\n  static shouldNeverReachHere() {\n    if (arguments.length === 0) {\n      Assert.shouldNeverReachHere(null)\n    } else if (arguments.length === 1) {\n      const message = arguments[0]\n      throw new AssertionFailedException('Should never reach here' + (message !== null ? ': ' + message : ''))\n    }\n  }\n  static isTrue() {\n    if (arguments.length === 1) {\n      const assertion = arguments[0]\n      Assert.isTrue(assertion, null)\n    } else if (arguments.length === 2) {\n      const assertion = arguments[0], message = arguments[1]\n      if (!assertion) \n        if (message === null) \n          throw new AssertionFailedException()\n        else \n          throw new AssertionFailedException(message)\n        \n      \n    }\n  }\n  static equals() {\n    if (arguments.length === 2) {\n      const expectedValue = arguments[0], actualValue = arguments[1]\n      Assert.equals(expectedValue, actualValue, null)\n    } else if (arguments.length === 3) {\n      const expectedValue = arguments[0], actualValue = arguments[1], message = arguments[2]\n      if (!actualValue.equals(expectedValue)) \n        throw new AssertionFailedException('Expected ' + expectedValue + ' but encountered ' + actualValue + (message !== null ? ': ' + message : ''))\n      \n    }\n  }\n}\n","import NumberUtil from '../util/NumberUtil'\nimport IllegalArgumentException from '../../../../java/lang/IllegalArgumentException'\nimport Double from '../../../../java/lang/Double'\nimport Comparable from '../../../../java/lang/Comparable'\nimport Cloneable from '../../../../java/lang/Cloneable'\nimport Comparator from '../../../../java/util/Comparator'\nimport Serializable from '../../../../java/io/Serializable'\nimport Assert from '../util/Assert'\n\nconst kBuf = new ArrayBuffer(8)\nconst kBufAsF64 = new Float64Array(kBuf)\nconst kBufAsI32 = new Int32Array(kBuf)\n\nexport default class Coordinate {\n  constructor() {\n    Coordinate.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this.x = null\n    this.y = null\n    this.z = null\n    if (arguments.length === 0) {\n      Coordinate.constructor_.call(this, 0.0, 0.0)\n    } else if (arguments.length === 1) {\n      const c = arguments[0]\n      Coordinate.constructor_.call(this, c.x, c.y, c.getZ())\n    } else if (arguments.length === 2) {\n      const x = arguments[0], y = arguments[1]\n      Coordinate.constructor_.call(this, x, y, Coordinate.NULL_ORDINATE)\n    } else if (arguments.length === 3) {\n      const x = arguments[0], y = arguments[1], z = arguments[2]\n      this.x = x\n      this.y = y\n      this.z = z\n    }\n  }\n  static hashCode(n) {\n    kBufAsF64[0] = n\n    return kBufAsI32[0] ^ kBufAsI32[1]\n  }\n  getM() {\n    return Double.NaN\n  }\n  setOrdinate(ordinateIndex, value) {\n    switch (ordinateIndex) {\n    case Coordinate.X:\n      this.x = value\n      break\n    case Coordinate.Y:\n      this.y = value\n      break\n    case Coordinate.Z:\n      this.setZ(value)\n      break\n    default:\n      throw new IllegalArgumentException('Invalid ordinate index: ' + ordinateIndex)\n    }\n  }\n  equals2D() {\n    if (arguments.length === 1) {\n      const other = arguments[0]\n      if (this.x !== other.x) \n        return false\n      \n      if (this.y !== other.y) \n        return false\n      \n      return true\n    } else if (arguments.length === 2) {\n      const c = arguments[0], tolerance = arguments[1]\n      if (!NumberUtil.equalsWithTolerance(this.x, c.x, tolerance)) \n        return false\n      \n      if (!NumberUtil.equalsWithTolerance(this.y, c.y, tolerance)) \n        return false\n      \n      return true\n    }\n  }\n  setM(m) {\n    throw new IllegalArgumentException('Invalid ordinate index: ' + Coordinate.M)\n  }\n  getZ() {\n    return this.z\n  }\n  getOrdinate(ordinateIndex) {\n    switch (ordinateIndex) {\n    case Coordinate.X:\n      return this.x\n    case Coordinate.Y:\n      return this.y\n    case Coordinate.Z:\n      return this.getZ()\n    }\n    throw new IllegalArgumentException('Invalid ordinate index: ' + ordinateIndex)\n  }\n  equals3D(other) {\n    return this.x === other.x && this.y === other.y && (this.getZ() === other.getZ() || Double.isNaN(this.getZ()) && Double.isNaN(other.getZ()))\n  }\n  equals(other) {\n    if (!(other instanceof Coordinate)) \n      return false\n    \n    return this.equals2D(other)\n  }\n  equalInZ(c, tolerance) {\n    return NumberUtil.equalsWithTolerance(this.getZ(), c.getZ(), tolerance)\n  }\n  setX(x) {\n    this.x = x\n  }\n  compareTo(o) {\n    const other = o\n    if (this.x < other.x) return -1\n    if (this.x > other.x) return 1\n    if (this.y < other.y) return -1\n    if (this.y > other.y) return 1\n    return 0\n  }\n  getX() {\n    return this.x\n  }\n  setZ(z) {\n    this.z = z\n  }\n  clone() {\n    try {\n      const coord = null\n      return coord\n    } catch (e) {\n      if (e instanceof CloneNotSupportedException) {\n        Assert.shouldNeverReachHere('this shouldn\\'t happen because this class is Cloneable')\n        return null\n      } else {\n        throw e\n      }\n    } finally {}\n  }\n  copy() {\n    return new Coordinate(this)\n  }\n  toString() {\n    return '(' + this.x + ', ' + this.y + ', ' + this.getZ() + ')'\n  }\n  distance3D(c) {\n    const dx = this.x - c.x\n    const dy = this.y - c.y\n    const dz = this.getZ() - c.getZ()\n    return Math.sqrt(dx * dx + dy * dy + dz * dz)\n  }\n  getY() {\n    return this.y\n  }\n  setY(y) {\n    this.y = y\n  }\n  distance(c) {\n    const dx = this.x - c.x\n    const dy = this.y - c.y\n    return Math.sqrt(dx * dx + dy * dy)\n  }\n  hashCode() {\n    let result = 17\n    result = 37 * result + Coordinate.hashCode(this.x)\n    result = 37 * result + Coordinate.hashCode(this.y)\n    return result\n  }\n  setCoordinate(other) {\n    this.x = other.x\n    this.y = other.y\n    this.z = other.getZ()\n  }\n  get interfaces_() {\n    return [Comparable, Cloneable, Serializable]\n  }\n}\nclass DimensionalComparator {\n  constructor() {\n    DimensionalComparator.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._dimensionsToTest = 2\n    if (arguments.length === 0) {\n      DimensionalComparator.constructor_.call(this, 2)\n    } else if (arguments.length === 1) {\n      const dimensionsToTest = arguments[0]\n      if (dimensionsToTest !== 2 && dimensionsToTest !== 3) throw new IllegalArgumentException('only 2 or 3 dimensions may be specified')\n      this._dimensionsToTest = dimensionsToTest\n    }\n  }\n  static compare(a, b) {\n    if (a < b) return -1\n    if (a > b) return 1\n    if (Double.isNaN(a)) {\n      if (Double.isNaN(b)) return 0\n      return -1\n    }\n    if (Double.isNaN(b)) return 1\n    return 0\n  }\n  compare(c1, c2) {\n    const compX = DimensionalComparator.compare(c1.x, c2.x)\n    if (compX !== 0) return compX\n    const compY = DimensionalComparator.compare(c1.y, c2.y)\n    if (compY !== 0) return compY\n    if (this._dimensionsToTest <= 2) return 0\n    const compZ = DimensionalComparator.compare(c1.getZ(), c2.getZ())\n    return compZ\n  }\n  get interfaces_() {\n    return [Comparator]\n  }\n}\nCoordinate.DimensionalComparator = DimensionalComparator\nCoordinate.NULL_ORDINATE = Double.NaN\nCoordinate.X = 0\nCoordinate.Y = 1\nCoordinate.Z = 2\nCoordinate.M = 3\n","import Coordinate from './Coordinate'\nimport Comparable from '../../../../java/lang/Comparable'\nimport Serializable from '../../../../java/io/Serializable'\nexport default class Envelope {\n  constructor() {\n    Envelope.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._minx = null\n    this._maxx = null\n    this._miny = null\n    this._maxy = null\n    if (arguments.length === 0) {\n      this.init()\n    } else if (arguments.length === 1) {\n      if (arguments[0] instanceof Coordinate) {\n        const p = arguments[0]\n        this.init(p.x, p.x, p.y, p.y)\n      } else if (arguments[0] instanceof Envelope) {\n        const env = arguments[0]\n        this.init(env)\n      }\n    } else if (arguments.length === 2) {\n      const p1 = arguments[0], p2 = arguments[1]\n      this.init(p1.x, p2.x, p1.y, p2.y)\n    } else if (arguments.length === 4) {\n      const x1 = arguments[0], x2 = arguments[1], y1 = arguments[2], y2 = arguments[3]\n      this.init(x1, x2, y1, y2)\n    }\n  }\n  static intersects() {\n    if (arguments.length === 3) {\n      const p1 = arguments[0], p2 = arguments[1], q = arguments[2]\n      if (q.x >= (p1.x < p2.x ? p1.x : p2.x) && q.x <= (p1.x > p2.x ? p1.x : p2.x) && (q.y >= (p1.y < p2.y ? p1.y : p2.y) && q.y <= (p1.y > p2.y ? p1.y : p2.y))) \n        return true\n      \n      return false\n    } else if (arguments.length === 4) {\n      const p1 = arguments[0], p2 = arguments[1], q1 = arguments[2], q2 = arguments[3]\n      let minq = Math.min(q1.x, q2.x)\n      let maxq = Math.max(q1.x, q2.x)\n      let minp = Math.min(p1.x, p2.x)\n      let maxp = Math.max(p1.x, p2.x)\n      if (minp > maxq) return false\n      if (maxp < minq) return false\n      minq = Math.min(q1.y, q2.y)\n      maxq = Math.max(q1.y, q2.y)\n      minp = Math.min(p1.y, p2.y)\n      maxp = Math.max(p1.y, p2.y)\n      if (minp > maxq) return false\n      if (maxp < minq) return false\n      return true\n    }\n  }\n  getArea() {\n    return this.getWidth() * this.getHeight()\n  }\n  equals(other) {\n    if (!(other instanceof Envelope)) \n      return false\n    \n    const otherEnvelope = other\n    if (this.isNull()) \n      return otherEnvelope.isNull()\n    \n    return this._maxx === otherEnvelope.getMaxX() && this._maxy === otherEnvelope.getMaxY() && this._minx === otherEnvelope.getMinX() && this._miny === otherEnvelope.getMinY()\n  }\n  intersection(env) {\n    if (this.isNull() || env.isNull() || !this.intersects(env)) return new Envelope()\n    const intMinX = this._minx > env._minx ? this._minx : env._minx\n    const intMinY = this._miny > env._miny ? this._miny : env._miny\n    const intMaxX = this._maxx < env._maxx ? this._maxx : env._maxx\n    const intMaxY = this._maxy < env._maxy ? this._maxy : env._maxy\n    return new Envelope(intMinX, intMaxX, intMinY, intMaxY)\n  }\n  isNull() {\n    return this._maxx < this._minx\n  }\n  getMaxX() {\n    return this._maxx\n  }\n  covers() {\n    if (arguments.length === 1) {\n      if (arguments[0] instanceof Coordinate) {\n        const p = arguments[0]\n        return this.covers(p.x, p.y)\n      } else if (arguments[0] instanceof Envelope) {\n        const other = arguments[0]\n        if (this.isNull() || other.isNull()) \n          return false\n        \n        return other.getMinX() >= this._minx && other.getMaxX() <= this._maxx && other.getMinY() >= this._miny && other.getMaxY() <= this._maxy\n      }\n    } else if (arguments.length === 2) {\n      const x = arguments[0], y = arguments[1]\n      if (this.isNull()) return false\n      return x >= this._minx && x <= this._maxx && y >= this._miny && y <= this._maxy\n    }\n  }\n  intersects() {\n    if (arguments.length === 1) {\n      if (arguments[0] instanceof Envelope) {\n        const other = arguments[0]\n        if (this.isNull() || other.isNull()) \n          return false\n        \n        return !(other._minx > this._maxx || other._maxx < this._minx || other._miny > this._maxy || other._maxy < this._miny)\n      } else if (arguments[0] instanceof Coordinate) {\n        const p = arguments[0]\n        return this.intersects(p.x, p.y)\n      }\n    } else if (arguments.length === 2) {\n      if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {\n        const a = arguments[0], b = arguments[1]\n        if (this.isNull()) \n          return false\n        \n        const envminx = a.x < b.x ? a.x : b.x\n        if (envminx > this._maxx) return false\n        const envmaxx = a.x > b.x ? a.x : b.x\n        if (envmaxx < this._minx) return false\n        const envminy = a.y < b.y ? a.y : b.y\n        if (envminy > this._maxy) return false\n        const envmaxy = a.y > b.y ? a.y : b.y\n        if (envmaxy < this._miny) return false\n        return true\n      } else if (typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {\n        const x = arguments[0], y = arguments[1]\n        if (this.isNull()) return false\n        return !(x > this._maxx || x < this._minx || y > this._maxy || y < this._miny)\n      }\n    }\n  }\n  getMinY() {\n    return this._miny\n  }\n  getDiameter() {\n    if (this.isNull()) \n      return 0\n    \n    const w = this.getWidth()\n    const h = this.getHeight()\n    return Math.sqrt(w * w + h * h)\n  }\n  getMinX() {\n    return this._minx\n  }\n  expandToInclude() {\n    if (arguments.length === 1) {\n      if (arguments[0] instanceof Coordinate) {\n        const p = arguments[0]\n        this.expandToInclude(p.x, p.y)\n      } else if (arguments[0] instanceof Envelope) {\n        const other = arguments[0]\n        if (other.isNull()) \n          return null\n        \n        if (this.isNull()) {\n          this._minx = other.getMinX()\n          this._maxx = other.getMaxX()\n          this._miny = other.getMinY()\n          this._maxy = other.getMaxY()\n        } else {\n          if (other._minx < this._minx) \n            this._minx = other._minx\n          \n          if (other._maxx > this._maxx) \n            this._maxx = other._maxx\n          \n          if (other._miny < this._miny) \n            this._miny = other._miny\n          \n          if (other._maxy > this._maxy) \n            this._maxy = other._maxy\n          \n        }\n      }\n    } else if (arguments.length === 2) {\n      const x = arguments[0], y = arguments[1]\n      if (this.isNull()) {\n        this._minx = x\n        this._maxx = x\n        this._miny = y\n        this._maxy = y\n      } else {\n        if (x < this._minx) \n          this._minx = x\n        \n        if (x > this._maxx) \n          this._maxx = x\n        \n        if (y < this._miny) \n          this._miny = y\n        \n        if (y > this._maxy) \n          this._maxy = y\n        \n      }\n    }\n  }\n  minExtent() {\n    if (this.isNull()) return 0.0\n    const w = this.getWidth()\n    const h = this.getHeight()\n    if (w < h) return w\n    return h\n  }\n  getWidth() {\n    if (this.isNull()) \n      return 0\n    \n    return this._maxx - this._minx\n  }\n  compareTo(o) {\n    const env = o\n    if (this.isNull()) {\n      if (env.isNull()) return 0\n      return -1\n    } else {\n      if (env.isNull()) return 1\n    }\n    if (this._minx < env._minx) return -1\n    if (this._minx > env._minx) return 1\n    if (this._miny < env._miny) return -1\n    if (this._miny > env._miny) return 1\n    if (this._maxx < env._maxx) return -1\n    if (this._maxx > env._maxx) return 1\n    if (this._maxy < env._maxy) return -1\n    if (this._maxy > env._maxy) return 1\n    return 0\n  }\n  translate(transX, transY) {\n    if (this.isNull()) \n      return null\n    \n    this.init(this.getMinX() + transX, this.getMaxX() + transX, this.getMinY() + transY, this.getMaxY() + transY)\n  }\n  copy() {\n    return new Envelope(this)\n  }\n  toString() {\n    return 'Env[' + this._minx + ' : ' + this._maxx + ', ' + this._miny + ' : ' + this._maxy + ']'\n  }\n  setToNull() {\n    this._minx = 0\n    this._maxx = -1\n    this._miny = 0\n    this._maxy = -1\n  }\n  disjoint(other) {\n    if (this.isNull() || other.isNull()) \n      return true\n    \n    return other._minx > this._maxx || other._maxx < this._minx || other._miny > this._maxy || other._maxy < this._miny\n  }\n  getHeight() {\n    if (this.isNull()) \n      return 0\n    \n    return this._maxy - this._miny\n  }\n  maxExtent() {\n    if (this.isNull()) return 0.0\n    const w = this.getWidth()\n    const h = this.getHeight()\n    if (w > h) return w\n    return h\n  }\n  expandBy() {\n    if (arguments.length === 1) {\n      const distance = arguments[0]\n      this.expandBy(distance, distance)\n    } else if (arguments.length === 2) {\n      const deltaX = arguments[0], deltaY = arguments[1]\n      if (this.isNull()) return null\n      this._minx -= deltaX\n      this._maxx += deltaX\n      this._miny -= deltaY\n      this._maxy += deltaY\n      if (this._minx > this._maxx || this._miny > this._maxy) this.setToNull()\n    }\n  }\n  contains() {\n    if (arguments.length === 1) {\n      if (arguments[0] instanceof Envelope) {\n        const other = arguments[0]\n        return this.covers(other)\n      } else if (arguments[0] instanceof Coordinate) {\n        const p = arguments[0]\n        return this.covers(p)\n      }\n    } else if (arguments.length === 2) {\n      const x = arguments[0], y = arguments[1]\n      return this.covers(x, y)\n    }\n  }\n  centre() {\n    if (this.isNull()) return null\n    return new Coordinate((this.getMinX() + this.getMaxX()) / 2.0, (this.getMinY() + this.getMaxY()) / 2.0)\n  }\n  init() {\n    if (arguments.length === 0) {\n      this.setToNull()\n    } else if (arguments.length === 1) {\n      if (arguments[0] instanceof Coordinate) {\n        const p = arguments[0]\n        this.init(p.x, p.x, p.y, p.y)\n      } else if (arguments[0] instanceof Envelope) {\n        const env = arguments[0]\n        this._minx = env._minx\n        this._maxx = env._maxx\n        this._miny = env._miny\n        this._maxy = env._maxy\n      }\n    } else if (arguments.length === 2) {\n      const p1 = arguments[0], p2 = arguments[1]\n      this.init(p1.x, p2.x, p1.y, p2.y)\n    } else if (arguments.length === 4) {\n      const x1 = arguments[0], x2 = arguments[1], y1 = arguments[2], y2 = arguments[3]\n      if (x1 < x2) {\n        this._minx = x1\n        this._maxx = x2\n      } else {\n        this._minx = x2\n        this._maxx = x1\n      }\n      if (y1 < y2) {\n        this._miny = y1\n        this._maxy = y2\n      } else {\n        this._miny = y2\n        this._maxy = y1\n      }\n    }\n  }\n  getMaxY() {\n    return this._maxy\n  }\n  distance(env) {\n    if (this.intersects(env)) return 0\n    let dx = 0.0\n    if (this._maxx < env._minx) dx = env._minx - this._maxx; else if (this._minx > env._maxx) dx = this._minx - env._maxx\n    let dy = 0.0\n    if (this._maxy < env._miny) dy = env._miny - this._maxy; else if (this._miny > env._maxy) dy = this._miny - env._maxy\n    if (dx === 0.0) return dy\n    if (dy === 0.0) return dx\n    return Math.sqrt(dx * dx + dy * dy)\n  }\n  hashCode() {\n    let result = 17\n    result = 37 * result + Coordinate.hashCode(this._minx)\n    result = 37 * result + Coordinate.hashCode(this._maxx)\n    result = 37 * result + Coordinate.hashCode(this._miny)\n    result = 37 * result + Coordinate.hashCode(this._maxy)\n    return result\n  }\n  get interfaces_() {\n    return [Comparable, Serializable]\n  }\n}\n","import IllegalArgumentException from '../../../../java/lang/IllegalArgumentException'\nimport GeometryComponentFilter from './GeometryComponentFilter'\nimport Comparable from '../../../../java/lang/Comparable'\nimport Cloneable from '../../../../java/lang/Cloneable'\nimport Serializable from '../../../../java/io/Serializable'\nimport Envelope from './Envelope'\nexport default class Geometry {\n  constructor() {\n    Geometry.constructor_.apply(this, arguments)\n  }\n\n  isGeometryCollection() {\n    return this.getTypeCode() === Geometry.TYPECODE_GEOMETRYCOLLECTION\n  }\n\n  getFactory() {\n    return this._factory\n  }\n\n  getGeometryN(n) {\n    return this\n  }\n\n  getArea() {\n    return 0.0\n  }\n\n  isRectangle() {\n    return false\n  }\n\n  equalsExact(other) {\n    return this === other || this.equalsExact(other, 0)\n  }\n\n  geometryChanged() {\n    this.apply(Geometry.geometryChangedFilter)\n  }\n\n  geometryChangedAction() {\n    this._envelope = null\n  }\n\n  equalsNorm(g) {\n    if (g === null) return false\n    return this.norm().equalsExact(g.norm())\n  }\n\n  getLength() {\n    return 0.0\n  }\n\n  getNumGeometries() {\n    return 1\n  }\n\n  compareTo() {\n    let other\n    if (arguments.length === 1) {\n      const o = arguments[0]\n      other = o\n      if (this.getTypeCode() !== other.getTypeCode()) return this.getTypeCode() - other.getTypeCode()\n\n      if (this.isEmpty() && other.isEmpty()) return 0\n\n      if (this.isEmpty()) return -1\n\n      if (other.isEmpty()) return 1\n\n      return this.compareToSameClass(o)\n    } else if (arguments.length === 2) {\n      const o = arguments[0]; const comp = arguments[1]\n      other = o\n      if (this.getTypeCode() !== other.getTypeCode()) return this.getTypeCode() - other.getTypeCode()\n\n      if (this.isEmpty() && other.isEmpty()) return 0\n\n      if (this.isEmpty()) return -1\n\n      if (other.isEmpty()) return 1\n\n      return this.compareToSameClass(o, comp)\n    }\n  }\n\n  getUserData() {\n    return this._userData\n  }\n\n  getSRID() {\n    return this._SRID\n  }\n\n  getEnvelope() {\n    return this.getFactory().toGeometry(this.getEnvelopeInternal())\n  }\n\n  checkNotGeometryCollection(g) {\n    if (g.getTypeCode() === Geometry.TYPECODE_GEOMETRYCOLLECTION) throw new IllegalArgumentException('This method does not support GeometryCollection arguments')\n  }\n\n  equal(a, b, tolerance) {\n    if (tolerance === 0) return a.equals(b)\n\n    return a.distance(b) <= tolerance\n  }\n\n  norm() {\n    const copy = this.copy()\n    copy.normalize()\n    return copy\n  }\n\n  reverse() {\n    const res = this.reverseInternal()\n    if (this.envelope != null) res.envelope = this.envelope.copy()\n\n    res.setSRID(this.getSRID())\n    return res\n  }\n\n  copy() {\n    const copy = this.copyInternal()\n    copy.envelope = this._envelope == null ? null : this._envelope.copy()\n    copy._SRID = this._SRID\n    copy._userData = this._userData\n    return copy\n  }\n\n  getPrecisionModel() {\n    return this._factory.getPrecisionModel()\n  }\n\n  getEnvelopeInternal() {\n    if (this._envelope === null) this._envelope = this.computeEnvelopeInternal()\n\n    return new Envelope(this._envelope)\n  }\n\n  setSRID(SRID) {\n    this._SRID = SRID\n  }\n\n  setUserData(userData) {\n    this._userData = userData\n  }\n\n  compare(a, b) {\n    const i = a.iterator()\n    const j = b.iterator()\n    while (i.hasNext() && j.hasNext()) {\n      const aElement = i.next()\n      const bElement = j.next()\n      const comparison = aElement.compareTo(bElement)\n      if (comparison !== 0) return comparison\n    }\n    if (i.hasNext()) return 1\n\n    if (j.hasNext()) return -1\n\n    return 0\n  }\n\n  hashCode() {\n    return this.getEnvelopeInternal().hashCode()\n  }\n\n  isEquivalentClass(other) {\n    return this.getClass() === other.getClass()\n  }\n\n  isGeometryCollectionOrDerived() {\n    if (this.getTypeCode() === Geometry.TYPECODE_GEOMETRYCOLLECTION || this.getTypeCode() === Geometry.TYPECODE_MULTIPOINT || this.getTypeCode() === Geometry.TYPECODE_MULTILINESTRING || this.getTypeCode() === Geometry.TYPECODE_MULTIPOLYGON) return true\n\n    return false\n  }\n\n  get interfaces_() {\n    return [Cloneable, Comparable, Serializable]\n  }\n\n  getClass() {\n    return Geometry\n  }\n\n  static hasNonEmptyElements(geometries) {\n    for (let i = 0; i < geometries.length; i++)\n      if (!geometries[i].isEmpty()) return true\n\n    return false\n  }\n\n  static hasNullElements(array) {\n    for (let i = 0; i < array.length; i++)\n      if (array[i] === null) return true\n\n    return false\n  }\n}\nGeometry.constructor_ = function(factory) {\n  if (!factory) return\n  this._envelope = null\n  this._userData = null\n  this._factory = factory\n  this._SRID = factory.getSRID()\n}\nGeometry.TYPECODE_POINT = 0\nGeometry.TYPECODE_MULTIPOINT = 1\nGeometry.TYPECODE_LINESTRING = 2\nGeometry.TYPECODE_LINEARRING = 3\nGeometry.TYPECODE_MULTILINESTRING = 4\nGeometry.TYPECODE_POLYGON = 5\nGeometry.TYPECODE_MULTIPOLYGON = 6\nGeometry.TYPECODE_GEOMETRYCOLLECTION = 7\nGeometry.TYPENAME_POINT = 'Point'\nGeometry.TYPENAME_MULTIPOINT = 'MultiPoint'\nGeometry.TYPENAME_LINESTRING = 'LineString'\nGeometry.TYPENAME_LINEARRING = 'LinearRing'\nGeometry.TYPENAME_MULTILINESTRING = 'MultiLineString'\nGeometry.TYPENAME_POLYGON = 'Polygon'\nGeometry.TYPENAME_MULTIPOLYGON = 'MultiPolygon'\nGeometry.TYPENAME_GEOMETRYCOLLECTION = 'GeometryCollection'\nGeometry.geometryChangedFilter = {\n  get interfaces_() {\n    return [GeometryComponentFilter]\n  },\n  filter(geom) {\n    geom.geometryChangedAction()\n  }\n}\n","import IllegalArgumentException from '../../../../java/lang/IllegalArgumentException'\nexport default class Location {\n  static toLocationSymbol(locationValue) {\n    switch (locationValue) {\n    case Location.EXTERIOR:\n      return 'e'\n    case Location.BOUNDARY:\n      return 'b'\n    case Location.INTERIOR:\n      return 'i'\n    case Location.NONE:\n      return '-'\n    }\n    throw new IllegalArgumentException('Unknown location value: ' + locationValue)\n  }\n}\nLocation.INTERIOR = 0\nLocation.BOUNDARY = 1\nLocation.EXTERIOR = 2\nLocation.NONE = -1\n","/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/Collection.html\n */\nexport default class Collection {\n  /**\n     * Ensures that this collection contains the specified element (optional\n     * operation).\n     * @param {Object} e\n     * @return {boolean}\n     */\n  add() { }\n  /**\n     * Appends all of the elements in the specified collection to the end of this\n     * list, in the order that they are returned by the specified collection's\n     * iterator (optional operation).\n     * @param {javascript.util.Collection} c\n     * @return {boolean}\n     */\n  addAll() { }\n  /**\n     * Returns true if this collection contains no elements.\n     * @return {boolean}\n     */\n  isEmpty() { }\n  /**\n     * Returns an iterator over the elements in this collection.\n     * @return {javascript.util.Iterator}\n     */\n  iterator() { }\n  /**\n     * Returns an iterator over the elements in this collection.\n     * @return {number}\n     */\n  size() { }\n  /**\n     * Returns an array containing all of the elements in this collection.\n     * @return {Array}\n     */\n  toArray() { }\n  /**\n     * Removes a single instance of the specified element from this collection if it\n     * is present. (optional)\n     * @param {Object} e\n     * @return {boolean}\n     */\n  remove() { }\n}\n","import Exception from '../lang/Exception'\n\nexport default class NoSuchElementException extends Exception {\n  constructor(message) {\n    super(message)\n    this.name = Object.keys({ NoSuchElementException })[0]\n  }\n}","import Exception from './Exception'\n\nexport default class UnsupportedOperationException extends Exception {\n  constructor(message) {\n    super(message)\n    this.name = Object.keys({ UnsupportedOperationException })[0]\n  }\n}\n","import Collection from './Collection'\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/Set.html\n *\n * @extends {Collection}\n * @constructor\n * @private\n */\nexport default class Set extends Collection {\n  /**\n   * Returns true if this set contains the specified element. More formally,\n   * returns true if and only if this set contains an element e such that (o==null ?\n   * e==null : o.equals(e)).\n   * @param {Object} e\n   * @return {boolean}\n   */\n  contains() { }\n}\n","import Collection from './Collection'\nimport NoSuchElementException from './NoSuchElementException'\nimport UnsupportedOperationException from '../lang/UnsupportedOperationException'\nimport Set from './Set'\n\n/**\n * @see http://docs.oracle.com/javase/6/docs/api/java/util/HashSet.html\n */\nexport default class HashSet extends Set {\n  constructor(o) {\n    super()\n    this.map = new Map()\n    if (o instanceof Collection)\n      this.addAll(o)\n  }\n\n  contains(o) {\n    const hashCode = o.hashCode ? o.hashCode() : o\n    if (this.map.has(hashCode))\n      return true\n    return false\n  }\n\n  add(o) {\n    const hashCode = o.hashCode ? o.hashCode() : o\n    if (this.map.has(hashCode))\n      return false\n    return !!this.map.set(hashCode, o)\n  }\n\n  addAll(c) {\n    for (const e of c)\n      this.add(e)\n    return true\n  }\n\n  remove() {\n    throw new UnsupportedOperationException()\n  }\n\n  size() {\n    return this.map.size\n  }\n\n  isEmpty() {\n    return this.map.size === 0\n  }\n\n  toArray() {\n    return Array.from(this.map.values())\n  }\n\n  iterator() {\n    return new Iterator(this.map)\n  }\n\n  [Symbol.iterator]() {\n    return this.map\n  }\n}\n\nclass Iterator {\n  constructor(map) {\n    this.iterator = map.values()\n    const { done, value } = this.iterator.next()\n    this.done = done\n    this.value = value\n  }\n\n  next() {\n    if (this.done)\n      throw new NoSuchElementException()\n    const current = this.value\n    const { done, value } = this.iterator.next()\n    this.done = done\n    this.value = value\n    return current\n  }\n\n  hasNext() {\n    return !this.done\n  }\n\n  remove() {\n    throw new UnsupportedOperationException()\n  }\n}\n","export default class Position {\n  static opposite(position) {\n    if (position === Position.LEFT) return Position.RIGHT\n    if (position === Position.RIGHT) return Position.LEFT\n    return position\n  }\n}\nPosition.ON = 0\nPosition.LEFT = 1\nPosition.RIGHT = 2\n","import Exception from '../lang/Exception'\n\nexport default class EmptyStackException extends Exception {\n  constructor(message) {\n    super(message)\n    this.name = Object.keys({ EmptyStackException })[0]\n  }\n}\n","import Exception from './Exception'\n\nexport default class IndexOutOfBoundsException extends Exception {\n  constructor(message) {\n    super(message)\n    this.name = Object.keys({ IndexOutOfBoundsException })[0]\n  } \n}","import Collection from './Collection'\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/List.html\n */\nexport default class List extends Collection {\n  /**\n     * Returns the element at the specified position in this list.\n     * @param {number} index\n     * @return {Object}\n     */\n  get() { }\n  /**\n     * Replaces the element at the specified position in this list with the\n     * specified element (optional operation).\n     * @param {number} index\n     * @param {Object} e\n     * @return {Object}\n     */\n  set() { }\n  /**\n     * Returns true if this collection contains no elements.\n     * @return {boolean}\n     */\n  isEmpty() { }\n}\n","import EmptyStackException from './EmptyStackException'\nimport IndexOutOfBoundsException from '../lang/IndexOutOfBoundsException'\nimport List from './List'\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/Stack.html\n */\nexport default class Stack extends List {\n  constructor() {\n    super()\n    this.array = []\n  }\n\n  add(e) {\n    this.array.push(e)\n    return true\n  }\n\n  get(index) {\n    if (index < 0 || index >= this.size())\n      throw new IndexOutOfBoundsException()\n    return this.array[index]\n  }\n\n  /**\n   * Pushes an item onto the top of this stack.\n   * @param {Object} e\n   * @return {Object}\n   */\n  push(e) {\n    this.array.push(e)\n    return e\n  }\n\n  /**\n   * Removes the object at the top of this stack and returns that object as the value of this function.\n   * @return {Object}\n   */\n  pop() {\n    if (this.array.length === 0)\n      throw new EmptyStackException()\n    return this.array.pop()\n  }\n\n  /**\n   * Looks at the object at the top of this stack without removing it from the\n   * stack.\n   * @return {Object}\n   */\n  peek() {\n    if (this.array.length === 0)\n      throw new EmptyStackException()\n    return this.array[this.array.length - 1]\n  }\n\n  /**\n   * Tests if this stack is empty.\n   * @return {boolean} true if and only if this stack contains no items; false\n   *         otherwise.\n   */\n  empty() {\n    return this.array.length === 0\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isEmpty() {\n    return this.empty()\n  }\n\n  /**\n   * Returns the 1-based position where an object is on this stack. If the object\n   * o occurs as an item in this stack, this method returns the distance from the\n   * top of the stack of the occurrence nearest the top of the stack; the topmost\n   * item on the stack is considered to be at distance 1. The equals method is\n   * used to compare o to the items in this stack.\n   *\n   * NOTE: does not currently actually use equals. (=== is used)\n   *\n   * @param {Object} o\n   * @return {number} the 1-based position from the top of the stack where the\n   *         object is located; the return value -1 indicates that the object is\n   *         not on the stack.\n   */\n  search(o) {\n    return this.array.indexOf(o)\n  }\n\n  /**\n   * @return {number}\n   */\n  size() {\n    return this.array.length\n  }\n\n  /**\n   * @return {Array}\n   */\n  toArray() {\n    return this.array.slice()\n  }\n}\n","export default function(o, i) {\n  return o.interfaces_ && o.interfaces_.indexOf(i) > -1\n}\n","export default class StringBuffer {\n  constructor(str) {\n    this.str = str\n  }\n  append(e) {\n    this.str += e\n  }\n  setCharAt(i, c) {\n    this.str = this.str.substr(0, i) + c + this.str.substr(i + 1)\n  }\n  toString() {\n    return this.str\n  }\n}","export default class Integer {\n  constructor(value) {\n    this.value = value\n  }\n\n  intValue() {\n    return this.value\n  }\n\n  compareTo(o) {\n    if (this.value < o)\n      return -1\n    if (this.value > o)\n      return 1\n    return 0\n  }\n\n  static compare(x, y) {\n    if (x < y)\n      return -1\n    if (x > y)\n      return 1\n    return 0\n  }\n\n  static isNan(n) {\n    return Number.isNaN(n)\n  }\n\n  static valueOf(value) {\n    return new Integer(value)\n  }\n}\n","export default class Character {\n  static isWhitespace(c) {\n    return ((c <= 32 && c >= 0) || c === 127)\n  }\n\n  static toUpperCase(c) {\n    return c.toUpperCase()\n  }\n}\n","import StringBuffer from '../../../../java/lang/StringBuffer'\nimport Double from '../../../../java/lang/Double'\nimport Integer from '../../../../java/lang/Integer'\nimport Character from '../../../../java/lang/Character'\nimport Comparable from '../../../../java/lang/Comparable'\nimport Cloneable from '../../../../java/lang/Cloneable'\nimport Serializable from '../../../../java/io/Serializable'\nexport default class DD {\n  constructor() {\n    DD.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._hi = 0.0\n    this._lo = 0.0\n    if (arguments.length === 0) {\n      this.init(0.0)\n    } else if (arguments.length === 1) {\n      if (typeof arguments[0] === 'number') {\n        const x = arguments[0]\n        this.init(x)\n      } else if (arguments[0] instanceof DD) {\n        const dd = arguments[0]\n        this.init(dd)\n      } else if (typeof arguments[0] === 'string') {\n        const str = arguments[0]\n        DD.constructor_.call(this, DD.parse(str))\n      }\n    } else if (arguments.length === 2) {\n      const hi = arguments[0], lo = arguments[1]\n      this.init(hi, lo)\n    }\n  }\n  static determinant() {\n    if (typeof arguments[3] === 'number' && (typeof arguments[2] === 'number' && (typeof arguments[0] === 'number' && typeof arguments[1] === 'number'))) {\n      const x1 = arguments[0], y1 = arguments[1], x2 = arguments[2], y2 = arguments[3]\n      return DD.determinant(DD.valueOf(x1), DD.valueOf(y1), DD.valueOf(x2), DD.valueOf(y2))\n    } else if (arguments[3] instanceof DD && (arguments[2] instanceof DD && (arguments[0] instanceof DD && arguments[1] instanceof DD))) {\n      const x1 = arguments[0], y1 = arguments[1], x2 = arguments[2], y2 = arguments[3]\n      const det = x1.multiply(y2).selfSubtract(y1.multiply(x2))\n      return det\n    }\n  }\n  static sqr(x) {\n    return DD.valueOf(x).selfMultiply(x)\n  }\n  static valueOf() {\n    if (typeof arguments[0] === 'string') {\n      const str = arguments[0]\n      return DD.parse(str)\n    } else if (typeof arguments[0] === 'number') {\n      const x = arguments[0]\n      return new DD(x)\n    }\n  }\n  static sqrt(x) {\n    return DD.valueOf(x).sqrt()\n  }\n  static parse(str) {\n    let i = 0\n    const strlen = str.length\n    while (Character.isWhitespace(str.charAt(i))) i++\n    let isNegative = false\n    if (i < strlen) {\n      const signCh = str.charAt(i)\n      if (signCh === '-' || signCh === '+') {\n        i++\n        if (signCh === '-') isNegative = true\n      }\n    }\n    const val = new DD()\n    let numDigits = 0\n    let numBeforeDec = 0\n    let exp = 0\n    let hasDecimalChar = false\n    while (true) {\n      if (i >= strlen) break\n      const ch = str.charAt(i)\n      i++\n      if (Character.isDigit(ch)) {\n        const d = ch - '0'\n        val.selfMultiply(DD.TEN)\n        val.selfAdd(d)\n        numDigits++\n        continue\n      }\n      if (ch === '.') {\n        numBeforeDec = numDigits\n        hasDecimalChar = true\n        continue\n      }\n      if (ch === 'e' || ch === 'E') {\n        const expStr = str.substring(i)\n        try {\n          exp = Integer.parseInt(expStr)\n        } catch (ex) {\n          if (ex instanceof NumberFormatException) \n            throw new NumberFormatException('Invalid exponent ' + expStr + ' in string ' + str)\n          else throw ex\n        } finally {}\n        break\n      }\n      throw new NumberFormatException('Unexpected character \\'' + ch + '\\' at position ' + i + ' in string ' + str)\n    }\n    let val2 = val\n    if (!hasDecimalChar) numBeforeDec = numDigits\n    const numDecPlaces = numDigits - numBeforeDec - exp\n    if (numDecPlaces === 0) {\n      val2 = val\n    } else if (numDecPlaces > 0) {\n      const scale = DD.TEN.pow(numDecPlaces)\n      val2 = val.divide(scale)\n    } else if (numDecPlaces < 0) {\n      const scale = DD.TEN.pow(-numDecPlaces)\n      val2 = val.multiply(scale)\n    }\n    if (isNegative) \n      return val2.negate()\n    \n    return val2\n  }\n  static createNaN() {\n    return new DD(Double.NaN, Double.NaN)\n  }\n  static copy(dd) {\n    return new DD(dd)\n  }\n  static magnitude(x) {\n    const xAbs = Math.abs(x)\n    const xLog10 = Math.log(xAbs) / Math.log(10)\n    let xMag = Math.trunc(Math.floor(xLog10))\n    const xApprox = Math.pow(10, xMag)\n    if (xApprox * 10 <= xAbs) xMag += 1\n    return xMag\n  }\n  static stringOfChar(ch, len) {\n    const buf = new StringBuffer()\n    for (let i = 0; i < len; i++) \n      buf.append(ch)\n    \n    return buf.toString()\n  }\n  le(y) {\n    return this._hi < y._hi || this._hi === y._hi && this._lo <= y._lo\n  }\n  extractSignificantDigits(insertDecimalPoint, magnitude) {\n    let y = this.abs()\n    let mag = DD.magnitude(y._hi)\n    const scale = DD.TEN.pow(mag)\n    y = y.divide(scale)\n    if (y.gt(DD.TEN)) {\n      y = y.divide(DD.TEN)\n      mag += 1\n    } else if (y.lt(DD.ONE)) {\n      y = y.multiply(DD.TEN)\n      mag -= 1\n    }\n    const decimalPointPos = mag + 1\n    const buf = new StringBuffer()\n    const numDigits = DD.MAX_PRINT_DIGITS - 1\n    for (let i = 0; i <= numDigits; i++) {\n      if (insertDecimalPoint && i === decimalPointPos) \n        buf.append('.')\n      \n      const digit = Math.trunc(y._hi)\n      if (digit < 0 || digit > 9) {}\n      if (digit < 0) \n        break\n      \n      let rebiasBy10 = false\n      let digitChar = 0\n      if (digit > 9) {\n        rebiasBy10 = true\n        digitChar = '9'\n      } else {\n        digitChar = '0' + digit\n      }\n      buf.append(digitChar)\n      y = y.subtract(DD.valueOf(digit)).multiply(DD.TEN)\n      if (rebiasBy10) y.selfAdd(DD.TEN)\n      let continueExtractingDigits = true\n      const remMag = DD.magnitude(y._hi)\n      if (remMag < 0 && Math.abs(remMag) >= numDigits - i) continueExtractingDigits = false\n      if (!continueExtractingDigits) break\n    }\n    magnitude[0] = mag\n    return buf.toString()\n  }\n  sqr() {\n    return this.multiply(this)\n  }\n  doubleValue() {\n    return this._hi + this._lo\n  }\n  subtract() {\n    if (arguments[0] instanceof DD) {\n      const y = arguments[0]\n      return this.add(y.negate())\n    } else if (typeof arguments[0] === 'number') {\n      const y = arguments[0]\n      return this.add(-y)\n    }\n  }\n  equals() {\n    if (arguments.length === 1 && arguments[0] instanceof DD) {\n      const y = arguments[0]\n      return this._hi === y._hi && this._lo === y._lo\n    }\n  }\n  isZero() {\n    return this._hi === 0.0 && this._lo === 0.0\n  }\n  selfSubtract() {\n    if (arguments[0] instanceof DD) {\n      const y = arguments[0]\n      if (this.isNaN()) return this\n      return this.selfAdd(-y._hi, -y._lo)\n    } else if (typeof arguments[0] === 'number') {\n      const y = arguments[0]\n      if (this.isNaN()) return this\n      return this.selfAdd(-y, 0.0)\n    }\n  }\n  getSpecialNumberString() {\n    if (this.isZero()) return '0.0'\n    if (this.isNaN()) return 'NaN '\n    return null\n  }\n  min(x) {\n    if (this.le(x)) \n      return this\n    else \n      return x\n    \n  }\n  selfDivide() {\n    if (arguments.length === 1) {\n      if (arguments[0] instanceof DD) {\n        const y = arguments[0]\n        return this.selfDivide(y._hi, y._lo)\n      } else if (typeof arguments[0] === 'number') {\n        const y = arguments[0]\n        return this.selfDivide(y, 0.0)\n      }\n    } else if (arguments.length === 2) {\n      const yhi = arguments[0], ylo = arguments[1]\n      let hc = null, tc = null, hy = null, ty = null, C = null, c = null, U = null, u = null\n      C = this._hi / yhi\n      c = DD.SPLIT * C\n      hc = c - C\n      u = DD.SPLIT * yhi\n      hc = c - hc\n      tc = C - hc\n      hy = u - yhi\n      U = C * yhi\n      hy = u - hy\n      ty = yhi - hy\n      u = hc * hy - U + hc * ty + tc * hy + tc * ty\n      c = (this._hi - U - u + this._lo - C * ylo) / yhi\n      u = C + c\n      this._hi = u\n      this._lo = C - u + c\n      return this\n    }\n  }\n  dump() {\n    return 'DD<' + this._hi + ', ' + this._lo + '>'\n  }\n  divide() {\n    if (arguments[0] instanceof DD) {\n      const y = arguments[0]\n      let hc = null, tc = null, hy = null, ty = null, C = null, c = null, U = null, u = null\n      C = this._hi / y._hi\n      c = DD.SPLIT * C\n      hc = c - C\n      u = DD.SPLIT * y._hi\n      hc = c - hc\n      tc = C - hc\n      hy = u - y._hi\n      U = C * y._hi\n      hy = u - hy\n      ty = y._hi - hy\n      u = hc * hy - U + hc * ty + tc * hy + tc * ty\n      c = (this._hi - U - u + this._lo - C * y._lo) / y._hi\n      u = C + c\n      const zhi = u\n      const zlo = C - u + c\n      return new DD(zhi, zlo)\n    } else if (typeof arguments[0] === 'number') {\n      const y = arguments[0]\n      if (Double.isNaN(y)) return DD.createNaN()\n      return DD.copy(this).selfDivide(y, 0.0)\n    }\n  }\n  ge(y) {\n    return this._hi > y._hi || this._hi === y._hi && this._lo >= y._lo\n  }\n  pow(exp) {\n    if (exp === 0.0) return DD.valueOf(1.0)\n    let r = new DD(this)\n    let s = DD.valueOf(1.0)\n    let n = Math.abs(exp)\n    if (n > 1) \n      while (n > 0) {\n        if (n % 2 === 1) \n          s.selfMultiply(r)\n        \n        n /= 2\n        if (n > 0) r = r.sqr()\n      }\n    else \n      s = r\n    \n    if (exp < 0) return s.reciprocal()\n    return s\n  }\n  ceil() {\n    if (this.isNaN()) return DD.NaN\n    const fhi = Math.ceil(this._hi)\n    let flo = 0.0\n    if (fhi === this._hi) \n      flo = Math.ceil(this._lo)\n    \n    return new DD(fhi, flo)\n  }\n  compareTo(o) {\n    const other = o\n    if (this._hi < other._hi) return -1\n    if (this._hi > other._hi) return 1\n    if (this._lo < other._lo) return -1\n    if (this._lo > other._lo) return 1\n    return 0\n  }\n  rint() {\n    if (this.isNaN()) return this\n    const plus5 = this.add(0.5)\n    return plus5.floor()\n  }\n  setValue() {\n    if (arguments[0] instanceof DD) {\n      const value = arguments[0]\n      this.init(value)\n      return this\n    } else if (typeof arguments[0] === 'number') {\n      const value = arguments[0]\n      this.init(value)\n      return this\n    }\n  }\n  max(x) {\n    if (this.ge(x)) \n      return this\n    else \n      return x\n    \n  }\n  sqrt() {\n    if (this.isZero()) return DD.valueOf(0.0)\n    if (this.isNegative()) \n      return DD.NaN\n    \n    const x = 1.0 / Math.sqrt(this._hi)\n    const ax = this._hi * x\n    const axdd = DD.valueOf(ax)\n    const diffSq = this.subtract(axdd.sqr())\n    const d2 = diffSq._hi * (x * 0.5)\n    return axdd.add(d2)\n  }\n  selfAdd() {\n    if (arguments.length === 1) {\n      if (arguments[0] instanceof DD) {\n        const y = arguments[0]\n        return this.selfAdd(y._hi, y._lo)\n      } else if (typeof arguments[0] === 'number') {\n        const y = arguments[0]\n        let H = null, h = null, S = null, s = null, e = null, f = null\n        S = this._hi + y\n        e = S - this._hi\n        s = S - e\n        s = y - e + (this._hi - s)\n        f = s + this._lo\n        H = S + f\n        h = f + (S - H)\n        this._hi = H + h\n        this._lo = h + (H - this._hi)\n        return this\n      }\n    } else if (arguments.length === 2) {\n      const yhi = arguments[0], ylo = arguments[1]\n      let H = null, h = null, T = null, t = null, S = null, s = null, e = null, f = null\n      S = this._hi + yhi\n      T = this._lo + ylo\n      e = S - this._hi\n      f = T - this._lo\n      s = S - e\n      t = T - f\n      s = yhi - e + (this._hi - s)\n      t = ylo - f + (this._lo - t)\n      e = s + T\n      H = S + e\n      h = e + (S - H)\n      e = t + h\n      const zhi = H + e\n      const zlo = e + (H - zhi)\n      this._hi = zhi\n      this._lo = zlo\n      return this\n    }\n  }\n  selfMultiply() {\n    if (arguments.length === 1) {\n      if (arguments[0] instanceof DD) {\n        const y = arguments[0]\n        return this.selfMultiply(y._hi, y._lo)\n      } else if (typeof arguments[0] === 'number') {\n        const y = arguments[0]\n        return this.selfMultiply(y, 0.0)\n      }\n    } else if (arguments.length === 2) {\n      const yhi = arguments[0], ylo = arguments[1]\n      let hx = null, tx = null, hy = null, ty = null, C = null, c = null\n      C = DD.SPLIT * this._hi\n      hx = C - this._hi\n      c = DD.SPLIT * yhi\n      hx = C - hx\n      tx = this._hi - hx\n      hy = c - yhi\n      C = this._hi * yhi\n      hy = c - hy\n      ty = yhi - hy\n      c = hx * hy - C + hx * ty + tx * hy + tx * ty + (this._hi * ylo + this._lo * yhi)\n      const zhi = C + c\n      hx = C - zhi\n      const zlo = c + hx\n      this._hi = zhi\n      this._lo = zlo\n      return this\n    }\n  }\n  selfSqr() {\n    return this.selfMultiply(this)\n  }\n  floor() {\n    if (this.isNaN()) return DD.NaN\n    const fhi = Math.floor(this._hi)\n    let flo = 0.0\n    if (fhi === this._hi) \n      flo = Math.floor(this._lo)\n    \n    return new DD(fhi, flo)\n  }\n  negate() {\n    if (this.isNaN()) return this\n    return new DD(-this._hi, -this._lo)\n  }\n  clone() {\n    try {\n      return null\n    } catch (ex) {\n      if (ex instanceof CloneNotSupportedException) \n        return null\n      else throw ex\n    } finally {}\n  }\n  multiply() {\n    if (arguments[0] instanceof DD) {\n      const y = arguments[0]\n      if (y.isNaN()) return DD.createNaN()\n      return DD.copy(this).selfMultiply(y)\n    } else if (typeof arguments[0] === 'number') {\n      const y = arguments[0]\n      if (Double.isNaN(y)) return DD.createNaN()\n      return DD.copy(this).selfMultiply(y, 0.0)\n    }\n  }\n  isNaN() {\n    return Double.isNaN(this._hi)\n  }\n  intValue() {\n    return Math.trunc(this._hi)\n  }\n  toString() {\n    const mag = DD.magnitude(this._hi)\n    if (mag >= -3 && mag <= 20) return this.toStandardNotation()\n    return this.toSciNotation()\n  }\n  toStandardNotation() {\n    const specialStr = this.getSpecialNumberString()\n    if (specialStr !== null) return specialStr\n    const magnitude = new Array(1).fill(null)\n    const sigDigits = this.extractSignificantDigits(true, magnitude)\n    const decimalPointPos = magnitude[0] + 1\n    let num = sigDigits\n    if (sigDigits.charAt(0) === '.') {\n      num = '0' + sigDigits\n    } else if (decimalPointPos < 0) {\n      num = '0.' + DD.stringOfChar('0', -decimalPointPos) + sigDigits\n    } else if (sigDigits.indexOf('.') === -1) {\n      const numZeroes = decimalPointPos - sigDigits.length\n      const zeroes = DD.stringOfChar('0', numZeroes)\n      num = sigDigits + zeroes + '.0'\n    }\n    if (this.isNegative()) return '-' + num\n    return num\n  }\n  reciprocal() {\n    let hc = null, tc = null, hy = null, ty = null, C = null, c = null, U = null, u = null\n    C = 1.0 / this._hi\n    c = DD.SPLIT * C\n    hc = c - C\n    u = DD.SPLIT * this._hi\n    hc = c - hc\n    tc = C - hc\n    hy = u - this._hi\n    U = C * this._hi\n    hy = u - hy\n    ty = this._hi - hy\n    u = hc * hy - U + hc * ty + tc * hy + tc * ty\n    c = (1.0 - U - u - C * this._lo) / this._hi\n    const zhi = C + c\n    const zlo = C - zhi + c\n    return new DD(zhi, zlo)\n  }\n  toSciNotation() {\n    if (this.isZero()) return DD.SCI_NOT_ZERO\n    const specialStr = this.getSpecialNumberString()\n    if (specialStr !== null) return specialStr\n    const magnitude = new Array(1).fill(null)\n    const digits = this.extractSignificantDigits(false, magnitude)\n    const expStr = DD.SCI_NOT_EXPONENT_CHAR + magnitude[0]\n    if (digits.charAt(0) === '0') \n      throw new IllegalStateException('Found leading zero: ' + digits)\n    \n    let trailingDigits = ''\n    if (digits.length > 1) trailingDigits = digits.substring(1)\n    const digitsWithDecimal = digits.charAt(0) + '.' + trailingDigits\n    if (this.isNegative()) return '-' + digitsWithDecimal + expStr\n    return digitsWithDecimal + expStr\n  }\n  abs() {\n    if (this.isNaN()) return DD.NaN\n    if (this.isNegative()) return this.negate()\n    return new DD(this)\n  }\n  isPositive() {\n    return this._hi > 0.0 || this._hi === 0.0 && this._lo > 0.0\n  }\n  lt(y) {\n    return this._hi < y._hi || this._hi === y._hi && this._lo < y._lo\n  }\n  add() {\n    if (arguments[0] instanceof DD) {\n      const y = arguments[0]\n      return DD.copy(this).selfAdd(y)\n    } else if (typeof arguments[0] === 'number') {\n      const y = arguments[0]\n      return DD.copy(this).selfAdd(y)\n    }\n  }\n  init() {\n    if (arguments.length === 1) {\n      if (typeof arguments[0] === 'number') {\n        const x = arguments[0]\n        this._hi = x\n        this._lo = 0.0\n      } else if (arguments[0] instanceof DD) {\n        const dd = arguments[0]\n        this._hi = dd._hi\n        this._lo = dd._lo\n      }\n    } else if (arguments.length === 2) {\n      const hi = arguments[0], lo = arguments[1]\n      this._hi = hi\n      this._lo = lo\n    }\n  }\n  gt(y) {\n    return this._hi > y._hi || this._hi === y._hi && this._lo > y._lo\n  }\n  isNegative() {\n    return this._hi < 0.0 || this._hi === 0.0 && this._lo < 0.0\n  }\n  trunc() {\n    if (this.isNaN()) return DD.NaN\n    if (this.isPositive()) return this.floor(); else return this.ceil()\n  }\n  signum() {\n    if (this._hi > 0) return 1\n    if (this._hi < 0) return -1\n    if (this._lo > 0) return 1\n    if (this._lo < 0) return -1\n    return 0\n  }\n  get interfaces_() {\n    return [Serializable, Comparable, Cloneable]\n  }\n}\nDD.PI = new DD(3.141592653589793116e+00, 1.224646799147353207e-16)\nDD.TWO_PI = new DD(6.283185307179586232e+00, 2.449293598294706414e-16)\nDD.PI_2 = new DD(1.570796326794896558e+00, 6.123233995736766036e-17)\nDD.E = new DD(2.718281828459045091e+00, 1.445646891729250158e-16)\nDD.NaN = new DD(Double.NaN, Double.NaN)\nDD.EPS = 1.23259516440783e-32\nDD.SPLIT = 134217729.0\nDD.MAX_PRINT_DIGITS = 32\nDD.TEN = DD.valueOf(10.0)\nDD.ONE = DD.valueOf(1.0)\nDD.SCI_NOT_EXPONENT_CHAR = 'E'\nDD.SCI_NOT_ZERO = '0.0E0'\n","import Coordinate from '../geom/Coordinate'\nimport Double from '../../../../java/lang/Double'\nimport DD from '../math/DD'\nexport default class CGAlgorithmsDD {\n  static orientationIndex(p1, p2, q) {\n    const index = CGAlgorithmsDD.orientationIndexFilter(p1, p2, q)\n    if (index <= 1) return index\n    const dx1 = DD.valueOf(p2.x).selfAdd(-p1.x)\n    const dy1 = DD.valueOf(p2.y).selfAdd(-p1.y)\n    const dx2 = DD.valueOf(q.x).selfAdd(-p2.x)\n    const dy2 = DD.valueOf(q.y).selfAdd(-p2.y)\n    return dx1.selfMultiply(dy2).selfSubtract(dy1.selfMultiply(dx2)).signum()\n  }\n  static signOfDet2x2() {\n    if (arguments[3] instanceof DD && (arguments[2] instanceof DD && (arguments[0] instanceof DD && arguments[1] instanceof DD))) {\n      const x1 = arguments[0], y1 = arguments[1], x2 = arguments[2], y2 = arguments[3]\n      const det = x1.multiply(y2).selfSubtract(y1.multiply(x2))\n      return det.signum()\n    } else if (typeof arguments[3] === 'number' && (typeof arguments[2] === 'number' && (typeof arguments[0] === 'number' && typeof arguments[1] === 'number'))) {\n      const dx1 = arguments[0], dy1 = arguments[1], dx2 = arguments[2], dy2 = arguments[3]\n      const x1 = DD.valueOf(dx1)\n      const y1 = DD.valueOf(dy1)\n      const x2 = DD.valueOf(dx2)\n      const y2 = DD.valueOf(dy2)\n      const det = x1.multiply(y2).selfSubtract(y1.multiply(x2))\n      return det.signum()\n    }\n  }\n  static intersection(p1, p2, q1, q2) {\n    const px = new DD(p1.y).selfSubtract(p2.y)\n    const py = new DD(p2.x).selfSubtract(p1.x)\n    const pw = new DD(p1.x).selfMultiply(p2.y).selfSubtract(new DD(p2.x).selfMultiply(p1.y))\n    const qx = new DD(q1.y).selfSubtract(q2.y)\n    const qy = new DD(q2.x).selfSubtract(q1.x)\n    const qw = new DD(q1.x).selfMultiply(q2.y).selfSubtract(new DD(q2.x).selfMultiply(q1.y))\n    const x = py.multiply(qw).selfSubtract(qy.multiply(pw))\n    const y = qx.multiply(pw).selfSubtract(px.multiply(qw))\n    const w = px.multiply(qy).selfSubtract(qx.multiply(py))\n    const xInt = x.selfDivide(w).doubleValue()\n    const yInt = y.selfDivide(w).doubleValue()\n    if (Double.isNaN(xInt) || (Double.isInfinite(xInt) || Double.isNaN(yInt)) || Double.isInfinite(yInt)) \n      return null\n    \n    return new Coordinate(xInt, yInt)\n  }\n  static orientationIndexFilter(pa, pb, pc) {\n    let detsum = null\n    const detleft = (pa.x - pc.x) * (pb.y - pc.y)\n    const detright = (pa.y - pc.y) * (pb.x - pc.x)\n    const det = detleft - detright\n    if (detleft > 0.0) \n      if (detright <= 0.0) \n        return CGAlgorithmsDD.signum(det)\n      else \n        detsum = detleft + detright\n      \n    else if (detleft < 0.0) \n      if (detright >= 0.0) \n        return CGAlgorithmsDD.signum(det)\n      else \n        detsum = -detleft - detright\n      \n    else \n      return CGAlgorithmsDD.signum(det)\n    \n    const errbound = CGAlgorithmsDD.DP_SAFE_EPSILON * detsum\n    if (det >= errbound || -det >= errbound) \n      return CGAlgorithmsDD.signum(det)\n    \n    return 2\n  }\n  static signum(x) {\n    if (x > 0) return 1\n    if (x < 0) return -1\n    return 0\n  }\n}\nCGAlgorithmsDD.DP_SAFE_EPSILON = 1e-15\n","import Double from '../../../../java/lang/Double'\nimport Cloneable from '../../../../java/lang/Cloneable'\nexport default class CoordinateSequence {\n  getM(index) {\n    if (this.hasM()) {\n      const mIndex = this.getDimension() - this.getMeasures()\n      return this.getOrdinate(index, mIndex)\n    } else {\n      return Double.NaN\n    }\n  }\n  setOrdinate(index, ordinateIndex, value) {}\n  getZ(index) {\n    if (this.hasZ()) \n      return this.getOrdinate(index, 2)\n    else \n      return Double.NaN\n    \n  }\n  size() {}\n  getOrdinate(index, ordinateIndex) {}\n  getCoordinate() {\n    if (arguments.length === 1) {\n      const i = arguments[0]\n    } else if (arguments.length === 2) {\n      const index = arguments[0], coord = arguments[1]\n    }\n  }\n  getCoordinateCopy(i) {}\n  createCoordinate() {}\n  getDimension() {}\n  hasM() {\n    return this.getMeasures() > 0\n  }\n  getX(index) {}\n  hasZ() {\n    return this.getDimension() - this.getMeasures() > 2\n  }\n  getMeasures() {\n    return 0\n  }\n  expandEnvelope(env) {}\n  copy() {}\n  getY(index) {}\n  toCoordinateArray() {}\n  get interfaces_() {\n    return [Cloneable]\n  }\n}\nCoordinateSequence.X = 0\nCoordinateSequence.Y = 1\nCoordinateSequence.Z = 2\nCoordinateSequence.M = 3\n","import hasInterface from '../../../../hasInterface'\nimport IllegalArgumentException from '../../../../java/lang/IllegalArgumentException'\nimport CGAlgorithmsDD from './CGAlgorithmsDD'\nimport CoordinateSequence from '../geom/CoordinateSequence'\nexport default class Orientation {\n  static index(p1, p2, q) {\n    return CGAlgorithmsDD.orientationIndex(p1, p2, q)\n  }\n  static isCCW() {\n    if (arguments[0] instanceof Array) {\n      const ring = arguments[0]\n      const nPts = ring.length - 1\n      if (nPts < 3) throw new IllegalArgumentException('Ring has fewer than 4 points, so orientation cannot be determined')\n      let hiPt = ring[0]\n      let hiIndex = 0\n      for (let i = 1; i <= nPts; i++) {\n        const p = ring[i]\n        if (p.y > hiPt.y) {\n          hiPt = p\n          hiIndex = i\n        }\n      }\n      let iPrev = hiIndex\n      do {\n        iPrev = iPrev - 1\n        if (iPrev < 0) iPrev = nPts\n      } while (ring[iPrev].equals2D(hiPt) && iPrev !== hiIndex)\n      let iNext = hiIndex\n      do \n        iNext = (iNext + 1) % nPts\n      while (ring[iNext].equals2D(hiPt) && iNext !== hiIndex)\n      const prev = ring[iPrev]\n      const next = ring[iNext]\n      if (prev.equals2D(hiPt) || next.equals2D(hiPt) || prev.equals2D(next)) return false\n      const disc = Orientation.index(prev, hiPt, next)\n      let isCCW = null\n      if (disc === 0) \n        isCCW = prev.x > next.x\n      else \n        isCCW = disc > 0\n      \n      return isCCW\n    } else if (hasInterface(arguments[0], CoordinateSequence)) {\n      const ring = arguments[0]\n      const nPts = ring.size() - 1\n      if (nPts < 3) throw new IllegalArgumentException('Ring has fewer than 4 points, so orientation cannot be determined')\n      let hiPt = ring.getCoordinate(0)\n      let hiIndex = 0\n      for (let i = 1; i <= nPts; i++) {\n        const p = ring.getCoordinate(i)\n        if (p.y > hiPt.y) {\n          hiPt = p\n          hiIndex = i\n        }\n      }\n      let prev = null\n      let iPrev = hiIndex\n      do {\n        iPrev = iPrev - 1\n        if (iPrev < 0) iPrev = nPts\n        prev = ring.getCoordinate(iPrev)\n      } while (prev.equals2D(hiPt) && iPrev !== hiIndex)\n      let next = null\n      let iNext = hiIndex\n      do {\n        iNext = (iNext + 1) % nPts\n        next = ring.getCoordinate(iNext)\n      } while (next.equals2D(hiPt) && iNext !== hiIndex)\n      if (prev.equals2D(hiPt) || next.equals2D(hiPt) || prev.equals2D(next)) return false\n      const disc = Orientation.index(prev, hiPt, next)\n      let isCCW = null\n      if (disc === 0) \n        isCCW = prev.x > next.x\n      else \n        isCCW = disc > 0\n      \n      return isCCW\n    }\n  }\n}\nOrientation.CLOCKWISE = -1\nOrientation.RIGHT = Orientation.CLOCKWISE\nOrientation.COUNTERCLOCKWISE = 1\nOrientation.LEFT = Orientation.COUNTERCLOCKWISE\nOrientation.COLLINEAR = 0\nOrientation.STRAIGHT = Orientation.COLLINEAR\n","import Position from '../../geomgraph/Position'\nimport Orientation from '../../algorithm/Orientation'\nimport Assert from '../../util/Assert'\nexport default class RightmostEdgeFinder {\n  constructor() {\n    RightmostEdgeFinder.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._minIndex = -1\n    this._minCoord = null\n    this._minDe = null\n    this._orientedDe = null\n  }\n  getCoordinate() {\n    return this._minCoord\n  }\n  getRightmostSide(de, index) {\n    let side = this.getRightmostSideOfSegment(de, index)\n    if (side < 0) side = this.getRightmostSideOfSegment(de, index - 1)\n    if (side < 0) {\n      this._minCoord = null\n      this.checkForRightmostCoordinate(de)\n    }\n    return side\n  }\n  findRightmostEdgeAtVertex() {\n    const pts = this._minDe.getEdge().getCoordinates()\n    Assert.isTrue(this._minIndex > 0 && this._minIndex < pts.length, 'rightmost point expected to be interior vertex of edge')\n    const pPrev = pts[this._minIndex - 1]\n    const pNext = pts[this._minIndex + 1]\n    const orientation = Orientation.index(this._minCoord, pNext, pPrev)\n    let usePrev = false\n    if (pPrev.y < this._minCoord.y && pNext.y < this._minCoord.y && orientation === Orientation.COUNTERCLOCKWISE) \n      usePrev = true\n    else if (pPrev.y > this._minCoord.y && pNext.y > this._minCoord.y && orientation === Orientation.CLOCKWISE) \n      usePrev = true\n    \n    if (usePrev) \n      this._minIndex = this._minIndex - 1\n    \n  }\n  getRightmostSideOfSegment(de, i) {\n    const e = de.getEdge()\n    const coord = e.getCoordinates()\n    if (i < 0 || i + 1 >= coord.length) return -1\n    if (coord[i].y === coord[i + 1].y) return -1\n    let pos = Position.LEFT\n    if (coord[i].y < coord[i + 1].y) pos = Position.RIGHT\n    return pos\n  }\n  getEdge() {\n    return this._orientedDe\n  }\n  checkForRightmostCoordinate(de) {\n    const coord = de.getEdge().getCoordinates()\n    for (let i = 0; i < coord.length - 1; i++) \n      if (this._minCoord === null || coord[i].x > this._minCoord.x) {\n        this._minDe = de\n        this._minIndex = i\n        this._minCoord = coord[i]\n      }\n    \n  }\n  findRightmostEdgeAtNode() {\n    const node = this._minDe.getNode()\n    const star = node.getEdges()\n    this._minDe = star.getRightmostEdge()\n    if (!this._minDe.isForward()) {\n      this._minDe = this._minDe.getSym()\n      this._minIndex = this._minDe.getEdge().getCoordinates().length - 1\n    }\n  }\n  findEdge(dirEdgeList) {\n    for (let i = dirEdgeList.iterator(); i.hasNext(); ) {\n      const de = i.next()\n      if (!de.isForward()) continue\n      this.checkForRightmostCoordinate(de)\n    }\n    Assert.isTrue(this._minIndex !== 0 || this._minCoord.equals(this._minDe.getCoordinate()), 'inconsistency in rightmost processing')\n    if (this._minIndex === 0) \n      this.findRightmostEdgeAtNode()\n    else \n      this.findRightmostEdgeAtVertex()\n    \n    this._orientedDe = this._minDe\n    const rightmostSide = this.getRightmostSide(this._minDe, this._minIndex)\n    if (rightmostSide === Position.LEFT) \n      this._orientedDe = this._minDe.getSym()\n    \n  }\n}\n","import Coordinate from './Coordinate'\nimport RuntimeException from '../../../../java/lang/RuntimeException'\n\nexport default class TopologyException extends RuntimeException {\n  constructor(msg, pt) {\n    super(pt ? msg + ' [ ' + pt + ' ]' : msg)\n    this.pt = pt ? new Coordinate(pt) : undefined\n    this.name = Object.keys({ TopologyException })[0]\n  }\n  getCoordinate() {\n    return this.pt\n  }\n}\n","export default class LinkedList {\n  constructor() {\n    this.array = []\n  }\n\n  addLast(e) {\n    this.array.push(e)\n  }\n\n  removeFirst() {\n    return this.array.shift()\n  }\n\n  isEmpty() {\n    return this.array.length === 0\n  }\n}\n","import Collection from './Collection'\nimport IndexOutOfBoundsException from '../lang/IndexOutOfBoundsException'\nimport List from './List'\nimport NoSuchElementException from './NoSuchElementException'\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/ArrayList.html\n */\nexport default class ArrayList extends List {\n\n  constructor(o) {\n    super()\n    this.array = []\n    if (o instanceof Collection) this.addAll(o)\n  }\n\n  get interfaces_() {\n    return [List, Collection]\n  }\n\n  ensureCapacity() { }\n\n  add(e) {\n    if (arguments.length === 1)\n      this.array.push(e)\n    else\n      this.array.splice(arguments[0], 0, arguments[1])\n    return true\n  }\n\n  clear() {\n    this.array = []\n  }\n\n  addAll(c) {\n    for (const e of c)\n      this.array.push(e)\n  }\n\n  set(index, element) {\n    const oldElement = this.array[index]\n    this.array[index] = element\n    return oldElement\n  }\n\n  iterator() {\n    return new Iterator(this)\n  }\n\n  get(index) {\n    if (index < 0 || index >= this.size())\n      throw new IndexOutOfBoundsException()\n    return this.array[index]\n  }\n\n  isEmpty() {\n    return this.array.length === 0\n  }\n\n  sort(comparator) {\n    if (comparator)\n      this.array.sort((a, b) => comparator.compare(a, b))\n    else this.array.sort()\n  }\n\n  size() {\n    return this.array.length\n  }\n\n  toArray() {\n    return this.array.slice()\n  }\n\n  remove(o) {\n    for (let i = 0, len = this.array.length; i < len; i++)\n      if (this.array[i] === o)\n        return !!this.array.splice(i, 1)\n    return false\n  }\n\n  [Symbol.iterator]() {\n    return this.array.values()\n  }\n}\n\nclass Iterator {\n  constructor(arrayList) {\n    this.arrayList = arrayList\n    this.position = 0\n  }\n\n  next() {\n    if (this.position === this.arrayList.size())\n      throw new NoSuchElementException()\n    return this.arrayList.get(this.position++)\n  }\n\n  hasNext() {\n    return this.position < this.arrayList.size()\n  }\n\n  set(element) {\n    return this.arrayList.set(this.position - 1, element)\n  }\n\n  remove() {\n    this.arrayList.remove(this.arrayList.get(this.position))\n  }\n}\n","import HashSet from '../../../../../java/util/HashSet'\nimport Position from '../../geomgraph/Position'\nimport Stack from '../../../../../java/util/Stack'\nimport RightmostEdgeFinder from './RightmostEdgeFinder'\nimport TopologyException from '../../geom/TopologyException'\nimport LinkedList from '../../../../../java/util/LinkedList'\nimport Comparable from '../../../../../java/lang/Comparable'\nimport ArrayList from '../../../../../java/util/ArrayList'\nimport Envelope from '../../geom/Envelope'\nexport default class BufferSubgraph {\n  constructor() {\n    BufferSubgraph.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._finder = null\n    this._dirEdgeList = new ArrayList()\n    this._nodes = new ArrayList()\n    this._rightMostCoord = null\n    this._env = null\n    this._finder = new RightmostEdgeFinder()\n  }\n  clearVisitedEdges() {\n    for (let it = this._dirEdgeList.iterator(); it.hasNext(); ) {\n      const de = it.next()\n      de.setVisited(false)\n    }\n  }\n  getRightmostCoordinate() {\n    return this._rightMostCoord\n  }\n  computeNodeDepth(n) {\n    let startEdge = null\n    for (let i = n.getEdges().iterator(); i.hasNext(); ) {\n      const de = i.next()\n      if (de.isVisited() || de.getSym().isVisited()) {\n        startEdge = de\n        break\n      }\n    }\n    if (startEdge === null) throw new TopologyException('unable to find edge to compute depths at ' + n.getCoordinate())\n    n.getEdges().computeDepths(startEdge)\n    for (let i = n.getEdges().iterator(); i.hasNext(); ) {\n      const de = i.next()\n      de.setVisited(true)\n      this.copySymDepths(de)\n    }\n  }\n  computeDepth(outsideDepth) {\n    this.clearVisitedEdges()\n    const de = this._finder.getEdge()\n    const n = de.getNode()\n    const label = de.getLabel()\n    de.setEdgeDepths(Position.RIGHT, outsideDepth)\n    this.copySymDepths(de)\n    this.computeDepths(de)\n  }\n  create(node) {\n    this.addReachable(node)\n    this._finder.findEdge(this._dirEdgeList)\n    this._rightMostCoord = this._finder.getCoordinate()\n  }\n  findResultEdges() {\n    for (let it = this._dirEdgeList.iterator(); it.hasNext(); ) {\n      const de = it.next()\n      if (de.getDepth(Position.RIGHT) >= 1 && de.getDepth(Position.LEFT) <= 0 && !de.isInteriorAreaEdge()) \n        de.setInResult(true)\n      \n    }\n  }\n  computeDepths(startEdge) {\n    const nodesVisited = new HashSet()\n    const nodeQueue = new LinkedList()\n    const startNode = startEdge.getNode()\n    nodeQueue.addLast(startNode)\n    nodesVisited.add(startNode)\n    startEdge.setVisited(true)\n    while (!nodeQueue.isEmpty()) {\n      const n = nodeQueue.removeFirst()\n      nodesVisited.add(n)\n      this.computeNodeDepth(n)\n      for (let i = n.getEdges().iterator(); i.hasNext(); ) {\n        const de = i.next()\n        const sym = de.getSym()\n        if (sym.isVisited()) continue\n        const adjNode = sym.getNode()\n        if (!nodesVisited.contains(adjNode)) {\n          nodeQueue.addLast(adjNode)\n          nodesVisited.add(adjNode)\n        }\n      }\n    }\n  }\n  compareTo(o) {\n    const graph = o\n    if (this._rightMostCoord.x < graph._rightMostCoord.x) \n      return -1\n    \n    if (this._rightMostCoord.x > graph._rightMostCoord.x) \n      return 1\n    \n    return 0\n  }\n  getEnvelope() {\n    if (this._env === null) {\n      const edgeEnv = new Envelope()\n      for (let it = this._dirEdgeList.iterator(); it.hasNext(); ) {\n        const dirEdge = it.next()\n        const pts = dirEdge.getEdge().getCoordinates()\n        for (let i = 0; i < pts.length - 1; i++) \n          edgeEnv.expandToInclude(pts[i])\n        \n      }\n      this._env = edgeEnv\n    }\n    return this._env\n  }\n  addReachable(startNode) {\n    const nodeStack = new Stack()\n    nodeStack.add(startNode)\n    while (!nodeStack.empty()) {\n      const node = nodeStack.pop()\n      this.add(node, nodeStack)\n    }\n  }\n  copySymDepths(de) {\n    const sym = de.getSym()\n    sym.setDepth(Position.LEFT, de.getDepth(Position.RIGHT))\n    sym.setDepth(Position.RIGHT, de.getDepth(Position.LEFT))\n  }\n  add(node, nodeStack) {\n    node.setVisited(true)\n    this._nodes.add(node)\n    for (let i = node.getEdges().iterator(); i.hasNext(); ) {\n      const de = i.next()\n      this._dirEdgeList.add(de)\n      const sym = de.getSym()\n      const symNode = sym.getNode()\n      if (!symNode.isVisited()) nodeStack.push(symNode)\n    }\n  }\n  getNodes() {\n    return this._nodes\n  }\n  getDirectedEdges() {\n    return this._dirEdgeList\n  }\n  get interfaces_() {\n    return [Comparable]\n  }\n}\n","import Coordinate from '../geom/Coordinate'\nimport Double from '../../../../java/lang/Double'\nexport default class Intersection {\n  static intersection(p1, p2, q1, q2) {\n    const minX0 = p1.x < p2.x ? p1.x : p2.x\n    const minY0 = p1.y < p2.y ? p1.y : p2.y\n    const maxX0 = p1.x > p2.x ? p1.x : p2.x\n    const maxY0 = p1.y > p2.y ? p1.y : p2.y\n    const minX1 = q1.x < q2.x ? q1.x : q2.x\n    const minY1 = q1.y < q2.y ? q1.y : q2.y\n    const maxX1 = q1.x > q2.x ? q1.x : q2.x\n    const maxY1 = q1.y > q2.y ? q1.y : q2.y\n    const intMinX = minX0 > minX1 ? minX0 : minX1\n    const intMaxX = maxX0 < maxX1 ? maxX0 : maxX1\n    const intMinY = minY0 > minY1 ? minY0 : minY1\n    const intMaxY = maxY0 < maxY1 ? maxY0 : maxY1\n    const midx = (intMinX + intMaxX) / 2.0\n    const midy = (intMinY + intMaxY) / 2.0\n    const p1x = p1.x - midx\n    const p1y = p1.y - midy\n    const p2x = p2.x - midx\n    const p2y = p2.y - midy\n    const q1x = q1.x - midx\n    const q1y = q1.y - midy\n    const q2x = q2.x - midx\n    const q2y = q2.y - midy\n    const px = p1y - p2y\n    const py = p2x - p1x\n    const pw = p1x * p2y - p2x * p1y\n    const qx = q1y - q2y\n    const qy = q2x - q1x\n    const qw = q1x * q2y - q2x * q1y\n    const x = py * qw - qy * pw\n    const y = qx * pw - px * qw\n    const w = px * qy - qx * py\n    const xInt = x / w\n    const yInt = y / w\n    if (Double.isNaN(xInt) || (Double.isInfinite(xInt) || Double.isNaN(yInt)) || Double.isInfinite(yInt)) \n      return null\n    \n    return new Coordinate(xInt + midx, yInt + midy)\n  }\n}\n","export default class System {\n  static arraycopy(src, srcPos, dest, destPos, len) {\n    let c = 0\n    for (let i = srcPos; i < srcPos + len; i++) {\n      dest[destPos + c] = src[i]\n      c++\n    }\n  }\n\n  static getProperty(name) {\n    return {\n      'line.separator': '\\n'\n    }[name]\n  }\n}\n","import Double from '../../../../java/lang/Double'\nexport default class MathUtil {\n  static log10(x) {\n    const ln = Math.log(x)\n    if (Double.isInfinite(ln)) return ln\n    if (Double.isNaN(ln)) return ln\n    return ln / MathUtil.LOG_10\n  }\n  static min(v1, v2, v3, v4) {\n    let min = v1\n    if (v2 < min) min = v2\n    if (v3 < min) min = v3\n    if (v4 < min) min = v4\n    return min\n  }\n  static clamp() {\n    if (typeof arguments[2] === 'number' && (typeof arguments[0] === 'number' && typeof arguments[1] === 'number')) {\n      const x = arguments[0], min = arguments[1], max = arguments[2]\n      if (x < min) return min\n      if (x > max) return max\n      return x\n    } else if (Number.isInteger(arguments[2]) && (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1]))) {\n      const x = arguments[0], min = arguments[1], max = arguments[2]\n      if (x < min) return min\n      if (x > max) return max\n      return x\n    }\n  }\n  static wrap(index, max) {\n    if (index < 0) \n      return max - -index % max\n    \n    return index % max\n  }\n  static max() {\n    if (arguments.length === 3) {\n      const v1 = arguments[0], v2 = arguments[1], v3 = arguments[2]\n      let max = v1\n      if (v2 > max) max = v2\n      if (v3 > max) max = v3\n      return max\n    } else if (arguments.length === 4) {\n      const v1 = arguments[0], v2 = arguments[1], v3 = arguments[2], v4 = arguments[3]\n      let max = v1\n      if (v2 > max) max = v2\n      if (v3 > max) max = v3\n      if (v4 > max) max = v4\n      return max\n    }\n  }\n  static average(x1, x2) {\n    return (x1 + x2) / 2.0\n  }\n}\nMathUtil.LOG_10 = Math.log(10)\n","import IllegalArgumentException from '../../../../java/lang/IllegalArgumentException'\nimport MathUtil from '../math/MathUtil'\nimport Envelope from '../geom/Envelope'\nexport default class Distance {\n  static segmentToSegment(A, B, C, D) {\n    if (A.equals(B)) return Distance.pointToSegment(A, C, D)\n    if (C.equals(D)) return Distance.pointToSegment(D, A, B)\n    let noIntersection = false\n    if (!Envelope.intersects(A, B, C, D)) {\n      noIntersection = true\n    } else {\n      const denom = (B.x - A.x) * (D.y - C.y) - (B.y - A.y) * (D.x - C.x)\n      if (denom === 0) {\n        noIntersection = true\n      } else {\n        const r_num = (A.y - C.y) * (D.x - C.x) - (A.x - C.x) * (D.y - C.y)\n        const s_num = (A.y - C.y) * (B.x - A.x) - (A.x - C.x) * (B.y - A.y)\n        const s = s_num / denom\n        const r = r_num / denom\n        if (r < 0 || r > 1 || s < 0 || s > 1) \n          noIntersection = true\n        \n      }\n    }\n    if (noIntersection) \n      return MathUtil.min(Distance.pointToSegment(A, C, D), Distance.pointToSegment(B, C, D), Distance.pointToSegment(C, A, B), Distance.pointToSegment(D, A, B))\n    \n    return 0.0\n  }\n  static pointToSegment(p, A, B) {\n    if (A.x === B.x && A.y === B.y) return p.distance(A)\n    const len2 = (B.x - A.x) * (B.x - A.x) + (B.y - A.y) * (B.y - A.y)\n    const r = ((p.x - A.x) * (B.x - A.x) + (p.y - A.y) * (B.y - A.y)) / len2\n    if (r <= 0.0) return p.distance(A)\n    if (r >= 1.0) return p.distance(B)\n    const s = ((A.y - p.y) * (B.x - A.x) - (A.x - p.x) * (B.y - A.y)) / len2\n    return Math.abs(s) * Math.sqrt(len2)\n  }\n  static pointToLinePerpendicular(p, A, B) {\n    const len2 = (B.x - A.x) * (B.x - A.x) + (B.y - A.y) * (B.y - A.y)\n    const s = ((A.y - p.y) * (B.x - A.x) - (A.x - p.x) * (B.y - A.y)) / len2\n    return Math.abs(s) * Math.sqrt(len2)\n  }\n  static pointToSegmentString(p, line) {\n    if (line.length === 0) throw new IllegalArgumentException('Line array must contain at least one vertex')\n    let minDistance = p.distance(line[0])\n    for (let i = 0; i < line.length - 1; i++) {\n      const dist = Distance.pointToSegment(p, line[i], line[i + 1])\n      if (dist < minDistance) \n        minDistance = dist\n      \n    }\n    return minDistance\n  }\n}\n","import hasInterface from '../../../../hasInterface'\nimport CoordinateSequence from './CoordinateSequence'\nexport default class CoordinateSequenceFactory {\n  create() {\n    if (arguments.length === 1) {\n      if (arguments[0] instanceof Array) {\n        const coordinates = arguments[0]\n      } else if (hasInterface(arguments[0], CoordinateSequence)) {\n        const coordSeq = arguments[0]\n      }\n    } else if (arguments.length === 2) {\n      const size = arguments[0], dimension = arguments[1]\n    } else if (arguments.length === 3) {\n      const size = arguments[0], dimension = arguments[1], measures = arguments[2]\n      return this.create(size, dimension)\n    }\n  }\n}\n","export default class CoordinateFilter {\n  filter(coord) {}\n}\n","import Coordinate from '../geom/Coordinate'\nexport default class Length {\n  static ofLine(pts) {\n    const n = pts.size()\n    if (n <= 1) return 0.0\n    let len = 0.0\n    const p = new Coordinate()\n    pts.getCoordinate(0, p)\n    let x0 = p.x\n    let y0 = p.y\n    for (let i = 1; i < n; i++) {\n      pts.getCoordinate(i, p)\n      const x1 = p.x\n      const y1 = p.y\n      const dx = x1 - x0\n      const dy = y1 - y0\n      len += Math.sqrt(dx * dx + dy * dy)\n      x0 = x1\n      y0 = y1\n    }\n    return len\n  }\n}\n","export default class Lineal {}\n","import hasInterface from '../../../../hasInterface'\nimport Coordinate from './Coordinate'\nimport Double from '../../../../java/lang/Double'\nimport CoordinateSequence from './CoordinateSequence'\nexport default class CoordinateSequences {\n  static copyCoord(src, srcPos, dest, destPos) {\n    const minDim = Math.min(src.getDimension(), dest.getDimension())\n    for (let dim = 0; dim < minDim; dim++) \n      dest.setOrdinate(destPos, dim, src.getOrdinate(srcPos, dim))\n    \n  }\n  static isRing(seq) {\n    const n = seq.size()\n    if (n === 0) return true\n    if (n <= 3) return false\n    return seq.getOrdinate(0, CoordinateSequence.X) === seq.getOrdinate(n - 1, CoordinateSequence.X) && seq.getOrdinate(0, CoordinateSequence.Y) === seq.getOrdinate(n - 1, CoordinateSequence.Y)\n  }\n  static scroll() {\n    if (arguments.length === 2) {\n      if (hasInterface(arguments[0], CoordinateSequence) && Number.isInteger(arguments[1])) {\n        const seq = arguments[0], indexOfFirstCoordinate = arguments[1]\n        CoordinateSequences.scroll(seq, indexOfFirstCoordinate, CoordinateSequences.isRing(seq))\n      } else if (hasInterface(arguments[0], CoordinateSequence) && arguments[1] instanceof Coordinate) {\n        const seq = arguments[0], firstCoordinate = arguments[1]\n        const i = CoordinateSequences.indexOf(firstCoordinate, seq)\n        if (i <= 0) return null\n        CoordinateSequences.scroll(seq, i)\n      }\n    } else if (arguments.length === 3) {\n      const seq = arguments[0], indexOfFirstCoordinate = arguments[1], ensureRing = arguments[2]\n      const i = indexOfFirstCoordinate\n      if (i <= 0) return null\n      const copy = seq.copy()\n      const last = ensureRing ? seq.size() - 1 : seq.size()\n      for (let j = 0; j < last; j++) \n        for (let k = 0; k < seq.getDimension(); k++) seq.setOrdinate(j, k, copy.getOrdinate((indexOfFirstCoordinate + j) % last, k))\n      \n      if (ensureRing) \n        for (let k = 0; k < seq.getDimension(); k++) seq.setOrdinate(last, k, seq.getOrdinate(0, k))\n      \n    }\n  }\n  static isEqual(cs1, cs2) {\n    const cs1Size = cs1.size()\n    const cs2Size = cs2.size()\n    if (cs1Size !== cs2Size) return false\n    const dim = Math.min(cs1.getDimension(), cs2.getDimension())\n    for (let i = 0; i < cs1Size; i++) \n      for (let d = 0; d < dim; d++) {\n        const v1 = cs1.getOrdinate(i, d)\n        const v2 = cs2.getOrdinate(i, d)\n        if (cs1.getOrdinate(i, d) === cs2.getOrdinate(i, d)) continue\n        if (Double.isNaN(v1) && Double.isNaN(v2)) continue\n        return false\n      }\n    \n    return true\n  }\n  static minCoordinateIndex() {\n    if (arguments.length === 1) {\n      const seq = arguments[0]\n      return CoordinateSequences.minCoordinateIndex(seq, 0, seq.size() - 1)\n    } else if (arguments.length === 3) {\n      const seq = arguments[0], from = arguments[1], to = arguments[2]\n      let minCoordIndex = -1\n      let minCoord = null\n      for (let i = from; i <= to; i++) {\n        const testCoord = seq.getCoordinate(i)\n        if (minCoord === null || minCoord.compareTo(testCoord) > 0) {\n          minCoord = testCoord\n          minCoordIndex = i\n        }\n      }\n      return minCoordIndex\n    }\n  }\n  static extend(fact, seq, size) {\n    const newseq = fact.create(size, seq.getDimension())\n    const n = seq.size()\n    CoordinateSequences.copy(seq, 0, newseq, 0, n)\n    if (n > 0) \n      for (let i = n; i < size; i++) CoordinateSequences.copy(seq, n - 1, newseq, i, 1)\n    \n    return newseq\n  }\n  static reverse(seq) {\n    const last = seq.size() - 1\n    const mid = Math.trunc(last / 2)\n    for (let i = 0; i <= mid; i++) \n      CoordinateSequences.swap(seq, i, last - i)\n    \n  }\n  static swap(seq, i, j) {\n    if (i === j) return null\n    for (let dim = 0; dim < seq.getDimension(); dim++) {\n      const tmp = seq.getOrdinate(i, dim)\n      seq.setOrdinate(i, dim, seq.getOrdinate(j, dim))\n      seq.setOrdinate(j, dim, tmp)\n    }\n  }\n  static copy(src, srcPos, dest, destPos, length) {\n    for (let i = 0; i < length; i++) \n      CoordinateSequences.copyCoord(src, srcPos + i, dest, destPos + i)\n    \n  }\n  static ensureValidRing(fact, seq) {\n    const n = seq.size()\n    if (n === 0) return seq\n    if (n <= 3) return CoordinateSequences.createClosedRing(fact, seq, 4)\n    const isClosed = seq.getOrdinate(0, CoordinateSequence.X) === seq.getOrdinate(n - 1, CoordinateSequence.X) && seq.getOrdinate(0, CoordinateSequence.Y) === seq.getOrdinate(n - 1, CoordinateSequence.Y)\n    if (isClosed) return seq\n    return CoordinateSequences.createClosedRing(fact, seq, n + 1)\n  }\n  static indexOf(coordinate, seq) {\n    for (let i = 0; i < seq.size(); i++) \n      if (coordinate.x === seq.getOrdinate(i, CoordinateSequence.X) && coordinate.y === seq.getOrdinate(i, CoordinateSequence.Y)) \n        return i\n      \n    \n    return -1\n  }\n  static createClosedRing(fact, seq, size) {\n    const newseq = fact.create(size, seq.getDimension())\n    const n = seq.size()\n    CoordinateSequences.copy(seq, 0, newseq, 0, n)\n    for (let i = n; i < size; i++) CoordinateSequences.copy(seq, 0, newseq, i, 1)\n    return newseq\n  }\n  static minCoordinate(seq) {\n    let minCoord = null\n    for (let i = 0; i < seq.size(); i++) {\n      const testCoord = seq.getCoordinate(i)\n      if (minCoord === null || minCoord.compareTo(testCoord) > 0) \n        minCoord = testCoord\n      \n    }\n    return minCoord\n  }\n}\n","import IllegalArgumentException from '../../../../java/lang/IllegalArgumentException'\nimport Character from '../../../../java/lang/Character'\nexport default class Dimension {\n  static toDimensionSymbol(dimensionValue) {\n    switch (dimensionValue) {\n    case Dimension.FALSE:\n      return Dimension.SYM_FALSE\n    case Dimension.TRUE:\n      return Dimension.SYM_TRUE\n    case Dimension.DONTCARE:\n      return Dimension.SYM_DONTCARE\n    case Dimension.P:\n      return Dimension.SYM_P\n    case Dimension.L:\n      return Dimension.SYM_L\n    case Dimension.A:\n      return Dimension.SYM_A\n    }\n    throw new IllegalArgumentException('Unknown dimension value: ' + dimensionValue)\n  }\n  static toDimensionValue(dimensionSymbol) {\n    switch (Character.toUpperCase(dimensionSymbol)) {\n    case Dimension.SYM_FALSE:\n      return Dimension.FALSE\n    case Dimension.SYM_TRUE:\n      return Dimension.TRUE\n    case Dimension.SYM_DONTCARE:\n      return Dimension.DONTCARE\n    case Dimension.SYM_P:\n      return Dimension.P\n    case Dimension.SYM_L:\n      return Dimension.L\n    case Dimension.SYM_A:\n      return Dimension.A\n    }\n    throw new IllegalArgumentException('Unknown dimension symbol: ' + dimensionSymbol)\n  }\n}\nDimension.P = 0\nDimension.L = 1\nDimension.A = 2\nDimension.FALSE = -1\nDimension.TRUE = -2\nDimension.DONTCARE = -3\nDimension.SYM_FALSE = 'F'\nDimension.SYM_TRUE = 'T'\nDimension.SYM_DONTCARE = '*'\nDimension.SYM_P = '0'\nDimension.SYM_L = '1'\nDimension.SYM_A = '2'\n","export default class GeometryFilter {\n  filter(geom) {}\n}\n","export default class CoordinateSequenceFilter {\n  filter(seq, i) {}\n  isDone() {}\n  isGeometryChanged() {}\n}\n","import Geometry from './Geometry'\nimport CoordinateFilter from './CoordinateFilter'\nimport hasInterface from '../../../../hasInterface'\nimport Length from '../algorithm/Length'\nimport IllegalArgumentException from '../../../../java/lang/IllegalArgumentException'\nimport Lineal from './Lineal'\nimport CoordinateSequences from './CoordinateSequences'\nimport GeometryComponentFilter from './GeometryComponentFilter'\nimport UnsupportedOperationException from '../../../../java/lang/UnsupportedOperationException'\nimport Dimension from './Dimension'\nimport GeometryFilter from './GeometryFilter'\nimport CoordinateSequenceFilter from './CoordinateSequenceFilter'\nimport Envelope from './Envelope'\nexport default class LineString extends Geometry {\n  constructor() {\n    super()\n    LineString.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._points = null\n    if (arguments.length === 0) {} else if (arguments.length === 2) {\n      const points = arguments[0], factory = arguments[1]\n      Geometry.constructor_.call(this, factory)\n      this.init(points)\n    }\n  }\n  computeEnvelopeInternal() {\n    if (this.isEmpty()) \n      return new Envelope()\n    \n    return this._points.expandEnvelope(new Envelope())\n  }\n  isRing() {\n    return this.isClosed() && this.isSimple()\n  }\n  getCoordinates() {\n    return this._points.toCoordinateArray()\n  }\n  copyInternal() {\n    return new LineString(this._points.copy(), this._factory)\n  }\n  equalsExact() {\n    if (arguments.length === 2 && (typeof arguments[1] === 'number' && arguments[0] instanceof Geometry)) {\n      const other = arguments[0], tolerance = arguments[1]\n      if (!this.isEquivalentClass(other)) \n        return false\n      \n      const otherLineString = other\n      if (this._points.size() !== otherLineString._points.size()) \n        return false\n      \n      for (let i = 0; i < this._points.size(); i++) \n        if (!this.equal(this._points.getCoordinate(i), otherLineString._points.getCoordinate(i), tolerance)) \n          return false\n        \n      \n      return true\n    } else {\n      return super.equalsExact.apply(this, arguments)\n    }\n  }\n  normalize() {\n    for (let i = 0; i < Math.trunc(this._points.size() / 2); i++) {\n      const j = this._points.size() - 1 - i\n      if (!this._points.getCoordinate(i).equals(this._points.getCoordinate(j))) {\n        if (this._points.getCoordinate(i).compareTo(this._points.getCoordinate(j)) > 0) {\n          const copy = this._points.copy()\n          CoordinateSequences.reverse(copy)\n          this._points = copy\n        }\n        return null\n      }\n    }\n  }\n  getCoordinate() {\n    if (this.isEmpty()) return null\n    return this._points.getCoordinate(0)\n  }\n  getBoundaryDimension() {\n    if (this.isClosed()) \n      return Dimension.FALSE\n    \n    return 0\n  }\n  isClosed() {\n    if (this.isEmpty()) \n      return false\n    \n    return this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints() - 1))\n  }\n  reverseInternal() {\n    const seq = this._points.copy()\n    CoordinateSequences.reverse(seq)\n    return this.getFactory().createLineString(seq)\n  }\n  getEndPoint() {\n    if (this.isEmpty()) \n      return null\n    \n    return this.getPointN(this.getNumPoints() - 1)\n  }\n  getTypeCode() {\n    return Geometry.TYPECODE_LINESTRING\n  }\n  getDimension() {\n    return 1\n  }\n  getLength() {\n    return Length.ofLine(this._points)\n  }\n  getNumPoints() {\n    return this._points.size()\n  }\n  compareToSameClass() {\n    if (arguments.length === 1) {\n      const o = arguments[0]\n      const line = o\n      let i = 0\n      let j = 0\n      while (i < this._points.size() && j < line._points.size()) {\n        const comparison = this._points.getCoordinate(i).compareTo(line._points.getCoordinate(j))\n        if (comparison !== 0) \n          return comparison\n        \n        i++\n        j++\n      }\n      if (i < this._points.size()) \n        return 1\n      \n      if (j < line._points.size()) \n        return -1\n      \n      return 0\n    } else if (arguments.length === 2) {\n      const o = arguments[0], comp = arguments[1]\n      const line = o\n      return comp.compare(this._points, line._points)\n    }\n  }\n  apply() {\n    if (hasInterface(arguments[0], CoordinateFilter)) {\n      const filter = arguments[0]\n      for (let i = 0; i < this._points.size(); i++) \n        filter.filter(this._points.getCoordinate(i))\n      \n    } else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {\n      const filter = arguments[0]\n      if (this._points.size() === 0) return null\n      for (let i = 0; i < this._points.size(); i++) {\n        filter.filter(this._points, i)\n        if (filter.isDone()) break\n      }\n      if (filter.isGeometryChanged()) this.geometryChanged()\n    } else if (hasInterface(arguments[0], GeometryFilter)) {\n      const filter = arguments[0]\n      filter.filter(this)\n    } else if (hasInterface(arguments[0], GeometryComponentFilter)) {\n      const filter = arguments[0]\n      filter.filter(this)\n    }\n  }\n  getBoundary() {\n    throw new UnsupportedOperationException()\n  }\n  isEquivalentClass(other) {\n    return other instanceof LineString\n  }\n  getCoordinateN(n) {\n    return this._points.getCoordinate(n)\n  }\n  getGeometryType() {\n    return Geometry.TYPENAME_LINESTRING\n  }\n  getCoordinateSequence() {\n    return this._points\n  }\n  isEmpty() {\n    return this._points.size() === 0\n  }\n  init(points) {\n    if (points === null) \n      points = this.getFactory().getCoordinateSequenceFactory().create([])\n    \n    if (points.size() === 1) \n      throw new IllegalArgumentException('Invalid number of points in LineString (found ' + points.size() + ' - must be 0 or >= 2)')\n    \n    this._points = points\n  }\n  isCoordinate(pt) {\n    for (let i = 0; i < this._points.size(); i++) \n      if (this._points.getCoordinate(i).equals(pt)) \n        return true\n      \n    \n    return false\n  }\n  getStartPoint() {\n    if (this.isEmpty()) \n      return null\n    \n    return this.getPointN(0)\n  }\n  getPointN(n) {\n    return this.getFactory().createPoint(this._points.getCoordinate(n))\n  }\n  get interfaces_() {\n    return [Lineal]\n  }\n}\n","export default class Puntal {}\n","import Geometry from './Geometry'\nimport CoordinateFilter from './CoordinateFilter'\nimport hasInterface from '../../../../hasInterface'\nimport GeometryComponentFilter from './GeometryComponentFilter'\nimport Dimension from './Dimension'\nimport GeometryFilter from './GeometryFilter'\nimport CoordinateSequenceFilter from './CoordinateSequenceFilter'\nimport Puntal from './Puntal'\nimport Envelope from './Envelope'\nimport Assert from '../util/Assert'\nexport default class Point extends Geometry {\n  constructor() {\n    super()\n    Point.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._coordinates = null\n    const coordinates = arguments[0], factory = arguments[1]\n    Geometry.constructor_.call(this, factory)\n    this.init(coordinates)\n  }\n  computeEnvelopeInternal() {\n    if (this.isEmpty()) \n      return new Envelope()\n    \n    const env = new Envelope()\n    env.expandToInclude(this._coordinates.getX(0), this._coordinates.getY(0))\n    return env\n  }\n  getCoordinates() {\n    return this.isEmpty() ? [] : [this.getCoordinate()]\n  }\n  copyInternal() {\n    return new Point(this._coordinates.copy(), this._factory)\n  }\n  equalsExact() {\n    if (arguments.length === 2 && (typeof arguments[1] === 'number' && arguments[0] instanceof Geometry)) {\n      const other = arguments[0], tolerance = arguments[1]\n      if (!this.isEquivalentClass(other)) \n        return false\n      \n      if (this.isEmpty() && other.isEmpty()) \n        return true\n      \n      if (this.isEmpty() !== other.isEmpty()) \n        return false\n      \n      return this.equal(other.getCoordinate(), this.getCoordinate(), tolerance)\n    } else {\n      return super.equalsExact.apply(this, arguments)\n    }\n  }\n  normalize() {}\n  getCoordinate() {\n    return this._coordinates.size() !== 0 ? this._coordinates.getCoordinate(0) : null\n  }\n  getBoundaryDimension() {\n    return Dimension.FALSE\n  }\n  reverseInternal() {\n    return this.getFactory().createPoint(this._coordinates.copy())\n  }\n  getTypeCode() {\n    return Geometry.TYPECODE_POINT\n  }\n  getDimension() {\n    return 0\n  }\n  getNumPoints() {\n    return this.isEmpty() ? 0 : 1\n  }\n  getX() {\n    if (this.getCoordinate() === null) \n      throw new IllegalStateException('getX called on empty Point')\n    \n    return this.getCoordinate().x\n  }\n  compareToSameClass() {\n    if (arguments.length === 1) {\n      const other = arguments[0]\n      const point = other\n      return this.getCoordinate().compareTo(point.getCoordinate())\n    } else if (arguments.length === 2) {\n      const other = arguments[0], comp = arguments[1]\n      const point = other\n      return comp.compare(this._coordinates, point._coordinates)\n    }\n  }\n  apply() {\n    if (hasInterface(arguments[0], CoordinateFilter)) {\n      const filter = arguments[0]\n      if (this.isEmpty()) \n        return null\n      \n      filter.filter(this.getCoordinate())\n    } else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {\n      const filter = arguments[0]\n      if (this.isEmpty()) return null\n      filter.filter(this._coordinates, 0)\n      if (filter.isGeometryChanged()) this.geometryChanged()\n    } else if (hasInterface(arguments[0], GeometryFilter)) {\n      const filter = arguments[0]\n      filter.filter(this)\n    } else if (hasInterface(arguments[0], GeometryComponentFilter)) {\n      const filter = arguments[0]\n      filter.filter(this)\n    }\n  }\n  getBoundary() {\n    return this.getFactory().createGeometryCollection()\n  }\n  getGeometryType() {\n    return Geometry.TYPENAME_POINT\n  }\n  getCoordinateSequence() {\n    return this._coordinates\n  }\n  getY() {\n    if (this.getCoordinate() === null) \n      throw new IllegalStateException('getY called on empty Point')\n    \n    return this.getCoordinate().y\n  }\n  isEmpty() {\n    return this._coordinates.size() === 0\n  }\n  init(coordinates) {\n    if (coordinates === null) \n      coordinates = this.getFactory().getCoordinateSequenceFactory().create([])\n    \n    Assert.isTrue(coordinates.size() <= 1)\n    this._coordinates = coordinates\n  }\n  isSimple() {\n    return true\n  }\n  get interfaces_() {\n    return [Puntal]\n  }\n}\n","import hasInterface from '../../../../hasInterface'\nimport Coordinate from '../geom/Coordinate'\nimport CoordinateSequence from '../geom/CoordinateSequence'\nexport default class Area {\n  static ofRing() {\n    if (arguments[0] instanceof Array) {\n      const ring = arguments[0]\n      return Math.abs(Area.ofRingSigned(ring))\n    } else if (hasInterface(arguments[0], CoordinateSequence)) {\n      const ring = arguments[0]\n      return Math.abs(Area.ofRingSigned(ring))\n    }\n  }\n  static ofRingSigned() {\n    if (arguments[0] instanceof Array) {\n      const ring = arguments[0]\n      if (ring.length < 3) return 0.0\n      let sum = 0.0\n      const x0 = ring[0].x\n      for (let i = 1; i < ring.length - 1; i++) {\n        const x = ring[i].x - x0\n        const y1 = ring[i + 1].y\n        const y2 = ring[i - 1].y\n        sum += x * (y2 - y1)\n      }\n      return sum / 2.0\n    } else if (hasInterface(arguments[0], CoordinateSequence)) {\n      const ring = arguments[0]\n      const n = ring.size()\n      if (n < 3) return 0.0\n      const p0 = new Coordinate()\n      const p1 = new Coordinate()\n      const p2 = new Coordinate()\n      ring.getCoordinate(0, p1)\n      ring.getCoordinate(1, p2)\n      const x0 = p1.x\n      p2.x -= x0\n      let sum = 0.0\n      for (let i = 1; i < n - 1; i++) {\n        p0.y = p1.y\n        p1.x = p2.x\n        p1.y = p2.y\n        ring.getCoordinate(i + 1, p2)\n        p2.x -= x0\n        sum += p1.x * (p0.y - p2.y)\n      }\n      return sum / 2.0\n    }\n  }\n}\n","import ArrayList from './ArrayList'\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/Arrays.html\n */\nexport default class Arrays {\n  static sort() {\n    const a = arguments[0]\n    if (arguments.length === 1) {\n      a.sort((a, b) => a.compareTo(b))\n    } else if (arguments.length === 2) {\n      a.sort((a, b) => arguments[1].compare(a, b))\n    } else if (arguments.length === 3) {\n      const t = a.slice(arguments[1], arguments[2])\n      t.sort()\n      const r = a.slice(0, arguments[1]).concat(t, a.slice(arguments[2], a.length))\n      a.splice(0, a.length)\n      for (const e of r)\n        a.push(e)\n    } else if (arguments.length === 4) {\n      const t = a.slice(arguments[1], arguments[2])\n      t.sort((a, b) => arguments[3].compare(a, b))\n      const r = a.slice(0, arguments[1]).concat(t, a.slice(arguments[2], a.length))\n      a.splice(0, a.length)\n      for (const e of r)\n        a.push(e)\n    }\n  }\n\n  /**\n   * @param {Array} array\n   * @return {ArrayList}\n   */\n  static asList(array) {\n    const arrayList = new ArrayList()\n    for (const e of array)\n      arrayList.add(e)\n    return arrayList\n  }\n\n  static copyOf(original, newLength) {\n    return original.slice(0, newLength)\n  }\n}\n","export default class Polygonal {}\n","import Area from '../algorithm/Area'\nimport Geometry from './Geometry'\nimport Arrays from '../../../../java/util/Arrays'\nimport CoordinateFilter from './CoordinateFilter'\nimport hasInterface from '../../../../hasInterface'\nimport IllegalArgumentException from '../../../../java/lang/IllegalArgumentException'\nimport Orientation from '../algorithm/Orientation'\nimport CoordinateSequences from './CoordinateSequences'\nimport GeometryComponentFilter from './GeometryComponentFilter'\nimport Polygonal from './Polygonal'\nimport GeometryFilter from './GeometryFilter'\nimport CoordinateSequenceFilter from './CoordinateSequenceFilter'\nexport default class Polygon extends Geometry {\n  constructor() {\n    super()\n    Polygon.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._shell = null\n    this._holes = null\n    let shell = arguments[0], holes = arguments[1], factory = arguments[2]\n    Geometry.constructor_.call(this, factory)\n    if (shell === null) \n      shell = this.getFactory().createLinearRing()\n    \n    if (holes === null) \n      holes = []\n    \n    if (Geometry.hasNullElements(holes)) \n      throw new IllegalArgumentException('holes must not contain null elements')\n    \n    if (shell.isEmpty() && Geometry.hasNonEmptyElements(holes)) \n      throw new IllegalArgumentException('shell is empty but holes are not')\n    \n    this._shell = shell\n    this._holes = holes\n  }\n  computeEnvelopeInternal() {\n    return this._shell.getEnvelopeInternal()\n  }\n  getCoordinates() {\n    if (this.isEmpty()) \n      return []\n    \n    const coordinates = new Array(this.getNumPoints()).fill(null)\n    let k = -1\n    const shellCoordinates = this._shell.getCoordinates()\n    for (let x = 0; x < shellCoordinates.length; x++) {\n      k++\n      coordinates[k] = shellCoordinates[x]\n    }\n    for (let i = 0; i < this._holes.length; i++) {\n      const childCoordinates = this._holes[i].getCoordinates()\n      for (let j = 0; j < childCoordinates.length; j++) {\n        k++\n        coordinates[k] = childCoordinates[j]\n      }\n    }\n    return coordinates\n  }\n  getArea() {\n    let area = 0.0\n    area += Area.ofRing(this._shell.getCoordinateSequence())\n    for (let i = 0; i < this._holes.length; i++) \n      area -= Area.ofRing(this._holes[i].getCoordinateSequence())\n    \n    return area\n  }\n  copyInternal() {\n    const shellCopy = this._shell.copy()\n    const holeCopies = new Array(this._holes.length).fill(null)\n    for (let i = 0; i < this._holes.length; i++) \n      holeCopies[i] = this._holes[i].copy()\n    \n    return new Polygon(shellCopy, holeCopies, this._factory)\n  }\n  isRectangle() {\n    if (this.getNumInteriorRing() !== 0) return false\n    if (this._shell === null) return false\n    if (this._shell.getNumPoints() !== 5) return false\n    const seq = this._shell.getCoordinateSequence()\n    const env = this.getEnvelopeInternal()\n    for (let i = 0; i < 5; i++) {\n      const x = seq.getX(i)\n      if (!(x === env.getMinX() || x === env.getMaxX())) return false\n      const y = seq.getY(i)\n      if (!(y === env.getMinY() || y === env.getMaxY())) return false\n    }\n    let prevX = seq.getX(0)\n    let prevY = seq.getY(0)\n    for (let i = 1; i <= 4; i++) {\n      const x = seq.getX(i)\n      const y = seq.getY(i)\n      const xChanged = x !== prevX\n      const yChanged = y !== prevY\n      if (xChanged === yChanged) return false\n      prevX = x\n      prevY = y\n    }\n    return true\n  }\n  equalsExact() {\n    if (arguments.length === 2 && (typeof arguments[1] === 'number' && arguments[0] instanceof Geometry)) {\n      const other = arguments[0], tolerance = arguments[1]\n      if (!this.isEquivalentClass(other)) \n        return false\n      \n      const otherPolygon = other\n      const thisShell = this._shell\n      const otherPolygonShell = otherPolygon._shell\n      if (!thisShell.equalsExact(otherPolygonShell, tolerance)) \n        return false\n      \n      if (this._holes.length !== otherPolygon._holes.length) \n        return false\n      \n      for (let i = 0; i < this._holes.length; i++) \n        if (!this._holes[i].equalsExact(otherPolygon._holes[i], tolerance)) \n          return false\n        \n      \n      return true\n    } else {\n      return super.equalsExact.apply(this, arguments)\n    }\n  }\n  normalize() {\n    if (arguments.length === 0) {\n      this._shell = this.normalized(this._shell, true)\n      for (let i = 0; i < this._holes.length; i++) \n        this._holes[i] = this.normalized(this._holes[i], false)\n      \n      Arrays.sort(this._holes)\n    } else if (arguments.length === 2) {\n      const ring = arguments[0], clockwise = arguments[1]\n      if (ring.isEmpty()) \n        return null\n      \n      const seq = ring.getCoordinateSequence()\n      const minCoordinateIndex = CoordinateSequences.minCoordinateIndex(seq, 0, seq.size() - 2)\n      CoordinateSequences.scroll(seq, minCoordinateIndex, true)\n      if (Orientation.isCCW(seq) === clockwise) CoordinateSequences.reverse(seq)\n    }\n  }\n  getCoordinate() {\n    return this._shell.getCoordinate()\n  }\n  getNumInteriorRing() {\n    return this._holes.length\n  }\n  getBoundaryDimension() {\n    return 1\n  }\n  reverseInternal() {\n    const shell = this.getExteriorRing().reverse()\n    const holes = new Array(this.getNumInteriorRing()).fill(null)\n    for (let i = 0; i < holes.length; i++) \n      holes[i] = this.getInteriorRingN(i).reverse()\n    \n    return this.getFactory().createPolygon(shell, holes)\n  }\n  getTypeCode() {\n    return Geometry.TYPECODE_POLYGON\n  }\n  getDimension() {\n    return 2\n  }\n  getLength() {\n    let len = 0.0\n    len += this._shell.getLength()\n    for (let i = 0; i < this._holes.length; i++) \n      len += this._holes[i].getLength()\n    \n    return len\n  }\n  getNumPoints() {\n    let numPoints = this._shell.getNumPoints()\n    for (let i = 0; i < this._holes.length; i++) \n      numPoints += this._holes[i].getNumPoints()\n    \n    return numPoints\n  }\n  convexHull() {\n    return this.getExteriorRing().convexHull()\n  }\n  normalized(ring, clockwise) {\n    const res = ring.copy()\n    this.normalize(res, clockwise)\n    return res\n  }\n  compareToSameClass() {\n    if (arguments.length === 1) {\n      const o = arguments[0]\n      const thisShell = this._shell\n      const otherShell = o._shell\n      return thisShell.compareToSameClass(otherShell)\n    } else if (arguments.length === 2) {\n      const o = arguments[0], comp = arguments[1]\n      const poly = o\n      const thisShell = this._shell\n      const otherShell = poly._shell\n      const shellComp = thisShell.compareToSameClass(otherShell, comp)\n      if (shellComp !== 0) return shellComp\n      const nHole1 = this.getNumInteriorRing()\n      const nHole2 = poly.getNumInteriorRing()\n      let i = 0\n      while (i < nHole1 && i < nHole2) {\n        const thisHole = this.getInteriorRingN(i)\n        const otherHole = poly.getInteriorRingN(i)\n        const holeComp = thisHole.compareToSameClass(otherHole, comp)\n        if (holeComp !== 0) return holeComp\n        i++\n      }\n      if (i < nHole1) return 1\n      if (i < nHole2) return -1\n      return 0\n    }\n  }\n  apply() {\n    if (hasInterface(arguments[0], CoordinateFilter)) {\n      const filter = arguments[0]\n      this._shell.apply(filter)\n      for (let i = 0; i < this._holes.length; i++) \n        this._holes[i].apply(filter)\n      \n    } else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {\n      const filter = arguments[0]\n      this._shell.apply(filter)\n      if (!filter.isDone()) \n        for (let i = 0; i < this._holes.length; i++) {\n          this._holes[i].apply(filter)\n          if (filter.isDone()) break\n        }\n      \n      if (filter.isGeometryChanged()) this.geometryChanged()\n    } else if (hasInterface(arguments[0], GeometryFilter)) {\n      const filter = arguments[0]\n      filter.filter(this)\n    } else if (hasInterface(arguments[0], GeometryComponentFilter)) {\n      const filter = arguments[0]\n      filter.filter(this)\n      this._shell.apply(filter)\n      for (let i = 0; i < this._holes.length; i++) \n        this._holes[i].apply(filter)\n      \n    }\n  }\n  getBoundary() {\n    if (this.isEmpty()) \n      return this.getFactory().createMultiLineString()\n    \n    const rings = new Array(this._holes.length + 1).fill(null)\n    rings[0] = this._shell\n    for (let i = 0; i < this._holes.length; i++) \n      rings[i + 1] = this._holes[i]\n    \n    if (rings.length <= 1) return this.getFactory().createLinearRing(rings[0].getCoordinateSequence())\n    return this.getFactory().createMultiLineString(rings)\n  }\n  getGeometryType() {\n    return Geometry.TYPENAME_POLYGON\n  }\n  getExteriorRing() {\n    return this._shell\n  }\n  isEmpty() {\n    return this._shell.isEmpty()\n  }\n  getInteriorRingN(n) {\n    return this._holes[n]\n  }\n  get interfaces_() {\n    return [Polygonal]\n  }\n}\n","import Set from './Set'\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/SortedSet.html\n */\nexport default class SortedSet extends Set {}\n","import Collection from './Collection'\nimport NoSuchElementException from './NoSuchElementException'\nimport UnsupportedOperationException from '../lang/UnsupportedOperationException'\nimport SortedSet from './SortedSet'\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/TreeSet.html\n */\nexport default class TreeSet extends SortedSet {\n  constructor(o) {\n    super()\n    this.array = []\n    if (o instanceof Collection)\n      this.addAll(o)\n  }\n\n  contains(o) {\n    for (const e of this.array)\n      if (e.compareTo(o) === 0)\n        return true\n    return false\n  }\n\n  add(o) {\n    if (this.contains(o))\n      return false\n    for (let i = 0, len = this.array.length; i < len; i++) {\n      const e = this.array[i]\n      if (e.compareTo(o) === 1)\n        return !!this.array.splice(i, 0, o)\n    }\n    this.array.push(o)\n    return true\n  }\n\n  addAll(c) {\n    for (const e of c)\n      this.add(e)\n    return true\n  }\n\n  remove() {\n    throw new UnsupportedOperationException()\n  }\n\n  size() {\n    return this.array.length\n  }\n\n  isEmpty() {\n    return this.array.length === 0\n  }\n\n  toArray() {\n    return this.array.slice()\n  }\n\n  iterator() {\n    return new Iterator(this.array)\n  }\n}\n\nclass Iterator {\n  constructor(array) {\n    this.array = array\n    this.position = 0\n  }\n\n  next() {\n    if (this.position === this.array.length)\n      throw new NoSuchElementException()\n    return this.array[this.position++]\n  }\n\n  hasNext() {\n    return this.position < this.array.length\n  }\n\n  remove() {\n    throw new UnsupportedOperationException()\n  }\n}\n","import TreeSet from '../../../../java/util/TreeSet'\nimport Geometry from './Geometry'\nimport Arrays from '../../../../java/util/Arrays'\nimport CoordinateFilter from './CoordinateFilter'\nimport hasInterface from '../../../../hasInterface'\nimport IllegalArgumentException from '../../../../java/lang/IllegalArgumentException'\nimport GeometryComponentFilter from './GeometryComponentFilter'\nimport Dimension from './Dimension'\nimport ArrayList from '../../../../java/util/ArrayList'\nimport GeometryFilter from './GeometryFilter'\nimport CoordinateSequenceFilter from './CoordinateSequenceFilter'\nimport Envelope from './Envelope'\nimport Assert from '../util/Assert'\nexport default class GeometryCollection extends Geometry {\n  constructor() {\n    super()\n    GeometryCollection.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._geometries = null\n    if (arguments.length === 0) {} else if (arguments.length === 2) {\n      let geometries = arguments[0], factory = arguments[1]\n      Geometry.constructor_.call(this, factory)\n      if (geometries === null) \n        geometries = []\n      \n      if (Geometry.hasNullElements(geometries)) \n        throw new IllegalArgumentException('geometries must not contain null elements')\n      \n      this._geometries = geometries\n    }\n  }\n  computeEnvelopeInternal() {\n    const envelope = new Envelope()\n    for (let i = 0; i < this._geometries.length; i++) \n      envelope.expandToInclude(this._geometries[i].getEnvelopeInternal())\n    \n    return envelope\n  }\n  getGeometryN(n) {\n    return this._geometries[n]\n  }\n  getCoordinates() {\n    const coordinates = new Array(this.getNumPoints()).fill(null)\n    let k = -1\n    for (let i = 0; i < this._geometries.length; i++) {\n      const childCoordinates = this._geometries[i].getCoordinates()\n      for (let j = 0; j < childCoordinates.length; j++) {\n        k++\n        coordinates[k] = childCoordinates[j]\n      }\n    }\n    return coordinates\n  }\n  getArea() {\n    let area = 0.0\n    for (let i = 0; i < this._geometries.length; i++) \n      area += this._geometries[i].getArea()\n    \n    return area\n  }\n  copyInternal() {\n    const geometries = new Array(this._geometries.length).fill(null)\n    for (let i = 0; i < geometries.length; i++) \n      geometries[i] = this._geometries[i].copy()\n    \n    return new GeometryCollection(geometries, this._factory)\n  }\n  equalsExact() {\n    if (arguments.length === 2 && (typeof arguments[1] === 'number' && arguments[0] instanceof Geometry)) {\n      const other = arguments[0], tolerance = arguments[1]\n      if (!this.isEquivalentClass(other)) \n        return false\n      \n      const otherCollection = other\n      if (this._geometries.length !== otherCollection._geometries.length) \n        return false\n      \n      for (let i = 0; i < this._geometries.length; i++) \n        if (!this._geometries[i].equalsExact(otherCollection._geometries[i], tolerance)) \n          return false\n        \n      \n      return true\n    } else {\n      return super.equalsExact.apply(this, arguments)\n    }\n  }\n  normalize() {\n    for (let i = 0; i < this._geometries.length; i++) \n      this._geometries[i].normalize()\n    \n    Arrays.sort(this._geometries)\n  }\n  getCoordinate() {\n    if (this.isEmpty()) return null\n    return this._geometries[0].getCoordinate()\n  }\n  getBoundaryDimension() {\n    let dimension = Dimension.FALSE\n    for (let i = 0; i < this._geometries.length; i++) \n      dimension = Math.max(dimension, this._geometries[i].getBoundaryDimension())\n    \n    return dimension\n  }\n  reverseInternal() {\n    const numGeometries = this._geometries.length\n    const reversed = new ArrayList(numGeometries)\n    for (let i = 0; i < numGeometries; i++) \n      reversed.add(this._geometries[i].reverse())\n    \n    return this.getFactory().buildGeometry(reversed)\n  }\n  getTypeCode() {\n    return Geometry.TYPECODE_GEOMETRYCOLLECTION\n  }\n  getDimension() {\n    let dimension = Dimension.FALSE\n    for (let i = 0; i < this._geometries.length; i++) \n      dimension = Math.max(dimension, this._geometries[i].getDimension())\n    \n    return dimension\n  }\n  getLength() {\n    let sum = 0.0\n    for (let i = 0; i < this._geometries.length; i++) \n      sum += this._geometries[i].getLength()\n    \n    return sum\n  }\n  getNumPoints() {\n    let numPoints = 0\n    for (let i = 0; i < this._geometries.length; i++) \n      numPoints += this._geometries[i].getNumPoints()\n    \n    return numPoints\n  }\n  getNumGeometries() {\n    return this._geometries.length\n  }\n  compareToSameClass() {\n    if (arguments.length === 1) {\n      const o = arguments[0]\n      const theseElements = new TreeSet(Arrays.asList(this._geometries))\n      const otherElements = new TreeSet(Arrays.asList(o._geometries))\n      return this.compare(theseElements, otherElements)\n    } else if (arguments.length === 2) {\n      const o = arguments[0], comp = arguments[1]\n      const gc = o\n      const n1 = this.getNumGeometries()\n      const n2 = gc.getNumGeometries()\n      let i = 0\n      while (i < n1 && i < n2) {\n        const thisGeom = this.getGeometryN(i)\n        const otherGeom = gc.getGeometryN(i)\n        const holeComp = thisGeom.compareToSameClass(otherGeom, comp)\n        if (holeComp !== 0) return holeComp\n        i++\n      }\n      if (i < n1) return 1\n      if (i < n2) return -1\n      return 0\n    }\n  }\n  apply() {\n    if (hasInterface(arguments[0], CoordinateFilter)) {\n      const filter = arguments[0]\n      for (let i = 0; i < this._geometries.length; i++) \n        this._geometries[i].apply(filter)\n      \n    } else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {\n      const filter = arguments[0]\n      if (this._geometries.length === 0) return null\n      for (let i = 0; i < this._geometries.length; i++) {\n        this._geometries[i].apply(filter)\n        if (filter.isDone()) \n          break\n        \n      }\n      if (filter.isGeometryChanged()) this.geometryChanged()\n    } else if (hasInterface(arguments[0], GeometryFilter)) {\n      const filter = arguments[0]\n      filter.filter(this)\n      for (let i = 0; i < this._geometries.length; i++) \n        this._geometries[i].apply(filter)\n      \n    } else if (hasInterface(arguments[0], GeometryComponentFilter)) {\n      const filter = arguments[0]\n      filter.filter(this)\n      for (let i = 0; i < this._geometries.length; i++) \n        this._geometries[i].apply(filter)\n      \n    }\n  }\n  getBoundary() {\n    Geometry.checkNotGeometryCollection(this)\n    Assert.shouldNeverReachHere()\n    return null\n  }\n  getGeometryType() {\n    return Geometry.TYPENAME_GEOMETRYCOLLECTION\n  }\n  isEmpty() {\n    for (let i = 0; i < this._geometries.length; i++) \n      if (!this._geometries[i].isEmpty()) \n        return false\n      \n    \n    return true\n  }\n}\n","import Geometry from './Geometry'\nimport GeometryCollection from './GeometryCollection'\nimport Dimension from './Dimension'\nimport Puntal from './Puntal'\nexport default class MultiPoint extends GeometryCollection {\n  constructor() {\n    super()\n    MultiPoint.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    const points = arguments[0], factory = arguments[1]\n    GeometryCollection.constructor_.call(this, points, factory)\n  }\n  copyInternal() {\n    const points = new Array(this._geometries.length).fill(null)\n    for (let i = 0; i < points.length; i++) \n      points[i] = this._geometries[i].copy()\n    \n    return new MultiPoint(points, this._factory)\n  }\n  isValid() {\n    return true\n  }\n  equalsExact() {\n    if (arguments.length === 2 && (typeof arguments[1] === 'number' && arguments[0] instanceof Geometry)) {\n      const other = arguments[0], tolerance = arguments[1]\n      if (!this.isEquivalentClass(other)) \n        return false\n      \n      return super.equalsExact.call(this, other, tolerance)\n    } else {\n      return super.equalsExact.apply(this, arguments)\n    }\n  }\n  getCoordinate() {\n    if (arguments.length === 1 && Number.isInteger(arguments[0])) {\n      const n = arguments[0]\n      return this._geometries[n].getCoordinate()\n    } else {\n      return super.getCoordinate.apply(this, arguments)\n    }\n  }\n  getBoundaryDimension() {\n    return Dimension.FALSE\n  }\n  getTypeCode() {\n    return Geometry.TYPECODE_MULTIPOINT\n  }\n  getDimension() {\n    return 0\n  }\n  getBoundary() {\n    return this.getFactory().createGeometryCollection()\n  }\n  getGeometryType() {\n    return Geometry.TYPENAME_MULTIPOINT\n  }\n  get interfaces_() {\n    return [Puntal]\n  }\n}\n","import LineString from './LineString'\nimport Geometry from './Geometry'\nimport IllegalArgumentException from '../../../../java/lang/IllegalArgumentException'\nimport CoordinateSequences from './CoordinateSequences'\nimport Dimension from './Dimension'\nexport default class LinearRing extends LineString {\n  constructor() {\n    super()\n    LinearRing.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    const points = arguments[0], factory = arguments[1]\n    LineString.constructor_.call(this, points, factory)\n    this.validateConstruction()\n  }\n  copyInternal() {\n    return new LinearRing(this._points.copy(), this._factory)\n  }\n  getBoundaryDimension() {\n    return Dimension.FALSE\n  }\n  isClosed() {\n    if (this.isEmpty()) \n      return true\n    \n    return super.isClosed.call(this)\n  }\n  reverseInternal() {\n    const seq = this._points.copy()\n    CoordinateSequences.reverse(seq)\n    return this.getFactory().createLinearRing(seq)\n  }\n  getTypeCode() {\n    return Geometry.TYPECODE_LINEARRING\n  }\n  validateConstruction() {\n    if (!this.isEmpty() && !super.isClosed.call(this)) \n      throw new IllegalArgumentException('Points of LinearRing do not form a closed linestring')\n    \n    if (this.getCoordinateSequence().size() >= 1 && this.getCoordinateSequence().size() < LinearRing.MINIMUM_VALID_SIZE) \n      throw new IllegalArgumentException('Invalid number of points in LinearRing (found ' + this.getCoordinateSequence().size() + ' - must be 0 or >= 4)')\n    \n  }\n  getGeometryType() {\n    return Geometry.TYPENAME_LINEARRING\n  }\n}\nLinearRing.MINIMUM_VALID_SIZE = 4\n","import Coordinate from './Coordinate'\nimport IllegalArgumentException from '../../../../java/lang/IllegalArgumentException'\nexport default class CoordinateXY extends Coordinate {\n  constructor() {\n    super()\n    CoordinateXY.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    if (arguments.length === 0) {\n      Coordinate.constructor_.call(this)\n    } else if (arguments.length === 1) {\n      if (arguments[0] instanceof CoordinateXY) {\n        const coord = arguments[0]\n        Coordinate.constructor_.call(this, coord.x, coord.y)\n      } else if (arguments[0] instanceof Coordinate) {\n        const coord = arguments[0]\n        Coordinate.constructor_.call(this, coord.x, coord.y)\n      }\n    } else if (arguments.length === 2) {\n      const x = arguments[0], y = arguments[1]\n      Coordinate.constructor_.call(this, x, y, Coordinate.NULL_ORDINATE)\n    }\n  }\n  setOrdinate(ordinateIndex, value) {\n    switch (ordinateIndex) {\n    case CoordinateXY.X:\n      this.x = value\n      break\n    case CoordinateXY.Y:\n      this.y = value\n      break\n    default:\n      throw new IllegalArgumentException('Invalid ordinate index: ' + ordinateIndex)\n    }\n  }\n  getZ() {\n    return Coordinate.NULL_ORDINATE\n  }\n  getOrdinate(ordinateIndex) {\n    switch (ordinateIndex) {\n    case CoordinateXY.X:\n      return this.x\n    case CoordinateXY.Y:\n      return this.y\n    }\n    throw new IllegalArgumentException('Invalid ordinate index: ' + ordinateIndex)\n  }\n  setZ(z) {\n    throw new IllegalArgumentException('CoordinateXY dimension 2 does not support z-ordinate')\n  }\n  copy() {\n    return new CoordinateXY(this)\n  }\n  toString() {\n    return '(' + this.x + ', ' + this.y + ')'\n  }\n  setCoordinate(other) {\n    this.x = other.x\n    this.y = other.y\n    this.z = other.getZ()\n  }\n}\nCoordinateXY.X = 0\nCoordinateXY.Y = 1\nCoordinateXY.Z = -1\nCoordinateXY.M = -1\n","import Coordinate from './Coordinate'\nimport IllegalArgumentException from '../../../../java/lang/IllegalArgumentException'\nexport default class CoordinateXYM extends Coordinate {\n  constructor() {\n    super()\n    CoordinateXYM.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._m = null\n    if (arguments.length === 0) {\n      Coordinate.constructor_.call(this)\n      this._m = 0.0\n    } else if (arguments.length === 1) {\n      if (arguments[0] instanceof CoordinateXYM) {\n        const coord = arguments[0]\n        Coordinate.constructor_.call(this, coord.x, coord.y)\n        this._m = coord._m\n      } else if (arguments[0] instanceof Coordinate) {\n        const coord = arguments[0]\n        Coordinate.constructor_.call(this, coord.x, coord.y)\n        this._m = this.getM()\n      }\n    } else if (arguments.length === 3) {\n      const x = arguments[0], y = arguments[1], m = arguments[2]\n      Coordinate.constructor_.call(this, x, y, Coordinate.NULL_ORDINATE)\n      this._m = m\n    }\n  }\n  getM() {\n    return this._m\n  }\n  setOrdinate(ordinateIndex, value) {\n    switch (ordinateIndex) {\n    case CoordinateXYM.X:\n      this.x = value\n      break\n    case CoordinateXYM.Y:\n      this.y = value\n      break\n    case CoordinateXYM.M:\n      this._m = value\n      break\n    default:\n      throw new IllegalArgumentException('Invalid ordinate index: ' + ordinateIndex)\n    }\n  }\n  setM(m) {\n    this._m = m\n  }\n  getZ() {\n    return Coordinate.NULL_ORDINATE\n  }\n  getOrdinate(ordinateIndex) {\n    switch (ordinateIndex) {\n    case CoordinateXYM.X:\n      return this.x\n    case CoordinateXYM.Y:\n      return this.y\n    case CoordinateXYM.M:\n      return this._m\n    }\n    throw new IllegalArgumentException('Invalid ordinate index: ' + ordinateIndex)\n  }\n  setZ(z) {\n    throw new IllegalArgumentException('CoordinateXY dimension 2 does not support z-ordinate')\n  }\n  copy() {\n    return new CoordinateXYM(this)\n  }\n  toString() {\n    return '(' + this.x + ', ' + this.y + ' m=' + this.getM() + ')'\n  }\n  setCoordinate(other) {\n    this.x = other.x\n    this.y = other.y\n    this.z = other.getZ()\n    this._m = other.getM()\n  }\n}\nCoordinateXYM.X = 0\nCoordinateXYM.Y = 1\nCoordinateXYM.Z = -1\nCoordinateXYM.M = 2\n","import Coordinate from './Coordinate'\nimport IllegalArgumentException from '../../../../java/lang/IllegalArgumentException'\nexport default class CoordinateXYZM extends Coordinate {\n  constructor() {\n    super()\n    CoordinateXYZM.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._m = null\n    if (arguments.length === 0) {\n      Coordinate.constructor_.call(this)\n      this._m = 0.0\n    } else if (arguments.length === 1) {\n      if (arguments[0] instanceof CoordinateXYZM) {\n        const coord = arguments[0]\n        Coordinate.constructor_.call(this, coord)\n        this._m = coord._m\n      } else if (arguments[0] instanceof Coordinate) {\n        const coord = arguments[0]\n        Coordinate.constructor_.call(this, coord)\n        this._m = this.getM()\n      }\n    } else if (arguments.length === 4) {\n      const x = arguments[0], y = arguments[1], z = arguments[2], m = arguments[3]\n      Coordinate.constructor_.call(this, x, y, z)\n      this._m = m\n    }\n  }\n  getM() {\n    return this._m\n  }\n  setOrdinate(ordinateIndex, value) {\n    switch (ordinateIndex) {\n    case Coordinate.X:\n      this.x = value\n      break\n    case Coordinate.Y:\n      this.y = value\n      break\n    case Coordinate.Z:\n      this.z = value\n      break\n    case Coordinate.M:\n      this._m = value\n      break\n    default:\n      throw new IllegalArgumentException('Invalid ordinate index: ' + ordinateIndex)\n    }\n  }\n  setM(m) {\n    this._m = m\n  }\n  getOrdinate(ordinateIndex) {\n    switch (ordinateIndex) {\n    case Coordinate.X:\n      return this.x\n    case Coordinate.Y:\n      return this.y\n    case Coordinate.Z:\n      return this.getZ()\n    case Coordinate.M:\n      return this.getM()\n    }\n    throw new IllegalArgumentException('Invalid ordinate index: ' + ordinateIndex)\n  }\n  copy() {\n    return new CoordinateXYZM(this)\n  }\n  toString() {\n    return '(' + this.x + ', ' + this.y + ', ' + this.getZ() + ' m=' + this.getM() + ')'\n  }\n  setCoordinate(other) {\n    this.x = other.x\n    this.y = other.y\n    this.z = other.getZ()\n    this._m = other.getM()\n  }\n}\n","import CoordinateXY from './CoordinateXY'\nimport Coordinate from './Coordinate'\nimport CoordinateXYM from './CoordinateXYM'\nimport CoordinateXYZM from './CoordinateXYZM'\nexport default class Coordinates {\n  static measures(coordinate) {\n    if (coordinate instanceof CoordinateXY) \n      return 0\n    else if (coordinate instanceof CoordinateXYM) \n      return 1\n    else if (coordinate instanceof CoordinateXYZM) \n      return 1\n    else if (coordinate instanceof Coordinate) \n      return 0\n    \n    return 0\n  }\n  static dimension(coordinate) {\n    if (coordinate instanceof CoordinateXY) \n      return 2\n    else if (coordinate instanceof CoordinateXYM) \n      return 3\n    else if (coordinate instanceof CoordinateXYZM) \n      return 4\n    else if (coordinate instanceof Coordinate) \n      return 3\n    \n    return 3\n  }\n  static create() {\n    if (arguments.length === 1) {\n      const dimension = arguments[0]\n      return Coordinates.create(dimension, 0)\n    } else if (arguments.length === 2) {\n      const dimension = arguments[0], measures = arguments[1]\n      if (dimension === 2) \n        return new CoordinateXY()\n      else if (dimension === 3 && measures === 0) \n        return new Coordinate()\n      else if (dimension === 3 && measures === 1) \n        return new CoordinateXYM()\n      else if (dimension === 4 && measures === 1) \n        return new CoordinateXYZM()\n      \n      return new Coordinate()\n    }\n  }\n}\n","import hasInterface from '../../../../hasInterface'\nimport Collection from '../../../../java/util/Collection'\nimport Coordinate from './Coordinate'\nimport ArrayList from '../../../../java/util/ArrayList'\nexport default class CoordinateList extends ArrayList {\n  constructor() {\n    super()\n    CoordinateList.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    if (arguments.length === 0) {} else if (arguments.length === 1) {\n      const coord = arguments[0]\n      this.ensureCapacity(coord.length)\n      this.add(coord, true)\n    } else if (arguments.length === 2) {\n      const coord = arguments[0], allowRepeated = arguments[1]\n      this.ensureCapacity(coord.length)\n      this.add(coord, allowRepeated)\n    }\n  }\n  getCoordinate(i) {\n    return this.get(i)\n  }\n  addAll() {\n    if (arguments.length === 2 && (typeof arguments[1] === 'boolean' && hasInterface(arguments[0], Collection))) {\n      const coll = arguments[0], allowRepeated = arguments[1]\n      let isChanged = false\n      for (let i = coll.iterator(); i.hasNext(); ) {\n        this.add(i.next(), allowRepeated)\n        isChanged = true\n      }\n      return isChanged\n    } else {\n      return super.addAll.apply(this, arguments)\n    }\n  }\n  clone() {\n    const clone = super.clone.call(this)\n    for (let i = 0; i < this.size(); i++) \n      clone.add(i, this.get(i).clone())\n    \n    return clone\n  }\n  toCoordinateArray() {\n    if (arguments.length === 0) {\n      return this.toArray(CoordinateList.coordArrayType)\n    } else if (arguments.length === 1) {\n      const isForward = arguments[0]\n      if (isForward) \n        return this.toArray(CoordinateList.coordArrayType)\n      \n      const size = this.size()\n      const pts = new Array(size).fill(null)\n      for (let i = 0; i < size; i++) \n        pts[i] = this.get(size - i - 1)\n      \n      return pts\n    }\n  }\n  add() {\n    if (arguments.length === 1) {\n      const coord = arguments[0]\n      return super.add.call(this, coord)\n    } else if (arguments.length === 2) {\n      if (arguments[0] instanceof Array && typeof arguments[1] === 'boolean') {\n        const coord = arguments[0], allowRepeated = arguments[1]\n        this.add(coord, allowRepeated, true)\n        return true\n      } else if (arguments[0] instanceof Coordinate && typeof arguments[1] === 'boolean') {\n        const coord = arguments[0], allowRepeated = arguments[1]\n        if (!allowRepeated) \n          if (this.size() >= 1) {\n            const last = this.get(this.size() - 1)\n            if (last.equals2D(coord)) return null\n          }\n        \n        super.add.call(this, coord)\n      } else if (arguments[0] instanceof Object && typeof arguments[1] === 'boolean') {\n        const obj = arguments[0], allowRepeated = arguments[1]\n        this.add(obj, allowRepeated)\n        return true\n      }\n    } else if (arguments.length === 3) {\n      if (typeof arguments[2] === 'boolean' && (arguments[0] instanceof Array && typeof arguments[1] === 'boolean')) {\n        const coord = arguments[0], allowRepeated = arguments[1], direction = arguments[2]\n        if (direction) \n          for (let i = 0; i < coord.length; i++) \n            this.add(coord[i], allowRepeated)\n          \n        else \n          for (let i = coord.length - 1; i >= 0; i--) \n            this.add(coord[i], allowRepeated)\n          \n        \n        return true\n      } else if (typeof arguments[2] === 'boolean' && (Number.isInteger(arguments[0]) && arguments[1] instanceof Coordinate)) {\n        const i = arguments[0], coord = arguments[1], allowRepeated = arguments[2]\n        if (!allowRepeated) {\n          const size = this.size()\n          if (size > 0) {\n            if (i > 0) {\n              const prev = this.get(i - 1)\n              if (prev.equals2D(coord)) return null\n            }\n            if (i < size) {\n              const next = this.get(i)\n              if (next.equals2D(coord)) return null\n            }\n          }\n        }\n        super.add.call(this, i, coord)\n      }\n    } else if (arguments.length === 4) {\n      const coord = arguments[0], allowRepeated = arguments[1], start = arguments[2], end = arguments[3]\n      let inc = 1\n      if (start > end) inc = -1\n      for (let i = start; i !== end; i += inc) \n        this.add(coord[i], allowRepeated)\n      \n      return true\n    }\n  }\n  closeRing() {\n    if (this.size() > 0) {\n      const duplicate = this.get(0).copy()\n      this.add(duplicate, false)\n    }\n  }\n}\nCoordinateList.coordArrayType = new Array(0).fill(null)\n","import CoordinateList from './CoordinateList'\nimport Coordinates from './Coordinates'\nimport MathUtil from '../math/MathUtil'\nimport System from '../../../../java/lang/System'\nimport Comparator from '../../../../java/util/Comparator'\nimport Envelope from './Envelope'\nexport default class CoordinateArrays {\n  static isRing(pts) {\n    if (pts.length < 4) return false\n    if (!pts[0].equals2D(pts[pts.length - 1])) return false\n    return true\n  }\n  static ptNotInList(testPts, pts) {\n    for (let i = 0; i < testPts.length; i++) {\n      const testPt = testPts[i]\n      if (CoordinateArrays.indexOf(testPt, pts) < 0) return testPt\n    }\n    return null\n  }\n  static scroll(coordinates, firstCoordinate) {\n    const i = CoordinateArrays.indexOf(firstCoordinate, coordinates)\n    if (i < 0) return null\n    const newCoordinates = new Array(coordinates.length).fill(null)\n    System.arraycopy(coordinates, i, newCoordinates, 0, coordinates.length - i)\n    System.arraycopy(coordinates, 0, newCoordinates, coordinates.length - i, i)\n    System.arraycopy(newCoordinates, 0, coordinates, 0, coordinates.length)\n  }\n  static equals() {\n    if (arguments.length === 2) {\n      const coord1 = arguments[0], coord2 = arguments[1]\n      if (coord1 === coord2) return true\n      if (coord1 === null || coord2 === null) return false\n      if (coord1.length !== coord2.length) return false\n      for (let i = 0; i < coord1.length; i++) \n        if (!coord1[i].equals(coord2[i])) return false\n      \n      return true\n    } else if (arguments.length === 3) {\n      const coord1 = arguments[0], coord2 = arguments[1], coordinateComparator = arguments[2]\n      if (coord1 === coord2) return true\n      if (coord1 === null || coord2 === null) return false\n      if (coord1.length !== coord2.length) return false\n      for (let i = 0; i < coord1.length; i++) \n        if (coordinateComparator.compare(coord1[i], coord2[i]) !== 0) return false\n      \n      return true\n    }\n  }\n  static intersection(coordinates, env) {\n    const coordList = new CoordinateList()\n    for (let i = 0; i < coordinates.length; i++) \n      if (env.intersects(coordinates[i])) coordList.add(coordinates[i], true)\n    \n    return coordList.toCoordinateArray()\n  }\n  static measures(pts) {\n    if (pts === null || pts.length === 0) \n      return 0\n    \n    let measures = 0\n    for (const coordinate of pts) \n      measures = Math.max(measures, Coordinates.measures(coordinate))\n    \n    return measures\n  }\n  static hasRepeatedPoints(coord) {\n    for (let i = 1; i < coord.length; i++) \n      if (coord[i - 1].equals(coord[i])) \n        return true\n      \n    \n    return false\n  }\n  static removeRepeatedPoints(coord) {\n    if (!CoordinateArrays.hasRepeatedPoints(coord)) return coord\n    const coordList = new CoordinateList(coord, false)\n    return coordList.toCoordinateArray()\n  }\n  static reverse(coord) {\n    const last = coord.length - 1\n    const mid = Math.trunc(last / 2)\n    for (let i = 0; i <= mid; i++) {\n      const tmp = coord[i]\n      coord[i] = coord[last - i]\n      coord[last - i] = tmp\n    }\n  }\n  static removeNull(coord) {\n    let nonNull = 0\n    for (let i = 0; i < coord.length; i++) \n      if (coord[i] !== null) nonNull++\n    \n    const newCoord = new Array(nonNull).fill(null)\n    if (nonNull === 0) return newCoord\n    let j = 0\n    for (let i = 0; i < coord.length; i++) \n      if (coord[i] !== null) newCoord[j++] = coord[i]\n    \n    return newCoord\n  }\n  static copyDeep() {\n    if (arguments.length === 1) {\n      const coordinates = arguments[0]\n      const copy = new Array(coordinates.length).fill(null)\n      for (let i = 0; i < coordinates.length; i++) \n        copy[i] = coordinates[i].copy()\n      \n      return copy\n    } else if (arguments.length === 5) {\n      const src = arguments[0], srcStart = arguments[1], dest = arguments[2], destStart = arguments[3], length = arguments[4]\n      for (let i = 0; i < length; i++) \n        dest[destStart + i] = src[srcStart + i].copy()\n      \n    }\n  }\n  static isEqualReversed(pts1, pts2) {\n    for (let i = 0; i < pts1.length; i++) {\n      const p1 = pts1[i]\n      const p2 = pts2[pts1.length - i - 1]\n      if (p1.compareTo(p2) !== 0) return false\n    }\n    return true\n  }\n  static envelope(coordinates) {\n    const env = new Envelope()\n    for (let i = 0; i < coordinates.length; i++) \n      env.expandToInclude(coordinates[i])\n    \n    return env\n  }\n  static toCoordinateArray(coordList) {\n    return coordList.toArray(CoordinateArrays.coordArrayType)\n  }\n  static dimension(pts) {\n    if (pts === null || pts.length === 0) \n      return 3\n    \n    let dimension = 0\n    for (const coordinate of pts) \n      dimension = Math.max(dimension, Coordinates.dimension(coordinate))\n    \n    return dimension\n  }\n  static atLeastNCoordinatesOrNothing(n, c) {\n    return c.length >= n ? c : []\n  }\n  static indexOf(coordinate, coordinates) {\n    for (let i = 0; i < coordinates.length; i++) \n      if (coordinate.equals(coordinates[i])) \n        return i\n      \n    \n    return -1\n  }\n  static increasingDirection(pts) {\n    for (let i = 0; i < Math.trunc(pts.length / 2); i++) {\n      const j = pts.length - 1 - i\n      const comp = pts[i].compareTo(pts[j])\n      if (comp !== 0) return comp\n    }\n    return 1\n  }\n  static compare(pts1, pts2) {\n    let i = 0\n    while (i < pts1.length && i < pts2.length) {\n      const compare = pts1[i].compareTo(pts2[i])\n      if (compare !== 0) return compare\n      i++\n    }\n    if (i < pts2.length) return -1\n    if (i < pts1.length) return 1\n    return 0\n  }\n  static minCoordinate(coordinates) {\n    let minCoord = null\n    for (let i = 0; i < coordinates.length; i++) \n      if (minCoord === null || minCoord.compareTo(coordinates[i]) > 0) \n        minCoord = coordinates[i]\n      \n    \n    return minCoord\n  }\n  static extract(pts, start, end) {\n    start = MathUtil.clamp(start, 0, pts.length)\n    end = MathUtil.clamp(end, -1, pts.length)\n    let npts = end - start + 1\n    if (end < 0) npts = 0\n    if (start >= pts.length) npts = 0\n    if (end < start) npts = 0\n    const extractPts = new Array(npts).fill(null)\n    if (npts === 0) return extractPts\n    let iPts = 0\n    for (let i = start; i <= end; i++) \n      extractPts[iPts++] = pts[i]\n    \n    return extractPts\n  }\n}\nclass ForwardComparator {\n  compare(o1, o2) {\n    const pts1 = o1\n    const pts2 = o2\n    return CoordinateArrays.compare(pts1, pts2)\n  }\n  get interfaces_() {\n    return [Comparator]\n  }\n}\nclass BidirectionalComparator {\n  compare(o1, o2) {\n    const pts1 = o1\n    const pts2 = o2\n    if (pts1.length < pts2.length) return -1\n    if (pts1.length > pts2.length) return 1\n    if (pts1.length === 0) return 0\n    const forwardComp = CoordinateArrays.compare(pts1, pts2)\n    const isEqualRev = CoordinateArrays.isEqualReversed(pts1, pts2)\n    if (isEqualRev) return 0\n    return forwardComp\n  }\n  OLDcompare(o1, o2) {\n    const pts1 = o1\n    const pts2 = o2\n    if (pts1.length < pts2.length) return -1\n    if (pts1.length > pts2.length) return 1\n    if (pts1.length === 0) return 0\n    const dir1 = CoordinateArrays.increasingDirection(pts1)\n    const dir2 = CoordinateArrays.increasingDirection(pts2)\n    let i1 = dir1 > 0 ? 0 : pts1.length - 1\n    let i2 = dir2 > 0 ? 0 : pts1.length - 1\n    for (let i = 0; i < pts1.length; i++) {\n      const comparePt = pts1[i1].compareTo(pts2[i2])\n      if (comparePt !== 0) return comparePt\n      i1 += dir1\n      i2 += dir2\n    }\n    return 0\n  }\n  get interfaces_() {\n    return [Comparator]\n  }\n}\nCoordinateArrays.ForwardComparator = ForwardComparator\nCoordinateArrays.BidirectionalComparator = BidirectionalComparator\nCoordinateArrays.coordArrayType = new Array(0).fill(null)\n","export default class StringBuilder {\n  constructor(str) {\n    this.str = str\n  }\n  append(e) {\n    this.str += e\n  }\n  setCharAt(i, c) {\n    this.str = this.str.substr(0, i) + c + this.str.substr(i + 1)\n  }\n  toString() {\n    return this.str\n  }\n}","import hasInterface from '../../../../../hasInterface'\nimport Coordinate from '../Coordinate'\nimport Double from '../../../../../java/lang/Double'\nimport Coordinates from '../Coordinates'\nimport CoordinateSequence from '../CoordinateSequence'\nimport CoordinateArrays from '../CoordinateArrays'\nimport Serializable from '../../../../../java/io/Serializable'\nimport StringBuilder from '../../../../../java/lang/StringBuilder'\nexport default class CoordinateArraySequence {\n  constructor() {\n    CoordinateArraySequence.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._dimension = 3\n    this._measures = 0\n    this._coordinates = null\n    if (arguments.length === 1) {\n      if (arguments[0] instanceof Array) {\n        const coordinates = arguments[0]\n        CoordinateArraySequence.constructor_.call(this, coordinates, CoordinateArrays.dimension(coordinates), CoordinateArrays.measures(coordinates))\n      } else if (Number.isInteger(arguments[0])) {\n        const size = arguments[0]\n        this._coordinates = new Array(size).fill(null)\n        for (let i = 0; i < size; i++) \n          this._coordinates[i] = new Coordinate()\n        \n      } else if (hasInterface(arguments[0], CoordinateSequence)) {\n        const coordSeq = arguments[0]\n        if (coordSeq === null) {\n          this._coordinates = new Array(0).fill(null)\n          return null\n        }\n        this._dimension = coordSeq.getDimension()\n        this._measures = coordSeq.getMeasures()\n        this._coordinates = new Array(coordSeq.size()).fill(null)\n        for (let i = 0; i < this._coordinates.length; i++) \n          this._coordinates[i] = coordSeq.getCoordinateCopy(i)\n        \n      }\n    } else if (arguments.length === 2) {\n      if (arguments[0] instanceof Array && Number.isInteger(arguments[1])) {\n        const coordinates = arguments[0], dimension = arguments[1]\n        CoordinateArraySequence.constructor_.call(this, coordinates, dimension, CoordinateArrays.measures(coordinates))\n      } else if (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {\n        const size = arguments[0], dimension = arguments[1]\n        this._coordinates = new Array(size).fill(null)\n        this._dimension = dimension\n        for (let i = 0; i < size; i++) \n          this._coordinates[i] = Coordinates.create(dimension)\n        \n      }\n    } else if (arguments.length === 3) {\n      if (Number.isInteger(arguments[2]) && (arguments[0] instanceof Array && Number.isInteger(arguments[1]))) {\n        const coordinates = arguments[0], dimension = arguments[1], measures = arguments[2]\n        this._dimension = dimension\n        this._measures = measures\n        if (coordinates === null) \n          this._coordinates = new Array(0).fill(null)\n        else \n          this._coordinates = coordinates\n        \n      } else if (Number.isInteger(arguments[2]) && (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1]))) {\n        const size = arguments[0], dimension = arguments[1], measures = arguments[2]\n        this._coordinates = new Array(size).fill(null)\n        this._dimension = dimension\n        this._measures = measures\n        for (let i = 0; i < size; i++) \n          this._coordinates[i] = this.createCoordinate()\n        \n      }\n    }\n  }\n  getM(index) {\n    if (this.hasM()) \n      return this._coordinates[index].getM()\n    else \n      return Double.NaN\n    \n  }\n  setOrdinate(index, ordinateIndex, value) {\n    switch (ordinateIndex) {\n    case CoordinateSequence.X:\n      this._coordinates[index].x = value\n      break\n    case CoordinateSequence.Y:\n      this._coordinates[index].y = value\n      break\n    default:\n      this._coordinates[index].setOrdinate(ordinateIndex, value)\n    }\n  }\n  getZ(index) {\n    if (this.hasZ()) \n      return this._coordinates[index].getZ()\n    else \n      return Double.NaN\n    \n  }\n  size() {\n    return this._coordinates.length\n  }\n  getOrdinate(index, ordinateIndex) {\n    switch (ordinateIndex) {\n    case CoordinateSequence.X:\n      return this._coordinates[index].x\n    case CoordinateSequence.Y:\n      return this._coordinates[index].y\n    default:\n      return this._coordinates[index].getOrdinate(ordinateIndex)\n    }\n  }\n  getCoordinate() {\n    if (arguments.length === 1) {\n      const i = arguments[0]\n      return this._coordinates[i]\n    } else if (arguments.length === 2) {\n      const index = arguments[0], coord = arguments[1]\n      coord.setCoordinate(this._coordinates[index])\n    }\n  }\n  getCoordinateCopy(i) {\n    const copy = this.createCoordinate()\n    copy.setCoordinate(this._coordinates[i])\n    return copy\n  }\n  createCoordinate() {\n    return Coordinates.create(this.getDimension(), this.getMeasures())\n  }\n  getDimension() {\n    return this._dimension\n  }\n  getX(index) {\n    return this._coordinates[index].x\n  }\n  getMeasures() {\n    return this._measures\n  }\n  expandEnvelope(env) {\n    for (let i = 0; i < this._coordinates.length; i++) \n      env.expandToInclude(this._coordinates[i])\n    \n    return env\n  }\n  copy() {\n    const cloneCoordinates = new Array(this.size()).fill(null)\n    for (let i = 0; i < this._coordinates.length; i++) {\n      const duplicate = this.createCoordinate()\n      duplicate.setCoordinate(this._coordinates[i])\n      cloneCoordinates[i] = duplicate\n    }\n    return new CoordinateArraySequence(cloneCoordinates, this._dimension, this._measures)\n  }\n  toString() {\n    if (this._coordinates.length > 0) {\n      const strBuilder = new StringBuilder(17 * this._coordinates.length)\n      strBuilder.append('(')\n      strBuilder.append(this._coordinates[0])\n      for (let i = 1; i < this._coordinates.length; i++) {\n        strBuilder.append(', ')\n        strBuilder.append(this._coordinates[i])\n      }\n      strBuilder.append(')')\n      return strBuilder.toString()\n    } else {\n      return '()'\n    }\n  }\n  getY(index) {\n    return this._coordinates[index].y\n  }\n  toCoordinateArray() {\n    return this._coordinates\n  }\n  get interfaces_() {\n    return [CoordinateSequence, Serializable]\n  }\n}\n","import CoordinateSequenceFactory from '../CoordinateSequenceFactory'\nimport hasInterface from '../../../../../hasInterface'\nimport CoordinateArraySequence from './CoordinateArraySequence'\nimport CoordinateSequence from '../CoordinateSequence'\nimport Serializable from '../../../../../java/io/Serializable'\nexport default class CoordinateArraySequenceFactory {\n  static instance() {\n    return CoordinateArraySequenceFactory.instanceObject\n  }\n  readResolve() {\n    return CoordinateArraySequenceFactory.instance()\n  }\n  create() {\n    if (arguments.length === 1) {\n      if (arguments[0] instanceof Array) {\n        const coordinates = arguments[0]\n        return new CoordinateArraySequence(coordinates)\n      } else if (hasInterface(arguments[0], CoordinateSequence)) {\n        const coordSeq = arguments[0]\n        return new CoordinateArraySequence(coordSeq)\n      }\n    } else if (arguments.length === 2) {\n      let size = arguments[0], dimension = arguments[1]\n      if (dimension > 3) dimension = 3\n      if (dimension < 2) dimension = 2\n      return new CoordinateArraySequence(size, dimension)\n    } else if (arguments.length === 3) {\n      let size = arguments[0], dimension = arguments[1], measures = arguments[2]\n      let spatial = dimension - measures\n      if (measures > 1) \n        measures = 1\n      \n      if (spatial > 3) \n        spatial = 3\n      \n      if (spatial < 2) spatial = 2\n      return new CoordinateArraySequence(size, spatial + measures, measures)\n    }\n  }\n  get interfaces_() {\n    return [CoordinateSequenceFactory, Serializable]\n  }\n}\nCoordinateArraySequenceFactory.instanceObject = new CoordinateArraySequenceFactory()\n","import Geometry from './Geometry'\nimport GeometryCollection from './GeometryCollection'\nimport Polygonal from './Polygonal'\nimport ArrayList from '../../../../java/util/ArrayList'\nexport default class MultiPolygon extends GeometryCollection {\n  constructor() {\n    super()\n    MultiPolygon.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    const polygons = arguments[0], factory = arguments[1]\n    GeometryCollection.constructor_.call(this, polygons, factory)\n  }\n  copyInternal() {\n    const polygons = new Array(this._geometries.length).fill(null)\n    for (let i = 0; i < polygons.length; i++) \n      polygons[i] = this._geometries[i].copy()\n    \n    return new MultiPolygon(polygons, this._factory)\n  }\n  equalsExact() {\n    if (arguments.length === 2 && (typeof arguments[1] === 'number' && arguments[0] instanceof Geometry)) {\n      const other = arguments[0], tolerance = arguments[1]\n      if (!this.isEquivalentClass(other)) \n        return false\n      \n      return super.equalsExact.call(this, other, tolerance)\n    } else {\n      return super.equalsExact.apply(this, arguments)\n    }\n  }\n  getBoundaryDimension() {\n    return 1\n  }\n  getTypeCode() {\n    return Geometry.TYPECODE_MULTIPOLYGON\n  }\n  getDimension() {\n    return 2\n  }\n  getBoundary() {\n    if (this.isEmpty()) \n      return this.getFactory().createMultiLineString()\n    \n    const allRings = new ArrayList()\n    for (let i = 0; i < this._geometries.length; i++) {\n      const polygon = this._geometries[i]\n      const rings = polygon.getBoundary()\n      for (let j = 0; j < rings.getNumGeometries(); j++) \n        allRings.add(rings.getGeometryN(j))\n      \n    }\n    const allRingsArray = new Array(allRings.size()).fill(null)\n    return this.getFactory().createMultiLineString(allRings.toArray(allRingsArray))\n  }\n  getGeometryType() {\n    return Geometry.TYPENAME_MULTIPOLYGON\n  }\n  get interfaces_() {\n    return [Polygonal]\n  }\n}\n","/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/Map.html\n */\nexport default class Map {\n  /**\n     * Returns the value to which the specified key is mapped, or null if this map\n     * contains no mapping for the key.\n     * @param {Object} key\n     * @return {Object}\n     */\n  get() { }\n\n  /**\n     * Associates the specified value with the specified key in this map (optional\n     * operation).\n     * @param {Object} key\n     * @param {Object} value\n     * @return {Object}\n     */\n  put() { }\n\n  /**\n     * Returns the number of key-value mappings in this map.\n     * @return {number}\n     */\n  size() { }\n\n  /**\n     * Returns a Collection view of the values contained in this map.\n     * @return {javascript.util.Collection}\n     */\n  values() { }\n\n  /**\n     * Returns a {@link Set} view of the mappings contained in this map.\n     * The set is backed by the map, so changes to the map are\n     * reflected in the set, and vice-versa.  If the map is modified\n     * while an iteration over the set is in progress (except through\n     * the iterator's own <tt>remove</tt> operation, or through the\n     * <tt>setValue</tt> operation on a map entry returned by the\n     * iterator) the results of the iteration are undefined.  The set\n     * supports element removal, which removes the corresponding\n     * mapping from the map, via the <tt>Iterator.remove</tt>,\n     * <tt>Set.remove</tt>, <tt>removeAll</tt>, <tt>retainAll</tt> and\n     * <tt>clear</tt> operations.  It does not support the\n     * <tt>add</tt> or <tt>addAll</tt> operations.\n     *\n     * @return {Set} a set view of the mappings contained in this map\n     */\n  entrySet() { }\n}\n","import ArrayList from './ArrayList'\nimport MapInterface from './Map'\nimport HashSet from './HashSet'\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/HashMap.html\n */\nexport default class HashMap extends MapInterface {\n  constructor() {\n    super()\n    this.map = new Map()\n  }\n\n  get(key) {\n    return this.map.get(key) || null\n  }\n\n  put(key, value) {\n    this.map.set(key, value)\n    return value\n  }\n\n  values() {\n    const arrayList = new ArrayList()\n    const it = this.map.values()\n    let o = it.next()\n    while (!o.done) {\n      arrayList.add(o.value)\n      o = it.next()\n    }\n    return arrayList\n  }\n\n  entrySet() {\n    const hashSet = new HashSet()\n    this.map.entries().forEach(entry => hashSet.add(entry))\n    return hashSet\n  }\n\n  size() {\n    return this.map.size()\n  }\n}\n","import HashMap from '../../../../java/util/HashMap'\nimport Coordinate from './Coordinate'\nimport Double from '../../../../java/lang/Double'\nimport Integer from '../../../../java/lang/Integer'\nimport Comparable from '../../../../java/lang/Comparable'\nimport Serializable from '../../../../java/io/Serializable'\nexport default class PrecisionModel {\n  constructor() {\n    PrecisionModel.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._modelType = null\n    this._scale = null\n    if (arguments.length === 0) \n      this._modelType = PrecisionModel.FLOATING\n    else if (arguments.length === 1) \n      if (arguments[0] instanceof Type) {\n        const modelType = arguments[0]\n        this._modelType = modelType\n        if (modelType === PrecisionModel.FIXED) \n          this.setScale(1.0)\n        \n      } else if (typeof arguments[0] === 'number') {\n        const scale = arguments[0]\n        this._modelType = PrecisionModel.FIXED\n        this.setScale(scale)\n      } else if (arguments[0] instanceof PrecisionModel) {\n        const pm = arguments[0]\n        this._modelType = pm._modelType\n        this._scale = pm._scale\n      }\n    \n  }\n  static mostPrecise(pm1, pm2) {\n    if (pm1.compareTo(pm2) >= 0) return pm1\n    return pm2\n  }\n  equals(other) {\n    if (!(other instanceof PrecisionModel)) \n      return false\n    \n    const otherPrecisionModel = other\n    return this._modelType === otherPrecisionModel._modelType && this._scale === otherPrecisionModel._scale\n  }\n  compareTo(o) {\n    const other = o\n    const sigDigits = this.getMaximumSignificantDigits()\n    const otherSigDigits = other.getMaximumSignificantDigits()\n    return Integer.compare(sigDigits, otherSigDigits)\n  }\n  getScale() {\n    return this._scale\n  }\n  isFloating() {\n    return this._modelType === PrecisionModel.FLOATING || this._modelType === PrecisionModel.FLOATING_SINGLE\n  }\n  getType() {\n    return this._modelType\n  }\n  toString() {\n    let description = 'UNKNOWN'\n    if (this._modelType === PrecisionModel.FLOATING) \n      description = 'Floating'\n    else if (this._modelType === PrecisionModel.FLOATING_SINGLE) \n      description = 'Floating-Single'\n    else if (this._modelType === PrecisionModel.FIXED) \n      description = 'Fixed (Scale=' + this.getScale() + ')'\n    \n    return description\n  }\n  makePrecise() {\n    if (typeof arguments[0] === 'number') {\n      const val = arguments[0]\n      if (Double.isNaN(val)) return val\n      if (this._modelType === PrecisionModel.FLOATING_SINGLE) {\n        const floatSingleVal = val\n        return floatSingleVal\n      }\n      if (this._modelType === PrecisionModel.FIXED) \n        return Math.round(val * this._scale) / this._scale\n      \n      return val\n    } else if (arguments[0] instanceof Coordinate) {\n      const coord = arguments[0]\n      if (this._modelType === PrecisionModel.FLOATING) return null\n      coord.x = this.makePrecise(coord.x)\n      coord.y = this.makePrecise(coord.y)\n    }\n  }\n  getMaximumSignificantDigits() {\n    let maxSigDigits = 16\n    if (this._modelType === PrecisionModel.FLOATING) \n      maxSigDigits = 16\n    else if (this._modelType === PrecisionModel.FLOATING_SINGLE) \n      maxSigDigits = 6\n    else if (this._modelType === PrecisionModel.FIXED) \n      maxSigDigits = 1 + Math.trunc(Math.ceil(Math.log(this.getScale()) / Math.log(10)))\n    \n    return maxSigDigits\n  }\n  setScale(scale) {\n    this._scale = Math.abs(scale)\n  }\n  get interfaces_() {\n    return [Serializable, Comparable]\n  }\n}\nclass Type {\n  constructor() {\n    Type.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._name = null\n    const name = arguments[0]\n    this._name = name\n    Type.nameToTypeMap.put(name, this)\n  }\n  readResolve() {\n    return Type.nameToTypeMap.get(this._name)\n  }\n  toString() {\n    return this._name\n  }\n  get interfaces_() {\n    return [Serializable]\n  }\n}\nType.nameToTypeMap = new HashMap()\nPrecisionModel.Type = Type\nPrecisionModel.FIXED = new Type('FIXED')\nPrecisionModel.FLOATING = new Type('FLOATING')\nPrecisionModel.FLOATING_SINGLE = new Type('FLOATING SINGLE')\nPrecisionModel.maximumPreciseValue = 9007199254740992.0\n","import Geometry from './Geometry'\nimport Lineal from './Lineal'\nimport GeometryCollection from './GeometryCollection'\nimport UnsupportedOperationException from '../../../../java/lang/UnsupportedOperationException'\nimport Dimension from './Dimension'\nexport default class MultiLineString extends GeometryCollection {\n  constructor() {\n    super()\n    MultiLineString.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    const lineStrings = arguments[0], factory = arguments[1]\n    GeometryCollection.constructor_.call(this, lineStrings, factory)\n  }\n  copyInternal() {\n    const lineStrings = new Array(this._geometries.length).fill(null)\n    for (let i = 0; i < lineStrings.length; i++) \n      lineStrings[i] = this._geometries[i].copy()\n    \n    return new MultiLineString(lineStrings, this._factory)\n  }\n  equalsExact() {\n    if (arguments.length === 2 && (typeof arguments[1] === 'number' && arguments[0] instanceof Geometry)) {\n      const other = arguments[0], tolerance = arguments[1]\n      if (!this.isEquivalentClass(other)) \n        return false\n      \n      return super.equalsExact.call(this, other, tolerance)\n    } else {\n      return super.equalsExact.apply(this, arguments)\n    }\n  }\n  getBoundaryDimension() {\n    if (this.isClosed()) \n      return Dimension.FALSE\n    \n    return 0\n  }\n  isClosed() {\n    if (this.isEmpty()) \n      return false\n    \n    for (let i = 0; i < this._geometries.length; i++) \n      if (!this._geometries[i].isClosed()) \n        return false\n      \n    \n    return true\n  }\n  getTypeCode() {\n    return Geometry.TYPECODE_MULTILINESTRING\n  }\n  getDimension() {\n    return 1\n  }\n  getBoundary() {\n    throw new UnsupportedOperationException()\n  }\n  getGeometryType() {\n    return Geometry.TYPENAME_MULTILINESTRING\n  }\n  get interfaces_() {\n    return [Lineal]\n  }\n}\n","import CoordinateSequenceFactory from './CoordinateSequenceFactory'\nimport LineString from './LineString'\nimport hasInterface from '../../../../hasInterface'\nimport Coordinate from './Coordinate'\nimport IllegalArgumentException from '../../../../java/lang/IllegalArgumentException'\nimport Point from './Point'\nimport Polygon from './Polygon'\nimport MultiPoint from './MultiPoint'\nimport LinearRing from './LinearRing'\nimport CoordinateArraySequenceFactory from './impl/CoordinateArraySequenceFactory'\nimport MultiPolygon from './MultiPolygon'\nimport CoordinateSequences from './CoordinateSequences'\nimport CoordinateSequence from './CoordinateSequence'\nimport GeometryCollection from './GeometryCollection'\nimport PrecisionModel from './PrecisionModel'\nimport Serializable from '../../../../java/io/Serializable'\nimport Assert from '../util/Assert'\nimport MultiLineString from './MultiLineString'\nexport default class GeometryFactory {\n  constructor() {\n    GeometryFactory.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._precisionModel = null\n    this._coordinateSequenceFactory = null\n    this._SRID = null\n    if (arguments.length === 0) {\n      GeometryFactory.constructor_.call(this, new PrecisionModel(), 0)\n    } else if (arguments.length === 1) {\n      if (hasInterface(arguments[0], CoordinateSequenceFactory)) {\n        const coordinateSequenceFactory = arguments[0]\n        GeometryFactory.constructor_.call(this, new PrecisionModel(), 0, coordinateSequenceFactory)\n      } else if (arguments[0] instanceof PrecisionModel) {\n        const precisionModel = arguments[0]\n        GeometryFactory.constructor_.call(this, precisionModel, 0, GeometryFactory.getDefaultCoordinateSequenceFactory())\n      }\n    } else if (arguments.length === 2) {\n      const precisionModel = arguments[0], SRID = arguments[1]\n      GeometryFactory.constructor_.call(this, precisionModel, SRID, GeometryFactory.getDefaultCoordinateSequenceFactory())\n    } else if (arguments.length === 3) {\n      const precisionModel = arguments[0], SRID = arguments[1], coordinateSequenceFactory = arguments[2]\n      this._precisionModel = precisionModel\n      this._coordinateSequenceFactory = coordinateSequenceFactory\n      this._SRID = SRID\n    }\n  }\n  static toMultiPolygonArray(multiPolygons) {\n    const multiPolygonArray = new Array(multiPolygons.size()).fill(null)\n    return multiPolygons.toArray(multiPolygonArray)\n  }\n  static toGeometryArray(geometries) {\n    if (geometries === null) return null\n    const geometryArray = new Array(geometries.size()).fill(null)\n    return geometries.toArray(geometryArray)\n  }\n  static getDefaultCoordinateSequenceFactory() {\n    return CoordinateArraySequenceFactory.instance()\n  }\n  static toMultiLineStringArray(multiLineStrings) {\n    const multiLineStringArray = new Array(multiLineStrings.size()).fill(null)\n    return multiLineStrings.toArray(multiLineStringArray)\n  }\n  static toLineStringArray(lineStrings) {\n    const lineStringArray = new Array(lineStrings.size()).fill(null)\n    return lineStrings.toArray(lineStringArray)\n  }\n  static toMultiPointArray(multiPoints) {\n    const multiPointArray = new Array(multiPoints.size()).fill(null)\n    return multiPoints.toArray(multiPointArray)\n  }\n  static toLinearRingArray(linearRings) {\n    const linearRingArray = new Array(linearRings.size()).fill(null)\n    return linearRings.toArray(linearRingArray)\n  }\n  static toPointArray(points) {\n    const pointArray = new Array(points.size()).fill(null)\n    return points.toArray(pointArray)\n  }\n  static toPolygonArray(polygons) {\n    const polygonArray = new Array(polygons.size()).fill(null)\n    return polygons.toArray(polygonArray)\n  }\n  static createPointFromInternalCoord(coord, exemplar) {\n    exemplar.getPrecisionModel().makePrecise(coord)\n    return exemplar.getFactory().createPoint(coord)\n  }\n  createEmpty(dimension) {\n    switch (dimension) {\n    case -1:\n      return this.createGeometryCollection()\n    case 0:\n      return this.createPoint()\n    case 1:\n      return this.createLineString()\n    case 2:\n      return this.createPolygon()\n    default:\n      throw new IllegalArgumentException('Invalid dimension: ' + dimension)\n    }\n  }\n  toGeometry(envelope) {\n    if (envelope.isNull()) \n      return this.createPoint()\n    \n    if (envelope.getMinX() === envelope.getMaxX() && envelope.getMinY() === envelope.getMaxY()) \n      return this.createPoint(new Coordinate(envelope.getMinX(), envelope.getMinY()))\n    \n    if (envelope.getMinX() === envelope.getMaxX() || envelope.getMinY() === envelope.getMaxY()) \n      return this.createLineString([new Coordinate(envelope.getMinX(), envelope.getMinY()), new Coordinate(envelope.getMaxX(), envelope.getMaxY())])\n    \n    return this.createPolygon(this.createLinearRing([new Coordinate(envelope.getMinX(), envelope.getMinY()), new Coordinate(envelope.getMinX(), envelope.getMaxY()), new Coordinate(envelope.getMaxX(), envelope.getMaxY()), new Coordinate(envelope.getMaxX(), envelope.getMinY()), new Coordinate(envelope.getMinX(), envelope.getMinY())]), null)\n  }\n  createLineString() {\n    if (arguments.length === 0) \n      return this.createLineString(this.getCoordinateSequenceFactory().create([]))\n    else if (arguments.length === 1) \n      if (arguments[0] instanceof Array) {\n        const coordinates = arguments[0]\n        return this.createLineString(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null)\n      } else if (hasInterface(arguments[0], CoordinateSequence)) {\n        const coordinates = arguments[0]\n        return new LineString(coordinates, this)\n      }\n    \n  }\n  createMultiLineString() {\n    if (arguments.length === 0) {\n      return new MultiLineString(null, this)\n    } else if (arguments.length === 1) {\n      const lineStrings = arguments[0]\n      return new MultiLineString(lineStrings, this)\n    }\n  }\n  buildGeometry(geomList) {\n    let geomType = null\n    let isHeterogeneous = false\n    let hasGeometryCollection = false\n    for (let i = geomList.iterator(); i.hasNext(); ) {\n      const geom = i.next()\n      const partType = geom.getTypeCode()\n      if (geomType === null) \n        geomType = partType\n      \n      if (partType !== geomType) \n        isHeterogeneous = true\n      \n      if (geom instanceof GeometryCollection) hasGeometryCollection = true\n    }\n    if (geomType === null) \n      return this.createGeometryCollection()\n    \n    if (isHeterogeneous || hasGeometryCollection) \n      return this.createGeometryCollection(GeometryFactory.toGeometryArray(geomList))\n    \n    const geom0 = geomList.iterator().next()\n    const isCollection = geomList.size() > 1\n    if (isCollection) {\n      if (geom0 instanceof Polygon) \n        return this.createMultiPolygon(GeometryFactory.toPolygonArray(geomList))\n      else if (geom0 instanceof LineString) \n        return this.createMultiLineString(GeometryFactory.toLineStringArray(geomList))\n      else if (geom0 instanceof Point) \n        return this.createMultiPoint(GeometryFactory.toPointArray(geomList))\n      \n      Assert.shouldNeverReachHere('Unhandled geometry type: ' + geom0.getGeometryType())\n    }\n    return geom0\n  }\n  createMultiPointFromCoords(coordinates) {\n    return this.createMultiPoint(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null)\n  }\n  createPoint() {\n    if (arguments.length === 0) \n      return this.createPoint(this.getCoordinateSequenceFactory().create([]))\n    else if (arguments.length === 1) \n      if (arguments[0] instanceof Coordinate) {\n        const coordinate = arguments[0]\n        return this.createPoint(coordinate !== null ? this.getCoordinateSequenceFactory().create([coordinate]) : null)\n      } else if (hasInterface(arguments[0], CoordinateSequence)) {\n        const coordinates = arguments[0]\n        return new Point(coordinates, this)\n      }\n    \n  }\n  getCoordinateSequenceFactory() {\n    return this._coordinateSequenceFactory\n  }\n  createPolygon() {\n    if (arguments.length === 0) {\n      return this.createPolygon(null, null)\n    } else if (arguments.length === 1) {\n      if (hasInterface(arguments[0], CoordinateSequence)) {\n        const shell = arguments[0]\n        return this.createPolygon(this.createLinearRing(shell))\n      } else if (arguments[0] instanceof Array) {\n        const shell = arguments[0]\n        return this.createPolygon(this.createLinearRing(shell))\n      } else if (arguments[0] instanceof LinearRing) {\n        const shell = arguments[0]\n        return this.createPolygon(shell, null)\n      }\n    } else if (arguments.length === 2) {\n      const shell = arguments[0], holes = arguments[1]\n      return new Polygon(shell, holes, this)\n    }\n  }\n  getSRID() {\n    return this._SRID\n  }\n  createGeometryCollection() {\n    if (arguments.length === 0) {\n      return new GeometryCollection(null, this)\n    } else if (arguments.length === 1) {\n      const geometries = arguments[0]\n      return new GeometryCollection(geometries, this)\n    }\n  }\n  getPrecisionModel() {\n    return this._precisionModel\n  }\n  createLinearRing() {\n    if (arguments.length === 0) \n      return this.createLinearRing(this.getCoordinateSequenceFactory().create([]))\n    else if (arguments.length === 1) \n      if (arguments[0] instanceof Array) {\n        const coordinates = arguments[0]\n        return this.createLinearRing(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null)\n      } else if (hasInterface(arguments[0], CoordinateSequence)) {\n        const coordinates = arguments[0]\n        return new LinearRing(coordinates, this)\n      }\n    \n  }\n  createMultiPolygon() {\n    if (arguments.length === 0) {\n      return new MultiPolygon(null, this)\n    } else if (arguments.length === 1) {\n      const polygons = arguments[0]\n      return new MultiPolygon(polygons, this)\n    }\n  }\n  createMultiPoint() {\n    if (arguments.length === 0) \n      return new MultiPoint(null, this)\n    else if (arguments.length === 1) \n      if (arguments[0] instanceof Array) {\n        const point = arguments[0]\n        return new MultiPoint(point, this)\n      } else if (hasInterface(arguments[0], CoordinateSequence)) {\n        const coordinates = arguments[0]\n        if (coordinates === null) \n          return this.createMultiPoint(new Array(0).fill(null))\n        \n        const points = new Array(coordinates.size()).fill(null)\n        for (let i = 0; i < coordinates.size(); i++) {\n          const ptSeq = this.getCoordinateSequenceFactory().create(1, coordinates.getDimension(), coordinates.getMeasures())\n          CoordinateSequences.copy(coordinates, i, ptSeq, 0, 1)\n          points[i] = this.createPoint(ptSeq)\n        }\n        return this.createMultiPoint(points)\n      }\n    \n  }\n  get interfaces_() {\n    return [Serializable]\n  }\n}\n","import Coordinate from '../geom/Coordinate'\nimport GeometryFactory from '../geom/GeometryFactory'\n\n/**\n * The coordinate layout for geometries, indicating whether a 3rd or 4th z ('Z')\n * or measure ('M') coordinate is available. Supported values are `'XY'`,\n * `'XYZ'`, `'XYM'`, `'XYZM'`.\n * @enum {string}\n */\nconst GeometryLayout = {\n  XY: 'XY',\n  XYZ: 'XYZ',\n  XYM: 'XYM',\n  XYZM: 'XYZM',\n}\n\n/**\n * The geometry type. One of `'Point'`, `'LineString'`, `'LinearRing'`,\n * `'Polygon'`, `'MultiPoint'`, `'MultiLineString'`, `'MultiPolygon'`,\n * `'GeometryCollection'`, `'Circle'`.\n * @enum {string}\n */\nconst GeometryType = {\n  POINT: 'Point',\n  LINE_STRING: 'LineString',\n  LINEAR_RING: 'LinearRing',\n  POLYGON: 'Polygon',\n  MULTI_POINT: 'MultiPoint',\n  MULTI_LINE_STRING: 'MultiLineString',\n  MULTI_POLYGON: 'MultiPolygon',\n  GEOMETRY_COLLECTION: 'GeometryCollection',\n  CIRCLE: 'Circle',\n}\n\n/**\n * @typedef {Object} Options\n * @property {boolean} [splitCollection=false] Whether to split GeometryCollections into\n * multiple features on reading.\n */\n\n/**\n * @typedef {Object} Token\n * @property {number} type\n * @property {number|string} [value]\n * @property {number} position\n */\n\n/**\n * @const\n * @type {string}\n */\nconst EMPTY = 'EMPTY'\n\n/**\n * @const\n * @type {string}\n */\nconst Z = 'Z'\n\n/**\n * @const\n * @type {string}\n */\nconst M = 'M'\n\n/**\n * @const\n * @type {string}\n */\nconst ZM = 'ZM'\n\n/**\n * @const\n * @enum {number}\n */\nconst TokenType = {\n  TEXT: 1,\n  LEFT_PAREN: 2,\n  RIGHT_PAREN: 3,\n  NUMBER: 4,\n  COMMA: 5,\n  EOF: 6,\n}\n\n/**\n * @const\n * @type {Object<string, string>}\n */\nconst WKTGeometryType = {}\nfor (const type in GeometryType)\n  WKTGeometryType[type] = GeometryType[type].toUpperCase()\n\n\n/**\n * Class to tokenize a WKT string.\n */\nclass Lexer {\n  /**\n   * @param {string} wkt WKT string.\n   */\n  constructor(wkt) {\n    /**\n     * @type {string}\n     */\n    this.wkt = wkt\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.index_ = -1\n  }\n\n  /**\n   * @param {string} c Character.\n   * @return {boolean} Whether the character is alphabetic.\n   * @private\n   */\n  isAlpha_(c) {\n    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')\n  }\n\n  /**\n   * @param {string} c Character.\n   * @param {boolean=} opt_decimal Whether the string number\n   *     contains a dot, i.e. is a decimal number.\n   * @return {boolean} Whether the character is numeric.\n   * @private\n   */\n  isNumeric_(c, opt_decimal) {\n    const decimal = opt_decimal !== undefined ? opt_decimal : false\n    return (c >= '0' && c <= '9') || (c == '.' && !decimal)\n  }\n\n  /**\n   * @param {string} c Character.\n   * @return {boolean} Whether the character is whitespace.\n   * @private\n   */\n  isWhiteSpace_(c) {\n    return c == ' ' || c == '\\t' || c == '\\r' || c == '\\n'\n  }\n\n  /**\n   * @return {string} Next string character.\n   * @private\n   */\n  nextChar_() {\n    return this.wkt.charAt(++this.index_)\n  }\n\n  /**\n   * Fetch and return the next token.\n   * @return {!Token} Next string token.\n   */\n  nextToken() {\n    const c = this.nextChar_()\n    const position = this.index_\n    /** @type {number|string} */\n    let value = c\n    let type\n\n    if (c == '(') {\n      type = TokenType.LEFT_PAREN\n    } else if (c == ',') {\n      type = TokenType.COMMA\n    } else if (c == ')') {\n      type = TokenType.RIGHT_PAREN\n    } else if (this.isNumeric_(c) || c == '-') {\n      type = TokenType.NUMBER\n      value = this.readNumber_()\n    } else if (this.isAlpha_(c)) {\n      type = TokenType.TEXT\n      value = this.readText_()\n    } else if (this.isWhiteSpace_(c)) {\n      return this.nextToken()\n    } else if (c === '') {\n      type = TokenType.EOF\n    } else {\n      throw new Error('Unexpected character: ' + c)\n    }\n\n    return { position: position, value: value, type: type }\n  }\n\n  /**\n   * @return {number} Numeric token value.\n   * @private\n   */\n  readNumber_() {\n    let c\n    const index = this.index_\n    let decimal = false\n    let scientificNotation = false\n    do {\n      if (c == '.')\n        decimal = true\n      else if (c == 'e' || c == 'E')\n        scientificNotation = true\n      c = this.nextChar_()\n    } while (\n      this.isNumeric_(c, decimal) ||\n      // if we haven't detected a scientific number before, 'e' or 'E'\n      // hint that we should continue to read\n      (!scientificNotation && (c == 'e' || c == 'E')) ||\n      // once we know that we have a scientific number, both '-' and '+'\n      // are allowed\n      (scientificNotation && (c == '-' || c == '+'))\n    )\n    return parseFloat(this.wkt.substring(index, this.index_--))\n  }\n\n  /**\n   * @return {string} String token value.\n   * @private\n   */\n  readText_() {\n    let c\n    const index = this.index_\n    do\n      c = this.nextChar_()\n    while (this.isAlpha_(c))\n    return this.wkt.substring(index, this.index_--).toUpperCase()\n  }\n}\n\n/**\n * Class to parse the tokens from the WKT string.\n */\nclass Parser {\n  /**\n   * @param {Lexer} lexer The lexer.\n   */\n  constructor(lexer, factory) {\n    /**\n     * @type {Lexer}\n     * @private\n     */\n    this.lexer_ = lexer\n\n    /**\n     * @type {Token}\n     * @private\n     */\n    this.token_\n\n    /**\n     * @type {import(\"../geom/GeometryLayout.js\").default}\n     * @private\n     */\n    this.layout_ = GeometryLayout.XY\n\n    this.factory = factory\n  }\n\n  /**\n   * Fetch the next token form the lexer and replace the active token.\n   * @private\n   */\n  consume_() {\n    this.token_ = this.lexer_.nextToken()\n  }\n\n  /**\n   * Tests if the given type matches the type of the current token.\n   * @param {TokenType} type Token type.\n   * @return {boolean} Whether the token matches the given type.\n   */\n  isTokenType(type) {\n    const isMatch = this.token_.type == type\n    return isMatch\n  }\n\n  /**\n   * If the given type matches the current token, consume it.\n   * @param {TokenType} type Token type.\n   * @return {boolean} Whether the token matches the given type.\n   */\n  match(type) {\n    const isMatch = this.isTokenType(type)\n    if (isMatch) \n      this.consume_()\n    return isMatch\n  }\n\n  /**\n   * Try to parse the tokens provided by the lexer.\n   * @return {import(\"../geom/Geometry.js\").default} The geometry.\n   */\n  parse() {\n    this.consume_()\n    const geometry = this.parseGeometry_()\n    return geometry\n  }\n\n  /**\n   * Try to parse the dimensional info.\n   * @return {import(\"../geom/GeometryLayout.js\").default} The layout.\n   * @private\n   */\n  parseGeometryLayout_() {\n    let layout = GeometryLayout.XY\n    const dimToken = this.token_\n    if (this.isTokenType(TokenType.TEXT)) {\n      const dimInfo = dimToken.value\n      if (dimInfo === Z)\n        layout = GeometryLayout.XYZ\n      else if (dimInfo === M)\n        layout = GeometryLayout.XYM\n      else if (dimInfo === ZM)\n        layout = GeometryLayout.XYZM\n      if (layout !== GeometryLayout.XY)\n        this.consume_()\n    }\n    return layout\n  }\n\n  /**\n   * @return {!Array<import(\"../geom/Geometry.js\").default>} A collection of geometries.\n   * @private\n   */\n  parseGeometryCollectionText_() {\n    if (this.match(TokenType.LEFT_PAREN)) {\n      const geometries = []\n      do\n        geometries.push(this.parseGeometry_())\n      while (this.match(TokenType.COMMA))\n      if (this.match(TokenType.RIGHT_PAREN)) \n        return geometries\n    } else if (this.isEmptyGeometry_()) {\n      return []\n    }\n    throw new Error(this.formatErrorMessage_())\n  }\n\n  /**\n   * @return {Array<number>} All values in a point.\n   * @private\n   */\n  parsePointText_() {\n    if (this.match(TokenType.LEFT_PAREN)) {\n      const coordinates = this.parsePoint_()\n      if (this.match(TokenType.RIGHT_PAREN)) \n        return coordinates\n    } else if (this.isEmptyGeometry_()) {\n      return null\n    }\n    throw new Error(this.formatErrorMessage_())\n  }\n\n  /**\n   * @return {!Array<!Array<number>>} All points in a linestring.\n   * @private\n   */\n  parseLineStringText_() {\n    if (this.match(TokenType.LEFT_PAREN)) {\n      const coordinates = this.parsePointList_()\n      if (this.match(TokenType.RIGHT_PAREN)) \n        return coordinates\n    } else if (this.isEmptyGeometry_()) {\n      return []\n    }\n    throw new Error(this.formatErrorMessage_())\n  }\n\n  /**\n   * @return {!Array<!Array<!Array<number>>>} All points in a polygon.\n   * @private\n   */\n  parsePolygonText_() {\n    if (this.match(TokenType.LEFT_PAREN)) {\n      const coordinates = this.parseLineStringTextList_()\n      if (this.match(TokenType.RIGHT_PAREN)) \n        return coordinates\n    } else if (this.isEmptyGeometry_()) {\n      return []\n    }\n    throw new Error(this.formatErrorMessage_())\n  }\n\n  /**\n   * @return {!Array<!Array<number>>} All points in a multipoint.\n   * @private\n   */\n  parseMultiPointText_() {\n    if (this.match(TokenType.LEFT_PAREN)) {\n      let coordinates\n      if (this.token_.type == TokenType.LEFT_PAREN) \n        coordinates = this.parsePointTextList_()\n      else\n        coordinates = this.parsePointList_()\n      if (this.match(TokenType.RIGHT_PAREN)) \n        return coordinates\n    } else if (this.isEmptyGeometry_()) {\n      return []\n    }\n    throw new Error(this.formatErrorMessage_())\n  }\n\n  /**\n   * @return {!Array<!Array<!Array<number>>>} All linestring points\n   *                                          in a multilinestring.\n   * @private\n   */\n  parseMultiLineStringText_() {\n    if (this.match(TokenType.LEFT_PAREN)) {\n      const coordinates = this.parseLineStringTextList_()\n      if (this.match(TokenType.RIGHT_PAREN)) \n        return coordinates\n    } else if (this.isEmptyGeometry_()) {\n      return []\n    }\n    throw new Error(this.formatErrorMessage_())\n  }\n\n  /**\n   * @return {!Array<!Array<!Array<!Array<number>>>>} All polygon points in a multipolygon.\n   * @private\n   */\n  parseMultiPolygonText_() {\n    if (this.match(TokenType.LEFT_PAREN)) {\n      const coordinates = this.parsePolygonTextList_()\n      if (this.match(TokenType.RIGHT_PAREN)) \n        return coordinates\n    } else if (this.isEmptyGeometry_()) {\n      return []\n    }\n    throw new Error(this.formatErrorMessage_())\n  }\n\n  /**\n   * @return {!Array<number>} A point.\n   * @private\n   */\n  parsePoint_() {\n    const coordinates = []\n    const dimensions = this.layout_.length\n    for (let i = 0; i < dimensions; ++i) {\n      const token = this.token_\n      if (this.match(TokenType.NUMBER)) \n        coordinates.push(/** @type {number} */(token.value))\n      else\n        break\n    }\n    if (coordinates.length == dimensions) \n      return coordinates\n    throw new Error(this.formatErrorMessage_())\n  }\n\n  /**\n   * @return {!Array<!Array<number>>} An array of points.\n   * @private\n   */\n  parsePointList_() {\n    const coordinates = [this.parsePoint_()]\n    while (this.match(TokenType.COMMA))\n      coordinates.push(this.parsePoint_())\n    return coordinates\n  }\n\n  /**\n   * @return {!Array<!Array<number>>} An array of points.\n   * @private\n   */\n  parsePointTextList_() {\n    const coordinates = [this.parsePointText_()]\n    while (this.match(TokenType.COMMA))\n      coordinates.push(this.parsePointText_())\n    return coordinates\n  }\n\n  /**\n   * @return {!Array<!Array<!Array<number>>>} An array of points.\n   * @private\n   */\n  parseLineStringTextList_() {\n    const coordinates = [this.parseLineStringText_()]\n    while (this.match(TokenType.COMMA))\n      coordinates.push(this.parseLineStringText_())\n    return coordinates\n  }\n\n  /**\n   * @return {!Array<!Array<!Array<!Array<number>>>>} An array of points.\n   * @private\n   */\n  parsePolygonTextList_() {\n    const coordinates = [this.parsePolygonText_()]\n    while (this.match(TokenType.COMMA))\n      coordinates.push(this.parsePolygonText_())\n    return coordinates\n  }\n\n  /**\n   * @return {boolean} Whether the token implies an empty geometry.\n   * @private\n   */\n  isEmptyGeometry_() {\n    const isEmpty =\n      this.isTokenType(TokenType.TEXT) && this.token_.value == EMPTY\n    if (isEmpty)\n      this.consume_()\n    return isEmpty\n  }\n\n  /**\n   * Create an error message for an unexpected token error.\n   * @return {string} Error message.\n   * @private\n   */\n  formatErrorMessage_() {\n    return (\n      'Unexpected `' +\n      this.token_.value +\n      '` at position ' +\n      this.token_.position +\n      ' in `' +\n      this.lexer_.wkt +\n      '`'\n    )\n  }\n\n  /**\n   * @return {!import(\"../geom/Geometry.js\").default} The geometry.\n   * @private\n   */\n  parseGeometry_() {\n    const factory = this.factory\n\n    const o2c = ordinates => new Coordinate(...ordinates)\n    const ca2p = coordinates => {\n      const rings = coordinates.map(a => factory.createLinearRing(a.map(o2c)))\n      if (rings.length > 1)\n        return factory.createPolygon(rings[0], rings.slice(1))\n      else\n        return factory.createPolygon(rings[0])\n    }\n\n    const token = this.token_\n    if (this.match(TokenType.TEXT)) {\n      const geomType = token.value\n      this.layout_ = this.parseGeometryLayout_()\n      if (geomType == 'GEOMETRYCOLLECTION') {\n        const geometries = this.parseGeometryCollectionText_()\n        return factory.createGeometryCollection(geometries)\n      } else {\n        switch (geomType) {\n        case 'POINT': {\n          const ordinates = this.parsePointText_()\n          if (!ordinates)\n            return factory.createPoint()\n          return factory.createPoint(new Coordinate(...ordinates))\n        }\n        case 'LINESTRING': {\n          const coordinates = this.parseLineStringText_()\n          const components = coordinates.map(o2c)\n          return factory.createLineString(components)\n        }\n        case 'LINEARRING': {\n          const coordinates = this.parseLineStringText_()\n          const components = coordinates.map(o2c)\n          return factory.createLinearRing(components)\n        }\n        case 'POLYGON': {\n          const coordinates = this.parsePolygonText_()\n          if (!coordinates || coordinates.length === 0)\n            return factory.createPolygon()\n          return ca2p(coordinates)\n        }\n        case 'MULTIPOINT': {\n          const coordinates = this.parseMultiPointText_()\n          if (!coordinates || coordinates.length === 0)\n            return factory.createMultiPoint()\n          const components = coordinates.map(o2c).map(c => factory.createPoint(c))\n          return factory.createMultiPoint(components)\n        }\n        case 'MULTILINESTRING': {\n          const coordinates = this.parseMultiLineStringText_()\n          const components = coordinates.map(a => factory.createLineString(a.map(o2c)))\n          return factory.createMultiLineString(components)\n        }\n        case 'MULTIPOLYGON': {\n          const coordinates = this.parseMultiPolygonText_()\n          if (!coordinates || coordinates.length === 0)\n            return factory.createMultiPolygon()\n          const polygons = coordinates.map(ca2p)\n          return factory.createMultiPolygon(polygons)\n        }\n        default: {\n          throw new Error('Invalid geometry type: ' + geomType)\n        }\n        }\n      }\n    }\n    throw new Error(this.formatErrorMessage_())\n  }\n}\n\n/**\n * @param {Point} geom Point geometry.\n * @return {string} Coordinates part of Point as WKT.\n */\nfunction encodePointGeometry(geom) {\n  if (geom.isEmpty())\n    return ''\n  const c = geom.getCoordinate()\n  const cs = [c.x, c.y]\n  if (c.z !== undefined && !Number.isNaN(c.z))\n    cs.push(c.z)\n  if (c.m !== undefined && !Number.isNaN(c.m))\n    cs.push(c.m)\n  return cs.join(' ')\n}\n\n/**\n * @param {MultiPoint} geom MultiPoint geometry.\n * @return {string} Coordinates part of MultiPoint as WKT.\n */\nfunction encodeMultiPointGeometry(geom) {\n  const array = []\n  for (let i = 0, ii = geom.getNumGeometries(); i < ii; ++i) \n    array.push('(' + encodePointGeometry(geom.getGeometryN(i)) + ')')\n  return array.join(', ')\n}\n\n/**\n * @param {GeometryCollection} geom GeometryCollection geometry.\n * @return {string} Coordinates part of GeometryCollection as WKT.\n */\nfunction encodeGeometryCollectionGeometry(geom) {\n  const array = []\n  for (let i = 0, ii = geom.getNumGeometries(); i < ii; ++i) \n    array.push(encode(geom.getGeometryN(i)))\n  return array.join(', ')\n}\n\n/**\n * @param {LineString|import(\"../geom/LinearRing.js\").default} geom LineString geometry.\n * @return {string} Coordinates part of LineString as WKT.\n */\nfunction encodeLineStringGeometry(geom) {\n  const coordinates = geom.getCoordinates()\n    .map(c => {\n      const a = [c.x, c.y]\n      if (c.z !== undefined && !Number.isNaN(c.z))\n        a.push(c.z)\n      if (c.m !== undefined && !Number.isNaN(c.m))\n        a.push(c.m)\n      return a\n    })\n  const array = []\n  for (let i = 0, ii = coordinates.length; i < ii; ++i) \n    array.push(coordinates[i].join(' '))\n  return array.join(', ')\n}\n\n/**\n * @param {MultiLineString} geom MultiLineString geometry.\n * @return {string} Coordinates part of MultiLineString as WKT.\n */\nfunction encodeMultiLineStringGeometry(geom) {\n  const array = []\n  for (let i = 0, ii = geom.getNumGeometries(); i < ii; ++i) \n    array.push('(' + encodeLineStringGeometry(geom.getGeometryN(i)) + ')')\n  return array.join(', ')\n}\n\n/**\n * @param {Polygon} geom Polygon geometry.\n * @return {string} Coordinates part of Polygon as WKT.\n */\nfunction encodePolygonGeometry(geom) {\n  const array = []\n  array.push('(' + encodeLineStringGeometry(geom.getExteriorRing()) + ')')\n  for (let i = 0, ii = geom.getNumInteriorRing(); i < ii; ++i) \n    array.push('(' + encodeLineStringGeometry(geom.getInteriorRingN(i)) + ')')\n  return array.join(', ')\n}\n\n/**\n * @param {MultiPolygon} geom MultiPolygon geometry.\n * @return {string} Coordinates part of MultiPolygon as WKT.\n */\nfunction encodeMultiPolygonGeometry(geom) {\n  const array = []\n  for (let i = 0, ii = geom.getNumGeometries(); i < ii; ++i) \n    array.push('(' + encodePolygonGeometry(geom.getGeometryN(i)) + ')')\n  return array.join(', ')\n}\n\n/**\n * @param {Geometry} geom Geometry geometry.\n * @return {string} Potential dimensional information for WKT type.\n */\nfunction encodeGeometryLayout(geom) {\n  let dimInfo = ''\n  if (geom.isEmpty())\n    return dimInfo\n  const c = geom.getCoordinate()\n  if (c.z !== undefined && !Number.isNaN(c.z))\n    dimInfo += Z\n  if (c.m !== undefined && !Number.isNaN(c.m))\n    dimInfo += M\n  return dimInfo\n}\n\n/**\n * @const\n * @type {Object<string, function(import(\"../geom/Geometry.js\").default): string>}\n */\nconst GeometryEncoder = {\n  'Point': encodePointGeometry,\n  'LineString': encodeLineStringGeometry,\n  'LinearRing': encodeLineStringGeometry,\n  'Polygon': encodePolygonGeometry,\n  'MultiPoint': encodeMultiPointGeometry,\n  'MultiLineString': encodeMultiLineStringGeometry,\n  'MultiPolygon': encodeMultiPolygonGeometry,\n  'GeometryCollection': encodeGeometryCollectionGeometry,\n}\n\n/**\n * Encode a geometry as WKT.\n * @param {!import(\"../geom/Geometry.js\").default} geom The geometry to encode.\n * @return {string} WKT string for the geometry.\n */\nfunction encode(geom) {\n  let type = geom.getGeometryType()\n  const geometryEncoder = GeometryEncoder[type]\n  type = type.toUpperCase()\n  const dimInfo = encodeGeometryLayout(geom)\n  if (dimInfo.length > 0) \n    type += ' ' + dimInfo\n  if (geom.isEmpty()) \n    return type + ' ' + EMPTY\n  const enc = geometryEncoder(geom)\n  return type + ' (' + enc + ')'\n}\n\n/**\n * Class for reading and writing Well-Known Text.\n *\n * NOTE: Adapted from OpenLayers.\n */\n\nexport default class WKTParser {\n  /** Create a new parser for WKT\n   *\n   * @param {GeometryFactory} geometryFactory\n   * @return An instance of WKTParser.\n   * @private\n   */\n  constructor(geometryFactory) {\n    this.geometryFactory = geometryFactory || new GeometryFactory()\n    this.precisionModel = this.geometryFactory.getPrecisionModel()\n  }\n\n  /**\n   * Deserialize a WKT string and return a geometry. Supports WKT for POINT,\n   * MULTIPOINT, LINESTRING, LINEARRING, MULTILINESTRING, POLYGON, MULTIPOLYGON,\n   * and GEOMETRYCOLLECTION.\n   *\n   * @param {String} wkt A WKT string.\n   * @return {Geometry} A geometry instance.\n   * @private\n   */\n  read(wkt) {\n    const lexer = new Lexer(wkt)\n    const parser = new Parser(lexer, this.geometryFactory)\n    const geometry = parser.parse()\n    return geometry\n  }\n\n  /**\n   * Serialize a geometry into a WKT string.\n   *\n   * @param {Geometry} geometry A feature or array of features.\n   * @return {String} The WKT string representation of the input geometries.\n   * @private\n   */\n  write(geometry) {\n    return encode(geometry)\n  }\n}\n","/**\n * @module org/locationtech/jts/io/WKTWriter\n */\n\nimport WKTParser from './WKTParser'\n\n/**\n * Writes the Well-Known Text representation of a {@link Geometry}. The\n * Well-Known Text format is defined in the <A\n * HREF=\"http://www.opengis.org/techno/specs.htm\"> OGC Simple Features\n * Specification for SQL</A>.\n * <p>\n * The <code>WKTWriter</code> outputs coordinates rounded to the precision\n * model. Only the maximum number of decimal places necessary to represent the\n * ordinates to the required precision will be output.\n * <p>\n * The SFS WKT spec does not define a special tag for {@link LinearRing}s.\n * Under the spec, rings are output as <code>LINESTRING</code>s.\n */\nexport default class WKTWriter {\n  /**\n   * @param {GeometryFactory} geometryFactory\n   */\n  constructor(geometryFactory) {\n    this.parser = new WKTParser(geometryFactory)\n  }\n\n  /**\n   * Converts a <code>Geometry</code> to its Well-known Text representation.\n   *\n   * @param {Geometry} geometry a <code>Geometry</code> to process.\n   * @return {string} a <Geometry Tagged Text> string (see the OpenGIS Simple\n   *         Features Specification).\n   * @memberof module:org/locationtech/jts/io/WKTWriter#\n   */\n  write(geometry) {\n    return this.parser.write(geometry)\n  }\n\n  /**\n   * Generates the WKT for a <tt>LINESTRING</tt> specified by two\n   * {@link Coordinate}s.\n   *\n   * @param p0 the first coordinate.\n   * @param p1 the second coordinate.\n   *\n   * @return the WKT.\n   * @private\n   */\n  static toLineString(p0, p1) {\n    if (arguments.length !== 2) throw new Error('Not implemented')\n\n    return 'LINESTRING ( ' + p0.x + ' ' + p0.y + ', ' + p1.x + ' ' + p1.y + ' )'\n  }\n}\n","import WKTWriter from '../io/WKTWriter'\nimport Coordinate from '../geom/Coordinate'\nimport Assert from '../util/Assert'\nimport StringBuilder from '../../../../java/lang/StringBuilder'\nexport default class LineIntersector {\n  constructor() {\n    LineIntersector.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._result = null\n    this._inputLines = Array(2).fill().map(() => Array(2))\n    this._intPt = new Array(2).fill(null)\n    this._intLineIndex = null\n    this._isProper = null\n    this._pa = null\n    this._pb = null\n    this._precisionModel = null\n    this._intPt[0] = new Coordinate()\n    this._intPt[1] = new Coordinate()\n    this._pa = this._intPt[0]\n    this._pb = this._intPt[1]\n    this._result = 0\n  }\n  static computeEdgeDistance(p, p0, p1) {\n    const dx = Math.abs(p1.x - p0.x)\n    const dy = Math.abs(p1.y - p0.y)\n    let dist = -1.0\n    if (p.equals(p0)) {\n      dist = 0.0\n    } else if (p.equals(p1)) {\n      if (dx > dy) dist = dx; else dist = dy\n    } else {\n      const pdx = Math.abs(p.x - p0.x)\n      const pdy = Math.abs(p.y - p0.y)\n      if (dx > dy) dist = pdx; else dist = pdy\n      if (dist === 0.0 && !p.equals(p0)) \n        dist = Math.max(pdx, pdy)\n      \n    }\n    Assert.isTrue(!(dist === 0.0 && !p.equals(p0)), 'Bad distance calculation')\n    return dist\n  }\n  static nonRobustComputeEdgeDistance(p, p1, p2) {\n    const dx = p.x - p1.x\n    const dy = p.y - p1.y\n    const dist = Math.sqrt(dx * dx + dy * dy)\n    Assert.isTrue(!(dist === 0.0 && !p.equals(p1)), 'Invalid distance calculation')\n    return dist\n  }\n  getIndexAlongSegment(segmentIndex, intIndex) {\n    this.computeIntLineIndex()\n    return this._intLineIndex[segmentIndex][intIndex]\n  }\n  getTopologySummary() {\n    const catBuilder = new StringBuilder()\n    if (this.isEndPoint()) catBuilder.append(' endpoint')\n    if (this._isProper) catBuilder.append(' proper')\n    if (this.isCollinear()) catBuilder.append(' collinear')\n    return catBuilder.toString()\n  }\n  computeIntersection(p1, p2, p3, p4) {\n    this._inputLines[0][0] = p1\n    this._inputLines[0][1] = p2\n    this._inputLines[1][0] = p3\n    this._inputLines[1][1] = p4\n    this._result = this.computeIntersect(p1, p2, p3, p4)\n  }\n  getIntersectionNum() {\n    return this._result\n  }\n  computeIntLineIndex() {\n    if (arguments.length === 0) {\n      if (this._intLineIndex === null) {\n        this._intLineIndex = Array(2).fill().map(() => Array(2))\n        this.computeIntLineIndex(0)\n        this.computeIntLineIndex(1)\n      }\n    } else if (arguments.length === 1) {\n      const segmentIndex = arguments[0]\n      const dist0 = this.getEdgeDistance(segmentIndex, 0)\n      const dist1 = this.getEdgeDistance(segmentIndex, 1)\n      if (dist0 > dist1) {\n        this._intLineIndex[segmentIndex][0] = 0\n        this._intLineIndex[segmentIndex][1] = 1\n      } else {\n        this._intLineIndex[segmentIndex][0] = 1\n        this._intLineIndex[segmentIndex][1] = 0\n      }\n    }\n  }\n  isProper() {\n    return this.hasIntersection() && this._isProper\n  }\n  setPrecisionModel(precisionModel) {\n    this._precisionModel = precisionModel\n  }\n  isInteriorIntersection() {\n    if (arguments.length === 0) {\n      if (this.isInteriorIntersection(0)) return true\n      if (this.isInteriorIntersection(1)) return true\n      return false\n    } else if (arguments.length === 1) {\n      const inputLineIndex = arguments[0]\n      for (let i = 0; i < this._result; i++) \n        if (!(this._intPt[i].equals2D(this._inputLines[inputLineIndex][0]) || this._intPt[i].equals2D(this._inputLines[inputLineIndex][1]))) \n          return true\n        \n      \n      return false\n    }\n  }\n  getIntersection(intIndex) {\n    return this._intPt[intIndex]\n  }\n  isEndPoint() {\n    return this.hasIntersection() && !this._isProper\n  }\n  hasIntersection() {\n    return this._result !== LineIntersector.NO_INTERSECTION\n  }\n  getEdgeDistance(segmentIndex, intIndex) {\n    const dist = LineIntersector.computeEdgeDistance(this._intPt[intIndex], this._inputLines[segmentIndex][0], this._inputLines[segmentIndex][1])\n    return dist\n  }\n  isCollinear() {\n    return this._result === LineIntersector.COLLINEAR_INTERSECTION\n  }\n  toString() {\n    return WKTWriter.toLineString(this._inputLines[0][0], this._inputLines[0][1]) + ' - ' + WKTWriter.toLineString(this._inputLines[1][0], this._inputLines[1][1]) + this.getTopologySummary()\n  }\n  getEndpoint(segmentIndex, ptIndex) {\n    return this._inputLines[segmentIndex][ptIndex]\n  }\n  isIntersection(pt) {\n    for (let i = 0; i < this._result; i++) \n      if (this._intPt[i].equals2D(pt)) \n        return true\n      \n    \n    return false\n  }\n  getIntersectionAlongSegment(segmentIndex, intIndex) {\n    this.computeIntLineIndex()\n    return this._intPt[this._intLineIndex[segmentIndex][intIndex]]\n  }\n}\nLineIntersector.DONT_INTERSECT = 0\nLineIntersector.DO_INTERSECT = 1\nLineIntersector.COLLINEAR = 2\nLineIntersector.NO_INTERSECTION = 0\nLineIntersector.POINT_INTERSECTION = 1\nLineIntersector.COLLINEAR_INTERSECTION = 2\n","import Coordinate from '../geom/Coordinate'\nimport Orientation from './Orientation'\nimport Intersection from './Intersection'\nimport CGAlgorithmsDD from './CGAlgorithmsDD'\nimport System from '../../../../java/lang/System'\nimport Envelope from '../geom/Envelope'\nimport Distance from './Distance'\nimport LineIntersector from './LineIntersector'\nexport default class RobustLineIntersector extends LineIntersector {\n  constructor() {\n    super()\n  }\n  static nearestEndpoint(p1, p2, q1, q2) {\n    let nearestPt = p1\n    let minDist = Distance.pointToSegment(p1, q1, q2)\n    let dist = Distance.pointToSegment(p2, q1, q2)\n    if (dist < minDist) {\n      minDist = dist\n      nearestPt = p2\n    }\n    dist = Distance.pointToSegment(q1, p1, p2)\n    if (dist < minDist) {\n      minDist = dist\n      nearestPt = q1\n    }\n    dist = Distance.pointToSegment(q2, p1, p2)\n    if (dist < minDist) {\n      minDist = dist\n      nearestPt = q2\n    }\n    return nearestPt\n  }\n  isInSegmentEnvelopes(intPt) {\n    const env0 = new Envelope(this._inputLines[0][0], this._inputLines[0][1])\n    const env1 = new Envelope(this._inputLines[1][0], this._inputLines[1][1])\n    return env0.contains(intPt) && env1.contains(intPt)\n  }\n  computeIntersection() {\n    if (arguments.length === 3) {\n      const p = arguments[0], p1 = arguments[1], p2 = arguments[2]\n      this._isProper = false\n      if (Envelope.intersects(p1, p2, p)) \n        if (Orientation.index(p1, p2, p) === 0 && Orientation.index(p2, p1, p) === 0) {\n          this._isProper = true\n          if (p.equals(p1) || p.equals(p2)) \n            this._isProper = false\n          \n          this._result = LineIntersector.POINT_INTERSECTION\n          return null\n        }\n      \n      this._result = LineIntersector.NO_INTERSECTION\n    } else {\n      return super.computeIntersection.apply(this, arguments)\n    }\n  }\n  intersection(p1, p2, q1, q2) {\n    let intPt = this.intersectionSafe(p1, p2, q1, q2)\n    if (!this.isInSegmentEnvelopes(intPt)) \n      intPt = new Coordinate(RobustLineIntersector.nearestEndpoint(p1, p2, q1, q2))\n    \n    if (this._precisionModel !== null) \n      this._precisionModel.makePrecise(intPt)\n    \n    return intPt\n  }\n  checkDD(p1, p2, q1, q2, intPt) {\n    const intPtDD = CGAlgorithmsDD.intersection(p1, p2, q1, q2)\n    const isIn = this.isInSegmentEnvelopes(intPtDD)\n    System.out.println('DD in env = ' + isIn + '  --------------------- ' + intPtDD)\n    if (intPt.distance(intPtDD) > 0.0001) \n      System.out.println('Distance = ' + intPt.distance(intPtDD))\n    \n  }\n  intersectionSafe(p1, p2, q1, q2) {\n    let intPt = Intersection.intersection(p1, p2, q1, q2)\n    if (intPt === null) intPt = RobustLineIntersector.nearestEndpoint(p1, p2, q1, q2)\n    return intPt\n  }\n  computeCollinearIntersection(p1, p2, q1, q2) {\n    const p1q1p2 = Envelope.intersects(p1, p2, q1)\n    const p1q2p2 = Envelope.intersects(p1, p2, q2)\n    const q1p1q2 = Envelope.intersects(q1, q2, p1)\n    const q1p2q2 = Envelope.intersects(q1, q2, p2)\n    if (p1q1p2 && p1q2p2) {\n      this._intPt[0] = q1\n      this._intPt[1] = q2\n      return LineIntersector.COLLINEAR_INTERSECTION\n    }\n    if (q1p1q2 && q1p2q2) {\n      this._intPt[0] = p1\n      this._intPt[1] = p2\n      return LineIntersector.COLLINEAR_INTERSECTION\n    }\n    if (p1q1p2 && q1p1q2) {\n      this._intPt[0] = q1\n      this._intPt[1] = p1\n      return q1.equals(p1) && !p1q2p2 && !q1p2q2 ? LineIntersector.POINT_INTERSECTION : LineIntersector.COLLINEAR_INTERSECTION\n    }\n    if (p1q1p2 && q1p2q2) {\n      this._intPt[0] = q1\n      this._intPt[1] = p2\n      return q1.equals(p2) && !p1q2p2 && !q1p1q2 ? LineIntersector.POINT_INTERSECTION : LineIntersector.COLLINEAR_INTERSECTION\n    }\n    if (p1q2p2 && q1p1q2) {\n      this._intPt[0] = q2\n      this._intPt[1] = p1\n      return q2.equals(p1) && !p1q1p2 && !q1p2q2 ? LineIntersector.POINT_INTERSECTION : LineIntersector.COLLINEAR_INTERSECTION\n    }\n    if (p1q2p2 && q1p2q2) {\n      this._intPt[0] = q2\n      this._intPt[1] = p2\n      return q2.equals(p2) && !p1q1p2 && !q1p1q2 ? LineIntersector.POINT_INTERSECTION : LineIntersector.COLLINEAR_INTERSECTION\n    }\n    return LineIntersector.NO_INTERSECTION\n  }\n  computeIntersect(p1, p2, q1, q2) {\n    this._isProper = false\n    if (!Envelope.intersects(p1, p2, q1, q2)) return LineIntersector.NO_INTERSECTION\n    const Pq1 = Orientation.index(p1, p2, q1)\n    const Pq2 = Orientation.index(p1, p2, q2)\n    if (Pq1 > 0 && Pq2 > 0 || Pq1 < 0 && Pq2 < 0) \n      return LineIntersector.NO_INTERSECTION\n    \n    const Qp1 = Orientation.index(q1, q2, p1)\n    const Qp2 = Orientation.index(q1, q2, p2)\n    if (Qp1 > 0 && Qp2 > 0 || Qp1 < 0 && Qp2 < 0) \n      return LineIntersector.NO_INTERSECTION\n    \n    const collinear = Pq1 === 0 && Pq2 === 0 && Qp1 === 0 && Qp2 === 0\n    if (collinear) \n      return this.computeCollinearIntersection(p1, p2, q1, q2)\n    \n    if (Pq1 === 0 || Pq2 === 0 || Qp1 === 0 || Qp2 === 0) {\n      this._isProper = false\n      if (p1.equals2D(q1) || p1.equals2D(q2)) \n        this._intPt[0] = p1\n      else if (p2.equals2D(q1) || p2.equals2D(q2)) \n        this._intPt[0] = p2\n      else if (Pq1 === 0) \n        this._intPt[0] = new Coordinate(q1)\n      else if (Pq2 === 0) \n        this._intPt[0] = new Coordinate(q2)\n      else if (Qp1 === 0) \n        this._intPt[0] = new Coordinate(p1)\n      else if (Qp2 === 0) \n        this._intPt[0] = new Coordinate(p2)\n      \n    } else {\n      this._isProper = true\n      this._intPt[0] = this.intersection(p1, p2, q1, q2)\n    }\n    return LineIntersector.POINT_INTERSECTION\n  }\n}\n","import Location from '../geom/Location'\nimport hasInterface from '../../../../hasInterface'\nimport Coordinate from '../geom/Coordinate'\nimport Orientation from './Orientation'\nimport CoordinateSequence from '../geom/CoordinateSequence'\nexport default class RayCrossingCounter {\n  constructor() {\n    RayCrossingCounter.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._p = null\n    this._crossingCount = 0\n    this._isPointOnSegment = false\n    const p = arguments[0]\n    this._p = p\n  }\n  static locatePointInRing() {\n    if (arguments[0] instanceof Coordinate && hasInterface(arguments[1], CoordinateSequence)) {\n      const p = arguments[0], ring = arguments[1]\n      const counter = new RayCrossingCounter(p)\n      const p1 = new Coordinate()\n      const p2 = new Coordinate()\n      for (let i = 1; i < ring.size(); i++) {\n        ring.getCoordinate(i, p1)\n        ring.getCoordinate(i - 1, p2)\n        counter.countSegment(p1, p2)\n        if (counter.isOnSegment()) return counter.getLocation()\n      }\n      return counter.getLocation()\n    } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Array) {\n      const p = arguments[0], ring = arguments[1]\n      const counter = new RayCrossingCounter(p)\n      for (let i = 1; i < ring.length; i++) {\n        const p1 = ring[i]\n        const p2 = ring[i - 1]\n        counter.countSegment(p1, p2)\n        if (counter.isOnSegment()) return counter.getLocation()\n      }\n      return counter.getLocation()\n    }\n  }\n  countSegment(p1, p2) {\n    if (p1.x < this._p.x && p2.x < this._p.x) return null\n    if (this._p.x === p2.x && this._p.y === p2.y) {\n      this._isPointOnSegment = true\n      return null\n    }\n    if (p1.y === this._p.y && p2.y === this._p.y) {\n      let minx = p1.x\n      let maxx = p2.x\n      if (minx > maxx) {\n        minx = p2.x\n        maxx = p1.x\n      }\n      if (this._p.x >= minx && this._p.x <= maxx) \n        this._isPointOnSegment = true\n      \n      return null\n    }\n    if (p1.y > this._p.y && p2.y <= this._p.y || p2.y > this._p.y && p1.y <= this._p.y) {\n      let orient = Orientation.index(p1, p2, this._p)\n      if (orient === Orientation.COLLINEAR) {\n        this._isPointOnSegment = true\n        return null\n      }\n      if (p2.y < p1.y) \n        orient = -orient\n      \n      if (orient === Orientation.LEFT) \n        this._crossingCount++\n      \n    }\n  }\n  isPointInPolygon() {\n    return this.getLocation() !== Location.EXTERIOR\n  }\n  getLocation() {\n    if (this._isPointOnSegment) return Location.BOUNDARY\n    if (this._crossingCount % 2 === 1) \n      return Location.INTERIOR\n    \n    return Location.EXTERIOR\n  }\n  isOnSegment() {\n    return this._isPointOnSegment\n  }\n}\n","import Location from '../geom/Location'\nimport hasInterface from '../../../../hasInterface'\nimport Coordinate from '../geom/Coordinate'\nimport CoordinateSequence from '../geom/CoordinateSequence'\nimport RobustLineIntersector from './RobustLineIntersector'\nimport RayCrossingCounter from './RayCrossingCounter'\nexport default class PointLocation {\n  static isOnLine() {\n    if (arguments[0] instanceof Coordinate && hasInterface(arguments[1], CoordinateSequence)) {\n      const p = arguments[0], line = arguments[1]\n      const lineIntersector = new RobustLineIntersector()\n      const p0 = new Coordinate()\n      const p1 = new Coordinate()\n      const n = line.size()\n      for (let i = 1; i < n; i++) {\n        line.getCoordinate(i - 1, p0)\n        line.getCoordinate(i, p1)\n        lineIntersector.computeIntersection(p, p0, p1)\n        if (lineIntersector.hasIntersection()) \n          return true\n        \n      }\n      return false\n    } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Array) {\n      const p = arguments[0], line = arguments[1]\n      const lineIntersector = new RobustLineIntersector()\n      for (let i = 1; i < line.length; i++) {\n        const p0 = line[i - 1]\n        const p1 = line[i]\n        lineIntersector.computeIntersection(p, p0, p1)\n        if (lineIntersector.hasIntersection()) \n          return true\n        \n      }\n      return false\n    }\n  }\n  static locateInRing(p, ring) {\n    return RayCrossingCounter.locatePointInRing(p, ring)\n  }\n  static isInRing(p, ring) {\n    return PointLocation.locateInRing(p, ring) !== Location.EXTERIOR\n  }\n}\n","import StringBuffer from '../../../../java/lang/StringBuffer'\nimport Location from '../geom/Location'\nimport Position from './Position'\nexport default class TopologyLocation {\n  constructor() {\n    TopologyLocation.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this.location = null\n    if (arguments.length === 1) {\n      if (arguments[0] instanceof Array) {\n        const location = arguments[0]\n        this.init(location.length)\n      } else if (Number.isInteger(arguments[0])) {\n        const on = arguments[0]\n        this.init(1)\n        this.location[Position.ON] = on\n      } else if (arguments[0] instanceof TopologyLocation) {\n        const gl = arguments[0]\n        this.init(gl.location.length)\n        if (gl !== null) \n          for (let i = 0; i < this.location.length; i++) \n            this.location[i] = gl.location[i]\n          \n        \n      }\n    } else if (arguments.length === 3) {\n      const on = arguments[0], left = arguments[1], right = arguments[2]\n      this.init(3)\n      this.location[Position.ON] = on\n      this.location[Position.LEFT] = left\n      this.location[Position.RIGHT] = right\n    }\n  }\n  setAllLocations(locValue) {\n    for (let i = 0; i < this.location.length; i++) \n      this.location[i] = locValue\n    \n  }\n  isNull() {\n    for (let i = 0; i < this.location.length; i++) \n      if (this.location[i] !== Location.NONE) return false\n    \n    return true\n  }\n  setAllLocationsIfNull(locValue) {\n    for (let i = 0; i < this.location.length; i++) \n      if (this.location[i] === Location.NONE) this.location[i] = locValue\n    \n  }\n  isLine() {\n    return this.location.length === 1\n  }\n  merge(gl) {\n    if (gl.location.length > this.location.length) {\n      const newLoc = new Array(3).fill(null)\n      newLoc[Position.ON] = this.location[Position.ON]\n      newLoc[Position.LEFT] = Location.NONE\n      newLoc[Position.RIGHT] = Location.NONE\n      this.location = newLoc\n    }\n    for (let i = 0; i < this.location.length; i++) \n      if (this.location[i] === Location.NONE && i < gl.location.length) this.location[i] = gl.location[i]\n    \n  }\n  getLocations() {\n    return this.location\n  }\n  flip() {\n    if (this.location.length <= 1) return null\n    const temp = this.location[Position.LEFT]\n    this.location[Position.LEFT] = this.location[Position.RIGHT]\n    this.location[Position.RIGHT] = temp\n  }\n  toString() {\n    const buf = new StringBuffer()\n    if (this.location.length > 1) buf.append(Location.toLocationSymbol(this.location[Position.LEFT]))\n    buf.append(Location.toLocationSymbol(this.location[Position.ON]))\n    if (this.location.length > 1) buf.append(Location.toLocationSymbol(this.location[Position.RIGHT]))\n    return buf.toString()\n  }\n  setLocations(on, left, right) {\n    this.location[Position.ON] = on\n    this.location[Position.LEFT] = left\n    this.location[Position.RIGHT] = right\n  }\n  get(posIndex) {\n    if (posIndex < this.location.length) return this.location[posIndex]\n    return Location.NONE\n  }\n  isArea() {\n    return this.location.length > 1\n  }\n  isAnyNull() {\n    for (let i = 0; i < this.location.length; i++) \n      if (this.location[i] === Location.NONE) return true\n    \n    return false\n  }\n  setLocation() {\n    if (arguments.length === 1) {\n      const locValue = arguments[0]\n      this.setLocation(Position.ON, locValue)\n    } else if (arguments.length === 2) {\n      const locIndex = arguments[0], locValue = arguments[1]\n      this.location[locIndex] = locValue\n    }\n  }\n  init(size) {\n    this.location = new Array(size).fill(null)\n    this.setAllLocations(Location.NONE)\n  }\n  isEqualOnSide(le, locIndex) {\n    return this.location[locIndex] === le.location[locIndex]\n  }\n  allPositionsEqual(loc) {\n    for (let i = 0; i < this.location.length; i++) \n      if (this.location[i] !== loc) return false\n    \n    return true\n  }\n}\n","import StringBuffer from '../../../../java/lang/StringBuffer'\nimport Location from '../geom/Location'\nimport Position from './Position'\nimport TopologyLocation from './TopologyLocation'\nexport default class Label {\n  constructor() {\n    Label.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this.elt = new Array(2).fill(null)\n    if (arguments.length === 1) {\n      if (Number.isInteger(arguments[0])) {\n        const onLoc = arguments[0]\n        this.elt[0] = new TopologyLocation(onLoc)\n        this.elt[1] = new TopologyLocation(onLoc)\n      } else if (arguments[0] instanceof Label) {\n        const lbl = arguments[0]\n        this.elt[0] = new TopologyLocation(lbl.elt[0])\n        this.elt[1] = new TopologyLocation(lbl.elt[1])\n      }\n    } else if (arguments.length === 2) {\n      const geomIndex = arguments[0], onLoc = arguments[1]\n      this.elt[0] = new TopologyLocation(Location.NONE)\n      this.elt[1] = new TopologyLocation(Location.NONE)\n      this.elt[geomIndex].setLocation(onLoc)\n    } else if (arguments.length === 3) {\n      const onLoc = arguments[0], leftLoc = arguments[1], rightLoc = arguments[2]\n      this.elt[0] = new TopologyLocation(onLoc, leftLoc, rightLoc)\n      this.elt[1] = new TopologyLocation(onLoc, leftLoc, rightLoc)\n    } else if (arguments.length === 4) {\n      const geomIndex = arguments[0], onLoc = arguments[1], leftLoc = arguments[2], rightLoc = arguments[3]\n      this.elt[0] = new TopologyLocation(Location.NONE, Location.NONE, Location.NONE)\n      this.elt[1] = new TopologyLocation(Location.NONE, Location.NONE, Location.NONE)\n      this.elt[geomIndex].setLocations(onLoc, leftLoc, rightLoc)\n    }\n  }\n  static toLineLabel(label) {\n    const lineLabel = new Label(Location.NONE)\n    for (let i = 0; i < 2; i++) \n      lineLabel.setLocation(i, label.getLocation(i))\n    \n    return lineLabel\n  }\n  getGeometryCount() {\n    let count = 0\n    if (!this.elt[0].isNull()) count++\n    if (!this.elt[1].isNull()) count++\n    return count\n  }\n  setAllLocations(geomIndex, location) {\n    this.elt[geomIndex].setAllLocations(location)\n  }\n  isNull(geomIndex) {\n    return this.elt[geomIndex].isNull()\n  }\n  setAllLocationsIfNull() {\n    if (arguments.length === 1) {\n      const location = arguments[0]\n      this.setAllLocationsIfNull(0, location)\n      this.setAllLocationsIfNull(1, location)\n    } else if (arguments.length === 2) {\n      const geomIndex = arguments[0], location = arguments[1]\n      this.elt[geomIndex].setAllLocationsIfNull(location)\n    }\n  }\n  isLine(geomIndex) {\n    return this.elt[geomIndex].isLine()\n  }\n  merge(lbl) {\n    for (let i = 0; i < 2; i++) \n      if (this.elt[i] === null && lbl.elt[i] !== null) \n        this.elt[i] = new TopologyLocation(lbl.elt[i])\n      else \n        this.elt[i].merge(lbl.elt[i])\n      \n    \n  }\n  flip() {\n    this.elt[0].flip()\n    this.elt[1].flip()\n  }\n  getLocation() {\n    if (arguments.length === 1) {\n      const geomIndex = arguments[0]\n      return this.elt[geomIndex].get(Position.ON)\n    } else if (arguments.length === 2) {\n      const geomIndex = arguments[0], posIndex = arguments[1]\n      return this.elt[geomIndex].get(posIndex)\n    }\n  }\n  toString() {\n    const buf = new StringBuffer()\n    if (this.elt[0] !== null) {\n      buf.append('A:')\n      buf.append(this.elt[0].toString())\n    }\n    if (this.elt[1] !== null) {\n      buf.append(' B:')\n      buf.append(this.elt[1].toString())\n    }\n    return buf.toString()\n  }\n  isArea() {\n    if (arguments.length === 0) {\n      return this.elt[0].isArea() || this.elt[1].isArea()\n    } else if (arguments.length === 1) {\n      const geomIndex = arguments[0]\n      return this.elt[geomIndex].isArea()\n    }\n  }\n  isAnyNull(geomIndex) {\n    return this.elt[geomIndex].isAnyNull()\n  }\n  setLocation() {\n    if (arguments.length === 2) {\n      const geomIndex = arguments[0], location = arguments[1]\n      this.elt[geomIndex].setLocation(Position.ON, location)\n    } else if (arguments.length === 3) {\n      const geomIndex = arguments[0], posIndex = arguments[1], location = arguments[2]\n      this.elt[geomIndex].setLocation(posIndex, location)\n    }\n  }\n  isEqualOnSide(lbl, side) {\n    return this.elt[0].isEqualOnSide(lbl.elt[0], side) && this.elt[1].isEqualOnSide(lbl.elt[1], side)\n  }\n  allPositionsEqual(geomIndex, loc) {\n    return this.elt[geomIndex].allPositionsEqual(loc)\n  }\n  toLine(geomIndex) {\n    if (this.elt[geomIndex].isArea()) this.elt[geomIndex] = new TopologyLocation(this.elt[geomIndex].location[0])\n  }\n}\n","import Location from '../geom/Location'\nimport Position from './Position'\nimport PointLocation from '../algorithm/PointLocation'\nimport TopologyException from '../geom/TopologyException'\nimport Orientation from '../algorithm/Orientation'\nimport Label from './Label'\nimport ArrayList from '../../../../java/util/ArrayList'\nimport Assert from '../util/Assert'\nexport default class EdgeRing {\n  constructor() {\n    EdgeRing.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._startDe = null\n    this._maxNodeDegree = -1\n    this._edges = new ArrayList()\n    this._pts = new ArrayList()\n    this._label = new Label(Location.NONE)\n    this._ring = null\n    this._isHole = null\n    this._shell = null\n    this._holes = new ArrayList()\n    this._geometryFactory = null\n    if (arguments.length === 0) {} else if (arguments.length === 2) {\n      const start = arguments[0], geometryFactory = arguments[1]\n      this._geometryFactory = geometryFactory\n      this.computePoints(start)\n      this.computeRing()\n    }\n  }\n  computeRing() {\n    if (this._ring !== null) return null\n    const coord = new Array(this._pts.size()).fill(null)\n    for (let i = 0; i < this._pts.size(); i++) \n      coord[i] = this._pts.get(i)\n    \n    this._ring = this._geometryFactory.createLinearRing(coord)\n    this._isHole = Orientation.isCCW(this._ring.getCoordinates())\n  }\n  isIsolated() {\n    return this._label.getGeometryCount() === 1\n  }\n  computePoints(start) {\n    this._startDe = start\n    let de = start\n    let isFirstEdge = true\n    do {\n      if (de === null) throw new TopologyException('Found null DirectedEdge')\n      if (de.getEdgeRing() === this) throw new TopologyException('Directed Edge visited twice during ring-building at ' + de.getCoordinate())\n      this._edges.add(de)\n      const label = de.getLabel()\n      Assert.isTrue(label.isArea())\n      this.mergeLabel(label)\n      this.addPoints(de.getEdge(), de.isForward(), isFirstEdge)\n      isFirstEdge = false\n      this.setEdgeRing(de, this)\n      de = this.getNext(de)\n    } while (de !== this._startDe)\n  }\n  getLinearRing() {\n    return this._ring\n  }\n  getCoordinate(i) {\n    return this._pts.get(i)\n  }\n  computeMaxNodeDegree() {\n    this._maxNodeDegree = 0\n    let de = this._startDe\n    do {\n      const node = de.getNode()\n      const degree = node.getEdges().getOutgoingDegree(this)\n      if (degree > this._maxNodeDegree) this._maxNodeDegree = degree\n      de = this.getNext(de)\n    } while (de !== this._startDe)\n    this._maxNodeDegree *= 2\n  }\n  addPoints(edge, isForward, isFirstEdge) {\n    const edgePts = edge.getCoordinates()\n    if (isForward) {\n      let startIndex = 1\n      if (isFirstEdge) startIndex = 0\n      for (let i = startIndex; i < edgePts.length; i++) \n        this._pts.add(edgePts[i])\n      \n    } else {\n      let startIndex = edgePts.length - 2\n      if (isFirstEdge) startIndex = edgePts.length - 1\n      for (let i = startIndex; i >= 0; i--) \n        this._pts.add(edgePts[i])\n      \n    }\n  }\n  isHole() {\n    return this._isHole\n  }\n  setInResult() {\n    let de = this._startDe\n    do {\n      de.getEdge().setInResult(true)\n      de = de.getNext()\n    } while (de !== this._startDe)\n  }\n  containsPoint(p) {\n    const shell = this.getLinearRing()\n    const env = shell.getEnvelopeInternal()\n    if (!env.contains(p)) return false\n    if (!PointLocation.isInRing(p, shell.getCoordinates())) return false\n    for (let i = this._holes.iterator(); i.hasNext(); ) {\n      const hole = i.next()\n      if (hole.containsPoint(p)) return false\n    }\n    return true\n  }\n  addHole(ring) {\n    this._holes.add(ring)\n  }\n  isShell() {\n    return this._shell === null\n  }\n  getLabel() {\n    return this._label\n  }\n  getEdges() {\n    return this._edges\n  }\n  getMaxNodeDegree() {\n    if (this._maxNodeDegree < 0) this.computeMaxNodeDegree()\n    return this._maxNodeDegree\n  }\n  getShell() {\n    return this._shell\n  }\n  mergeLabel() {\n    if (arguments.length === 1) {\n      const deLabel = arguments[0]\n      this.mergeLabel(deLabel, 0)\n      this.mergeLabel(deLabel, 1)\n    } else if (arguments.length === 2) {\n      const deLabel = arguments[0], geomIndex = arguments[1]\n      const loc = deLabel.getLocation(geomIndex, Position.RIGHT)\n      if (loc === Location.NONE) return null\n      if (this._label.getLocation(geomIndex) === Location.NONE) {\n        this._label.setLocation(geomIndex, loc)\n        return null\n      }\n    }\n  }\n  setShell(shell) {\n    this._shell = shell\n    if (shell !== null) shell.addHole(this)\n  }\n  toPolygon(geometryFactory) {\n    const holeLR = new Array(this._holes.size()).fill(null)\n    for (let i = 0; i < this._holes.size(); i++) \n      holeLR[i] = this._holes.get(i).getLinearRing()\n    \n    const poly = geometryFactory.createPolygon(this.getLinearRing(), holeLR)\n    return poly\n  }\n}\n","import EdgeRing from '../../geomgraph/EdgeRing'\nexport default class MinimalEdgeRing extends EdgeRing {\n  constructor() {\n    super()\n    MinimalEdgeRing.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    const start = arguments[0], geometryFactory = arguments[1]\n    EdgeRing.constructor_.call(this, start, geometryFactory)\n  }\n  setEdgeRing(de, er) {\n    de.setMinEdgeRing(er)\n  }\n  getNext(de) {\n    return de.getNextMin()\n  }\n}\n","import MinimalEdgeRing from './MinimalEdgeRing'\nimport EdgeRing from '../../geomgraph/EdgeRing'\nimport ArrayList from '../../../../../java/util/ArrayList'\nexport default class MaximalEdgeRing extends EdgeRing {\n  constructor() {\n    super()\n    MaximalEdgeRing.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    const start = arguments[0], geometryFactory = arguments[1]\n    EdgeRing.constructor_.call(this, start, geometryFactory)\n  }\n  buildMinimalRings() {\n    const minEdgeRings = new ArrayList()\n    let de = this._startDe\n    do {\n      if (de.getMinEdgeRing() === null) {\n        const minEr = new MinimalEdgeRing(de, this._geometryFactory)\n        minEdgeRings.add(minEr)\n      }\n      de = de.getNext()\n    } while (de !== this._startDe)\n    return minEdgeRings\n  }\n  setEdgeRing(de, er) {\n    de.setEdgeRing(er)\n  }\n  linkDirectedEdgesForMinimalEdgeRings() {\n    let de = this._startDe\n    do {\n      const node = de.getNode()\n      node.getEdges().linkMinimalDirectedEdges(this)\n      de = de.getNext()\n    } while (de !== this._startDe)\n  }\n  getNext(de) {\n    return de.getNext()\n  }\n}\n","import Assert from '../util/Assert'\nexport default class GraphComponent {\n  constructor() {\n    GraphComponent.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._label = null\n    this._isInResult = false\n    this._isCovered = false\n    this._isCoveredSet = false\n    this._isVisited = false\n    if (arguments.length === 0) {} else if (arguments.length === 1) {\n      const label = arguments[0]\n      this._label = label\n    }\n  }\n  setVisited(isVisited) {\n    this._isVisited = isVisited\n  }\n  setInResult(isInResult) {\n    this._isInResult = isInResult\n  }\n  isCovered() {\n    return this._isCovered\n  }\n  isCoveredSet() {\n    return this._isCoveredSet\n  }\n  setLabel(label) {\n    this._label = label\n  }\n  getLabel() {\n    return this._label\n  }\n  setCovered(isCovered) {\n    this._isCovered = isCovered\n    this._isCoveredSet = true\n  }\n  updateIM(im) {\n    Assert.isTrue(this._label.getGeometryCount() >= 2, 'found partial label')\n    this.computeIM(im)\n  }\n  isInResult() {\n    return this._isInResult\n  }\n  isVisited() {\n    return this._isVisited\n  }\n}\n","import Location from '../geom/Location'\nimport Label from './Label'\nimport GraphComponent from './GraphComponent'\nexport default class Node extends GraphComponent {\n  constructor() {\n    super()\n    Node.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._coord = null\n    this._edges = null\n    const coord = arguments[0], edges = arguments[1]\n    this._coord = coord\n    this._edges = edges\n    this._label = new Label(0, Location.NONE)\n  }\n  isIncidentEdgeInResult() {\n    for (let it = this.getEdges().getEdges().iterator(); it.hasNext(); ) {\n      const de = it.next()\n      if (de.getEdge().isInResult()) return true\n    }\n    return false\n  }\n  isIsolated() {\n    return this._label.getGeometryCount() === 1\n  }\n  getCoordinate() {\n    return this._coord\n  }\n  print(out) {\n    out.println('node ' + this._coord + ' lbl: ' + this._label)\n  }\n  computeIM(im) {}\n  computeMergedLocation(label2, eltIndex) {\n    let loc = Location.NONE\n    loc = this._label.getLocation(eltIndex)\n    if (!label2.isNull(eltIndex)) {\n      const nLoc = label2.getLocation(eltIndex)\n      if (loc !== Location.BOUNDARY) loc = nLoc\n    }\n    return loc\n  }\n  setLabel() {\n    if (arguments.length === 2 && (Number.isInteger(arguments[1]) && Number.isInteger(arguments[0]))) {\n      const argIndex = arguments[0], onLocation = arguments[1]\n      if (this._label === null) \n        this._label = new Label(argIndex, onLocation)\n      else this._label.setLocation(argIndex, onLocation)\n    } else {\n      return super.setLabel.apply(this, arguments)\n    }\n  }\n  getEdges() {\n    return this._edges\n  }\n  mergeLabel() {\n    if (arguments[0] instanceof Node) {\n      const n = arguments[0]\n      this.mergeLabel(n._label)\n    } else if (arguments[0] instanceof Label) {\n      const label2 = arguments[0]\n      for (let i = 0; i < 2; i++) {\n        const loc = this.computeMergedLocation(label2, i)\n        const thisLoc = this._label.getLocation(i)\n        if (thisLoc === Location.NONE) this._label.setLocation(i, loc)\n      }\n    }\n  }\n  add(e) {\n    this._edges.insert(e)\n    e.setNode(this)\n  }\n  setLabelBoundary(argIndex) {\n    if (this._label === null) return null\n    let loc = Location.NONE\n    if (this._label !== null) loc = this._label.getLocation(argIndex)\n    let newLoc = null\n    switch (loc) {\n    case Location.BOUNDARY:\n      newLoc = Location.INTERIOR\n      break\n    case Location.INTERIOR:\n      newLoc = Location.BOUNDARY\n      break\n    default:\n      newLoc = Location.BOUNDARY\n      break\n    }\n    this._label.setLocation(argIndex, newLoc)\n  }\n}\n","import Map from './Map'\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/SortedMap.html\n */\nexport default class SortedMap extends Map {}\n","import ArrayList from './ArrayList'\nimport SortedMap from './SortedMap'\nimport HashSet from './HashSet'\n\nconst BLACK = 0\nconst RED = 1\n\nfunction colorOf(p) {\n  return (p == null ? BLACK : p.color)\n}\nfunction parentOf(p) {\n  return (p == null ? null : p.parent)\n}\nfunction setColor(p, c) {\n  if (p !== null) p.color = c\n}\nfunction leftOf(p) {\n  return (p == null ? null : p.left)\n}\nfunction rightOf(p) {\n  return (p == null ? null : p.right)\n}\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/TreeMap.html\n */\nexport default class TreeMap extends SortedMap {\n  constructor() {\n    super()\n    this.root_ = null\n    this.size_ = 0\n  }\n\n  get(key) {\n    let p = this.root_\n    while (p !== null) {\n      const cmp = key.compareTo(p.key)\n      if (cmp < 0)\n        p = p.left\n      else if (cmp > 0)\n        p = p.right\n      else return p.value\n    }\n    return null\n  }\n\n  put(key, value) {\n    if (this.root_ === null) {\n      this.root_ = {\n        key: key,\n        value: value,\n        left: null,\n        right: null,\n        parent: null,\n        color: BLACK,\n        getValue() {\n          return this.value\n        },\n        getKey() {\n          return this.key\n        }\n      }\n      this.size_ = 1\n      return null\n    }\n    let t = this.root_; let parent; let cmp\n    do {\n      parent = t\n      cmp = key.compareTo(t.key)\n      if (cmp < 0) {\n        t = t.left\n      } else if (cmp > 0) {\n        t = t.right\n      } else {\n        const oldValue = t.value\n        t.value = value\n        return oldValue\n      }\n    } while (t !== null)\n    const e = {\n      key: key,\n      left: null,\n      right: null,\n      value: value,\n      parent: parent,\n      color: BLACK,\n      getValue() {\n        return this.value\n      },\n      getKey() {\n        return this.key\n      }\n    }\n    if (cmp < 0)\n      parent.left = e\n    else parent.right = e\n\n    this.fixAfterInsertion(e)\n    this.size_++\n    return null\n  }\n\n  /**\n   * @param {Object} x\n   */\n  fixAfterInsertion(x) {\n    let y\n    x.color = RED\n    while (x != null && x !== this.root_ && x.parent.color === RED)\n      if (parentOf(x) === leftOf(parentOf(parentOf(x)))) {\n        y = rightOf(parentOf(parentOf(x)))\n        if (colorOf(y) === RED) {\n          setColor(parentOf(x), BLACK)\n          setColor(y, BLACK)\n          setColor(parentOf(parentOf(x)), RED)\n          x = parentOf(parentOf(x))\n        } else {\n          if (x === rightOf(parentOf(x))) {\n            x = parentOf(x)\n            this.rotateLeft(x)\n          }\n          setColor(parentOf(x), BLACK)\n          setColor(parentOf(parentOf(x)), RED)\n          this.rotateRight(parentOf(parentOf(x)))\n        }\n      } else {\n        y = leftOf(parentOf(parentOf(x)))\n        if (colorOf(y) === RED) {\n          setColor(parentOf(x), BLACK)\n          setColor(y, BLACK)\n          setColor(parentOf(parentOf(x)), RED)\n          x = parentOf(parentOf(x))\n        } else {\n          if (x === leftOf(parentOf(x))) {\n            x = parentOf(x)\n            this.rotateRight(x)\n          }\n          setColor(parentOf(x), BLACK)\n          setColor(parentOf(parentOf(x)), RED)\n          this.rotateLeft(parentOf(parentOf(x)))\n        }\n      }\n\n    this.root_.color = BLACK\n  }\n\n  values() {\n    const arrayList = new ArrayList()\n    let p = this.getFirstEntry()\n    if (p !== null) {\n      arrayList.add(p.value)\n      while ((p = TreeMap.successor(p)) !== null)\n        arrayList.add(p.value)\n    }\n    return arrayList\n  }\n\n  entrySet() {\n    const hashSet = new HashSet()\n    let p = this.getFirstEntry()\n    if (p !== null) {\n      hashSet.add(p)\n      while ((p = TreeMap.successor(p)) !== null)\n        hashSet.add(p)\n    }\n    return hashSet\n  }\n\n  /**\n   * @param {Object} p\n   */\n  rotateLeft(p) {\n    if (p != null) {\n      const r = p.right\n      p.right = r.left\n      if (r.left != null)\n        r.left.parent = p\n      r.parent = p.parent\n      if (p.parent == null)\n        this.root_ = r\n      else if (p.parent.left === p)\n        p.parent.left = r\n      else\n        p.parent.right = r\n      r.left = p\n      p.parent = r\n    }\n  }\n\n  /**\n   * @param {Object} p\n   */\n  rotateRight(p) {\n    if (p != null) {\n      const l = p.left\n      p.left = l.right\n      if (l.right != null)\n        l.right.parent = p\n      l.parent = p.parent\n      if (p.parent == null)\n        this.root_ = l\n      else if (p.parent.right === p)\n        p.parent.right = l\n      else\n        p.parent.left = l\n      l.right = p\n      p.parent = l\n    }\n  }\n\n  /**\n   * @return {Object}\n   */\n  getFirstEntry() {\n    let p = this.root_\n    if (p != null)\n      while (p.left != null) p = p.left\n    return p\n  }\n\n  /**\n   * @param {Object} t\n   * @return {Object}\n   * @private\n   */\n  static successor(t) {\n    let p\n    if (t === null) {\n      return null\n    } else if (t.right !== null) {\n      p = t.right\n      while (p.left !== null)\n        p = p.left\n      return p\n    } else {\n      p = t.parent\n      let ch = t\n      while (p !== null && ch === p.right) {\n        ch = p\n        p = p.parent\n      }\n      return p\n    }\n  }\n\n  size() {\n    return this.size_\n  }\n\n  containsKey(key) {\n    let p = this.root_\n    while (p !== null) {\n      const cmp = key.compareTo(p.key)\n      if (cmp < 0)\n        p = p.left\n      else if (cmp > 0)\n        p = p.right\n      else return true\n    }\n    return false\n  }\n}\n","import Location from '../geom/Location'\nimport Coordinate from '../geom/Coordinate'\nimport Node from './Node'\nimport ArrayList from '../../../../java/util/ArrayList'\nimport TreeMap from '../../../../java/util/TreeMap'\nexport default class NodeMap {\n  constructor() {\n    NodeMap.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this.nodeMap = new TreeMap()\n    this.nodeFact = null\n    const nodeFact = arguments[0]\n    this.nodeFact = nodeFact\n  }\n  find(coord) {\n    return this.nodeMap.get(coord)\n  }\n  addNode() {\n    if (arguments[0] instanceof Coordinate) {\n      const coord = arguments[0]\n      let node = this.nodeMap.get(coord)\n      if (node === null) {\n        node = this.nodeFact.createNode(coord)\n        this.nodeMap.put(coord, node)\n      }\n      return node\n    } else if (arguments[0] instanceof Node) {\n      const n = arguments[0]\n      const node = this.nodeMap.get(n.getCoordinate())\n      if (node === null) {\n        this.nodeMap.put(n.getCoordinate(), n)\n        return n\n      }\n      node.mergeLabel(n)\n      return node\n    }\n  }\n  print(out) {\n    for (let it = this.iterator(); it.hasNext(); ) {\n      const n = it.next()\n      n.print(out)\n    }\n  }\n  iterator() {\n    return this.nodeMap.values().iterator()\n  }\n  values() {\n    return this.nodeMap.values()\n  }\n  getBoundaryNodes(geomIndex) {\n    const bdyNodes = new ArrayList()\n    for (let i = this.iterator(); i.hasNext(); ) {\n      const node = i.next()\n      if (node.getLabel().getLocation(geomIndex) === Location.BOUNDARY) bdyNodes.add(node)\n    }\n    return bdyNodes\n  }\n  add(e) {\n    const p = e.getCoordinate()\n    const n = this.addNode(p)\n    n.add(e)\n  }\n}\n","import Coordinate from '../geom/Coordinate'\nimport IllegalArgumentException from '../../../../java/lang/IllegalArgumentException'\nexport default class Quadrant {\n  static isNorthern(quad) {\n    return quad === Quadrant.NE || quad === Quadrant.NW\n  }\n  static isOpposite(quad1, quad2) {\n    if (quad1 === quad2) return false\n    const diff = (quad1 - quad2 + 4) % 4\n    if (diff === 2) return true\n    return false\n  }\n  static commonHalfPlane(quad1, quad2) {\n    if (quad1 === quad2) return quad1\n    const diff = (quad1 - quad2 + 4) % 4\n    if (diff === 2) return -1\n    const min = quad1 < quad2 ? quad1 : quad2\n    const max = quad1 > quad2 ? quad1 : quad2\n    if (min === 0 && max === 3) return 3\n    return min\n  }\n  static isInHalfPlane(quad, halfPlane) {\n    if (halfPlane === Quadrant.SE) \n      return quad === Quadrant.SE || quad === Quadrant.SW\n    \n    return quad === halfPlane || quad === halfPlane + 1\n  }\n  static quadrant() {\n    if (typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {\n      const dx = arguments[0], dy = arguments[1]\n      if (dx === 0.0 && dy === 0.0) throw new IllegalArgumentException('Cannot compute the quadrant for point ( ' + dx + ', ' + dy + ' )')\n      if (dx >= 0.0) \n        if (dy >= 0.0) return Quadrant.NE; else return Quadrant.SE\n      else \n      if (dy >= 0.0) return Quadrant.NW; else return Quadrant.SW\n      \n    } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {\n      const p0 = arguments[0], p1 = arguments[1]\n      if (p1.x === p0.x && p1.y === p0.y) throw new IllegalArgumentException('Cannot compute the quadrant for two identical points ' + p0)\n      if (p1.x >= p0.x) \n        if (p1.y >= p0.y) return Quadrant.NE; else return Quadrant.SE\n      else \n      if (p1.y >= p0.y) return Quadrant.NW; else return Quadrant.SW\n      \n    }\n  }\n}\nQuadrant.NE = 0\nQuadrant.NW = 1\nQuadrant.SW = 2\nQuadrant.SE = 3\n","import Orientation from '../algorithm/Orientation'\nimport Comparable from '../../../../java/lang/Comparable'\nimport Quadrant from './Quadrant'\nimport Assert from '../util/Assert'\nexport default class EdgeEnd {\n  constructor() {\n    EdgeEnd.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._edge = null\n    this._label = null\n    this._node = null\n    this._p0 = null\n    this._p1 = null\n    this._dx = null\n    this._dy = null\n    this._quadrant = null\n    if (arguments.length === 1) {\n      const edge = arguments[0]\n      this._edge = edge\n    } else if (arguments.length === 3) {\n      const edge = arguments[0], p0 = arguments[1], p1 = arguments[2]\n      EdgeEnd.constructor_.call(this, edge, p0, p1, null)\n    } else if (arguments.length === 4) {\n      const edge = arguments[0], p0 = arguments[1], p1 = arguments[2], label = arguments[3]\n      EdgeEnd.constructor_.call(this, edge)\n      this.init(p0, p1)\n      this._label = label\n    }\n  }\n  compareDirection(e) {\n    if (this._dx === e._dx && this._dy === e._dy) return 0\n    if (this._quadrant > e._quadrant) return 1\n    if (this._quadrant < e._quadrant) return -1\n    return Orientation.index(e._p0, e._p1, this._p1)\n  }\n  getDy() {\n    return this._dy\n  }\n  getCoordinate() {\n    return this._p0\n  }\n  setNode(node) {\n    this._node = node\n  }\n  print(out) {\n    const angle = Math.atan2(this._dy, this._dx)\n    const className = this.getClass().getName()\n    const lastDotPos = className.lastIndexOf('.')\n    const name = className.substring(lastDotPos + 1)\n    out.print('  ' + name + ': ' + this._p0 + ' - ' + this._p1 + ' ' + this._quadrant + ':' + angle + '   ' + this._label)\n  }\n  compareTo(obj) {\n    const e = obj\n    return this.compareDirection(e)\n  }\n  getDirectedCoordinate() {\n    return this._p1\n  }\n  getDx() {\n    return this._dx\n  }\n  getLabel() {\n    return this._label\n  }\n  getEdge() {\n    return this._edge\n  }\n  getQuadrant() {\n    return this._quadrant\n  }\n  getNode() {\n    return this._node\n  }\n  toString() {\n    const angle = Math.atan2(this._dy, this._dx)\n    const className = this.getClass().getName()\n    const lastDotPos = className.lastIndexOf('.')\n    const name = className.substring(lastDotPos + 1)\n    return '  ' + name + ': ' + this._p0 + ' - ' + this._p1 + ' ' + this._quadrant + ':' + angle + '   ' + this._label\n  }\n  computeLabel(boundaryNodeRule) {}\n  init(p0, p1) {\n    this._p0 = p0\n    this._p1 = p1\n    this._dx = p1.x - p0.x\n    this._dy = p1.y - p0.y\n    this._quadrant = Quadrant.quadrant(this._dx, this._dy)\n    Assert.isTrue(!(this._dx === 0 && this._dy === 0), 'EdgeEnd with identical endpoints found')\n  }\n  get interfaces_() {\n    return [Comparable]\n  }\n}\n","import Location from '../geom/Location'\nimport EdgeEnd from './EdgeEnd'\nimport Position from './Position'\nimport TopologyException from '../geom/TopologyException'\nimport Label from './Label'\nexport default class DirectedEdge extends EdgeEnd {\n  constructor() {\n    super()\n    DirectedEdge.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._isForward = null\n    this._isInResult = false\n    this._isVisited = false\n    this._sym = null\n    this._next = null\n    this._nextMin = null\n    this._edgeRing = null\n    this._minEdgeRing = null\n    this._depth = [0, -999, -999]\n    const edge = arguments[0], isForward = arguments[1]\n    EdgeEnd.constructor_.call(this, edge)\n    this._isForward = isForward\n    if (isForward) {\n      this.init(edge.getCoordinate(0), edge.getCoordinate(1))\n    } else {\n      const n = edge.getNumPoints() - 1\n      this.init(edge.getCoordinate(n), edge.getCoordinate(n - 1))\n    }\n    this.computeDirectedLabel()\n  }\n  static depthFactor(currLocation, nextLocation) {\n    if (currLocation === Location.EXTERIOR && nextLocation === Location.INTERIOR) return 1; else if (currLocation === Location.INTERIOR && nextLocation === Location.EXTERIOR) return -1\n    return 0\n  }\n  getNextMin() {\n    return this._nextMin\n  }\n  getDepth(position) {\n    return this._depth[position]\n  }\n  setVisited(isVisited) {\n    this._isVisited = isVisited\n  }\n  computeDirectedLabel() {\n    this._label = new Label(this._edge.getLabel())\n    if (!this._isForward) this._label.flip()\n  }\n  getNext() {\n    return this._next\n  }\n  setDepth(position, depthVal) {\n    if (this._depth[position] !== -999) \n      if (this._depth[position] !== depthVal) throw new TopologyException('assigned depths do not match', this.getCoordinate())\n    \n    this._depth[position] = depthVal\n  }\n  isInteriorAreaEdge() {\n    let isInteriorAreaEdge = true\n    for (let i = 0; i < 2; i++) \n      if (!(this._label.isArea(i) && this._label.getLocation(i, Position.LEFT) === Location.INTERIOR && this._label.getLocation(i, Position.RIGHT) === Location.INTERIOR)) \n        isInteriorAreaEdge = false\n      \n    \n    return isInteriorAreaEdge\n  }\n  setNextMin(nextMin) {\n    this._nextMin = nextMin\n  }\n  print(out) {\n    super.print.call(this, out)\n    out.print(' ' + this._depth[Position.LEFT] + '/' + this._depth[Position.RIGHT])\n    out.print(' (' + this.getDepthDelta() + ')')\n    if (this._isInResult) out.print(' inResult')\n  }\n  setMinEdgeRing(minEdgeRing) {\n    this._minEdgeRing = minEdgeRing\n  }\n  isLineEdge() {\n    const isLine = this._label.isLine(0) || this._label.isLine(1)\n    const isExteriorIfArea0 = !this._label.isArea(0) || this._label.allPositionsEqual(0, Location.EXTERIOR)\n    const isExteriorIfArea1 = !this._label.isArea(1) || this._label.allPositionsEqual(1, Location.EXTERIOR)\n    return isLine && isExteriorIfArea0 && isExteriorIfArea1\n  }\n  setEdgeRing(edgeRing) {\n    this._edgeRing = edgeRing\n  }\n  getMinEdgeRing() {\n    return this._minEdgeRing\n  }\n  getDepthDelta() {\n    let depthDelta = this._edge.getDepthDelta()\n    if (!this._isForward) depthDelta = -depthDelta\n    return depthDelta\n  }\n  setInResult(isInResult) {\n    this._isInResult = isInResult\n  }\n  getSym() {\n    return this._sym\n  }\n  isForward() {\n    return this._isForward\n  }\n  getEdge() {\n    return this._edge\n  }\n  printEdge(out) {\n    this.print(out)\n    out.print(' ')\n    if (this._isForward) this._edge.print(out); else this._edge.printReverse(out)\n  }\n  setSym(de) {\n    this._sym = de\n  }\n  setVisitedEdge(isVisited) {\n    this.setVisited(isVisited)\n    this._sym.setVisited(isVisited)\n  }\n  setEdgeDepths(position, depth) {\n    let depthDelta = this.getEdge().getDepthDelta()\n    if (!this._isForward) depthDelta = -depthDelta\n    let directionFactor = 1\n    if (position === Position.LEFT) directionFactor = -1\n    const oppositePos = Position.opposite(position)\n    const delta = depthDelta * directionFactor\n    const oppositeDepth = depth + delta\n    this.setDepth(position, depth)\n    this.setDepth(oppositePos, oppositeDepth)\n  }\n  getEdgeRing() {\n    return this._edgeRing\n  }\n  isInResult() {\n    return this._isInResult\n  }\n  setNext(next) {\n    this._next = next\n  }\n  isVisited() {\n    return this._isVisited\n  }\n}\n","import Node from './Node'\nexport default class NodeFactory {\n  createNode(coord) {\n    return new Node(coord, null)\n  }\n}\n","import Location from '../geom/Location'\nimport Coordinate from '../geom/Coordinate'\nimport Node from './Node'\nimport NodeMap from './NodeMap'\nimport Orientation from '../algorithm/Orientation'\nimport DirectedEdge from './DirectedEdge'\nimport System from '../../../../java/lang/System'\nimport ArrayList from '../../../../java/util/ArrayList'\nimport Quadrant from './Quadrant'\nimport NodeFactory from './NodeFactory'\nexport default class PlanarGraph {\n  constructor() {\n    PlanarGraph.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._edges = new ArrayList()\n    this._nodes = null\n    this._edgeEndList = new ArrayList()\n    if (arguments.length === 0) {\n      this._nodes = new NodeMap(new NodeFactory())\n    } else if (arguments.length === 1) {\n      const nodeFact = arguments[0]\n      this._nodes = new NodeMap(nodeFact)\n    }\n  }\n  static linkResultDirectedEdges(nodes) {\n    for (let nodeit = nodes.iterator(); nodeit.hasNext(); ) {\n      const node = nodeit.next()\n      node.getEdges().linkResultDirectedEdges()\n    }\n  }\n  printEdges(out) {\n    out.println('Edges:')\n    for (let i = 0; i < this._edges.size(); i++) {\n      out.println('edge ' + i + ':')\n      const e = this._edges.get(i)\n      e.print(out)\n      e.eiList.print(out)\n    }\n  }\n  find(coord) {\n    return this._nodes.find(coord)\n  }\n  addNode() {\n    if (arguments[0] instanceof Node) {\n      const node = arguments[0]\n      return this._nodes.addNode(node)\n    } else if (arguments[0] instanceof Coordinate) {\n      const coord = arguments[0]\n      return this._nodes.addNode(coord)\n    }\n  }\n  getNodeIterator() {\n    return this._nodes.iterator()\n  }\n  linkResultDirectedEdges() {\n    for (let nodeit = this._nodes.iterator(); nodeit.hasNext(); ) {\n      const node = nodeit.next()\n      node.getEdges().linkResultDirectedEdges()\n    }\n  }\n  debugPrintln(o) {\n    System.out.println(o)\n  }\n  isBoundaryNode(geomIndex, coord) {\n    const node = this._nodes.find(coord)\n    if (node === null) return false\n    const label = node.getLabel()\n    if (label !== null && label.getLocation(geomIndex) === Location.BOUNDARY) return true\n    return false\n  }\n  linkAllDirectedEdges() {\n    for (let nodeit = this._nodes.iterator(); nodeit.hasNext(); ) {\n      const node = nodeit.next()\n      node.getEdges().linkAllDirectedEdges()\n    }\n  }\n  matchInSameDirection(p0, p1, ep0, ep1) {\n    if (!p0.equals(ep0)) return false\n    if (Orientation.index(p0, p1, ep1) === Orientation.COLLINEAR && Quadrant.quadrant(p0, p1) === Quadrant.quadrant(ep0, ep1)) return true\n    return false\n  }\n  getEdgeEnds() {\n    return this._edgeEndList\n  }\n  debugPrint(o) {\n    System.out.print(o)\n  }\n  getEdgeIterator() {\n    return this._edges.iterator()\n  }\n  findEdgeInSameDirection(p0, p1) {\n    for (let i = 0; i < this._edges.size(); i++) {\n      const e = this._edges.get(i)\n      const eCoord = e.getCoordinates()\n      if (this.matchInSameDirection(p0, p1, eCoord[0], eCoord[1])) return e\n      if (this.matchInSameDirection(p0, p1, eCoord[eCoord.length - 1], eCoord[eCoord.length - 2])) return e\n    }\n    return null\n  }\n  insertEdge(e) {\n    this._edges.add(e)\n  }\n  findEdgeEnd(e) {\n    for (let i = this.getEdgeEnds().iterator(); i.hasNext(); ) {\n      const ee = i.next()\n      if (ee.getEdge() === e) return ee\n    }\n    return null\n  }\n  addEdges(edgesToAdd) {\n    for (let it = edgesToAdd.iterator(); it.hasNext(); ) {\n      const e = it.next()\n      this._edges.add(e)\n      const de1 = new DirectedEdge(e, true)\n      const de2 = new DirectedEdge(e, false)\n      de1.setSym(de2)\n      de2.setSym(de1)\n      this.add(de1)\n      this.add(de2)\n    }\n  }\n  add(e) {\n    this._nodes.add(e)\n    this._edgeEndList.add(e)\n  }\n  getNodes() {\n    return this._nodes.values()\n  }\n  findEdge(p0, p1) {\n    for (let i = 0; i < this._edges.size(); i++) {\n      const e = this._edges.get(i)\n      const eCoord = e.getCoordinates()\n      if (p0.equals(eCoord[0]) && p1.equals(eCoord[1])) return e\n    }\n    return null\n  }\n}\n","import PointLocation from '../../algorithm/PointLocation'\nimport TopologyException from '../../geom/TopologyException'\nimport MaximalEdgeRing from './MaximalEdgeRing'\nimport CoordinateArrays from '../../geom/CoordinateArrays'\nimport ArrayList from '../../../../../java/util/ArrayList'\nimport Assert from '../../util/Assert'\nimport PlanarGraph from '../../geomgraph/PlanarGraph'\nexport default class PolygonBuilder {\n  constructor() {\n    PolygonBuilder.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._geometryFactory = null\n    this._shellList = new ArrayList()\n    const geometryFactory = arguments[0]\n    this._geometryFactory = geometryFactory\n  }\n  static findEdgeRingContaining(testEr, shellList) {\n    const testRing = testEr.getLinearRing()\n    const testEnv = testRing.getEnvelopeInternal()\n    let testPt = testRing.getCoordinateN(0)\n    let minShell = null\n    let minShellEnv = null\n    for (let it = shellList.iterator(); it.hasNext(); ) {\n      const tryShell = it.next()\n      const tryShellRing = tryShell.getLinearRing()\n      const tryShellEnv = tryShellRing.getEnvelopeInternal()\n      if (tryShellEnv.equals(testEnv)) continue\n      if (!tryShellEnv.contains(testEnv)) continue\n      testPt = CoordinateArrays.ptNotInList(testRing.getCoordinates(), tryShellRing.getCoordinates())\n      let isContained = false\n      if (PointLocation.isInRing(testPt, tryShellRing.getCoordinates())) isContained = true\n      if (isContained) \n        if (minShell === null || minShellEnv.contains(tryShellEnv)) {\n          minShell = tryShell\n          minShellEnv = minShell.getLinearRing().getEnvelopeInternal()\n        }\n      \n    }\n    return minShell\n  }\n  sortShellsAndHoles(edgeRings, shellList, freeHoleList) {\n    for (let it = edgeRings.iterator(); it.hasNext(); ) {\n      const er = it.next()\n      if (er.isHole()) \n        freeHoleList.add(er)\n      else \n        shellList.add(er)\n      \n    }\n  }\n  computePolygons(shellList) {\n    const resultPolyList = new ArrayList()\n    for (let it = shellList.iterator(); it.hasNext(); ) {\n      const er = it.next()\n      const poly = er.toPolygon(this._geometryFactory)\n      resultPolyList.add(poly)\n    }\n    return resultPolyList\n  }\n  placeFreeHoles(shellList, freeHoleList) {\n    for (let it = freeHoleList.iterator(); it.hasNext(); ) {\n      const hole = it.next()\n      if (hole.getShell() === null) {\n        const shell = PolygonBuilder.findEdgeRingContaining(hole, shellList)\n        if (shell === null) throw new TopologyException('unable to assign hole to a shell', hole.getCoordinate(0))\n        hole.setShell(shell)\n      }\n    }\n  }\n  buildMinimalEdgeRings(maxEdgeRings, shellList, freeHoleList) {\n    const edgeRings = new ArrayList()\n    for (let it = maxEdgeRings.iterator(); it.hasNext(); ) {\n      const er = it.next()\n      if (er.getMaxNodeDegree() > 2) {\n        er.linkDirectedEdgesForMinimalEdgeRings()\n        const minEdgeRings = er.buildMinimalRings()\n        const shell = this.findShell(minEdgeRings)\n        if (shell !== null) {\n          this.placePolygonHoles(shell, minEdgeRings)\n          shellList.add(shell)\n        } else {\n          freeHoleList.addAll(minEdgeRings)\n        }\n      } else {\n        edgeRings.add(er)\n      }\n    }\n    return edgeRings\n  }\n  buildMaximalEdgeRings(dirEdges) {\n    const maxEdgeRings = new ArrayList()\n    for (let it = dirEdges.iterator(); it.hasNext(); ) {\n      const de = it.next()\n      if (de.isInResult() && de.getLabel().isArea()) \n        if (de.getEdgeRing() === null) {\n          const er = new MaximalEdgeRing(de, this._geometryFactory)\n          maxEdgeRings.add(er)\n          er.setInResult()\n        }\n      \n    }\n    return maxEdgeRings\n  }\n  placePolygonHoles(shell, minEdgeRings) {\n    for (let it = minEdgeRings.iterator(); it.hasNext(); ) {\n      const er = it.next()\n      if (er.isHole()) \n        er.setShell(shell)\n      \n    }\n  }\n  getPolygons() {\n    const resultPolyList = this.computePolygons(this._shellList)\n    return resultPolyList\n  }\n  findShell(minEdgeRings) {\n    let shellCount = 0\n    let shell = null\n    for (let it = minEdgeRings.iterator(); it.hasNext(); ) {\n      const er = it.next()\n      if (!er.isHole()) {\n        shell = er\n        shellCount++\n      }\n    }\n    Assert.isTrue(shellCount <= 1, 'found two shells in MinimalEdgeRing list')\n    return shell\n  }\n  add() {\n    if (arguments.length === 1) {\n      const graph = arguments[0]\n      this.add(graph.getEdgeEnds(), graph.getNodes())\n    } else if (arguments.length === 2) {\n      const dirEdges = arguments[0], nodes = arguments[1]\n      PlanarGraph.linkResultDirectedEdges(nodes)\n      const maxEdgeRings = this.buildMaximalEdgeRings(dirEdges)\n      const freeHoleList = new ArrayList()\n      const edgeRings = this.buildMinimalEdgeRings(maxEdgeRings, this._shellList, freeHoleList)\n      this.sortShellsAndHoles(edgeRings, this._shellList, freeHoleList)\n      this.placeFreeHoles(this._shellList, freeHoleList)\n    }\n  }\n}\n","export default class Boundable {\n  getBounds() {}\n}\n","import Boundable from './Boundable'\nimport Serializable from '../../../../../java/io/Serializable'\nexport default class ItemBoundable {\n  constructor() {\n    ItemBoundable.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._bounds = null\n    this._item = null\n    const bounds = arguments[0], item = arguments[1]\n    this._bounds = bounds\n    this._item = item\n  }\n  getItem() {\n    return this._item\n  }\n  getBounds() {\n    return this._bounds\n  }\n  get interfaces_() {\n    return [Boundable, Serializable]\n  }\n}\n","import ArrayList from '../../../../java/util/ArrayList'\nexport default class PriorityQueue {\n  constructor() {\n    PriorityQueue.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._size = null\n    this._items = null\n    this._size = 0\n    this._items = new ArrayList()\n    this._items.add(null)\n  }\n  poll() {\n    if (this.isEmpty()) return null\n    const minItem = this._items.get(1)\n    this._items.set(1, this._items.get(this._size))\n    this._size -= 1\n    this.reorder(1)\n    return minItem\n  }\n  size() {\n    return this._size\n  }\n  reorder(hole) {\n    let child = null\n    const tmp = this._items.get(hole)\n    for (; hole * 2 <= this._size; hole = child) {\n      child = hole * 2\n      if (child !== this._size && this._items.get(child + 1).compareTo(this._items.get(child)) < 0) child++\n      if (this._items.get(child).compareTo(tmp) < 0) this._items.set(hole, this._items.get(child)); else break\n    }\n    this._items.set(hole, tmp)\n  }\n  clear() {\n    this._size = 0\n    this._items.clear()\n  }\n  peek() {\n    if (this.isEmpty()) return null\n    const minItem = this._items.get(1)\n    return minItem\n  }\n  isEmpty() {\n    return this._size === 0\n  }\n  add(x) {\n    this._items.add(null)\n    this._size += 1\n    let hole = this._size\n    this._items.set(0, x)\n    for (; x.compareTo(this._items.get(Math.trunc(hole / 2))) < 0; hole /= 2) \n      this._items.set(hole, this._items.get(Math.trunc(hole / 2)))\n    \n    this._items.set(hole, x)\n  }\n}\n","export default class SpatialIndex {\n  insert(itemEnv, item) {}\n  remove(itemEnv, item) {}\n  query() {\n    if (arguments.length === 1) {\n      const searchEnv = arguments[0]\n    } else if (arguments.length === 2) {\n      const searchEnv = arguments[0], visitor = arguments[1]\n    }\n  }\n}\n","import Boundable from './Boundable'\nimport ArrayList from '../../../../../java/util/ArrayList'\nimport Serializable from '../../../../../java/io/Serializable'\nimport Assert from '../../util/Assert'\nexport default class AbstractNode {\n  constructor() {\n    AbstractNode.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._childBoundables = new ArrayList()\n    this._bounds = null\n    this._level = null\n    if (arguments.length === 0) {} else if (arguments.length === 1) {\n      const level = arguments[0]\n      this._level = level\n    }\n  }\n  getLevel() {\n    return this._level\n  }\n  size() {\n    return this._childBoundables.size()\n  }\n  getChildBoundables() {\n    return this._childBoundables\n  }\n  addChildBoundable(childBoundable) {\n    Assert.isTrue(this._bounds === null)\n    this._childBoundables.add(childBoundable)\n  }\n  isEmpty() {\n    return this._childBoundables.isEmpty()\n  }\n  getBounds() {\n    if (this._bounds === null) \n      this._bounds = this.computeBounds()\n    \n    return this._bounds\n  }\n  get interfaces_() {\n    return [Boundable, Serializable]\n  }\n}\n","import Arrays from './Arrays'\nimport ArrayList from './ArrayList'\n\nconst Collections = {\n  reverseOrder: function() {\n    return {\n      compare(a, b) {\n        return b.compareTo(a)\n      }\n    }\n  },\n  min: function(l) {\n    Collections.sort(l)\n    return l.get(0)\n  },\n  sort: function(l, c) {\n    const a = l.toArray()\n    if (c)\n      Arrays.sort(a, c)\n    else\n      Arrays.sort(a)\n    const i = l.iterator()\n    for (let pos = 0, alen = a.length; pos < alen; pos++) {\n      i.next()\n      i.set(a[pos])\n    }\n  },\n  singletonList: function(o) {\n    const arrayList = new ArrayList()\n    arrayList.add(o)\n    return arrayList\n  }\n}\n\nexport default Collections\n","export default class EnvelopeDistance {\n  static maxDistance(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) {\n    let dist = EnvelopeDistance.distance(ax1, ay1, bx1, by1)\n    dist = Math.max(dist, EnvelopeDistance.distance(ax1, ay1, bx2, by2))\n    dist = Math.max(dist, EnvelopeDistance.distance(ax2, ay2, bx1, by1))\n    dist = Math.max(dist, EnvelopeDistance.distance(ax2, ay2, bx2, by2))\n    return dist\n  }\n  static distance(x1, y1, x2, y2) {\n    const dx = x2 - x1\n    const dy = y2 - y1\n    return Math.sqrt(dx * dx + dy * dy)\n  }\n  static maximumDistance(env1, env2) {\n    const minx = Math.min(env1.getMinX(), env2.getMinX())\n    const miny = Math.min(env1.getMinY(), env2.getMinY())\n    const maxx = Math.max(env1.getMaxX(), env2.getMaxX())\n    const maxy = Math.max(env1.getMaxY(), env2.getMaxY())\n    return EnvelopeDistance.distance(minx, miny, maxx, maxy)\n  }\n  static minMaxDistance(a, b) {\n    const aminx = a.getMinX()\n    const aminy = a.getMinY()\n    const amaxx = a.getMaxX()\n    const amaxy = a.getMaxY()\n    const bminx = b.getMinX()\n    const bminy = b.getMinY()\n    const bmaxx = b.getMaxX()\n    const bmaxy = b.getMaxY()\n    let dist = EnvelopeDistance.maxDistance(aminx, aminy, aminx, amaxy, bminx, bminy, bminx, bmaxy)\n    dist = Math.min(dist, EnvelopeDistance.maxDistance(aminx, aminy, aminx, amaxy, bminx, bminy, bmaxx, bminy))\n    dist = Math.min(dist, EnvelopeDistance.maxDistance(aminx, aminy, aminx, amaxy, bmaxx, bmaxy, bminx, bmaxy))\n    dist = Math.min(dist, EnvelopeDistance.maxDistance(aminx, aminy, aminx, amaxy, bmaxx, bmaxy, bmaxx, bminy))\n    dist = Math.min(dist, EnvelopeDistance.maxDistance(aminx, aminy, amaxx, aminy, bminx, bminy, bminx, bmaxy))\n    dist = Math.min(dist, EnvelopeDistance.maxDistance(aminx, aminy, amaxx, aminy, bminx, bminy, bmaxx, bminy))\n    dist = Math.min(dist, EnvelopeDistance.maxDistance(aminx, aminy, amaxx, aminy, bmaxx, bmaxy, bminx, bmaxy))\n    dist = Math.min(dist, EnvelopeDistance.maxDistance(aminx, aminy, amaxx, aminy, bmaxx, bmaxy, bmaxx, bminy))\n    dist = Math.min(dist, EnvelopeDistance.maxDistance(amaxx, amaxy, aminx, amaxy, bminx, bminy, bminx, bmaxy))\n    dist = Math.min(dist, EnvelopeDistance.maxDistance(amaxx, amaxy, aminx, amaxy, bminx, bminy, bmaxx, bminy))\n    dist = Math.min(dist, EnvelopeDistance.maxDistance(amaxx, amaxy, aminx, amaxy, bmaxx, bmaxy, bminx, bmaxy))\n    dist = Math.min(dist, EnvelopeDistance.maxDistance(amaxx, amaxy, aminx, amaxy, bmaxx, bmaxy, bmaxx, bminy))\n    dist = Math.min(dist, EnvelopeDistance.maxDistance(amaxx, amaxy, amaxx, aminy, bminx, bminy, bminx, bmaxy))\n    dist = Math.min(dist, EnvelopeDistance.maxDistance(amaxx, amaxy, amaxx, aminy, bminx, bminy, bmaxx, bminy))\n    dist = Math.min(dist, EnvelopeDistance.maxDistance(amaxx, amaxy, amaxx, aminy, bmaxx, bmaxy, bminx, bmaxy))\n    dist = Math.min(dist, EnvelopeDistance.maxDistance(amaxx, amaxy, amaxx, aminy, bmaxx, bmaxy, bmaxx, bminy))\n    return dist\n  }\n}\n","import IllegalArgumentException from '../../../../../java/lang/IllegalArgumentException'\nimport AbstractNode from './AbstractNode'\nimport EnvelopeDistance from './EnvelopeDistance'\nimport Comparable from '../../../../../java/lang/Comparable'\nexport default class BoundablePair {\n  constructor() {\n    BoundablePair.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._boundable1 = null\n    this._boundable2 = null\n    this._distance = null\n    this._itemDistance = null\n    const boundable1 = arguments[0], boundable2 = arguments[1], itemDistance = arguments[2]\n    this._boundable1 = boundable1\n    this._boundable2 = boundable2\n    this._itemDistance = itemDistance\n    this._distance = this.distance()\n  }\n  static area(b) {\n    return b.getBounds().getArea()\n  }\n  static isComposite(item) {\n    return item instanceof AbstractNode\n  }\n  maximumDistance() {\n    return EnvelopeDistance.maximumDistance(this._boundable1.getBounds(), this._boundable2.getBounds())\n  }\n  expandToQueue(priQ, minDistance) {\n    const isComp1 = BoundablePair.isComposite(this._boundable1)\n    const isComp2 = BoundablePair.isComposite(this._boundable2)\n    if (isComp1 && isComp2) {\n      if (BoundablePair.area(this._boundable1) > BoundablePair.area(this._boundable2)) {\n        this.expand(this._boundable1, this._boundable2, false, priQ, minDistance)\n        return null\n      } else {\n        this.expand(this._boundable2, this._boundable1, true, priQ, minDistance)\n        return null\n      }\n    } else if (isComp1) {\n      this.expand(this._boundable1, this._boundable2, false, priQ, minDistance)\n      return null\n    } else if (isComp2) {\n      this.expand(this._boundable2, this._boundable1, true, priQ, minDistance)\n      return null\n    }\n    throw new IllegalArgumentException('neither boundable is composite')\n  }\n  isLeaves() {\n    return !(BoundablePair.isComposite(this._boundable1) || BoundablePair.isComposite(this._boundable2))\n  }\n  compareTo(o) {\n    const nd = o\n    if (this._distance < nd._distance) return -1\n    if (this._distance > nd._distance) return 1\n    return 0\n  }\n  expand(bndComposite, bndOther, isFlipped, priQ, minDistance) {\n    const children = bndComposite.getChildBoundables()\n    for (let i = children.iterator(); i.hasNext(); ) {\n      const child = i.next()\n      let bp = null\n      if (isFlipped) \n        bp = new BoundablePair(bndOther, child, this._itemDistance)\n      else \n        bp = new BoundablePair(child, bndOther, this._itemDistance)\n      \n      if (bp.getDistance() < minDistance) \n        priQ.add(bp)\n      \n    }\n  }\n  getBoundable(i) {\n    if (i === 0) return this._boundable1\n    return this._boundable2\n  }\n  getDistance() {\n    return this._distance\n  }\n  distance() {\n    if (this.isLeaves()) \n      return this._itemDistance.distance(this._boundable1, this._boundable2)\n    \n    return this._boundable1.getBounds().distance(this._boundable2.getBounds())\n  }\n  get interfaces_() {\n    return [Comparable]\n  }\n}\n","export default class ItemVisitor {\n  visitItem(item) {}\n}\n","import ItemBoundable from './ItemBoundable'\nimport hasInterface from '../../../../../hasInterface'\nimport ItemVisitor from '../ItemVisitor'\nimport AbstractNode from './AbstractNode'\nimport Collections from '../../../../../java/util/Collections'\nimport ArrayList from '../../../../../java/util/ArrayList'\nimport Serializable from '../../../../../java/io/Serializable'\nimport Assert from '../../util/Assert'\nimport List from '../../../../../java/util/List'\nexport default class AbstractSTRtree {\n  constructor() {\n    AbstractSTRtree.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._root = null\n    this._built = false\n    this._itemBoundables = new ArrayList()\n    this._nodeCapacity = null\n    if (arguments.length === 0) {\n      AbstractSTRtree.constructor_.call(this, AbstractSTRtree.DEFAULT_NODE_CAPACITY)\n    } else if (arguments.length === 1) {\n      const nodeCapacity = arguments[0]\n      Assert.isTrue(nodeCapacity > 1, 'Node capacity must be greater than 1')\n      this._nodeCapacity = nodeCapacity\n    }\n  }\n  static compareDoubles(a, b) {\n    return a > b ? 1 : a < b ? -1 : 0\n  }\n  queryInternal() {\n    if (hasInterface(arguments[2], ItemVisitor) && (arguments[0] instanceof Object && arguments[1] instanceof AbstractNode)) {\n      const searchBounds = arguments[0], node = arguments[1], visitor = arguments[2]\n      const childBoundables = node.getChildBoundables()\n      for (let i = 0; i < childBoundables.size(); i++) {\n        const childBoundable = childBoundables.get(i)\n        if (!this.getIntersectsOp().intersects(childBoundable.getBounds(), searchBounds)) \n          continue\n        \n        if (childBoundable instanceof AbstractNode) \n          this.queryInternal(searchBounds, childBoundable, visitor)\n        else if (childBoundable instanceof ItemBoundable) \n          visitor.visitItem(childBoundable.getItem())\n        else \n          Assert.shouldNeverReachHere()\n        \n      }\n    } else if (hasInterface(arguments[2], List) && (arguments[0] instanceof Object && arguments[1] instanceof AbstractNode)) {\n      const searchBounds = arguments[0], node = arguments[1], matches = arguments[2]\n      const childBoundables = node.getChildBoundables()\n      for (let i = 0; i < childBoundables.size(); i++) {\n        const childBoundable = childBoundables.get(i)\n        if (!this.getIntersectsOp().intersects(childBoundable.getBounds(), searchBounds)) \n          continue\n        \n        if (childBoundable instanceof AbstractNode) \n          this.queryInternal(searchBounds, childBoundable, matches)\n        else if (childBoundable instanceof ItemBoundable) \n          matches.add(childBoundable.getItem())\n        else \n          Assert.shouldNeverReachHere()\n        \n      }\n    }\n  }\n  getNodeCapacity() {\n    return this._nodeCapacity\n  }\n  lastNode(nodes) {\n    return nodes.get(nodes.size() - 1)\n  }\n  size() {\n    if (arguments.length === 0) {\n      if (this.isEmpty()) \n        return 0\n      \n      this.build()\n      return this.size(this._root)\n    } else if (arguments.length === 1) {\n      const node = arguments[0]\n      let size = 0\n      for (let i = node.getChildBoundables().iterator(); i.hasNext(); ) {\n        const childBoundable = i.next()\n        if (childBoundable instanceof AbstractNode) \n          size += this.size(childBoundable)\n        else if (childBoundable instanceof ItemBoundable) \n          size += 1\n        \n      }\n      return size\n    }\n  }\n  removeItem(node, item) {\n    let childToRemove = null\n    for (let i = node.getChildBoundables().iterator(); i.hasNext(); ) {\n      const childBoundable = i.next()\n      if (childBoundable instanceof ItemBoundable) \n        if (childBoundable.getItem() === item) childToRemove = childBoundable\n      \n    }\n    if (childToRemove !== null) {\n      node.getChildBoundables().remove(childToRemove)\n      return true\n    }\n    return false\n  }\n  itemsTree() {\n    if (arguments.length === 0) {\n      this.build()\n      const valuesTree = this.itemsTree(this._root)\n      if (valuesTree === null) return new ArrayList()\n      return valuesTree\n    } else if (arguments.length === 1) {\n      const node = arguments[0]\n      const valuesTreeForNode = new ArrayList()\n      for (let i = node.getChildBoundables().iterator(); i.hasNext(); ) {\n        const childBoundable = i.next()\n        if (childBoundable instanceof AbstractNode) {\n          const valuesTreeForChild = this.itemsTree(childBoundable)\n          if (valuesTreeForChild !== null) valuesTreeForNode.add(valuesTreeForChild)\n        } else if (childBoundable instanceof ItemBoundable) {\n          valuesTreeForNode.add(childBoundable.getItem())\n        } else {\n          Assert.shouldNeverReachHere()\n        }\n      }\n      if (valuesTreeForNode.size() <= 0) return null\n      return valuesTreeForNode\n    }\n  }\n  insert(bounds, item) {\n    Assert.isTrue(!this._built, 'Cannot insert items into an STR packed R-tree after it has been built.')\n    this._itemBoundables.add(new ItemBoundable(bounds, item))\n  }\n  boundablesAtLevel() {\n    if (arguments.length === 1) {\n      const level = arguments[0]\n      const boundables = new ArrayList()\n      this.boundablesAtLevel(level, this._root, boundables)\n      return boundables\n    } else if (arguments.length === 3) {\n      const level = arguments[0], top = arguments[1], boundables = arguments[2]\n      Assert.isTrue(level > -2)\n      if (top.getLevel() === level) {\n        boundables.add(top)\n        return null\n      }\n      for (let i = top.getChildBoundables().iterator(); i.hasNext(); ) {\n        const boundable = i.next()\n        if (boundable instanceof AbstractNode) {\n          this.boundablesAtLevel(level, boundable, boundables)\n        } else {\n          Assert.isTrue(boundable instanceof ItemBoundable)\n          if (level === -1) \n            boundables.add(boundable)\n          \n        }\n      }\n      return null\n    }\n  }\n  query() {\n    if (arguments.length === 1) {\n      const searchBounds = arguments[0]\n      this.build()\n      const matches = new ArrayList()\n      if (this.isEmpty()) \n        return matches\n      \n      if (this.getIntersectsOp().intersects(this._root.getBounds(), searchBounds)) \n        this.queryInternal(searchBounds, this._root, matches)\n      \n      return matches\n    } else if (arguments.length === 2) {\n      const searchBounds = arguments[0], visitor = arguments[1]\n      this.build()\n      if (this.isEmpty()) \n        return null\n      \n      if (this.getIntersectsOp().intersects(this._root.getBounds(), searchBounds)) \n        this.queryInternal(searchBounds, this._root, visitor)\n      \n    }\n  }\n  build() {\n    if (this._built) return null\n    this._root = this._itemBoundables.isEmpty() ? this.createNode(0) : this.createHigherLevels(this._itemBoundables, -1)\n    this._itemBoundables = null\n    this._built = true\n  }\n  getRoot() {\n    this.build()\n    return this._root\n  }\n  remove() {\n    if (arguments.length === 2) {\n      const searchBounds = arguments[0], item = arguments[1]\n      this.build()\n      if (this.getIntersectsOp().intersects(this._root.getBounds(), searchBounds)) \n        return this.remove(searchBounds, this._root, item)\n      \n      return false\n    } else if (arguments.length === 3) {\n      const searchBounds = arguments[0], node = arguments[1], item = arguments[2]\n      let found = this.removeItem(node, item)\n      if (found) return true\n      let childToPrune = null\n      for (let i = node.getChildBoundables().iterator(); i.hasNext(); ) {\n        const childBoundable = i.next()\n        if (!this.getIntersectsOp().intersects(childBoundable.getBounds(), searchBounds)) \n          continue\n        \n        if (childBoundable instanceof AbstractNode) {\n          found = this.remove(searchBounds, childBoundable, item)\n          if (found) {\n            childToPrune = childBoundable\n            break\n          }\n        }\n      }\n      if (childToPrune !== null) \n        if (childToPrune.getChildBoundables().isEmpty()) \n          node.getChildBoundables().remove(childToPrune)\n        \n      \n      return found\n    }\n  }\n  createHigherLevels(boundablesOfALevel, level) {\n    Assert.isTrue(!boundablesOfALevel.isEmpty())\n    const parentBoundables = this.createParentBoundables(boundablesOfALevel, level + 1)\n    if (parentBoundables.size() === 1) \n      return parentBoundables.get(0)\n    \n    return this.createHigherLevels(parentBoundables, level + 1)\n  }\n  depth() {\n    if (arguments.length === 0) {\n      if (this.isEmpty()) \n        return 0\n      \n      this.build()\n      return this.depth(this._root)\n    } else if (arguments.length === 1) {\n      const node = arguments[0]\n      let maxChildDepth = 0\n      for (let i = node.getChildBoundables().iterator(); i.hasNext(); ) {\n        const childBoundable = i.next()\n        if (childBoundable instanceof AbstractNode) {\n          const childDepth = this.depth(childBoundable)\n          if (childDepth > maxChildDepth) maxChildDepth = childDepth\n        }\n      }\n      return maxChildDepth + 1\n    }\n  }\n  createParentBoundables(childBoundables, newLevel) {\n    Assert.isTrue(!childBoundables.isEmpty())\n    const parentBoundables = new ArrayList()\n    parentBoundables.add(this.createNode(newLevel))\n    const sortedChildBoundables = new ArrayList(childBoundables)\n    Collections.sort(sortedChildBoundables, this.getComparator())\n    for (let i = sortedChildBoundables.iterator(); i.hasNext(); ) {\n      const childBoundable = i.next()\n      if (this.lastNode(parentBoundables).getChildBoundables().size() === this.getNodeCapacity()) \n        parentBoundables.add(this.createNode(newLevel))\n      \n      this.lastNode(parentBoundables).addChildBoundable(childBoundable)\n    }\n    return parentBoundables\n  }\n  isEmpty() {\n    if (!this._built) return this._itemBoundables.isEmpty()\n    return this._root.isEmpty()\n  }\n  get interfaces_() {\n    return [Serializable]\n  }\n}\nfunction IntersectsOp() {}\nAbstractSTRtree.IntersectsOp = IntersectsOp\nAbstractSTRtree.DEFAULT_NODE_CAPACITY = 10\n","export default class ItemDistance {\n  distance(item1, item2) {}\n}\n","import ItemBoundable from './ItemBoundable'\nimport PriorityQueue from '../../util/PriorityQueue'\nimport hasInterface from '../../../../../hasInterface'\nimport SpatialIndex from '../SpatialIndex'\nimport AbstractNode from './AbstractNode'\nimport Double from '../../../../../java/lang/Double'\nimport Collections from '../../../../../java/util/Collections'\nimport BoundablePair from './BoundablePair'\nimport ArrayList from '../../../../../java/util/ArrayList'\nimport Comparator from '../../../../../java/util/Comparator'\nimport Serializable from '../../../../../java/io/Serializable'\nimport Envelope from '../../geom/Envelope'\nimport Assert from '../../util/Assert'\nimport AbstractSTRtree from './AbstractSTRtree'\nimport ItemDistance from './ItemDistance'\nexport default class STRtree extends AbstractSTRtree {\n  constructor() {\n    super()\n    STRtree.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    if (arguments.length === 0) {\n      STRtree.constructor_.call(this, STRtree.DEFAULT_NODE_CAPACITY)\n    } else if (arguments.length === 1) {\n      const nodeCapacity = arguments[0]\n      AbstractSTRtree.constructor_.call(this, nodeCapacity)\n    }\n  }\n  static centreX(e) {\n    return STRtree.avg(e.getMinX(), e.getMaxX())\n  }\n  static avg(a, b) {\n    return (a + b) / 2\n  }\n  static getItems(kNearestNeighbors) {\n    const items = new Array(kNearestNeighbors.size()).fill(null)\n    let count = 0\n    while (!kNearestNeighbors.isEmpty()) {\n      const bp = kNearestNeighbors.poll()\n      items[count] = bp.getBoundable(0).getItem()\n      count++\n    }\n    return items\n  }\n  static centreY(e) {\n    return STRtree.avg(e.getMinY(), e.getMaxY())\n  }\n  createParentBoundablesFromVerticalSlices(verticalSlices, newLevel) {\n    Assert.isTrue(verticalSlices.length > 0)\n    const parentBoundables = new ArrayList()\n    for (let i = 0; i < verticalSlices.length; i++) \n      parentBoundables.addAll(this.createParentBoundablesFromVerticalSlice(verticalSlices[i], newLevel))\n    \n    return parentBoundables\n  }\n  nearestNeighbourK() {\n    if (arguments.length === 2) {\n      const initBndPair = arguments[0], k = arguments[1]\n      return this.nearestNeighbourK(initBndPair, Double.POSITIVE_INFINITY, k)\n    } else if (arguments.length === 3) {\n      const initBndPair = arguments[0], maxDistance = arguments[1], k = arguments[2]\n      let distanceLowerBound = maxDistance\n      const priQ = new PriorityQueue()\n      priQ.add(initBndPair)\n      const kNearestNeighbors = new PriorityQueue()\n      while (!priQ.isEmpty() && distanceLowerBound >= 0.0) {\n        const bndPair = priQ.poll()\n        const pairDistance = bndPair.getDistance()\n        if (pairDistance >= distanceLowerBound) \n          break\n        \n        if (bndPair.isLeaves()) \n          if (kNearestNeighbors.size() < k) {\n            kNearestNeighbors.add(bndPair)\n          } else {\n            const bp1 = kNearestNeighbors.peek()\n            if (bp1.getDistance() > pairDistance) {\n              kNearestNeighbors.poll()\n              kNearestNeighbors.add(bndPair)\n            }\n            const bp2 = kNearestNeighbors.peek()\n            distanceLowerBound = bp2.getDistance()\n          }\n        else \n          bndPair.expandToQueue(priQ, distanceLowerBound)\n        \n      }\n      return STRtree.getItems(kNearestNeighbors)\n    }\n  }\n  createNode(level) {\n    return new STRtreeNode(level)\n  }\n  size() {\n    if (arguments.length === 0) \n      return super.size.call(this)\n    else return super.size.apply(this, arguments)\n  }\n  insert() {\n    if (arguments.length === 2 && (arguments[1] instanceof Object && arguments[0] instanceof Envelope)) {\n      const itemEnv = arguments[0], item = arguments[1]\n      if (itemEnv.isNull()) \n        return null\n      \n      super.insert.call(this, itemEnv, item)\n    } else {\n      return super.insert.apply(this, arguments)\n    }\n  }\n  getIntersectsOp() {\n    return STRtree.intersectsOp\n  }\n  verticalSlices(childBoundables, sliceCount) {\n    const sliceCapacity = Math.trunc(Math.ceil(childBoundables.size() / sliceCount))\n    const slices = new Array(sliceCount).fill(null)\n    const i = childBoundables.iterator()\n    for (let j = 0; j < sliceCount; j++) {\n      slices[j] = new ArrayList()\n      let boundablesAddedToSlice = 0\n      while (i.hasNext() && boundablesAddedToSlice < sliceCapacity) {\n        const childBoundable = i.next()\n        slices[j].add(childBoundable)\n        boundablesAddedToSlice++\n      }\n    }\n    return slices\n  }\n  query() {\n    if (arguments.length === 1) {\n      const searchEnv = arguments[0]\n      return super.query.call(this, searchEnv)\n    } else if (arguments.length === 2) {\n      const searchEnv = arguments[0], visitor = arguments[1]\n      super.query.call(this, searchEnv, visitor)\n    }\n  }\n  getComparator() {\n    return STRtree.yComparator\n  }\n  createParentBoundablesFromVerticalSlice(childBoundables, newLevel) {\n    return super.createParentBoundables.call(this, childBoundables, newLevel)\n  }\n  remove() {\n    if (arguments.length === 2 && (arguments[1] instanceof Object && arguments[0] instanceof Envelope)) {\n      const itemEnv = arguments[0], item = arguments[1]\n      return super.remove.call(this, itemEnv, item)\n    } else {\n      return super.remove.apply(this, arguments)\n    }\n  }\n  depth() {\n    if (arguments.length === 0) \n      return super.depth.call(this)\n    else return super.depth.apply(this, arguments)\n  }\n  createParentBoundables(childBoundables, newLevel) {\n    Assert.isTrue(!childBoundables.isEmpty())\n    const minLeafCount = Math.trunc(Math.ceil(childBoundables.size() / this.getNodeCapacity()))\n    const sortedChildBoundables = new ArrayList(childBoundables)\n    Collections.sort(sortedChildBoundables, STRtree.xComparator)\n    const verticalSlices = this.verticalSlices(sortedChildBoundables, Math.trunc(Math.ceil(Math.sqrt(minLeafCount))))\n    return this.createParentBoundablesFromVerticalSlices(verticalSlices, newLevel)\n  }\n  nearestNeighbour() {\n    if (arguments.length === 1) {\n      if (hasInterface(arguments[0], ItemDistance)) {\n        const itemDist = arguments[0]\n        if (this.isEmpty()) return null\n        const bp = new BoundablePair(this.getRoot(), this.getRoot(), itemDist)\n        return this.nearestNeighbour(bp)\n      } else if (arguments[0] instanceof BoundablePair) {\n        const initBndPair = arguments[0]\n        let distanceLowerBound = Double.POSITIVE_INFINITY\n        let minPair = null\n        const priQ = new PriorityQueue()\n        priQ.add(initBndPair)\n        while (!priQ.isEmpty() && distanceLowerBound > 0.0) {\n          const bndPair = priQ.poll()\n          const pairDistance = bndPair.getDistance()\n          if (pairDistance >= distanceLowerBound) break\n          if (bndPair.isLeaves()) {\n            distanceLowerBound = pairDistance\n            minPair = bndPair\n          } else {\n            bndPair.expandToQueue(priQ, distanceLowerBound)\n          }\n        }\n        if (minPair === null) return null\n        return [minPair.getBoundable(0).getItem(), minPair.getBoundable(1).getItem()]\n      }\n    } else if (arguments.length === 2) {\n      const tree = arguments[0], itemDist = arguments[1]\n      if (this.isEmpty() || tree.isEmpty()) return null\n      const bp = new BoundablePair(this.getRoot(), tree.getRoot(), itemDist)\n      return this.nearestNeighbour(bp)\n    } else if (arguments.length === 3) {\n      const env = arguments[0], item = arguments[1], itemDist = arguments[2]\n      const bnd = new ItemBoundable(env, item)\n      const bp = new BoundablePair(this.getRoot(), bnd, itemDist)\n      return this.nearestNeighbour(bp)[0]\n    } else if (arguments.length === 4) {\n      const env = arguments[0], item = arguments[1], itemDist = arguments[2], k = arguments[3]\n      const bnd = new ItemBoundable(env, item)\n      const bp = new BoundablePair(this.getRoot(), bnd, itemDist)\n      return this.nearestNeighbourK(bp, k)\n    }\n  }\n  isWithinDistance() {\n    if (arguments.length === 2) {\n      const initBndPair = arguments[0], maxDistance = arguments[1]\n      let distanceUpperBound = Double.POSITIVE_INFINITY\n      const priQ = new PriorityQueue()\n      priQ.add(initBndPair)\n      while (!priQ.isEmpty()) {\n        const bndPair = priQ.poll()\n        const pairDistance = bndPair.getDistance()\n        if (pairDistance > maxDistance) return false\n        if (bndPair.maximumDistance() <= maxDistance) return true\n        if (bndPair.isLeaves()) {\n          distanceUpperBound = pairDistance\n          if (distanceUpperBound <= maxDistance) return true\n        } else {\n          bndPair.expandToQueue(priQ, distanceUpperBound)\n        }\n      }\n      return false\n    } else if (arguments.length === 3) {\n      const tree = arguments[0], itemDist = arguments[1], maxDistance = arguments[2]\n      const bp = new BoundablePair(this.getRoot(), tree.getRoot(), itemDist)\n      return this.isWithinDistance(bp, maxDistance)\n    }\n  }\n  get interfaces_() {\n    return [SpatialIndex, Serializable]\n  }\n}\nclass STRtreeNode extends AbstractNode {\n  constructor() {\n    super()\n    STRtreeNode.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    const level = arguments[0]\n    AbstractNode.constructor_.call(this, level)\n  }\n  computeBounds() {\n    let bounds = null\n    for (let i = this.getChildBoundables().iterator(); i.hasNext(); ) {\n      const childBoundable = i.next()\n      if (bounds === null) \n        bounds = new Envelope(childBoundable.getBounds())\n      else \n        bounds.expandToInclude(childBoundable.getBounds())\n      \n    }\n    return bounds\n  }\n}\nSTRtree.STRtreeNode = STRtreeNode\nSTRtree.xComparator = new (class {\n  get interfaces_() {\n    return [Comparator]\n  }\n  compare(o1, o2) {\n    return AbstractSTRtree.compareDoubles(STRtree.centreX(o1.getBounds()), STRtree.centreX(o2.getBounds()))\n  }\n})()\nSTRtree.yComparator = new (class {\n  get interfaces_() {\n    return [Comparator]\n  }\n  compare(o1, o2) {\n    return AbstractSTRtree.compareDoubles(STRtree.centreY(o1.getBounds()), STRtree.centreY(o2.getBounds()))\n  }\n})()\nSTRtree.intersectsOp = new (class {\n  get interfaces_() {\n    return [IntersectsOp]\n  }\n  intersects(aBounds, bBounds) {\n    return aBounds.intersects(bBounds)\n  }\n})()\nSTRtree.DEFAULT_NODE_CAPACITY = 10\n","import Assert from '../util/Assert'\nexport default class SegmentPointComparator {\n  static relativeSign(x0, x1) {\n    if (x0 < x1) return -1\n    if (x0 > x1) return 1\n    return 0\n  }\n  static compare(octant, p0, p1) {\n    if (p0.equals2D(p1)) return 0\n    const xSign = SegmentPointComparator.relativeSign(p0.x, p1.x)\n    const ySign = SegmentPointComparator.relativeSign(p0.y, p1.y)\n    switch (octant) {\n    case 0:\n      return SegmentPointComparator.compareValue(xSign, ySign)\n    case 1:\n      return SegmentPointComparator.compareValue(ySign, xSign)\n    case 2:\n      return SegmentPointComparator.compareValue(ySign, -xSign)\n    case 3:\n      return SegmentPointComparator.compareValue(-xSign, ySign)\n    case 4:\n      return SegmentPointComparator.compareValue(-xSign, -ySign)\n    case 5:\n      return SegmentPointComparator.compareValue(-ySign, -xSign)\n    case 6:\n      return SegmentPointComparator.compareValue(-ySign, xSign)\n    case 7:\n      return SegmentPointComparator.compareValue(xSign, -ySign)\n    }\n    Assert.shouldNeverReachHere('invalid octant value')\n    return 0\n  }\n  static compareValue(compareSign0, compareSign1) {\n    if (compareSign0 < 0) return -1\n    if (compareSign0 > 0) return 1\n    if (compareSign1 < 0) return -1\n    if (compareSign1 > 0) return 1\n    return 0\n  }\n}\n","import Coordinate from '../geom/Coordinate'\nimport SegmentPointComparator from './SegmentPointComparator'\nimport Comparable from '../../../../java/lang/Comparable'\nexport default class SegmentNode {\n  constructor() {\n    SegmentNode.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._segString = null\n    this.coord = null\n    this.segmentIndex = null\n    this._segmentOctant = null\n    this._isInterior = null\n    const segString = arguments[0], coord = arguments[1], segmentIndex = arguments[2], segmentOctant = arguments[3]\n    this._segString = segString\n    this.coord = new Coordinate(coord)\n    this.segmentIndex = segmentIndex\n    this._segmentOctant = segmentOctant\n    this._isInterior = !coord.equals2D(segString.getCoordinate(segmentIndex))\n  }\n  getCoordinate() {\n    return this.coord\n  }\n  print(out) {\n    out.print(this.coord)\n    out.print(' seg # = ' + this.segmentIndex)\n  }\n  compareTo(obj) {\n    const other = obj\n    if (this.segmentIndex < other.segmentIndex) return -1\n    if (this.segmentIndex > other.segmentIndex) return 1\n    if (this.coord.equals2D(other.coord)) return 0\n    if (!this._isInterior) return -1\n    if (!other._isInterior) return 1\n    return SegmentPointComparator.compare(this._segmentOctant, this.coord, other.coord)\n  }\n  isEndPoint(maxSegmentIndex) {\n    if (this.segmentIndex === 0 && !this._isInterior) return true\n    if (this.segmentIndex === maxSegmentIndex) return true\n    return false\n  }\n  toString() {\n    return this.segmentIndex + ':' + this.coord.toString()\n  }\n  isInterior() {\n    return this._isInterior\n  }\n  get interfaces_() {\n    return [Comparable]\n  }\n}\n","/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/Iterator.html\n * @constructor\n * @private\n */\nexport default class Iterator {\n  /**\n     * Returns true if the iteration has more elements.\n     * @return {boolean}\n     */\n  hasNext() {}\n\n  /**\n     * Returns the next element in the iteration.\n     * @return {Object}\n     */\n  next() {}\n\n  /**\n     * Removes from the underlying collection the last element returned by the\n     * iterator (optional operation).\n     */\n  remove() {}\n}\n","import CoordinateList from '../geom/CoordinateList'\nimport SegmentNode from './SegmentNode'\nimport Iterator from '../../../../java/util/Iterator'\nimport Coordinate from '../geom/Coordinate'\nimport NodedSegmentString from './NodedSegmentString'\nimport Integer from '../../../../java/lang/Integer'\nimport UnsupportedOperationException from '../../../../java/lang/UnsupportedOperationException'\nimport ArrayList from '../../../../java/util/ArrayList'\nimport RuntimeException from '../../../../java/lang/RuntimeException'\nimport Assert from '../util/Assert'\nimport TreeMap from '../../../../java/util/TreeMap'\nexport default class SegmentNodeList {\n  constructor() {\n    SegmentNodeList.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._nodeMap = new TreeMap()\n    this._edge = null\n    const edge = arguments[0]\n    this._edge = edge\n  }\n  getSplitCoordinates() {\n    const coordList = new CoordinateList()\n    this.addEndpoints()\n    const it = this.iterator()\n    let eiPrev = it.next()\n    while (it.hasNext()) {\n      const ei = it.next()\n      this.addEdgeCoordinates(eiPrev, ei, coordList)\n      eiPrev = ei\n    }\n    return coordList.toCoordinateArray()\n  }\n  addCollapsedNodes() {\n    const collapsedVertexIndexes = new ArrayList()\n    this.findCollapsesFromInsertedNodes(collapsedVertexIndexes)\n    this.findCollapsesFromExistingVertices(collapsedVertexIndexes)\n    for (let it = collapsedVertexIndexes.iterator(); it.hasNext(); ) {\n      const vertexIndex = it.next().intValue()\n      this.add(this._edge.getCoordinate(vertexIndex), vertexIndex)\n    }\n  }\n  createSplitEdgePts(ei0, ei1) {\n    let npts = ei1.segmentIndex - ei0.segmentIndex + 2\n    if (npts === 2) return [new Coordinate(ei0.coord), new Coordinate(ei1.coord)]\n    const lastSegStartPt = this._edge.getCoordinate(ei1.segmentIndex)\n    const useIntPt1 = ei1.isInterior() || !ei1.coord.equals2D(lastSegStartPt)\n    if (!useIntPt1) \n      npts--\n    \n    const pts = new Array(npts).fill(null)\n    let ipt = 0\n    pts[ipt++] = new Coordinate(ei0.coord)\n    for (let i = ei0.segmentIndex + 1; i <= ei1.segmentIndex; i++) \n      pts[ipt++] = this._edge.getCoordinate(i)\n    \n    if (useIntPt1) pts[ipt] = new Coordinate(ei1.coord)\n    return pts\n  }\n  print(out) {\n    out.println('Intersections:')\n    for (let it = this.iterator(); it.hasNext(); ) {\n      const ei = it.next()\n      ei.print(out)\n    }\n  }\n  findCollapsesFromExistingVertices(collapsedVertexIndexes) {\n    for (let i = 0; i < this._edge.size() - 2; i++) {\n      const p0 = this._edge.getCoordinate(i)\n      const p1 = this._edge.getCoordinate(i + 1)\n      const p2 = this._edge.getCoordinate(i + 2)\n      if (p0.equals2D(p2)) \n        collapsedVertexIndexes.add(Integer.valueOf(i + 1))\n      \n    }\n  }\n  addEdgeCoordinates(ei0, ei1, coordList) {\n    const pts = this.createSplitEdgePts(ei0, ei1)\n    coordList.add(pts, false)\n  }\n  iterator() {\n    return this._nodeMap.values().iterator()\n  }\n  addSplitEdges(edgeList) {\n    this.addEndpoints()\n    this.addCollapsedNodes()\n    const it = this.iterator()\n    let eiPrev = it.next()\n    while (it.hasNext()) {\n      const ei = it.next()\n      const newEdge = this.createSplitEdge(eiPrev, ei)\n      edgeList.add(newEdge)\n      eiPrev = ei\n    }\n  }\n  findCollapseIndex(ei0, ei1, collapsedVertexIndex) {\n    if (!ei0.coord.equals2D(ei1.coord)) return false\n    let numVerticesBetween = ei1.segmentIndex - ei0.segmentIndex\n    if (!ei1.isInterior()) \n      numVerticesBetween--\n    \n    if (numVerticesBetween === 1) {\n      collapsedVertexIndex[0] = ei0.segmentIndex + 1\n      return true\n    }\n    return false\n  }\n  findCollapsesFromInsertedNodes(collapsedVertexIndexes) {\n    const collapsedVertexIndex = new Array(1).fill(null)\n    const it = this.iterator()\n    let eiPrev = it.next()\n    while (it.hasNext()) {\n      const ei = it.next()\n      const isCollapsed = this.findCollapseIndex(eiPrev, ei, collapsedVertexIndex)\n      if (isCollapsed) collapsedVertexIndexes.add(Integer.valueOf(collapsedVertexIndex[0]))\n      eiPrev = ei\n    }\n  }\n  getEdge() {\n    return this._edge\n  }\n  addEndpoints() {\n    const maxSegIndex = this._edge.size() - 1\n    this.add(this._edge.getCoordinate(0), 0)\n    this.add(this._edge.getCoordinate(maxSegIndex), maxSegIndex)\n  }\n  createSplitEdge(ei0, ei1) {\n    const pts = this.createSplitEdgePts(ei0, ei1)\n    return new NodedSegmentString(pts, this._edge.getData())\n  }\n  add(intPt, segmentIndex) {\n    const eiNew = new SegmentNode(this._edge, intPt, segmentIndex, this._edge.getSegmentOctant(segmentIndex))\n    const ei = this._nodeMap.get(eiNew)\n    if (ei !== null) {\n      Assert.isTrue(ei.coord.equals2D(intPt), 'Found equal nodes with different coordinates')\n      return ei\n    }\n    this._nodeMap.put(eiNew, eiNew)\n    return eiNew\n  }\n  checkSplitEdgesCorrectness(splitEdges) {\n    const edgePts = this._edge.getCoordinates()\n    const split0 = splitEdges.get(0)\n    const pt0 = split0.getCoordinate(0)\n    if (!pt0.equals2D(edgePts[0])) throw new RuntimeException('bad split edge start point at ' + pt0)\n    const splitn = splitEdges.get(splitEdges.size() - 1)\n    const splitnPts = splitn.getCoordinates()\n    const ptn = splitnPts[splitnPts.length - 1]\n    if (!ptn.equals2D(edgePts[edgePts.length - 1])) throw new RuntimeException('bad split edge end point at ' + ptn)\n  }\n}\nclass NodeVertexIterator {\n  constructor() {\n    NodeVertexIterator.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._nodeList = null\n    this._edge = null\n    this._nodeIt = null\n    this._currNode = null\n    this._nextNode = null\n    this._currSegIndex = 0\n    const nodeList = arguments[0]\n    this._nodeList = nodeList\n    this._edge = nodeList.getEdge()\n    this._nodeIt = nodeList.iterator()\n    this.readNextNode()\n  }\n  next() {\n    if (this._currNode === null) {\n      this._currNode = this._nextNode\n      this._currSegIndex = this._currNode.segmentIndex\n      this.readNextNode()\n      return this._currNode\n    }\n    if (this._nextNode === null) return null\n    if (this._nextNode.segmentIndex === this._currNode.segmentIndex) {\n      this._currNode = this._nextNode\n      this._currSegIndex = this._currNode.segmentIndex\n      this.readNextNode()\n      return this._currNode\n    }\n    if (this._nextNode.segmentIndex > this._currNode.segmentIndex) {}\n    return null\n  }\n  remove() {\n    throw new UnsupportedOperationException(this.getClass().getName())\n  }\n  hasNext() {\n    if (this._nextNode === null) return false\n    return true\n  }\n  readNextNode() {\n    if (this._nodeIt.hasNext()) this._nextNode = this._nodeIt.next(); else this._nextNode = null\n  }\n  get interfaces_() {\n    return [Iterator]\n  }\n}\n","import Coordinate from '../geom/Coordinate'\nimport IllegalArgumentException from '../../../../java/lang/IllegalArgumentException'\nexport default class Octant {\n  static octant() {\n    if (typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {\n      const dx = arguments[0], dy = arguments[1]\n      if (dx === 0.0 && dy === 0.0) throw new IllegalArgumentException('Cannot compute the octant for point ( ' + dx + ', ' + dy + ' )')\n      const adx = Math.abs(dx)\n      const ady = Math.abs(dy)\n      if (dx >= 0) \n        if (dy >= 0) \n          if (adx >= ady) return 0; else return 1\n        else \n        if (adx >= ady) return 7; else return 6\n        \n      else \n      if (dy >= 0) \n        if (adx >= ady) return 3; else return 2\n      else \n      if (adx >= ady) return 4; else return 5\n        \n      \n    } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {\n      const p0 = arguments[0], p1 = arguments[1]\n      const dx = p1.x - p0.x\n      const dy = p1.y - p0.y\n      if (dx === 0.0 && dy === 0.0) throw new IllegalArgumentException('Cannot compute the octant for two identical points ' + p0)\n      return Octant.octant(dx, dy)\n    }\n  }\n}\n","export default class SegmentString {\n  getCoordinates() {}\n  size() {}\n  getCoordinate(i) {}\n  isClosed() {}\n  setData(data) {}\n  getData() {}\n}\n","import SegmentString from './SegmentString'\nexport default class NodableSegmentString {\n  addIntersection(intPt, segmentIndex) {}\n  get interfaces_() {\n    return [SegmentString]\n  }\n}\n","import SegmentNodeList from './SegmentNodeList'\nimport WKTWriter from '../io/WKTWriter'\nimport CoordinateArraySequence from '../geom/impl/CoordinateArraySequence'\nimport Coordinate from '../geom/Coordinate'\nimport Octant from './Octant'\nimport ArrayList from '../../../../java/util/ArrayList'\nimport NodableSegmentString from './NodableSegmentString'\nexport default class NodedSegmentString {\n  constructor() {\n    NodedSegmentString.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._nodeList = new SegmentNodeList(this)\n    this._pts = null\n    this._data = null\n    const pts = arguments[0], data = arguments[1]\n    this._pts = pts\n    this._data = data\n  }\n  static getNodedSubstrings() {\n    if (arguments.length === 1) {\n      const segStrings = arguments[0]\n      const resultEdgelist = new ArrayList()\n      NodedSegmentString.getNodedSubstrings(segStrings, resultEdgelist)\n      return resultEdgelist\n    } else if (arguments.length === 2) {\n      const segStrings = arguments[0], resultEdgelist = arguments[1]\n      for (let i = segStrings.iterator(); i.hasNext(); ) {\n        const ss = i.next()\n        ss.getNodeList().addSplitEdges(resultEdgelist)\n      }\n    }\n  }\n  getCoordinates() {\n    return this._pts\n  }\n  size() {\n    return this._pts.length\n  }\n  getCoordinate(i) {\n    return this._pts[i]\n  }\n  isClosed() {\n    return this._pts[0].equals(this._pts[this._pts.length - 1])\n  }\n  getSegmentOctant(index) {\n    if (index === this._pts.length - 1) return -1\n    return this.safeOctant(this.getCoordinate(index), this.getCoordinate(index + 1))\n  }\n  setData(data) {\n    this._data = data\n  }\n  safeOctant(p0, p1) {\n    if (p0.equals2D(p1)) return 0\n    return Octant.octant(p0, p1)\n  }\n  getData() {\n    return this._data\n  }\n  addIntersection() {\n    if (arguments.length === 2) {\n      const intPt = arguments[0], segmentIndex = arguments[1]\n      this.addIntersectionNode(intPt, segmentIndex)\n    } else if (arguments.length === 4) {\n      const li = arguments[0], segmentIndex = arguments[1], geomIndex = arguments[2], intIndex = arguments[3]\n      const intPt = new Coordinate(li.getIntersection(intIndex))\n      this.addIntersection(intPt, segmentIndex)\n    }\n  }\n  toString() {\n    return WKTWriter.toLineString(new CoordinateArraySequence(this._pts))\n  }\n  getNodeList() {\n    return this._nodeList\n  }\n  addIntersectionNode(intPt, segmentIndex) {\n    let normalizedSegmentIndex = segmentIndex\n    const nextSegIndex = normalizedSegmentIndex + 1\n    if (nextSegIndex < this._pts.length) {\n      const nextPt = this._pts[nextSegIndex]\n      if (intPt.equals2D(nextPt)) \n        normalizedSegmentIndex = nextSegIndex\n      \n    }\n    const ei = this._nodeList.add(intPt, normalizedSegmentIndex)\n    return ei\n  }\n  addIntersections(li, segmentIndex, geomIndex) {\n    for (let i = 0; i < li.getIntersectionNum(); i++) \n      this.addIntersection(li, segmentIndex, geomIndex, i)\n    \n  }\n  get interfaces_() {\n    return [NodableSegmentString]\n  }\n}\n","import Coordinate from './Coordinate'\nimport Double from '../../../../java/lang/Double'\nimport Orientation from '../algorithm/Orientation'\nimport Intersection from '../algorithm/Intersection'\nimport Comparable from '../../../../java/lang/Comparable'\nimport RobustLineIntersector from '../algorithm/RobustLineIntersector'\nimport Serializable from '../../../../java/io/Serializable'\nimport Distance from '../algorithm/Distance'\nexport default class LineSegment {\n  constructor() {\n    LineSegment.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this.p0 = null\n    this.p1 = null\n    if (arguments.length === 0) {\n      LineSegment.constructor_.call(this, new Coordinate(), new Coordinate())\n    } else if (arguments.length === 1) {\n      const ls = arguments[0]\n      LineSegment.constructor_.call(this, ls.p0, ls.p1)\n    } else if (arguments.length === 2) {\n      const p0 = arguments[0], p1 = arguments[1]\n      this.p0 = p0\n      this.p1 = p1\n    } else if (arguments.length === 4) {\n      const x0 = arguments[0], y0 = arguments[1], x1 = arguments[2], y1 = arguments[3]\n      LineSegment.constructor_.call(this, new Coordinate(x0, y0), new Coordinate(x1, y1))\n    }\n  }\n  static midPoint(p0, p1) {\n    return new Coordinate((p0.x + p1.x) / 2, (p0.y + p1.y) / 2)\n  }\n  minX() {\n    return Math.min(this.p0.x, this.p1.x)\n  }\n  orientationIndex() {\n    if (arguments[0] instanceof LineSegment) {\n      const seg = arguments[0]\n      const orient0 = Orientation.index(this.p0, this.p1, seg.p0)\n      const orient1 = Orientation.index(this.p0, this.p1, seg.p1)\n      if (orient0 >= 0 && orient1 >= 0) return Math.max(orient0, orient1)\n      if (orient0 <= 0 && orient1 <= 0) return Math.max(orient0, orient1)\n      return 0\n    } else if (arguments[0] instanceof Coordinate) {\n      const p = arguments[0]\n      return Orientation.index(this.p0, this.p1, p)\n    }\n  }\n  toGeometry(geomFactory) {\n    return geomFactory.createLineString([this.p0, this.p1])\n  }\n  isVertical() {\n    return this.p0.x === this.p1.x\n  }\n  equals(o) {\n    if (!(o instanceof LineSegment)) \n      return false\n    \n    const other = o\n    return this.p0.equals(other.p0) && this.p1.equals(other.p1)\n  }\n  intersection(line) {\n    const li = new RobustLineIntersector()\n    li.computeIntersection(this.p0, this.p1, line.p0, line.p1)\n    if (li.hasIntersection()) return li.getIntersection(0)\n    return null\n  }\n  project() {\n    if (arguments[0] instanceof Coordinate) {\n      const p = arguments[0]\n      if (p.equals(this.p0) || p.equals(this.p1)) return new Coordinate(p)\n      const r = this.projectionFactor(p)\n      const coord = new Coordinate()\n      coord.x = this.p0.x + r * (this.p1.x - this.p0.x)\n      coord.y = this.p0.y + r * (this.p1.y - this.p0.y)\n      return coord\n    } else if (arguments[0] instanceof LineSegment) {\n      const seg = arguments[0]\n      const pf0 = this.projectionFactor(seg.p0)\n      const pf1 = this.projectionFactor(seg.p1)\n      if (pf0 >= 1.0 && pf1 >= 1.0) return null\n      if (pf0 <= 0.0 && pf1 <= 0.0) return null\n      let newp0 = this.project(seg.p0)\n      if (pf0 < 0.0) newp0 = this.p0\n      if (pf0 > 1.0) newp0 = this.p1\n      let newp1 = this.project(seg.p1)\n      if (pf1 < 0.0) newp1 = this.p0\n      if (pf1 > 1.0) newp1 = this.p1\n      return new LineSegment(newp0, newp1)\n    }\n  }\n  normalize() {\n    if (this.p1.compareTo(this.p0) < 0) this.reverse()\n  }\n  angle() {\n    return Math.atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x)\n  }\n  getCoordinate(i) {\n    if (i === 0) return this.p0\n    return this.p1\n  }\n  distancePerpendicular(p) {\n    return Distance.pointToLinePerpendicular(p, this.p0, this.p1)\n  }\n  minY() {\n    return Math.min(this.p0.y, this.p1.y)\n  }\n  midPoint() {\n    return LineSegment.midPoint(this.p0, this.p1)\n  }\n  projectionFactor(p) {\n    if (p.equals(this.p0)) return 0.0\n    if (p.equals(this.p1)) return 1.0\n    const dx = this.p1.x - this.p0.x\n    const dy = this.p1.y - this.p0.y\n    const len = dx * dx + dy * dy\n    if (len <= 0.0) return Double.NaN\n    const r = ((p.x - this.p0.x) * dx + (p.y - this.p0.y) * dy) / len\n    return r\n  }\n  closestPoints(line) {\n    const intPt = this.intersection(line)\n    if (intPt !== null) \n      return [intPt, intPt]\n    \n    const closestPt = new Array(2).fill(null)\n    let minDistance = Double.MAX_VALUE\n    let dist = null\n    const close00 = this.closestPoint(line.p0)\n    minDistance = close00.distance(line.p0)\n    closestPt[0] = close00\n    closestPt[1] = line.p0\n    const close01 = this.closestPoint(line.p1)\n    dist = close01.distance(line.p1)\n    if (dist < minDistance) {\n      minDistance = dist\n      closestPt[0] = close01\n      closestPt[1] = line.p1\n    }\n    const close10 = line.closestPoint(this.p0)\n    dist = close10.distance(this.p0)\n    if (dist < minDistance) {\n      minDistance = dist\n      closestPt[0] = this.p0\n      closestPt[1] = close10\n    }\n    const close11 = line.closestPoint(this.p1)\n    dist = close11.distance(this.p1)\n    if (dist < minDistance) {\n      minDistance = dist\n      closestPt[0] = this.p1\n      closestPt[1] = close11\n    }\n    return closestPt\n  }\n  closestPoint(p) {\n    const factor = this.projectionFactor(p)\n    if (factor > 0 && factor < 1) \n      return this.project(p)\n    \n    const dist0 = this.p0.distance(p)\n    const dist1 = this.p1.distance(p)\n    if (dist0 < dist1) return this.p0\n    return this.p1\n  }\n  maxX() {\n    return Math.max(this.p0.x, this.p1.x)\n  }\n  getLength() {\n    return this.p0.distance(this.p1)\n  }\n  compareTo(o) {\n    const other = o\n    const comp0 = this.p0.compareTo(other.p0)\n    if (comp0 !== 0) return comp0\n    return this.p1.compareTo(other.p1)\n  }\n  reverse() {\n    const temp = this.p0\n    this.p0 = this.p1\n    this.p1 = temp\n  }\n  equalsTopo(other) {\n    return this.p0.equals(other.p0) && this.p1.equals(other.p1) || this.p0.equals(other.p1) && this.p1.equals(other.p0)\n  }\n  lineIntersection(line) {\n    const intPt = Intersection.intersection(this.p0, this.p1, line.p0, line.p1)\n    return intPt\n  }\n  maxY() {\n    return Math.max(this.p0.y, this.p1.y)\n  }\n  pointAlongOffset(segmentLengthFraction, offsetDistance) {\n    const segx = this.p0.x + segmentLengthFraction * (this.p1.x - this.p0.x)\n    const segy = this.p0.y + segmentLengthFraction * (this.p1.y - this.p0.y)\n    const dx = this.p1.x - this.p0.x\n    const dy = this.p1.y - this.p0.y\n    const len = Math.sqrt(dx * dx + dy * dy)\n    let ux = 0.0\n    let uy = 0.0\n    if (offsetDistance !== 0.0) {\n      if (len <= 0.0) throw new IllegalStateException('Cannot compute offset from zero-length line segment')\n      ux = offsetDistance * dx / len\n      uy = offsetDistance * dy / len\n    }\n    const offsetx = segx - uy\n    const offsety = segy + ux\n    const coord = new Coordinate(offsetx, offsety)\n    return coord\n  }\n  setCoordinates() {\n    if (arguments.length === 1) {\n      const ls = arguments[0]\n      this.setCoordinates(ls.p0, ls.p1)\n    } else if (arguments.length === 2) {\n      const p0 = arguments[0], p1 = arguments[1]\n      this.p0.x = p0.x\n      this.p0.y = p0.y\n      this.p1.x = p1.x\n      this.p1.y = p1.y\n    }\n  }\n  segmentFraction(inputPt) {\n    let segFrac = this.projectionFactor(inputPt)\n    if (segFrac < 0.0) segFrac = 0.0; else if (segFrac > 1.0 || Double.isNaN(segFrac)) segFrac = 1.0\n    return segFrac\n  }\n  toString() {\n    return 'LINESTRING( ' + this.p0.x + ' ' + this.p0.y + ', ' + this.p1.x + ' ' + this.p1.y + ')'\n  }\n  isHorizontal() {\n    return this.p0.y === this.p1.y\n  }\n  reflect(p) {\n    const A = this.p1.getY() - this.p0.getY()\n    const B = this.p0.getX() - this.p1.getX()\n    const C = this.p0.getY() * (this.p1.getX() - this.p0.getX()) - this.p0.getX() * (this.p1.getY() - this.p0.getY())\n    const A2plusB2 = A * A + B * B\n    const A2subB2 = A * A - B * B\n    const x = p.getX()\n    const y = p.getY()\n    const rx = (-A2subB2 * x - 2 * A * B * y - 2 * A * C) / A2plusB2\n    const ry = (A2subB2 * y - 2 * A * B * x - 2 * B * C) / A2plusB2\n    return new Coordinate(rx, ry)\n  }\n  distance() {\n    if (arguments[0] instanceof LineSegment) {\n      const ls = arguments[0]\n      return Distance.segmentToSegment(this.p0, this.p1, ls.p0, ls.p1)\n    } else if (arguments[0] instanceof Coordinate) {\n      const p = arguments[0]\n      return Distance.pointToSegment(p, this.p0, this.p1)\n    }\n  }\n  pointAlong(segmentLengthFraction) {\n    const coord = new Coordinate()\n    coord.x = this.p0.x + segmentLengthFraction * (this.p1.x - this.p0.x)\n    coord.y = this.p0.y + segmentLengthFraction * (this.p1.y - this.p0.y)\n    return coord\n  }\n  hashCode() {\n    let bits0 = Double.doubleToLongBits(this.p0.x)\n    bits0 ^= Double.doubleToLongBits(this.p0.y) * 31\n    const hash0 = Math.trunc(bits0) ^ Math.trunc(bits0 >> 32)\n    let bits1 = Double.doubleToLongBits(this.p1.x)\n    bits1 ^= Double.doubleToLongBits(this.p1.y) * 31\n    const hash1 = Math.trunc(bits1) ^ Math.trunc(bits1 >> 32)\n    return hash0 ^ hash1\n  }\n  get interfaces_() {\n    return [Comparable, Serializable]\n  }\n}\n","import LineSegment from '../../geom/LineSegment'\nexport default class MonotoneChainOverlapAction {\n  constructor() {\n    MonotoneChainOverlapAction.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._overlapSeg1 = new LineSegment()\n    this._overlapSeg2 = new LineSegment()\n  }\n  overlap() {\n    if (arguments.length === 2) {\n      const seg1 = arguments[0], seg2 = arguments[1]\n    } else if (arguments.length === 4) {\n      const mc1 = arguments[0], start1 = arguments[1], mc2 = arguments[2], start2 = arguments[3]\n      mc1.getLineSegment(start1, this._overlapSeg1)\n      mc2.getLineSegment(start2, this._overlapSeg2)\n      this.overlap(this._overlapSeg1, this._overlapSeg2)\n    }\n  }\n}\n","import Envelope from '../../geom/Envelope'\nexport default class MonotoneChain {\n  constructor() {\n    MonotoneChain.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._pts = null\n    this._start = null\n    this._end = null\n    this._env = null\n    this._context = null\n    this._id = null\n    const pts = arguments[0], start = arguments[1], end = arguments[2], context = arguments[3]\n    this._pts = pts\n    this._start = start\n    this._end = end\n    this._context = context\n  }\n  getLineSegment(index, ls) {\n    ls.p0 = this._pts[index]\n    ls.p1 = this._pts[index + 1]\n  }\n  computeSelect(searchEnv, start0, end0, mcs) {\n    const p0 = this._pts[start0]\n    const p1 = this._pts[end0]\n    if (end0 - start0 === 1) {\n      mcs.select(this, start0)\n      return null\n    }\n    if (!searchEnv.intersects(p0, p1)) return null\n    const mid = Math.trunc((start0 + end0) / 2)\n    if (start0 < mid) \n      this.computeSelect(searchEnv, start0, mid, mcs)\n    \n    if (mid < end0) \n      this.computeSelect(searchEnv, mid, end0, mcs)\n    \n  }\n  getCoordinates() {\n    const coord = new Array(this._end - this._start + 1).fill(null)\n    let index = 0\n    for (let i = this._start; i <= this._end; i++) \n      coord[index++] = this._pts[i]\n    \n    return coord\n  }\n  computeOverlaps() {\n    if (arguments.length === 2) {\n      const mc = arguments[0], mco = arguments[1]\n      this.computeOverlaps(this._start, this._end, mc, mc._start, mc._end, mco)\n    } else if (arguments.length === 6) {\n      const start0 = arguments[0], end0 = arguments[1], mc = arguments[2], start1 = arguments[3], end1 = arguments[4], mco = arguments[5]\n      if (end0 - start0 === 1 && end1 - start1 === 1) {\n        mco.overlap(this, start0, mc, start1)\n        return null\n      }\n      if (!this.overlaps(start0, end0, mc, start1, end1)) return null\n      const mid0 = Math.trunc((start0 + end0) / 2)\n      const mid1 = Math.trunc((start1 + end1) / 2)\n      if (start0 < mid0) {\n        if (start1 < mid1) this.computeOverlaps(start0, mid0, mc, start1, mid1, mco)\n        if (mid1 < end1) this.computeOverlaps(start0, mid0, mc, mid1, end1, mco)\n      }\n      if (mid0 < end0) {\n        if (start1 < mid1) this.computeOverlaps(mid0, end0, mc, start1, mid1, mco)\n        if (mid1 < end1) this.computeOverlaps(mid0, end0, mc, mid1, end1, mco)\n      }\n    }\n  }\n  setId(id) {\n    this._id = id\n  }\n  select(searchEnv, mcs) {\n    this.computeSelect(searchEnv, this._start, this._end, mcs)\n  }\n  getEnvelope() {\n    if (this._env === null) {\n      const p0 = this._pts[this._start]\n      const p1 = this._pts[this._end]\n      this._env = new Envelope(p0, p1)\n    }\n    return this._env\n  }\n  overlaps(start0, end0, mc, start1, end1) {\n    return Envelope.intersects(this._pts[start0], this._pts[end0], mc._pts[start1], mc._pts[end1])\n  }\n  getEndIndex() {\n    return this._end\n  }\n  getStartIndex() {\n    return this._start\n  }\n  getContext() {\n    return this._context\n  }\n  getId() {\n    return this._id\n  }\n}\n","import MonotoneChain from './MonotoneChain'\nimport ArrayList from '../../../../../java/util/ArrayList'\nimport Quadrant from '../../geomgraph/Quadrant'\nexport default class MonotoneChainBuilder {\n  static findChainEnd(pts, start) {\n    let safeStart = start\n    while (safeStart < pts.length - 1 && pts[safeStart].equals2D(pts[safeStart + 1])) \n      safeStart++\n    \n    if (safeStart >= pts.length - 1) \n      return pts.length - 1\n    \n    const chainQuad = Quadrant.quadrant(pts[safeStart], pts[safeStart + 1])\n    let last = start + 1\n    while (last < pts.length) {\n      if (!pts[last - 1].equals2D(pts[last])) {\n        const quad = Quadrant.quadrant(pts[last - 1], pts[last])\n        if (quad !== chainQuad) break\n      }\n      last++\n    }\n    return last - 1\n  }\n  static getChains() {\n    if (arguments.length === 1) {\n      const pts = arguments[0]\n      return MonotoneChainBuilder.getChains(pts, null)\n    } else if (arguments.length === 2) {\n      const pts = arguments[0], context = arguments[1]\n      const mcList = new ArrayList()\n      let chainStart = 0\n      do {\n        const chainEnd = MonotoneChainBuilder.findChainEnd(pts, chainStart)\n        const mc = new MonotoneChain(pts, chainStart, chainEnd, context)\n        mcList.add(mc)\n        chainStart = chainEnd\n      } while (chainStart < pts.length - 1)\n      return mcList\n    }\n  }\n}\n","export default class Noder {\n  computeNodes(segStrings) {}\n  getNodedSubstrings() {}\n}\n","import Noder from './Noder'\nexport default class SinglePassNoder {\n  constructor() {\n    SinglePassNoder.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._segInt = null\n    if (arguments.length === 0) {} else if (arguments.length === 1) {\n      const segInt = arguments[0]\n      this.setSegmentIntersector(segInt)\n    }\n  }\n  setSegmentIntersector(segInt) {\n    this._segInt = segInt\n  }\n  get interfaces_() {\n    return [Noder]\n  }\n}\n","import STRtree from '../index/strtree/STRtree'\nimport NodedSegmentString from './NodedSegmentString'\nimport MonotoneChainOverlapAction from '../index/chain/MonotoneChainOverlapAction'\nimport MonotoneChainBuilder from '../index/chain/MonotoneChainBuilder'\nimport ArrayList from '../../../../java/util/ArrayList'\nimport SinglePassNoder from './SinglePassNoder'\nexport default class MCIndexNoder extends SinglePassNoder {\n  constructor() {\n    super()\n    MCIndexNoder.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._monoChains = new ArrayList()\n    this._index = new STRtree()\n    this._idCounter = 0\n    this._nodedSegStrings = null\n    this._nOverlaps = 0\n    if (arguments.length === 0) {} else if (arguments.length === 1) {\n      const si = arguments[0]\n      SinglePassNoder.constructor_.call(this, si)\n    }\n  }\n  getMonotoneChains() {\n    return this._monoChains\n  }\n  getNodedSubstrings() {\n    return NodedSegmentString.getNodedSubstrings(this._nodedSegStrings)\n  }\n  getIndex() {\n    return this._index\n  }\n  add(segStr) {\n    const segChains = MonotoneChainBuilder.getChains(segStr.getCoordinates(), segStr)\n    for (let i = segChains.iterator(); i.hasNext(); ) {\n      const mc = i.next()\n      mc.setId(this._idCounter++)\n      this._index.insert(mc.getEnvelope(), mc)\n      this._monoChains.add(mc)\n    }\n  }\n  computeNodes(inputSegStrings) {\n    this._nodedSegStrings = inputSegStrings\n    for (let i = inputSegStrings.iterator(); i.hasNext(); ) \n      this.add(i.next())\n    \n    this.intersectChains()\n  }\n  intersectChains() {\n    const overlapAction = new SegmentOverlapAction(this._segInt)\n    for (let i = this._monoChains.iterator(); i.hasNext(); ) {\n      const queryChain = i.next()\n      const overlapChains = this._index.query(queryChain.getEnvelope())\n      for (let j = overlapChains.iterator(); j.hasNext(); ) {\n        const testChain = j.next()\n        if (testChain.getId() > queryChain.getId()) {\n          queryChain.computeOverlaps(testChain, overlapAction)\n          this._nOverlaps++\n        }\n        if (this._segInt.isDone()) return null\n      }\n    }\n  }\n}\nclass SegmentOverlapAction extends MonotoneChainOverlapAction {\n  constructor() {\n    super()\n    SegmentOverlapAction.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._si = null\n    const si = arguments[0]\n    this._si = si\n  }\n  overlap() {\n    if (arguments.length === 4) {\n      const mc1 = arguments[0], start1 = arguments[1], mc2 = arguments[2], start2 = arguments[3]\n      const ss1 = mc1.getContext()\n      const ss2 = mc2.getContext()\n      this._si.processIntersections(ss1, start1, ss2, start2)\n    } else {\n      return super.overlap.apply(this, arguments)\n    }\n  }\n}\nMCIndexNoder.SegmentOverlapAction = SegmentOverlapAction\n","import CoordinateList from '../../geom/CoordinateList'\nimport Orientation from '../../algorithm/Orientation'\nimport Distance from '../../algorithm/Distance'\nexport default class BufferInputLineSimplifier {\n  constructor() {\n    BufferInputLineSimplifier.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._inputLine = null\n    this._distanceTol = null\n    this._isDeleted = null\n    this._angleOrientation = Orientation.COUNTERCLOCKWISE\n    const inputLine = arguments[0]\n    this._inputLine = inputLine\n  }\n  static simplify(inputLine, distanceTol) {\n    const simp = new BufferInputLineSimplifier(inputLine)\n    return simp.simplify(distanceTol)\n  }\n  isDeletable(i0, i1, i2, distanceTol) {\n    const p0 = this._inputLine[i0]\n    const p1 = this._inputLine[i1]\n    const p2 = this._inputLine[i2]\n    if (!this.isConcave(p0, p1, p2)) return false\n    if (!this.isShallow(p0, p1, p2, distanceTol)) return false\n    return this.isShallowSampled(p0, p1, i0, i2, distanceTol)\n  }\n  deleteShallowConcavities() {\n    let index = 1\n    let midIndex = this.findNextNonDeletedIndex(index)\n    let lastIndex = this.findNextNonDeletedIndex(midIndex)\n    let isChanged = false\n    while (lastIndex < this._inputLine.length) {\n      let isMiddleVertexDeleted = false\n      if (this.isDeletable(index, midIndex, lastIndex, this._distanceTol)) {\n        this._isDeleted[midIndex] = BufferInputLineSimplifier.DELETE\n        isMiddleVertexDeleted = true\n        isChanged = true\n      }\n      if (isMiddleVertexDeleted) index = lastIndex; else index = midIndex\n      midIndex = this.findNextNonDeletedIndex(index)\n      lastIndex = this.findNextNonDeletedIndex(midIndex)\n    }\n    return isChanged\n  }\n  isShallowConcavity(p0, p1, p2, distanceTol) {\n    const orientation = Orientation.index(p0, p1, p2)\n    const isAngleToSimplify = orientation === this._angleOrientation\n    if (!isAngleToSimplify) return false\n    const dist = Distance.pointToSegment(p1, p0, p2)\n    return dist < distanceTol\n  }\n  isShallowSampled(p0, p2, i0, i2, distanceTol) {\n    let inc = Math.trunc((i2 - i0) / BufferInputLineSimplifier.NUM_PTS_TO_CHECK)\n    if (inc <= 0) inc = 1\n    for (let i = i0; i < i2; i += inc) \n      if (!this.isShallow(p0, p2, this._inputLine[i], distanceTol)) return false\n    \n    return true\n  }\n  isConcave(p0, p1, p2) {\n    const orientation = Orientation.index(p0, p1, p2)\n    const isConcave = orientation === this._angleOrientation\n    return isConcave\n  }\n  simplify(distanceTol) {\n    this._distanceTol = Math.abs(distanceTol)\n    if (distanceTol < 0) this._angleOrientation = Orientation.CLOCKWISE\n    this._isDeleted = new Array(this._inputLine.length).fill(null)\n    let isChanged = false\n    do \n      isChanged = this.deleteShallowConcavities()\n    while (isChanged)\n    return this.collapseLine()\n  }\n  findNextNonDeletedIndex(index) {\n    let next = index + 1\n    while (next < this._inputLine.length && this._isDeleted[next] === BufferInputLineSimplifier.DELETE) next++\n    return next\n  }\n  isShallow(p0, p1, p2, distanceTol) {\n    const dist = Distance.pointToSegment(p1, p0, p2)\n    return dist < distanceTol\n  }\n  collapseLine() {\n    const coordList = new CoordinateList()\n    for (let i = 0; i < this._inputLine.length; i++) \n      if (this._isDeleted[i] !== BufferInputLineSimplifier.DELETE) coordList.add(this._inputLine[i])\n    \n    return coordList.toCoordinateArray()\n  }\n}\nBufferInputLineSimplifier.INIT = 0\nBufferInputLineSimplifier.DELETE = 1\nBufferInputLineSimplifier.KEEP = 1\nBufferInputLineSimplifier.NUM_PTS_TO_CHECK = 10\n","import GeometryFactory from '../../geom/GeometryFactory'\nimport Coordinate from '../../geom/Coordinate'\nimport ArrayList from '../../../../../java/util/ArrayList'\nexport default class OffsetSegmentString {\n  constructor() {\n    OffsetSegmentString.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._ptList = null\n    this._precisionModel = null\n    this._minimimVertexDistance = 0.0\n    this._ptList = new ArrayList()\n  }\n  getCoordinates() {\n    const coord = this._ptList.toArray(OffsetSegmentString.COORDINATE_ARRAY_TYPE)\n    return coord\n  }\n  setPrecisionModel(precisionModel) {\n    this._precisionModel = precisionModel\n  }\n  addPt(pt) {\n    const bufPt = new Coordinate(pt)\n    this._precisionModel.makePrecise(bufPt)\n    if (this.isRedundant(bufPt)) return null\n    this._ptList.add(bufPt)\n  }\n  reverse() {}\n  addPts(pt, isForward) {\n    if (isForward) \n      for (let i = 0; i < pt.length; i++) \n        this.addPt(pt[i])\n      \n    else \n      for (let i = pt.length - 1; i >= 0; i--) \n        this.addPt(pt[i])\n      \n    \n  }\n  isRedundant(pt) {\n    if (this._ptList.size() < 1) return false\n    const lastPt = this._ptList.get(this._ptList.size() - 1)\n    const ptDist = pt.distance(lastPt)\n    if (ptDist < this._minimimVertexDistance) return true\n    return false\n  }\n  toString() {\n    const fact = new GeometryFactory()\n    const line = fact.createLineString(this.getCoordinates())\n    return line.toString()\n  }\n  closeRing() {\n    if (this._ptList.size() < 1) return null\n    const startPt = new Coordinate(this._ptList.get(0))\n    const lastPt = this._ptList.get(this._ptList.size() - 1)\n    if (startPt.equals(lastPt)) return null\n    this._ptList.add(startPt)\n  }\n  setMinimumVertexDistance(minimimVertexDistance) {\n    this._minimimVertexDistance = minimimVertexDistance\n  }\n}\nOffsetSegmentString.COORDINATE_ARRAY_TYPE = new Array(0).fill(null)\n","import Orientation from './Orientation'\nexport default class Angle {\n  static toDegrees(radians) {\n    return radians * 180 / Math.PI\n  }\n  static normalize(angle) {\n    while (angle > Math.PI) angle -= Angle.PI_TIMES_2\n    while (angle <= -Math.PI) angle += Angle.PI_TIMES_2\n    return angle\n  }\n  static angle() {\n    if (arguments.length === 1) {\n      const p = arguments[0]\n      return Math.atan2(p.y, p.x)\n    } else if (arguments.length === 2) {\n      const p0 = arguments[0], p1 = arguments[1]\n      const dx = p1.x - p0.x\n      const dy = p1.y - p0.y\n      return Math.atan2(dy, dx)\n    }\n  }\n  static isAcute(p0, p1, p2) {\n    const dx0 = p0.x - p1.x\n    const dy0 = p0.y - p1.y\n    const dx1 = p2.x - p1.x\n    const dy1 = p2.y - p1.y\n    const dotprod = dx0 * dx1 + dy0 * dy1\n    return dotprod > 0\n  }\n  static isObtuse(p0, p1, p2) {\n    const dx0 = p0.x - p1.x\n    const dy0 = p0.y - p1.y\n    const dx1 = p2.x - p1.x\n    const dy1 = p2.y - p1.y\n    const dotprod = dx0 * dx1 + dy0 * dy1\n    return dotprod < 0\n  }\n  static interiorAngle(p0, p1, p2) {\n    const anglePrev = Angle.angle(p1, p0)\n    const angleNext = Angle.angle(p1, p2)\n    return Math.abs(angleNext - anglePrev)\n  }\n  static normalizePositive(angle) {\n    if (angle < 0.0) {\n      while (angle < 0.0) angle += Angle.PI_TIMES_2\n      if (angle >= Angle.PI_TIMES_2) angle = 0.0\n    } else {\n      while (angle >= Angle.PI_TIMES_2) angle -= Angle.PI_TIMES_2\n      if (angle < 0.0) angle = 0.0\n    }\n    return angle\n  }\n  static angleBetween(tip1, tail, tip2) {\n    const a1 = Angle.angle(tail, tip1)\n    const a2 = Angle.angle(tail, tip2)\n    return Angle.diff(a1, a2)\n  }\n  static diff(ang1, ang2) {\n    let delAngle = null\n    if (ang1 < ang2) \n      delAngle = ang2 - ang1\n    else \n      delAngle = ang1 - ang2\n    \n    if (delAngle > Math.PI) \n      delAngle = 2 * Math.PI - delAngle\n    \n    return delAngle\n  }\n  static toRadians(angleDegrees) {\n    return angleDegrees * Math.PI / 180.0\n  }\n  static getTurn(ang1, ang2) {\n    const crossproduct = Math.sin(ang2 - ang1)\n    if (crossproduct > 0) \n      return Angle.COUNTERCLOCKWISE\n    \n    if (crossproduct < 0) \n      return Angle.CLOCKWISE\n    \n    return Angle.NONE\n  }\n  static angleBetweenOriented(tip1, tail, tip2) {\n    const a1 = Angle.angle(tail, tip1)\n    const a2 = Angle.angle(tail, tip2)\n    const angDel = a2 - a1\n    if (angDel <= -Math.PI) return angDel + Angle.PI_TIMES_2\n    if (angDel > Math.PI) return angDel - Angle.PI_TIMES_2\n    return angDel\n  }\n}\nAngle.PI_TIMES_2 = 2.0 * Math.PI\nAngle.PI_OVER_2 = Math.PI / 2.0\nAngle.PI_OVER_4 = Math.PI / 4.0\nAngle.COUNTERCLOCKWISE = Orientation.COUNTERCLOCKWISE\nAngle.CLOCKWISE = Orientation.CLOCKWISE\nAngle.NONE = Orientation.COLLINEAR\n","import BufferParameters from './BufferParameters'\nimport Position from '../../geomgraph/Position'\nimport Coordinate from '../../geom/Coordinate'\nimport Orientation from '../../algorithm/Orientation'\nimport Intersection from '../../algorithm/Intersection'\nimport OffsetSegmentString from './OffsetSegmentString'\nimport LineSegment from '../../geom/LineSegment'\nimport Angle from '../../algorithm/Angle'\nimport RobustLineIntersector from '../../algorithm/RobustLineIntersector'\nexport default class OffsetSegmentGenerator {\n  constructor() {\n    OffsetSegmentGenerator.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._maxCurveSegmentError = 0.0\n    this._filletAngleQuantum = null\n    this._closingSegLengthFactor = 1\n    this._segList = null\n    this._distance = 0.0\n    this._precisionModel = null\n    this._bufParams = null\n    this._li = null\n    this._s0 = null\n    this._s1 = null\n    this._s2 = null\n    this._seg0 = new LineSegment()\n    this._seg1 = new LineSegment()\n    this._offset0 = new LineSegment()\n    this._offset1 = new LineSegment()\n    this._side = 0\n    this._hasNarrowConcaveAngle = false\n    const precisionModel = arguments[0], bufParams = arguments[1], distance = arguments[2]\n    this._precisionModel = precisionModel\n    this._bufParams = bufParams\n    this._li = new RobustLineIntersector()\n    this._filletAngleQuantum = Math.PI / 2.0 / bufParams.getQuadrantSegments()\n    if (bufParams.getQuadrantSegments() >= 8 && bufParams.getJoinStyle() === BufferParameters.JOIN_ROUND) this._closingSegLengthFactor = OffsetSegmentGenerator.MAX_CLOSING_SEG_LEN_FACTOR\n    this.init(distance)\n  }\n  addNextSegment(p, addStartPoint) {\n    this._s0 = this._s1\n    this._s1 = this._s2\n    this._s2 = p\n    this._seg0.setCoordinates(this._s0, this._s1)\n    this.computeOffsetSegment(this._seg0, this._side, this._distance, this._offset0)\n    this._seg1.setCoordinates(this._s1, this._s2)\n    this.computeOffsetSegment(this._seg1, this._side, this._distance, this._offset1)\n    if (this._s1.equals(this._s2)) return null\n    const orientation = Orientation.index(this._s0, this._s1, this._s2)\n    const outsideTurn = orientation === Orientation.CLOCKWISE && this._side === Position.LEFT || orientation === Orientation.COUNTERCLOCKWISE && this._side === Position.RIGHT\n    if (orientation === 0) \n      this.addCollinear(addStartPoint)\n    else if (outsideTurn) \n      this.addOutsideTurn(orientation, addStartPoint)\n    else \n      this.addInsideTurn(orientation, addStartPoint)\n    \n  }\n  addLineEndCap(p0, p1) {\n    const seg = new LineSegment(p0, p1)\n    const offsetL = new LineSegment()\n    this.computeOffsetSegment(seg, Position.LEFT, this._distance, offsetL)\n    const offsetR = new LineSegment()\n    this.computeOffsetSegment(seg, Position.RIGHT, this._distance, offsetR)\n    const dx = p1.x - p0.x\n    const dy = p1.y - p0.y\n    const angle = Math.atan2(dy, dx)\n    switch (this._bufParams.getEndCapStyle()) {\n    case BufferParameters.CAP_ROUND:\n      this._segList.addPt(offsetL.p1)\n      this.addDirectedFillet(p1, angle + Math.PI / 2, angle - Math.PI / 2, Orientation.CLOCKWISE, this._distance)\n      this._segList.addPt(offsetR.p1)\n      break\n    case BufferParameters.CAP_FLAT:\n      this._segList.addPt(offsetL.p1)\n      this._segList.addPt(offsetR.p1)\n      break\n    case BufferParameters.CAP_SQUARE:\n      const squareCapSideOffset = new Coordinate()\n      squareCapSideOffset.x = Math.abs(this._distance) * Math.cos(angle)\n      squareCapSideOffset.y = Math.abs(this._distance) * Math.sin(angle)\n      const squareCapLOffset = new Coordinate(offsetL.p1.x + squareCapSideOffset.x, offsetL.p1.y + squareCapSideOffset.y)\n      const squareCapROffset = new Coordinate(offsetR.p1.x + squareCapSideOffset.x, offsetR.p1.y + squareCapSideOffset.y)\n      this._segList.addPt(squareCapLOffset)\n      this._segList.addPt(squareCapROffset)\n      break\n    }\n  }\n  getCoordinates() {\n    const pts = this._segList.getCoordinates()\n    return pts\n  }\n  addMitreJoin(p, offset0, offset1, distance) {\n    const intPt = Intersection.intersection(offset0.p0, offset0.p1, offset1.p0, offset1.p1)\n    if (intPt !== null) {\n      const mitreRatio = distance <= 0.0 ? 1.0 : intPt.distance(p) / Math.abs(distance)\n      if (mitreRatio <= this._bufParams.getMitreLimit()) {\n        this._segList.addPt(intPt)\n        return null\n      }\n    }\n    this.addLimitedMitreJoin(offset0, offset1, distance, this._bufParams.getMitreLimit())\n  }\n  addOutsideTurn(orientation, addStartPoint) {\n    if (this._offset0.p1.distance(this._offset1.p0) < this._distance * OffsetSegmentGenerator.OFFSET_SEGMENT_SEPARATION_FACTOR) {\n      this._segList.addPt(this._offset0.p1)\n      return null\n    }\n    if (this._bufParams.getJoinStyle() === BufferParameters.JOIN_MITRE) {\n      this.addMitreJoin(this._s1, this._offset0, this._offset1, this._distance)\n    } else if (this._bufParams.getJoinStyle() === BufferParameters.JOIN_BEVEL) {\n      this.addBevelJoin(this._offset0, this._offset1)\n    } else {\n      if (addStartPoint) this._segList.addPt(this._offset0.p1)\n      this.addCornerFillet(this._s1, this._offset0.p1, this._offset1.p0, orientation, this._distance)\n      this._segList.addPt(this._offset1.p0)\n    }\n  }\n  createSquare(p) {\n    this._segList.addPt(new Coordinate(p.x + this._distance, p.y + this._distance))\n    this._segList.addPt(new Coordinate(p.x + this._distance, p.y - this._distance))\n    this._segList.addPt(new Coordinate(p.x - this._distance, p.y - this._distance))\n    this._segList.addPt(new Coordinate(p.x - this._distance, p.y + this._distance))\n    this._segList.closeRing()\n  }\n  addSegments(pt, isForward) {\n    this._segList.addPts(pt, isForward)\n  }\n  addFirstSegment() {\n    this._segList.addPt(this._offset1.p0)\n  }\n  addCornerFillet(p, p0, p1, direction, radius) {\n    const dx0 = p0.x - p.x\n    const dy0 = p0.y - p.y\n    let startAngle = Math.atan2(dy0, dx0)\n    const dx1 = p1.x - p.x\n    const dy1 = p1.y - p.y\n    const endAngle = Math.atan2(dy1, dx1)\n    if (direction === Orientation.CLOCKWISE) {\n      if (startAngle <= endAngle) startAngle += 2.0 * Math.PI\n    } else {\n      if (startAngle >= endAngle) startAngle -= 2.0 * Math.PI\n    }\n    this._segList.addPt(p0)\n    this.addDirectedFillet(p, startAngle, endAngle, direction, radius)\n    this._segList.addPt(p1)\n  }\n  addLastSegment() {\n    this._segList.addPt(this._offset1.p1)\n  }\n  initSideSegments(s1, s2, side) {\n    this._s1 = s1\n    this._s2 = s2\n    this._side = side\n    this._seg1.setCoordinates(s1, s2)\n    this.computeOffsetSegment(this._seg1, side, this._distance, this._offset1)\n  }\n  addLimitedMitreJoin(offset0, offset1, distance, mitreLimit) {\n    const basePt = this._seg0.p1\n    const ang0 = Angle.angle(basePt, this._seg0.p0)\n    const angDiff = Angle.angleBetweenOriented(this._seg0.p0, basePt, this._seg1.p1)\n    const angDiffHalf = angDiff / 2\n    const midAng = Angle.normalize(ang0 + angDiffHalf)\n    const mitreMidAng = Angle.normalize(midAng + Math.PI)\n    const mitreDist = mitreLimit * distance\n    const bevelDelta = mitreDist * Math.abs(Math.sin(angDiffHalf))\n    const bevelHalfLen = distance - bevelDelta\n    const bevelMidX = basePt.x + mitreDist * Math.cos(mitreMidAng)\n    const bevelMidY = basePt.y + mitreDist * Math.sin(mitreMidAng)\n    const bevelMidPt = new Coordinate(bevelMidX, bevelMidY)\n    const mitreMidLine = new LineSegment(basePt, bevelMidPt)\n    const bevelEndLeft = mitreMidLine.pointAlongOffset(1.0, bevelHalfLen)\n    const bevelEndRight = mitreMidLine.pointAlongOffset(1.0, -bevelHalfLen)\n    if (this._side === Position.LEFT) {\n      this._segList.addPt(bevelEndLeft)\n      this._segList.addPt(bevelEndRight)\n    } else {\n      this._segList.addPt(bevelEndRight)\n      this._segList.addPt(bevelEndLeft)\n    }\n  }\n  addDirectedFillet(p, startAngle, endAngle, direction, radius) {\n    const directionFactor = direction === Orientation.CLOCKWISE ? -1 : 1\n    const totalAngle = Math.abs(startAngle - endAngle)\n    const nSegs = Math.trunc(totalAngle / this._filletAngleQuantum + 0.5)\n    if (nSegs < 1) return null\n    const angleInc = totalAngle / nSegs\n    const pt = new Coordinate()\n    for (let i = 0; i < nSegs; i++) {\n      const angle = startAngle + directionFactor * i * angleInc\n      pt.x = p.x + radius * Math.cos(angle)\n      pt.y = p.y + radius * Math.sin(angle)\n      this._segList.addPt(pt)\n    }\n  }\n  computeOffsetSegment(seg, side, distance, offset) {\n    const sideSign = side === Position.LEFT ? 1 : -1\n    const dx = seg.p1.x - seg.p0.x\n    const dy = seg.p1.y - seg.p0.y\n    const len = Math.sqrt(dx * dx + dy * dy)\n    const ux = sideSign * distance * dx / len\n    const uy = sideSign * distance * dy / len\n    offset.p0.x = seg.p0.x - uy\n    offset.p0.y = seg.p0.y + ux\n    offset.p1.x = seg.p1.x - uy\n    offset.p1.y = seg.p1.y + ux\n  }\n  addInsideTurn(orientation, addStartPoint) {\n    this._li.computeIntersection(this._offset0.p0, this._offset0.p1, this._offset1.p0, this._offset1.p1)\n    if (this._li.hasIntersection()) {\n      this._segList.addPt(this._li.getIntersection(0))\n    } else {\n      this._hasNarrowConcaveAngle = true\n      if (this._offset0.p1.distance(this._offset1.p0) < this._distance * OffsetSegmentGenerator.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR) {\n        this._segList.addPt(this._offset0.p1)\n      } else {\n        this._segList.addPt(this._offset0.p1)\n        if (this._closingSegLengthFactor > 0) {\n          const mid0 = new Coordinate((this._closingSegLengthFactor * this._offset0.p1.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset0.p1.y + this._s1.y) / (this._closingSegLengthFactor + 1))\n          this._segList.addPt(mid0)\n          const mid1 = new Coordinate((this._closingSegLengthFactor * this._offset1.p0.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset1.p0.y + this._s1.y) / (this._closingSegLengthFactor + 1))\n          this._segList.addPt(mid1)\n        } else {\n          this._segList.addPt(this._s1)\n        }\n        this._segList.addPt(this._offset1.p0)\n      }\n    }\n  }\n  createCircle(p) {\n    const pt = new Coordinate(p.x + this._distance, p.y)\n    this._segList.addPt(pt)\n    this.addDirectedFillet(p, 0.0, 2.0 * Math.PI, -1, this._distance)\n    this._segList.closeRing()\n  }\n  addBevelJoin(offset0, offset1) {\n    this._segList.addPt(offset0.p1)\n    this._segList.addPt(offset1.p0)\n  }\n  init(distance) {\n    this._distance = distance\n    this._maxCurveSegmentError = distance * (1 - Math.cos(this._filletAngleQuantum / 2.0))\n    this._segList = new OffsetSegmentString()\n    this._segList.setPrecisionModel(this._precisionModel)\n    this._segList.setMinimumVertexDistance(distance * OffsetSegmentGenerator.CURVE_VERTEX_SNAP_DISTANCE_FACTOR)\n  }\n  addCollinear(addStartPoint) {\n    this._li.computeIntersection(this._s0, this._s1, this._s1, this._s2)\n    const numInt = this._li.getIntersectionNum()\n    if (numInt >= 2) \n      if (this._bufParams.getJoinStyle() === BufferParameters.JOIN_BEVEL || this._bufParams.getJoinStyle() === BufferParameters.JOIN_MITRE) {\n        if (addStartPoint) this._segList.addPt(this._offset0.p1)\n        this._segList.addPt(this._offset1.p0)\n      } else {\n        this.addCornerFillet(this._s1, this._offset0.p1, this._offset1.p0, Orientation.CLOCKWISE, this._distance)\n      }\n    \n  }\n  closeRing() {\n    this._segList.closeRing()\n  }\n  hasNarrowConcaveAngle() {\n    return this._hasNarrowConcaveAngle\n  }\n}\nOffsetSegmentGenerator.OFFSET_SEGMENT_SEPARATION_FACTOR = 1.0E-3\nOffsetSegmentGenerator.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR = 1.0E-3\nOffsetSegmentGenerator.CURVE_VERTEX_SNAP_DISTANCE_FACTOR = 1.0E-6\nOffsetSegmentGenerator.MAX_CLOSING_SEG_LEN_FACTOR = 80\n","import BufferParameters from './BufferParameters'\nimport Position from '../../geomgraph/Position'\nimport Coordinate from '../../geom/Coordinate'\nimport BufferInputLineSimplifier from './BufferInputLineSimplifier'\nimport CoordinateArrays from '../../geom/CoordinateArrays'\nimport OffsetSegmentGenerator from './OffsetSegmentGenerator'\nexport default class OffsetCurveBuilder {\n  constructor() {\n    OffsetCurveBuilder.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._distance = 0.0\n    this._precisionModel = null\n    this._bufParams = null\n    const precisionModel = arguments[0], bufParams = arguments[1]\n    this._precisionModel = precisionModel\n    this._bufParams = bufParams\n  }\n  static copyCoordinates(pts) {\n    const copy = new Array(pts.length).fill(null)\n    for (let i = 0; i < copy.length; i++) \n      copy[i] = new Coordinate(pts[i])\n    \n    return copy\n  }\n  getOffsetCurve(inputPts, distance) {\n    this._distance = distance\n    if (distance === 0.0) return null\n    const isRightSide = distance < 0.0\n    const posDistance = Math.abs(distance)\n    const segGen = this.getSegGen(posDistance)\n    if (inputPts.length <= 1) \n      this.computePointCurve(inputPts[0], segGen)\n    else \n      this.computeOffsetCurve(inputPts, isRightSide, segGen)\n    \n    const curvePts = segGen.getCoordinates()\n    if (isRightSide) CoordinateArrays.reverse(curvePts)\n    return curvePts\n  }\n  computeSingleSidedBufferCurve(inputPts, isRightSide, segGen) {\n    const distTol = this.simplifyTolerance(this._distance)\n    if (isRightSide) {\n      segGen.addSegments(inputPts, true)\n      const simp2 = BufferInputLineSimplifier.simplify(inputPts, -distTol)\n      const n2 = simp2.length - 1\n      segGen.initSideSegments(simp2[n2], simp2[n2 - 1], Position.LEFT)\n      segGen.addFirstSegment()\n      for (let i = n2 - 2; i >= 0; i--) \n        segGen.addNextSegment(simp2[i], true)\n      \n    } else {\n      segGen.addSegments(inputPts, false)\n      const simp1 = BufferInputLineSimplifier.simplify(inputPts, distTol)\n      const n1 = simp1.length - 1\n      segGen.initSideSegments(simp1[0], simp1[1], Position.LEFT)\n      segGen.addFirstSegment()\n      for (let i = 2; i <= n1; i++) \n        segGen.addNextSegment(simp1[i], true)\n      \n    }\n    segGen.addLastSegment()\n    segGen.closeRing()\n  }\n  computeRingBufferCurve(inputPts, side, segGen) {\n    let distTol = this.simplifyTolerance(this._distance)\n    if (side === Position.RIGHT) distTol = -distTol\n    const simp = BufferInputLineSimplifier.simplify(inputPts, distTol)\n    const n = simp.length - 1\n    segGen.initSideSegments(simp[n - 1], simp[0], side)\n    for (let i = 1; i <= n; i++) {\n      const addStartPoint = i !== 1\n      segGen.addNextSegment(simp[i], addStartPoint)\n    }\n    segGen.closeRing()\n  }\n  computeLineBufferCurve(inputPts, segGen) {\n    const distTol = this.simplifyTolerance(this._distance)\n    const simp1 = BufferInputLineSimplifier.simplify(inputPts, distTol)\n    const n1 = simp1.length - 1\n    segGen.initSideSegments(simp1[0], simp1[1], Position.LEFT)\n    for (let i = 2; i <= n1; i++) \n      segGen.addNextSegment(simp1[i], true)\n    \n    segGen.addLastSegment()\n    segGen.addLineEndCap(simp1[n1 - 1], simp1[n1])\n    const simp2 = BufferInputLineSimplifier.simplify(inputPts, -distTol)\n    const n2 = simp2.length - 1\n    segGen.initSideSegments(simp2[n2], simp2[n2 - 1], Position.LEFT)\n    for (let i = n2 - 2; i >= 0; i--) \n      segGen.addNextSegment(simp2[i], true)\n    \n    segGen.addLastSegment()\n    segGen.addLineEndCap(simp2[1], simp2[0])\n    segGen.closeRing()\n  }\n  computePointCurve(pt, segGen) {\n    switch (this._bufParams.getEndCapStyle()) {\n    case BufferParameters.CAP_ROUND:\n      segGen.createCircle(pt)\n      break\n    case BufferParameters.CAP_SQUARE:\n      segGen.createSquare(pt)\n      break\n    }\n  }\n  getLineCurve(inputPts, distance) {\n    this._distance = distance\n    if (this.isLineOffsetEmpty(distance)) return null\n    const posDistance = Math.abs(distance)\n    const segGen = this.getSegGen(posDistance)\n    if (inputPts.length <= 1) {\n      this.computePointCurve(inputPts[0], segGen)\n    } else \n    if (this._bufParams.isSingleSided()) {\n      const isRightSide = distance < 0.0\n      this.computeSingleSidedBufferCurve(inputPts, isRightSide, segGen)\n    } else {\n      this.computeLineBufferCurve(inputPts, segGen)\n    }\n    \n    const lineCoord = segGen.getCoordinates()\n    return lineCoord\n  }\n  getBufferParameters() {\n    return this._bufParams\n  }\n  simplifyTolerance(bufDistance) {\n    return bufDistance * this._bufParams.getSimplifyFactor()\n  }\n  getRingCurve(inputPts, side, distance) {\n    this._distance = distance\n    if (inputPts.length <= 2) return this.getLineCurve(inputPts, distance)\n    if (distance === 0.0) \n      return OffsetCurveBuilder.copyCoordinates(inputPts)\n    \n    const segGen = this.getSegGen(distance)\n    this.computeRingBufferCurve(inputPts, side, segGen)\n    return segGen.getCoordinates()\n  }\n  computeOffsetCurve(inputPts, isRightSide, segGen) {\n    const distTol = this.simplifyTolerance(this._distance)\n    if (isRightSide) {\n      const simp2 = BufferInputLineSimplifier.simplify(inputPts, -distTol)\n      const n2 = simp2.length - 1\n      segGen.initSideSegments(simp2[n2], simp2[n2 - 1], Position.LEFT)\n      segGen.addFirstSegment()\n      for (let i = n2 - 2; i >= 0; i--) \n        segGen.addNextSegment(simp2[i], true)\n      \n    } else {\n      const simp1 = BufferInputLineSimplifier.simplify(inputPts, distTol)\n      const n1 = simp1.length - 1\n      segGen.initSideSegments(simp1[0], simp1[1], Position.LEFT)\n      segGen.addFirstSegment()\n      for (let i = 2; i <= n1; i++) \n        segGen.addNextSegment(simp1[i], true)\n      \n    }\n    segGen.addLastSegment()\n  }\n  isLineOffsetEmpty(distance) {\n    if (distance === 0.0) return true\n    if (distance < 0.0 && !this._bufParams.isSingleSided()) return true\n    return false\n  }\n  getSegGen(distance) {\n    return new OffsetSegmentGenerator(this._precisionModel, this._bufParams, distance)\n  }\n}\n","import hasInterface from '../../../../../hasInterface'\nimport Position from '../../geomgraph/Position'\nimport Coordinate from '../../geom/Coordinate'\nimport Orientation from '../../algorithm/Orientation'\nimport Collections from '../../../../../java/util/Collections'\nimport DirectedEdge from '../../geomgraph/DirectedEdge'\nimport LineSegment from '../../geom/LineSegment'\nimport Comparable from '../../../../../java/lang/Comparable'\nimport ArrayList from '../../../../../java/util/ArrayList'\nimport List from '../../../../../java/util/List'\nexport default class SubgraphDepthLocater {\n  constructor() {\n    SubgraphDepthLocater.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._subgraphs = null\n    this._seg = new LineSegment()\n    const subgraphs = arguments[0]\n    this._subgraphs = subgraphs\n  }\n  findStabbedSegments() {\n    if (arguments.length === 1) {\n      const stabbingRayLeftPt = arguments[0]\n      const stabbedSegments = new ArrayList()\n      for (let i = this._subgraphs.iterator(); i.hasNext(); ) {\n        const bsg = i.next()\n        const env = bsg.getEnvelope()\n        if (stabbingRayLeftPt.y < env.getMinY() || stabbingRayLeftPt.y > env.getMaxY()) continue\n        this.findStabbedSegments(stabbingRayLeftPt, bsg.getDirectedEdges(), stabbedSegments)\n      }\n      return stabbedSegments\n    } else if (arguments.length === 3) {\n      if (hasInterface(arguments[2], List) && (arguments[0] instanceof Coordinate && arguments[1] instanceof DirectedEdge)) {\n        const stabbingRayLeftPt = arguments[0], dirEdge = arguments[1], stabbedSegments = arguments[2]\n        const pts = dirEdge.getEdge().getCoordinates()\n        for (let i = 0; i < pts.length - 1; i++) {\n          this._seg.p0 = pts[i]\n          this._seg.p1 = pts[i + 1]\n          if (this._seg.p0.y > this._seg.p1.y) this._seg.reverse()\n          const maxx = Math.max(this._seg.p0.x, this._seg.p1.x)\n          if (maxx < stabbingRayLeftPt.x) continue\n          if (this._seg.isHorizontal()) continue\n          if (stabbingRayLeftPt.y < this._seg.p0.y || stabbingRayLeftPt.y > this._seg.p1.y) continue\n          if (Orientation.index(this._seg.p0, this._seg.p1, stabbingRayLeftPt) === Orientation.RIGHT) continue\n          let depth = dirEdge.getDepth(Position.LEFT)\n          if (!this._seg.p0.equals(pts[i])) depth = dirEdge.getDepth(Position.RIGHT)\n          const ds = new DepthSegment(this._seg, depth)\n          stabbedSegments.add(ds)\n        }\n      } else if (hasInterface(arguments[2], List) && (arguments[0] instanceof Coordinate && hasInterface(arguments[1], List))) {\n        const stabbingRayLeftPt = arguments[0], dirEdges = arguments[1], stabbedSegments = arguments[2]\n        for (let i = dirEdges.iterator(); i.hasNext(); ) {\n          const de = i.next()\n          if (!de.isForward()) continue\n          this.findStabbedSegments(stabbingRayLeftPt, de, stabbedSegments)\n        }\n      }\n    }\n  }\n  getDepth(p) {\n    const stabbedSegments = this.findStabbedSegments(p)\n    if (stabbedSegments.size() === 0) return 0\n    const ds = Collections.min(stabbedSegments)\n    return ds._leftDepth\n  }\n}\nclass DepthSegment {\n  constructor() {\n    DepthSegment.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._upwardSeg = null\n    this._leftDepth = null\n    const seg = arguments[0], depth = arguments[1]\n    this._upwardSeg = new LineSegment(seg)\n    this._leftDepth = depth\n  }\n  compareTo(obj) {\n    const other = obj\n    if (this._upwardSeg.minX() >= other._upwardSeg.maxX()) return 1\n    if (this._upwardSeg.maxX() <= other._upwardSeg.minX()) return -1\n    let orientIndex = this._upwardSeg.orientationIndex(other._upwardSeg)\n    if (orientIndex !== 0) return orientIndex\n    orientIndex = -1 * other._upwardSeg.orientationIndex(this._upwardSeg)\n    if (orientIndex !== 0) return orientIndex\n    return this._upwardSeg.compareTo(other._upwardSeg)\n  }\n  compareX(seg0, seg1) {\n    const compare0 = seg0.p0.compareTo(seg1.p0)\n    if (compare0 !== 0) return compare0\n    return seg0.p1.compareTo(seg1.p1)\n  }\n  toString() {\n    return this._upwardSeg.toString()\n  }\n  get interfaces_() {\n    return [Comparable]\n  }\n}\nSubgraphDepthLocater.DepthSegment = DepthSegment\n","import Exception from '../../../../java/lang/Exception'\nexport default class NotRepresentableException extends Exception {\n  constructor() {\n    super()\n    NotRepresentableException.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    Exception.constructor_.call(this, 'Projective point not representable on the Cartesian plane.')\n  }\n}\n","import NotRepresentableException from './NotRepresentableException'\nimport Coordinate from '../geom/Coordinate'\nimport Double from '../../../../java/lang/Double'\nexport default class HCoordinate {\n  constructor() {\n    HCoordinate.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this.x = null\n    this.y = null\n    this.w = null\n    if (arguments.length === 0) {\n      this.x = 0.0\n      this.y = 0.0\n      this.w = 1.0\n    } else if (arguments.length === 1) {\n      const p = arguments[0]\n      this.x = p.x\n      this.y = p.y\n      this.w = 1.0\n    } else if (arguments.length === 2) {\n      if (typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {\n        const _x = arguments[0], _y = arguments[1]\n        this.x = _x\n        this.y = _y\n        this.w = 1.0\n      } else if (arguments[0] instanceof HCoordinate && arguments[1] instanceof HCoordinate) {\n        const p1 = arguments[0], p2 = arguments[1]\n        this.x = p1.y * p2.w - p2.y * p1.w\n        this.y = p2.x * p1.w - p1.x * p2.w\n        this.w = p1.x * p2.y - p2.x * p1.y\n      } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {\n        const p1 = arguments[0], p2 = arguments[1]\n        this.x = p1.y - p2.y\n        this.y = p2.x - p1.x\n        this.w = p1.x * p2.y - p2.x * p1.y\n      }\n    } else if (arguments.length === 3) {\n      const _x = arguments[0], _y = arguments[1], _w = arguments[2]\n      this.x = _x\n      this.y = _y\n      this.w = _w\n    } else if (arguments.length === 4) {\n      const p1 = arguments[0], p2 = arguments[1], q1 = arguments[2], q2 = arguments[3]\n      const px = p1.y - p2.y\n      const py = p2.x - p1.x\n      const pw = p1.x * p2.y - p2.x * p1.y\n      const qx = q1.y - q2.y\n      const qy = q2.x - q1.x\n      const qw = q1.x * q2.y - q2.x * q1.y\n      this.x = py * qw - qy * pw\n      this.y = qx * pw - px * qw\n      this.w = px * qy - qx * py\n    }\n  }\n  getY() {\n    const a = this.y / this.w\n    if (Double.isNaN(a) || Double.isInfinite(a)) \n      throw new NotRepresentableException()\n    \n    return a\n  }\n  getX() {\n    const a = this.x / this.w\n    if (Double.isNaN(a) || Double.isInfinite(a)) \n      throw new NotRepresentableException()\n    \n    return a\n  }\n  getCoordinate() {\n    const p = new Coordinate()\n    p.x = this.getX()\n    p.y = this.getY()\n    return p\n  }\n}\n","import Coordinate from './Coordinate'\nimport IllegalArgumentException from '../../../../java/lang/IllegalArgumentException'\nimport DD from '../math/DD'\nimport Angle from '../algorithm/Angle'\nimport HCoordinate from '../algorithm/HCoordinate'\nexport default class Triangle {\n  constructor() {\n    Triangle.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this.p0 = null\n    this.p1 = null\n    this.p2 = null\n    const p0 = arguments[0], p1 = arguments[1], p2 = arguments[2]\n    this.p0 = p0\n    this.p1 = p1\n    this.p2 = p2\n  }\n  static area(a, b, c) {\n    return Math.abs(((c.x - a.x) * (b.y - a.y) - (b.x - a.x) * (c.y - a.y)) / 2)\n  }\n  static signedArea(a, b, c) {\n    return ((c.x - a.x) * (b.y - a.y) - (b.x - a.x) * (c.y - a.y)) / 2\n  }\n  static det(m00, m01, m10, m11) {\n    return m00 * m11 - m01 * m10\n  }\n  static interpolateZ(p, v0, v1, v2) {\n    const x0 = v0.x\n    const y0 = v0.y\n    const a = v1.x - x0\n    const b = v2.x - x0\n    const c = v1.y - y0\n    const d = v2.y - y0\n    const det = a * d - b * c\n    const dx = p.x - x0\n    const dy = p.y - y0\n    const t = (d * dx - b * dy) / det\n    const u = (-c * dx + a * dy) / det\n    const z = v0.getZ() + t * (v1.getZ() - v0.getZ()) + u * (v2.getZ() - v0.getZ())\n    return z\n  }\n  static longestSideLength(a, b, c) {\n    const lenAB = a.distance(b)\n    const lenBC = b.distance(c)\n    const lenCA = c.distance(a)\n    let maxLen = lenAB\n    if (lenBC > maxLen) maxLen = lenBC\n    if (lenCA > maxLen) maxLen = lenCA\n    return maxLen\n  }\n  static circumcentreDD(a, b, c) {\n    const ax = DD.valueOf(a.x).subtract(c.x)\n    const ay = DD.valueOf(a.y).subtract(c.y)\n    const bx = DD.valueOf(b.x).subtract(c.x)\n    const by = DD.valueOf(b.y).subtract(c.y)\n    const denom = DD.determinant(ax, ay, bx, by).multiply(2)\n    const asqr = ax.sqr().add(ay.sqr())\n    const bsqr = bx.sqr().add(by.sqr())\n    const numx = DD.determinant(ay, asqr, by, bsqr)\n    const numy = DD.determinant(ax, asqr, bx, bsqr)\n    const ccx = DD.valueOf(c.x).subtract(numx.divide(denom)).doubleValue()\n    const ccy = DD.valueOf(c.y).add(numy.divide(denom)).doubleValue()\n    return new Coordinate(ccx, ccy)\n  }\n  static isAcute(a, b, c) {\n    if (!Angle.isAcute(a, b, c)) return false\n    if (!Angle.isAcute(b, c, a)) return false\n    if (!Angle.isAcute(c, a, b)) return false\n    return true\n  }\n  static circumcentre(a, b, c) {\n    const cx = c.x\n    const cy = c.y\n    const ax = a.x - cx\n    const ay = a.y - cy\n    const bx = b.x - cx\n    const by = b.y - cy\n    const denom = 2 * Triangle.det(ax, ay, bx, by)\n    const numx = Triangle.det(ay, ax * ax + ay * ay, by, bx * bx + by * by)\n    const numy = Triangle.det(ax, ax * ax + ay * ay, bx, bx * bx + by * by)\n    const ccx = cx - numx / denom\n    const ccy = cy + numy / denom\n    return new Coordinate(ccx, ccy)\n  }\n  static perpendicularBisector(a, b) {\n    const dx = b.x - a.x\n    const dy = b.y - a.y\n    const l1 = new HCoordinate(a.x + dx / 2.0, a.y + dy / 2.0, 1.0)\n    const l2 = new HCoordinate(a.x - dy + dx / 2.0, a.y + dx + dy / 2.0, 1.0)\n    return new HCoordinate(l1, l2)\n  }\n  static angleBisector(a, b, c) {\n    const len0 = b.distance(a)\n    const len2 = b.distance(c)\n    const frac = len0 / (len0 + len2)\n    const dx = c.x - a.x\n    const dy = c.y - a.y\n    const splitPt = new Coordinate(a.x + frac * dx, a.y + frac * dy)\n    return splitPt\n  }\n  static area3D(a, b, c) {\n    const ux = b.x - a.x\n    const uy = b.y - a.y\n    const uz = b.getZ() - a.getZ()\n    const vx = c.x - a.x\n    const vy = c.y - a.y\n    const vz = c.getZ() - a.getZ()\n    const crossx = uy * vz - uz * vy\n    const crossy = uz * vx - ux * vz\n    const crossz = ux * vy - uy * vx\n    const absSq = crossx * crossx + crossy * crossy + crossz * crossz\n    const area3D = Math.sqrt(absSq) / 2\n    return area3D\n  }\n  static centroid(a, b, c) {\n    const x = (a.x + b.x + c.x) / 3\n    const y = (a.y + b.y + c.y) / 3\n    return new Coordinate(x, y)\n  }\n  static inCentre(a, b, c) {\n    const len0 = b.distance(c)\n    const len1 = a.distance(c)\n    const len2 = a.distance(b)\n    const circum = len0 + len1 + len2\n    const inCentreX = (len0 * a.x + len1 * b.x + len2 * c.x) / circum\n    const inCentreY = (len0 * a.y + len1 * b.y + len2 * c.y) / circum\n    return new Coordinate(inCentreX, inCentreY)\n  }\n  area() {\n    return Triangle.area(this.p0, this.p1, this.p2)\n  }\n  signedArea() {\n    return Triangle.signedArea(this.p0, this.p1, this.p2)\n  }\n  interpolateZ(p) {\n    if (p === null) throw new IllegalArgumentException('Supplied point is null.')\n    return Triangle.interpolateZ(p, this.p0, this.p1, this.p2)\n  }\n  longestSideLength() {\n    return Triangle.longestSideLength(this.p0, this.p1, this.p2)\n  }\n  isAcute() {\n    return Triangle.isAcute(this.p0, this.p1, this.p2)\n  }\n  circumcentre() {\n    return Triangle.circumcentre(this.p0, this.p1, this.p2)\n  }\n  area3D() {\n    return Triangle.area3D(this.p0, this.p1, this.p2)\n  }\n  centroid() {\n    return Triangle.centroid(this.p0, this.p1, this.p2)\n  }\n  inCentre() {\n    return Triangle.inCentre(this.p0, this.p1, this.p2)\n  }\n}\n","import Location from '../../geom/Location'\nimport LineString from '../../geom/LineString'\nimport Position from '../../geomgraph/Position'\nimport Point from '../../geom/Point'\nimport NodedSegmentString from '../../noding/NodedSegmentString'\nimport Polygon from '../../geom/Polygon'\nimport MultiPoint from '../../geom/MultiPoint'\nimport LinearRing from '../../geom/LinearRing'\nimport Orientation from '../../algorithm/Orientation'\nimport MultiPolygon from '../../geom/MultiPolygon'\nimport Label from '../../geomgraph/Label'\nimport GeometryCollection from '../../geom/GeometryCollection'\nimport UnsupportedOperationException from '../../../../../java/lang/UnsupportedOperationException'\nimport CoordinateArrays from '../../geom/CoordinateArrays'\nimport ArrayList from '../../../../../java/util/ArrayList'\nimport Distance from '../../algorithm/Distance'\nimport MultiLineString from '../../geom/MultiLineString'\nimport Triangle from '../../geom/Triangle'\nexport default class OffsetCurveSetBuilder {\n  constructor() {\n    OffsetCurveSetBuilder.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._inputGeom = null\n    this._distance = null\n    this._curveBuilder = null\n    this._curveList = new ArrayList()\n    const inputGeom = arguments[0], distance = arguments[1], curveBuilder = arguments[2]\n    this._inputGeom = inputGeom\n    this._distance = distance\n    this._curveBuilder = curveBuilder\n  }\n  addRingSide(coord, offsetDistance, side, cwLeftLoc, cwRightLoc) {\n    if (offsetDistance === 0.0 && coord.length < LinearRing.MINIMUM_VALID_SIZE) return null\n    let leftLoc = cwLeftLoc\n    let rightLoc = cwRightLoc\n    if (coord.length >= LinearRing.MINIMUM_VALID_SIZE && Orientation.isCCW(coord)) {\n      leftLoc = cwRightLoc\n      rightLoc = cwLeftLoc\n      side = Position.opposite(side)\n    }\n    const curve = this._curveBuilder.getRingCurve(coord, side, offsetDistance)\n    this.addCurve(curve, leftLoc, rightLoc)\n  }\n  addRingBothSides(coord, distance) {\n    this.addRingSide(coord, distance, Position.LEFT, Location.EXTERIOR, Location.INTERIOR)\n    this.addRingSide(coord, distance, Position.RIGHT, Location.INTERIOR, Location.EXTERIOR)\n  }\n  addPoint(p) {\n    if (this._distance <= 0.0) return null\n    const coord = p.getCoordinates()\n    const curve = this._curveBuilder.getLineCurve(coord, this._distance)\n    this.addCurve(curve, Location.EXTERIOR, Location.INTERIOR)\n  }\n  addPolygon(p) {\n    let offsetDistance = this._distance\n    let offsetSide = Position.LEFT\n    if (this._distance < 0.0) {\n      offsetDistance = -this._distance\n      offsetSide = Position.RIGHT\n    }\n    const shell = p.getExteriorRing()\n    const shellCoord = CoordinateArrays.removeRepeatedPoints(shell.getCoordinates())\n    if (this._distance < 0.0 && this.isErodedCompletely(shell, this._distance)) return null\n    if (this._distance <= 0.0 && shellCoord.length < 3) return null\n    this.addRingSide(shellCoord, offsetDistance, offsetSide, Location.EXTERIOR, Location.INTERIOR)\n    for (let i = 0; i < p.getNumInteriorRing(); i++) {\n      const hole = p.getInteriorRingN(i)\n      const holeCoord = CoordinateArrays.removeRepeatedPoints(hole.getCoordinates())\n      if (this._distance > 0.0 && this.isErodedCompletely(hole, -this._distance)) continue\n      this.addRingSide(holeCoord, offsetDistance, Position.opposite(offsetSide), Location.INTERIOR, Location.EXTERIOR)\n    }\n  }\n  isTriangleErodedCompletely(triangleCoord, bufferDistance) {\n    const tri = new Triangle(triangleCoord[0], triangleCoord[1], triangleCoord[2])\n    const inCentre = tri.inCentre()\n    const distToCentre = Distance.pointToSegment(inCentre, tri.p0, tri.p1)\n    return distToCentre < Math.abs(bufferDistance)\n  }\n  addLineString(line) {\n    if (this._curveBuilder.isLineOffsetEmpty(this._distance)) return null\n    const coord = CoordinateArrays.removeRepeatedPoints(line.getCoordinates())\n    if (CoordinateArrays.isRing(coord) && !this._curveBuilder.getBufferParameters().isSingleSided()) {\n      this.addRingBothSides(coord, this._distance)\n    } else {\n      const curve = this._curveBuilder.getLineCurve(coord, this._distance)\n      this.addCurve(curve, Location.EXTERIOR, Location.INTERIOR)\n    }\n  }\n  addCurve(coord, leftLoc, rightLoc) {\n    if (coord === null || coord.length < 2) return null\n    const e = new NodedSegmentString(coord, new Label(0, Location.BOUNDARY, leftLoc, rightLoc))\n    this._curveList.add(e)\n  }\n  getCurves() {\n    this.add(this._inputGeom)\n    return this._curveList\n  }\n  add(g) {\n    if (g.isEmpty()) return null\n    if (g instanceof Polygon) this.addPolygon(g); else if (g instanceof LineString) this.addLineString(g); else if (g instanceof Point) this.addPoint(g); else if (g instanceof MultiPoint) this.addCollection(g); else if (g instanceof MultiLineString) this.addCollection(g); else if (g instanceof MultiPolygon) this.addCollection(g); else if (g instanceof GeometryCollection) this.addCollection(g); else throw new UnsupportedOperationException(g.getGeometryType())\n  }\n  isErodedCompletely(ring, bufferDistance) {\n    const ringCoord = ring.getCoordinates()\n    if (ringCoord.length < 4) return bufferDistance < 0\n    if (ringCoord.length === 4) return this.isTriangleErodedCompletely(ringCoord, bufferDistance)\n    const env = ring.getEnvelopeInternal()\n    const envMinDimension = Math.min(env.getHeight(), env.getWidth())\n    if (bufferDistance < 0.0 && 2 * Math.abs(bufferDistance) > envMinDimension) return true\n    return false\n  }\n  addCollection(gc) {\n    for (let i = 0; i < gc.getNumGeometries(); i++) {\n      const g = gc.getGeometryN(i)\n      this.add(g)\n    }\n  }\n}\n","export default class PointOnGeometryLocator {\n  locate(p) {}\n}\n","import Iterator from '../../../../java/util/Iterator'\nimport NoSuchElementException from '../../../../java/util/NoSuchElementException'\nimport GeometryCollection from './GeometryCollection'\nimport UnsupportedOperationException from '../../../../java/lang/UnsupportedOperationException'\nexport default class GeometryCollectionIterator {\n  constructor() {\n    GeometryCollectionIterator.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._parent = null\n    this._atStart = null\n    this._max = null\n    this._index = null\n    this._subcollectionIterator = null\n    const parent = arguments[0]\n    this._parent = parent\n    this._atStart = true\n    this._index = 0\n    this._max = parent.getNumGeometries()\n  }\n  static isAtomic(geom) {\n    return !(geom instanceof GeometryCollection)\n  }\n  next() {\n    if (this._atStart) {\n      this._atStart = false\n      if (GeometryCollectionIterator.isAtomic(this._parent)) this._index++\n      return this._parent\n    }\n    if (this._subcollectionIterator !== null) \n      if (this._subcollectionIterator.hasNext()) \n        return this._subcollectionIterator.next()\n      else \n        this._subcollectionIterator = null\n      \n    \n    if (this._index >= this._max) \n      throw new NoSuchElementException()\n    \n    const obj = this._parent.getGeometryN(this._index++)\n    if (obj instanceof GeometryCollection) {\n      this._subcollectionIterator = new GeometryCollectionIterator(obj)\n      return this._subcollectionIterator.next()\n    }\n    return obj\n  }\n  remove() {\n    throw new UnsupportedOperationException(this.getClass().getName())\n  }\n  hasNext() {\n    if (this._atStart) \n      return true\n    \n    if (this._subcollectionIterator !== null) {\n      if (this._subcollectionIterator.hasNext()) \n        return true\n      \n      this._subcollectionIterator = null\n    }\n    if (this._index >= this._max) \n      return false\n    \n    return true\n  }\n  get interfaces_() {\n    return [Iterator]\n  }\n}\n","import Location from '../../geom/Location'\nimport Polygon from '../../geom/Polygon'\nimport PointLocation from '../PointLocation'\nimport PointOnGeometryLocator from './PointOnGeometryLocator'\nimport GeometryCollectionIterator from '../../geom/GeometryCollectionIterator'\nimport GeometryCollection from '../../geom/GeometryCollection'\nexport default class SimplePointInAreaLocator {\n  constructor() {\n    SimplePointInAreaLocator.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._geom = null\n    const geom = arguments[0]\n    this._geom = geom\n  }\n  static locatePointInPolygon(p, poly) {\n    if (poly.isEmpty()) return Location.EXTERIOR\n    const shell = poly.getExteriorRing()\n    const shellLoc = SimplePointInAreaLocator.locatePointInRing(p, shell)\n    if (shellLoc !== Location.INTERIOR) return shellLoc\n    for (let i = 0; i < poly.getNumInteriorRing(); i++) {\n      const hole = poly.getInteriorRingN(i)\n      const holeLoc = SimplePointInAreaLocator.locatePointInRing(p, hole)\n      if (holeLoc === Location.BOUNDARY) return Location.BOUNDARY\n      if (holeLoc === Location.INTERIOR) return Location.EXTERIOR\n    }\n    return Location.INTERIOR\n  }\n  static locatePointInRing(p, ring) {\n    if (!ring.getEnvelopeInternal().intersects(p)) return Location.EXTERIOR\n    return PointLocation.locateInRing(p, ring.getCoordinates())\n  }\n  static containsPointInPolygon(p, poly) {\n    return Location.EXTERIOR !== SimplePointInAreaLocator.locatePointInPolygon(p, poly)\n  }\n  static locateInGeometry(p, geom) {\n    if (geom instanceof Polygon) \n      return SimplePointInAreaLocator.locatePointInPolygon(p, geom)\n    \n    if (geom instanceof GeometryCollection) {\n      const geomi = new GeometryCollectionIterator(geom)\n      while (geomi.hasNext()) {\n        const g2 = geomi.next()\n        if (g2 !== geom) {\n          const loc = SimplePointInAreaLocator.locateInGeometry(p, g2)\n          if (loc !== Location.EXTERIOR) return loc\n        }\n      }\n    }\n    return Location.EXTERIOR\n  }\n  static isContained(p, geom) {\n    return Location.EXTERIOR !== SimplePointInAreaLocator.locate(p, geom)\n  }\n  static locate(p, geom) {\n    if (geom.isEmpty()) return Location.EXTERIOR\n    if (!geom.getEnvelopeInternal().intersects(p)) return Location.EXTERIOR\n    return SimplePointInAreaLocator.locateInGeometry(p, geom)\n  }\n  locate(p) {\n    return SimplePointInAreaLocator.locate(p, this._geom)\n  }\n  get interfaces_() {\n    return [PointOnGeometryLocator]\n  }\n}\n","import StringBuffer from '../../../../java/lang/StringBuffer'\nimport Location from '../geom/Location'\nimport Position from './Position'\nimport TopologyException from '../geom/TopologyException'\nimport System from '../../../../java/lang/System'\nimport SimplePointInAreaLocator from '../algorithm/locate/SimplePointInAreaLocator'\nimport ArrayList from '../../../../java/util/ArrayList'\nimport Assert from '../util/Assert'\nimport TreeMap from '../../../../java/util/TreeMap'\nexport default class EdgeEndStar {\n  constructor() {\n    EdgeEndStar.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._edgeMap = new TreeMap()\n    this._edgeList = null\n    this._ptInAreaLocation = [Location.NONE, Location.NONE]\n  }\n  getNextCW(ee) {\n    this.getEdges()\n    const i = this._edgeList.indexOf(ee)\n    let iNextCW = i - 1\n    if (i === 0) iNextCW = this._edgeList.size() - 1\n    return this._edgeList.get(iNextCW)\n  }\n  propagateSideLabels(geomIndex) {\n    let startLoc = Location.NONE\n    for (let it = this.iterator(); it.hasNext(); ) {\n      const e = it.next()\n      const label = e.getLabel()\n      if (label.isArea(geomIndex) && label.getLocation(geomIndex, Position.LEFT) !== Location.NONE) startLoc = label.getLocation(geomIndex, Position.LEFT)\n    }\n    if (startLoc === Location.NONE) return null\n    let currLoc = startLoc\n    for (let it = this.iterator(); it.hasNext(); ) {\n      const e = it.next()\n      const label = e.getLabel()\n      if (label.getLocation(geomIndex, Position.ON) === Location.NONE) label.setLocation(geomIndex, Position.ON, currLoc)\n      if (label.isArea(geomIndex)) {\n        const leftLoc = label.getLocation(geomIndex, Position.LEFT)\n        const rightLoc = label.getLocation(geomIndex, Position.RIGHT)\n        if (rightLoc !== Location.NONE) {\n          if (rightLoc !== currLoc) throw new TopologyException('side location conflict', e.getCoordinate())\n          if (leftLoc === Location.NONE) \n            Assert.shouldNeverReachHere('found single null side (at ' + e.getCoordinate() + ')')\n          \n          currLoc = leftLoc\n        } else {\n          Assert.isTrue(label.getLocation(geomIndex, Position.LEFT) === Location.NONE, 'found single null side')\n          label.setLocation(geomIndex, Position.RIGHT, currLoc)\n          label.setLocation(geomIndex, Position.LEFT, currLoc)\n        }\n      }\n    }\n  }\n  getCoordinate() {\n    const it = this.iterator()\n    if (!it.hasNext()) return null\n    const e = it.next()\n    return e.getCoordinate()\n  }\n  print(out) {\n    System.out.println('EdgeEndStar:   ' + this.getCoordinate())\n    for (let it = this.iterator(); it.hasNext(); ) {\n      const e = it.next()\n      e.print(out)\n    }\n  }\n  isAreaLabelsConsistent(geomGraph) {\n    this.computeEdgeEndLabels(geomGraph.getBoundaryNodeRule())\n    return this.checkAreaLabelsConsistent(0)\n  }\n  checkAreaLabelsConsistent(geomIndex) {\n    const edges = this.getEdges()\n    if (edges.size() <= 0) return true\n    const lastEdgeIndex = edges.size() - 1\n    const startLabel = edges.get(lastEdgeIndex).getLabel()\n    const startLoc = startLabel.getLocation(geomIndex, Position.LEFT)\n    Assert.isTrue(startLoc !== Location.NONE, 'Found unlabelled area edge')\n    let currLoc = startLoc\n    for (let it = this.iterator(); it.hasNext(); ) {\n      const e = it.next()\n      const label = e.getLabel()\n      Assert.isTrue(label.isArea(geomIndex), 'Found non-area edge')\n      const leftLoc = label.getLocation(geomIndex, Position.LEFT)\n      const rightLoc = label.getLocation(geomIndex, Position.RIGHT)\n      if (leftLoc === rightLoc) \n        return false\n      \n      if (rightLoc !== currLoc) \n        return false\n      \n      currLoc = leftLoc\n    }\n    return true\n  }\n  findIndex(eSearch) {\n    this.iterator()\n    for (let i = 0; i < this._edgeList.size(); i++) {\n      const e = this._edgeList.get(i)\n      if (e === eSearch) return i\n    }\n    return -1\n  }\n  iterator() {\n    return this.getEdges().iterator()\n  }\n  getEdges() {\n    if (this._edgeList === null) \n      this._edgeList = new ArrayList(this._edgeMap.values())\n    \n    return this._edgeList\n  }\n  getLocation(geomIndex, p, geom) {\n    if (this._ptInAreaLocation[geomIndex] === Location.NONE) \n      this._ptInAreaLocation[geomIndex] = SimplePointInAreaLocator.locate(p, geom[geomIndex].getGeometry())\n    \n    return this._ptInAreaLocation[geomIndex]\n  }\n  toString() {\n    const buf = new StringBuffer()\n    buf.append('EdgeEndStar:   ' + this.getCoordinate())\n    buf.append('\\n')\n    for (let it = this.iterator(); it.hasNext(); ) {\n      const e = it.next()\n      buf.append(e)\n      buf.append('\\n')\n    }\n    return buf.toString()\n  }\n  computeEdgeEndLabels(boundaryNodeRule) {\n    for (let it = this.iterator(); it.hasNext(); ) {\n      const ee = it.next()\n      ee.computeLabel(boundaryNodeRule)\n    }\n  }\n  computeLabelling(geomGraph) {\n    this.computeEdgeEndLabels(geomGraph[0].getBoundaryNodeRule())\n    this.propagateSideLabels(0)\n    this.propagateSideLabels(1)\n    const hasDimensionalCollapseEdge = [false, false]\n    for (let it = this.iterator(); it.hasNext(); ) {\n      const e = it.next()\n      const label = e.getLabel()\n      for (let geomi = 0; geomi < 2; geomi++) \n        if (label.isLine(geomi) && label.getLocation(geomi) === Location.BOUNDARY) hasDimensionalCollapseEdge[geomi] = true\n      \n    }\n    for (let it = this.iterator(); it.hasNext(); ) {\n      const e = it.next()\n      const label = e.getLabel()\n      for (let geomi = 0; geomi < 2; geomi++) \n        if (label.isAnyNull(geomi)) {\n          let loc = Location.NONE\n          if (hasDimensionalCollapseEdge[geomi]) {\n            loc = Location.EXTERIOR\n          } else {\n            const p = e.getCoordinate()\n            loc = this.getLocation(geomi, p, geomGraph)\n          }\n          label.setAllLocationsIfNull(geomi, loc)\n        }\n      \n    }\n  }\n  getDegree() {\n    return this._edgeMap.size()\n  }\n  insertEdgeEnd(e, obj) {\n    this._edgeMap.put(e, obj)\n    this._edgeList = null\n  }\n}\n","import Location from '../geom/Location'\nimport Position from './Position'\nimport TopologyException from '../geom/TopologyException'\nimport EdgeEndStar from './EdgeEndStar'\nimport System from '../../../../java/lang/System'\nimport Label from './Label'\nimport ArrayList from '../../../../java/util/ArrayList'\nimport Quadrant from './Quadrant'\nimport Assert from '../util/Assert'\nexport default class DirectedEdgeStar extends EdgeEndStar {\n  constructor() {\n    super()\n    DirectedEdgeStar.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._resultAreaEdgeList = null\n    this._label = null\n    this._SCANNING_FOR_INCOMING = 1\n    this._LINKING_TO_OUTGOING = 2\n  }\n  linkResultDirectedEdges() {\n    this.getResultAreaEdges()\n    let firstOut = null\n    let incoming = null\n    let state = this._SCANNING_FOR_INCOMING\n    for (let i = 0; i < this._resultAreaEdgeList.size(); i++) {\n      const nextOut = this._resultAreaEdgeList.get(i)\n      const nextIn = nextOut.getSym()\n      if (!nextOut.getLabel().isArea()) continue\n      if (firstOut === null && nextOut.isInResult()) firstOut = nextOut\n      switch (state) {\n      case this._SCANNING_FOR_INCOMING:\n        if (!nextIn.isInResult()) continue\n        incoming = nextIn\n        state = this._LINKING_TO_OUTGOING\n        break\n      case this._LINKING_TO_OUTGOING:\n        if (!nextOut.isInResult()) continue\n        incoming.setNext(nextOut)\n        state = this._SCANNING_FOR_INCOMING\n        break\n      }\n    }\n    if (state === this._LINKING_TO_OUTGOING) {\n      if (firstOut === null) throw new TopologyException('no outgoing dirEdge found', this.getCoordinate())\n      Assert.isTrue(firstOut.isInResult(), 'unable to link last incoming dirEdge')\n      incoming.setNext(firstOut)\n    }\n  }\n  insert(ee) {\n    const de = ee\n    this.insertEdgeEnd(de, de)\n  }\n  getRightmostEdge() {\n    const edges = this.getEdges()\n    const size = edges.size()\n    if (size < 1) return null\n    const de0 = edges.get(0)\n    if (size === 1) return de0\n    const deLast = edges.get(size - 1)\n    const quad0 = de0.getQuadrant()\n    const quad1 = deLast.getQuadrant()\n    if (Quadrant.isNorthern(quad0) && Quadrant.isNorthern(quad1)) {\n      return de0\n    } else if (!Quadrant.isNorthern(quad0) && !Quadrant.isNorthern(quad1)) {\n      return deLast\n    } else {\n      const nonHorizontalEdge = null\n      if (de0.getDy() !== 0) return de0; else if (deLast.getDy() !== 0) return deLast\n    }\n    Assert.shouldNeverReachHere('found two horizontal edges incident on node')\n    return null\n  }\n  print(out) {\n    System.out.println('DirectedEdgeStar: ' + this.getCoordinate())\n    for (let it = this.iterator(); it.hasNext(); ) {\n      const de = it.next()\n      out.print('out ')\n      de.print(out)\n      out.println()\n      out.print('in ')\n      de.getSym().print(out)\n      out.println()\n    }\n  }\n  getResultAreaEdges() {\n    if (this._resultAreaEdgeList !== null) return this._resultAreaEdgeList\n    this._resultAreaEdgeList = new ArrayList()\n    for (let it = this.iterator(); it.hasNext(); ) {\n      const de = it.next()\n      if (de.isInResult() || de.getSym().isInResult()) this._resultAreaEdgeList.add(de)\n    }\n    return this._resultAreaEdgeList\n  }\n  updateLabelling(nodeLabel) {\n    for (let it = this.iterator(); it.hasNext(); ) {\n      const de = it.next()\n      const label = de.getLabel()\n      label.setAllLocationsIfNull(0, nodeLabel.getLocation(0))\n      label.setAllLocationsIfNull(1, nodeLabel.getLocation(1))\n    }\n  }\n  linkAllDirectedEdges() {\n    this.getEdges()\n    let prevOut = null\n    let firstIn = null\n    for (let i = this._edgeList.size() - 1; i >= 0; i--) {\n      const nextOut = this._edgeList.get(i)\n      const nextIn = nextOut.getSym()\n      if (firstIn === null) firstIn = nextIn\n      if (prevOut !== null) nextIn.setNext(prevOut)\n      prevOut = nextOut\n    }\n    firstIn.setNext(prevOut)\n  }\n  computeDepths() {\n    if (arguments.length === 1) {\n      const de = arguments[0]\n      const edgeIndex = this.findIndex(de)\n      const startDepth = de.getDepth(Position.LEFT)\n      const targetLastDepth = de.getDepth(Position.RIGHT)\n      const nextDepth = this.computeDepths(edgeIndex + 1, this._edgeList.size(), startDepth)\n      const lastDepth = this.computeDepths(0, edgeIndex, nextDepth)\n      if (lastDepth !== targetLastDepth) throw new TopologyException('depth mismatch at ' + de.getCoordinate())\n    } else if (arguments.length === 3) {\n      const startIndex = arguments[0], endIndex = arguments[1], startDepth = arguments[2]\n      let currDepth = startDepth\n      for (let i = startIndex; i < endIndex; i++) {\n        const nextDe = this._edgeList.get(i)\n        nextDe.setEdgeDepths(Position.RIGHT, currDepth)\n        currDepth = nextDe.getDepth(Position.LEFT)\n      }\n      return currDepth\n    }\n  }\n  mergeSymLabels() {\n    for (let it = this.iterator(); it.hasNext(); ) {\n      const de = it.next()\n      const label = de.getLabel()\n      label.merge(de.getSym().getLabel())\n    }\n  }\n  linkMinimalDirectedEdges(er) {\n    let firstOut = null\n    let incoming = null\n    let state = this._SCANNING_FOR_INCOMING\n    for (let i = this._resultAreaEdgeList.size() - 1; i >= 0; i--) {\n      const nextOut = this._resultAreaEdgeList.get(i)\n      const nextIn = nextOut.getSym()\n      if (firstOut === null && nextOut.getEdgeRing() === er) firstOut = nextOut\n      switch (state) {\n      case this._SCANNING_FOR_INCOMING:\n        if (nextIn.getEdgeRing() !== er) continue\n        incoming = nextIn\n        state = this._LINKING_TO_OUTGOING\n        break\n      case this._LINKING_TO_OUTGOING:\n        if (nextOut.getEdgeRing() !== er) continue\n        incoming.setNextMin(nextOut)\n        state = this._SCANNING_FOR_INCOMING\n        break\n      }\n    }\n    if (state === this._LINKING_TO_OUTGOING) {\n      Assert.isTrue(firstOut !== null, 'found null for first outgoing dirEdge')\n      Assert.isTrue(firstOut.getEdgeRing() === er, 'unable to link last incoming dirEdge')\n      incoming.setNextMin(firstOut)\n    }\n  }\n  getOutgoingDegree() {\n    if (arguments.length === 0) {\n      let degree = 0\n      for (let it = this.iterator(); it.hasNext(); ) {\n        const de = it.next()\n        if (de.isInResult()) degree++\n      }\n      return degree\n    } else if (arguments.length === 1) {\n      const er = arguments[0]\n      let degree = 0\n      for (let it = this.iterator(); it.hasNext(); ) {\n        const de = it.next()\n        if (de.getEdgeRing() === er) degree++\n      }\n      return degree\n    }\n  }\n  getLabel() {\n    return this._label\n  }\n  findCoveredLineEdges() {\n    let startLoc = Location.NONE\n    for (let it = this.iterator(); it.hasNext(); ) {\n      const nextOut = it.next()\n      const nextIn = nextOut.getSym()\n      if (!nextOut.isLineEdge()) {\n        if (nextOut.isInResult()) {\n          startLoc = Location.INTERIOR\n          break\n        }\n        if (nextIn.isInResult()) {\n          startLoc = Location.EXTERIOR\n          break\n        }\n      }\n    }\n    if (startLoc === Location.NONE) return null\n    let currLoc = startLoc\n    for (let it = this.iterator(); it.hasNext(); ) {\n      const nextOut = it.next()\n      const nextIn = nextOut.getSym()\n      if (nextOut.isLineEdge()) {\n        nextOut.getEdge().setCovered(currLoc === Location.INTERIOR)\n      } else {\n        if (nextOut.isInResult()) currLoc = Location.EXTERIOR\n        if (nextIn.isInResult()) currLoc = Location.INTERIOR\n      }\n    }\n  }\n  computeLabelling(geom) {\n    super.computeLabelling.call(this, geom)\n    this._label = new Label(Location.NONE)\n    for (let it = this.iterator(); it.hasNext(); ) {\n      const ee = it.next()\n      const e = ee.getEdge()\n      const eLabel = e.getLabel()\n      for (let i = 0; i < 2; i++) {\n        const eLoc = eLabel.getLocation(i)\n        if (eLoc === Location.INTERIOR || eLoc === Location.BOUNDARY) this._label.setLocation(i, Location.INTERIOR)\n      }\n    }\n  }\n}\n","import DirectedEdgeStar from '../../geomgraph/DirectedEdgeStar'\nimport Node from '../../geomgraph/Node'\nimport NodeFactory from '../../geomgraph/NodeFactory'\nexport default class OverlayNodeFactory extends NodeFactory {\n  constructor() {\n    super()\n  }\n  createNode(coord) {\n    return new Node(coord, new DirectedEdgeStar())\n  }\n}\n","import Comparable from '../../../../java/lang/Comparable'\nimport CoordinateArrays from '../geom/CoordinateArrays'\nexport default class OrientedCoordinateArray {\n  constructor() {\n    OrientedCoordinateArray.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._pts = null\n    this._orientation = null\n    const pts = arguments[0]\n    this._pts = pts\n    this._orientation = OrientedCoordinateArray.orientation(pts)\n  }\n  static orientation(pts) {\n    return CoordinateArrays.increasingDirection(pts) === 1\n  }\n  static compareOriented(pts1, orientation1, pts2, orientation2) {\n    const dir1 = orientation1 ? 1 : -1\n    const dir2 = orientation2 ? 1 : -1\n    const limit1 = orientation1 ? pts1.length : -1\n    const limit2 = orientation2 ? pts2.length : -1\n    let i1 = orientation1 ? 0 : pts1.length - 1\n    let i2 = orientation2 ? 0 : pts2.length - 1\n    while (true) {\n      const compPt = pts1[i1].compareTo(pts2[i2])\n      if (compPt !== 0) return compPt\n      i1 += dir1\n      i2 += dir2\n      const done1 = i1 === limit1\n      const done2 = i2 === limit2\n      if (done1 && !done2) return -1\n      if (!done1 && done2) return 1\n      if (done1 && done2) return 0\n    }\n  }\n  compareTo(o1) {\n    const oca = o1\n    const comp = OrientedCoordinateArray.compareOriented(this._pts, this._orientation, oca._pts, oca._orientation)\n    return comp\n  }\n  get interfaces_() {\n    return [Comparable]\n  }\n}\n","import OrientedCoordinateArray from '../noding/OrientedCoordinateArray'\nimport ArrayList from '../../../../java/util/ArrayList'\nimport TreeMap from '../../../../java/util/TreeMap'\nexport default class EdgeList {\n  constructor() {\n    EdgeList.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._edges = new ArrayList()\n    this._ocaMap = new TreeMap()\n  }\n  print(out) {\n    out.print('MULTILINESTRING ( ')\n    for (let j = 0; j < this._edges.size(); j++) {\n      const e = this._edges.get(j)\n      if (j > 0) out.print(',')\n      out.print('(')\n      const pts = e.getCoordinates()\n      for (let i = 0; i < pts.length; i++) {\n        if (i > 0) out.print(',')\n        out.print(pts[i].x + ' ' + pts[i].y)\n      }\n      out.println(')')\n    }\n    out.print(')  ')\n  }\n  addAll(edgeColl) {\n    for (let i = edgeColl.iterator(); i.hasNext(); ) \n      this.add(i.next())\n    \n  }\n  findEdgeIndex(e) {\n    for (let i = 0; i < this._edges.size(); i++) \n      if (this._edges.get(i).equals(e)) return i\n    \n    return -1\n  }\n  iterator() {\n    return this._edges.iterator()\n  }\n  getEdges() {\n    return this._edges\n  }\n  get(i) {\n    return this._edges.get(i)\n  }\n  findEqualEdge(e) {\n    const oca = new OrientedCoordinateArray(e.getCoordinates())\n    const matchEdge = this._ocaMap.get(oca)\n    return matchEdge\n  }\n  add(e) {\n    this._edges.add(e)\n    const oca = new OrientedCoordinateArray(e.getCoordinates())\n    this._ocaMap.put(oca, e)\n  }\n}\n","export default class SegmentIntersector {\n  processIntersections(e0, segIndex0, e1, segIndex1) {}\n  isDone() {}\n}\n","import SegmentIntersector from './SegmentIntersector'\nexport default class IntersectionAdder {\n  constructor() {\n    IntersectionAdder.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._hasIntersection = false\n    this._hasProper = false\n    this._hasProperInterior = false\n    this._hasInterior = false\n    this._properIntersectionPoint = null\n    this._li = null\n    this._isSelfIntersection = null\n    this.numIntersections = 0\n    this.numInteriorIntersections = 0\n    this.numProperIntersections = 0\n    this.numTests = 0\n    const li = arguments[0]\n    this._li = li\n  }\n  static isAdjacentSegments(i1, i2) {\n    return Math.abs(i1 - i2) === 1\n  }\n  isTrivialIntersection(e0, segIndex0, e1, segIndex1) {\n    if (e0 === e1) \n      if (this._li.getIntersectionNum() === 1) {\n        if (IntersectionAdder.isAdjacentSegments(segIndex0, segIndex1)) return true\n        if (e0.isClosed()) {\n          const maxSegIndex = e0.size() - 1\n          if (segIndex0 === 0 && segIndex1 === maxSegIndex || segIndex1 === 0 && segIndex0 === maxSegIndex) \n            return true\n          \n        }\n      }\n    \n    return false\n  }\n  getProperIntersectionPoint() {\n    return this._properIntersectionPoint\n  }\n  hasProperInteriorIntersection() {\n    return this._hasProperInterior\n  }\n  getLineIntersector() {\n    return this._li\n  }\n  hasProperIntersection() {\n    return this._hasProper\n  }\n  processIntersections(e0, segIndex0, e1, segIndex1) {\n    if (e0 === e1 && segIndex0 === segIndex1) return null\n    this.numTests++\n    const p00 = e0.getCoordinates()[segIndex0]\n    const p01 = e0.getCoordinates()[segIndex0 + 1]\n    const p10 = e1.getCoordinates()[segIndex1]\n    const p11 = e1.getCoordinates()[segIndex1 + 1]\n    this._li.computeIntersection(p00, p01, p10, p11)\n    if (this._li.hasIntersection()) {\n      this.numIntersections++\n      if (this._li.isInteriorIntersection()) {\n        this.numInteriorIntersections++\n        this._hasInterior = true\n      }\n      if (!this.isTrivialIntersection(e0, segIndex0, e1, segIndex1)) {\n        this._hasIntersection = true\n        e0.addIntersections(this._li, segIndex0, 0)\n        e1.addIntersections(this._li, segIndex1, 1)\n        if (this._li.isProper()) {\n          this.numProperIntersections++\n          this._hasProper = true\n          this._hasProperInterior = true\n        }\n      }\n    }\n  }\n  hasIntersection() {\n    return this._hasIntersection\n  }\n  isDone() {\n    return false\n  }\n  hasInteriorIntersection() {\n    return this._hasInterior\n  }\n  get interfaces_() {\n    return [SegmentIntersector]\n  }\n}\n","import Coordinate from '../geom/Coordinate'\nimport Comparable from '../../../../java/lang/Comparable'\nexport default class EdgeIntersection {\n  constructor() {\n    EdgeIntersection.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this.coord = null\n    this.segmentIndex = null\n    this.dist = null\n    const coord = arguments[0], segmentIndex = arguments[1], dist = arguments[2]\n    this.coord = new Coordinate(coord)\n    this.segmentIndex = segmentIndex\n    this.dist = dist\n  }\n  getSegmentIndex() {\n    return this.segmentIndex\n  }\n  getCoordinate() {\n    return this.coord\n  }\n  print(out) {\n    out.print(this.coord)\n    out.print(' seg # = ' + this.segmentIndex)\n    out.println(' dist = ' + this.dist)\n  }\n  compareTo(obj) {\n    const other = obj\n    return this.compare(other.segmentIndex, other.dist)\n  }\n  isEndPoint(maxSegmentIndex) {\n    if (this.segmentIndex === 0 && this.dist === 0.0) return true\n    if (this.segmentIndex === maxSegmentIndex) return true\n    return false\n  }\n  toString() {\n    return this.coord + ' seg # = ' + this.segmentIndex + ' dist = ' + this.dist\n  }\n  getDistance() {\n    return this.dist\n  }\n  compare(segmentIndex, dist) {\n    if (this.segmentIndex < segmentIndex) return -1\n    if (this.segmentIndex > segmentIndex) return 1\n    if (this.dist < dist) return -1\n    if (this.dist > dist) return 1\n    return 0\n  }\n  get interfaces_() {\n    return [Comparable]\n  }\n}\n","import EdgeIntersection from './EdgeIntersection'\nimport Coordinate from '../geom/Coordinate'\nimport Label from './Label'\nimport Edge from './Edge'\nimport TreeMap from '../../../../java/util/TreeMap'\nexport default class EdgeIntersectionList {\n  constructor() {\n    EdgeIntersectionList.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._nodeMap = new TreeMap()\n    this.edge = null\n    const edge = arguments[0]\n    this.edge = edge\n  }\n  print(out) {\n    out.println('Intersections:')\n    for (let it = this.iterator(); it.hasNext(); ) {\n      const ei = it.next()\n      ei.print(out)\n    }\n  }\n  iterator() {\n    return this._nodeMap.values().iterator()\n  }\n  addSplitEdges(edgeList) {\n    this.addEndpoints()\n    const it = this.iterator()\n    let eiPrev = it.next()\n    while (it.hasNext()) {\n      const ei = it.next()\n      const newEdge = this.createSplitEdge(eiPrev, ei)\n      edgeList.add(newEdge)\n      eiPrev = ei\n    }\n  }\n  addEndpoints() {\n    const maxSegIndex = this.edge.pts.length - 1\n    this.add(this.edge.pts[0], 0, 0.0)\n    this.add(this.edge.pts[maxSegIndex], maxSegIndex, 0.0)\n  }\n  createSplitEdge(ei0, ei1) {\n    let npts = ei1.segmentIndex - ei0.segmentIndex + 2\n    const lastSegStartPt = this.edge.pts[ei1.segmentIndex]\n    const useIntPt1 = ei1.dist > 0.0 || !ei1.coord.equals2D(lastSegStartPt)\n    if (!useIntPt1) \n      npts--\n    \n    const pts = new Array(npts).fill(null)\n    let ipt = 0\n    pts[ipt++] = new Coordinate(ei0.coord)\n    for (let i = ei0.segmentIndex + 1; i <= ei1.segmentIndex; i++) \n      pts[ipt++] = this.edge.pts[i]\n    \n    if (useIntPt1) pts[ipt] = ei1.coord\n    return new Edge(pts, new Label(this.edge._label))\n  }\n  add(intPt, segmentIndex, dist) {\n    const eiNew = new EdgeIntersection(intPt, segmentIndex, dist)\n    const ei = this._nodeMap.get(eiNew)\n    if (ei !== null) \n      return ei\n    \n    this._nodeMap.put(eiNew, eiNew)\n    return eiNew\n  }\n  isIntersection(pt) {\n    for (let it = this.iterator(); it.hasNext(); ) {\n      const ei = it.next()\n      if (ei.coord.equals(pt)) return true\n    }\n    return false\n  }\n}\n","import Location from './Location'\nimport IllegalArgumentException from '../../../../java/lang/IllegalArgumentException'\nimport Dimension from './Dimension'\nimport Cloneable from '../../../../java/lang/Cloneable'\nimport StringBuilder from '../../../../java/lang/StringBuilder'\nexport default class IntersectionMatrix {\n  constructor() {\n    IntersectionMatrix.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._matrix = null\n    if (arguments.length === 0) {\n      this._matrix = Array(3).fill().map(() => Array(3))\n      this.setAll(Dimension.FALSE)\n    } else if (arguments.length === 1) {\n      if (typeof arguments[0] === 'string') {\n        const elements = arguments[0]\n        IntersectionMatrix.constructor_.call(this)\n        this.set(elements)\n      } else if (arguments[0] instanceof IntersectionMatrix) {\n        const other = arguments[0]\n        IntersectionMatrix.constructor_.call(this)\n        this._matrix[Location.INTERIOR][Location.INTERIOR] = other._matrix[Location.INTERIOR][Location.INTERIOR]\n        this._matrix[Location.INTERIOR][Location.BOUNDARY] = other._matrix[Location.INTERIOR][Location.BOUNDARY]\n        this._matrix[Location.INTERIOR][Location.EXTERIOR] = other._matrix[Location.INTERIOR][Location.EXTERIOR]\n        this._matrix[Location.BOUNDARY][Location.INTERIOR] = other._matrix[Location.BOUNDARY][Location.INTERIOR]\n        this._matrix[Location.BOUNDARY][Location.BOUNDARY] = other._matrix[Location.BOUNDARY][Location.BOUNDARY]\n        this._matrix[Location.BOUNDARY][Location.EXTERIOR] = other._matrix[Location.BOUNDARY][Location.EXTERIOR]\n        this._matrix[Location.EXTERIOR][Location.INTERIOR] = other._matrix[Location.EXTERIOR][Location.INTERIOR]\n        this._matrix[Location.EXTERIOR][Location.BOUNDARY] = other._matrix[Location.EXTERIOR][Location.BOUNDARY]\n        this._matrix[Location.EXTERIOR][Location.EXTERIOR] = other._matrix[Location.EXTERIOR][Location.EXTERIOR]\n      }\n    }\n  }\n  static matches() {\n    if (Number.isInteger(arguments[0]) && typeof arguments[1] === 'string') {\n      const actualDimensionValue = arguments[0], requiredDimensionSymbol = arguments[1]\n      if (requiredDimensionSymbol === Dimension.SYM_DONTCARE) \n        return true\n      \n      if (requiredDimensionSymbol === Dimension.SYM_TRUE && (actualDimensionValue >= 0 || actualDimensionValue === Dimension.TRUE)) \n        return true\n      \n      if (requiredDimensionSymbol === Dimension.SYM_FALSE && actualDimensionValue === Dimension.FALSE) \n        return true\n      \n      if (requiredDimensionSymbol === Dimension.SYM_P && actualDimensionValue === Dimension.P) \n        return true\n      \n      if (requiredDimensionSymbol === Dimension.SYM_L && actualDimensionValue === Dimension.L) \n        return true\n      \n      if (requiredDimensionSymbol === Dimension.SYM_A && actualDimensionValue === Dimension.A) \n        return true\n      \n      return false\n    } else if (typeof arguments[0] === 'string' && typeof arguments[1] === 'string') {\n      const actualDimensionSymbols = arguments[0], requiredDimensionSymbols = arguments[1]\n      const m = new IntersectionMatrix(actualDimensionSymbols)\n      return m.matches(requiredDimensionSymbols)\n    }\n  }\n  static isTrue(actualDimensionValue) {\n    if (actualDimensionValue >= 0 || actualDimensionValue === Dimension.TRUE) \n      return true\n    \n    return false\n  }\n  isIntersects() {\n    return !this.isDisjoint()\n  }\n  isCovers() {\n    const hasPointInCommon = IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.BOUNDARY]) || IntersectionMatrix.isTrue(this._matrix[Location.BOUNDARY][Location.INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[Location.BOUNDARY][Location.BOUNDARY])\n    return hasPointInCommon && this._matrix[Location.EXTERIOR][Location.INTERIOR] === Dimension.FALSE && this._matrix[Location.EXTERIOR][Location.BOUNDARY] === Dimension.FALSE\n  }\n  isCoveredBy() {\n    const hasPointInCommon = IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.BOUNDARY]) || IntersectionMatrix.isTrue(this._matrix[Location.BOUNDARY][Location.INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[Location.BOUNDARY][Location.BOUNDARY])\n    return hasPointInCommon && this._matrix[Location.INTERIOR][Location.EXTERIOR] === Dimension.FALSE && this._matrix[Location.BOUNDARY][Location.EXTERIOR] === Dimension.FALSE\n  }\n  set() {\n    if (arguments.length === 1) {\n      const dimensionSymbols = arguments[0]\n      for (let i = 0; i < dimensionSymbols.length; i++) {\n        const row = Math.trunc(i / 3)\n        const col = i % 3\n        this._matrix[row][col] = Dimension.toDimensionValue(dimensionSymbols.charAt(i))\n      }\n    } else if (arguments.length === 3) {\n      const row = arguments[0], column = arguments[1], dimensionValue = arguments[2]\n      this._matrix[row][column] = dimensionValue\n    }\n  }\n  isContains() {\n    return IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) && this._matrix[Location.EXTERIOR][Location.INTERIOR] === Dimension.FALSE && this._matrix[Location.EXTERIOR][Location.BOUNDARY] === Dimension.FALSE\n  }\n  setAtLeast() {\n    if (arguments.length === 1) {\n      const minimumDimensionSymbols = arguments[0]\n      for (let i = 0; i < minimumDimensionSymbols.length; i++) {\n        const row = Math.trunc(i / 3)\n        const col = i % 3\n        this.setAtLeast(row, col, Dimension.toDimensionValue(minimumDimensionSymbols.charAt(i)))\n      }\n    } else if (arguments.length === 3) {\n      const row = arguments[0], column = arguments[1], minimumDimensionValue = arguments[2]\n      if (this._matrix[row][column] < minimumDimensionValue) \n        this._matrix[row][column] = minimumDimensionValue\n      \n    }\n  }\n  setAtLeastIfValid(row, column, minimumDimensionValue) {\n    if (row >= 0 && column >= 0) \n      this.setAtLeast(row, column, minimumDimensionValue)\n    \n  }\n  isWithin() {\n    return IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) && this._matrix[Location.INTERIOR][Location.EXTERIOR] === Dimension.FALSE && this._matrix[Location.BOUNDARY][Location.EXTERIOR] === Dimension.FALSE\n  }\n  isTouches(dimensionOfGeometryA, dimensionOfGeometryB) {\n    if (dimensionOfGeometryA > dimensionOfGeometryB) \n      return this.isTouches(dimensionOfGeometryB, dimensionOfGeometryA)\n    \n    if (dimensionOfGeometryA === Dimension.A && dimensionOfGeometryB === Dimension.A || dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.L || dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.A || dimensionOfGeometryA === Dimension.P && dimensionOfGeometryB === Dimension.A || dimensionOfGeometryA === Dimension.P && dimensionOfGeometryB === Dimension.L) \n      return this._matrix[Location.INTERIOR][Location.INTERIOR] === Dimension.FALSE && (IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.BOUNDARY]) || IntersectionMatrix.isTrue(this._matrix[Location.BOUNDARY][Location.INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[Location.BOUNDARY][Location.BOUNDARY]))\n    \n    return false\n  }\n  isOverlaps(dimensionOfGeometryA, dimensionOfGeometryB) {\n    if (dimensionOfGeometryA === Dimension.P && dimensionOfGeometryB === Dimension.P || dimensionOfGeometryA === Dimension.A && dimensionOfGeometryB === Dimension.A) \n      return IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) && IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.EXTERIOR]) && IntersectionMatrix.isTrue(this._matrix[Location.EXTERIOR][Location.INTERIOR])\n    \n    if (dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.L) \n      return this._matrix[Location.INTERIOR][Location.INTERIOR] === 1 && IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.EXTERIOR]) && IntersectionMatrix.isTrue(this._matrix[Location.EXTERIOR][Location.INTERIOR])\n    \n    return false\n  }\n  isEquals(dimensionOfGeometryA, dimensionOfGeometryB) {\n    if (dimensionOfGeometryA !== dimensionOfGeometryB) \n      return false\n    \n    return IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) && this._matrix[Location.INTERIOR][Location.EXTERIOR] === Dimension.FALSE && this._matrix[Location.BOUNDARY][Location.EXTERIOR] === Dimension.FALSE && this._matrix[Location.EXTERIOR][Location.INTERIOR] === Dimension.FALSE && this._matrix[Location.EXTERIOR][Location.BOUNDARY] === Dimension.FALSE\n  }\n  toString() {\n    const builder = new StringBuilder('123456789')\n    for (let ai = 0; ai < 3; ai++) \n      for (let bi = 0; bi < 3; bi++) \n        builder.setCharAt(3 * ai + bi, Dimension.toDimensionSymbol(this._matrix[ai][bi]))\n      \n    \n    return builder.toString()\n  }\n  setAll(dimensionValue) {\n    for (let ai = 0; ai < 3; ai++) \n      for (let bi = 0; bi < 3; bi++) \n        this._matrix[ai][bi] = dimensionValue\n      \n    \n  }\n  get(row, column) {\n    return this._matrix[row][column]\n  }\n  transpose() {\n    let temp = this._matrix[1][0]\n    this._matrix[1][0] = this._matrix[0][1]\n    this._matrix[0][1] = temp\n    temp = this._matrix[2][0]\n    this._matrix[2][0] = this._matrix[0][2]\n    this._matrix[0][2] = temp\n    temp = this._matrix[2][1]\n    this._matrix[2][1] = this._matrix[1][2]\n    this._matrix[1][2] = temp\n    return this\n  }\n  matches(requiredDimensionSymbols) {\n    if (requiredDimensionSymbols.length !== 9) \n      throw new IllegalArgumentException('Should be length 9: ' + requiredDimensionSymbols)\n    \n    for (let ai = 0; ai < 3; ai++) \n      for (let bi = 0; bi < 3; bi++) \n        if (!IntersectionMatrix.matches(this._matrix[ai][bi], requiredDimensionSymbols.charAt(3 * ai + bi))) \n          return false\n        \n      \n    \n    return true\n  }\n  add(im) {\n    for (let i = 0; i < 3; i++) \n      for (let j = 0; j < 3; j++) \n        this.setAtLeast(i, j, im.get(i, j))\n      \n    \n  }\n  isDisjoint() {\n    return this._matrix[Location.INTERIOR][Location.INTERIOR] === Dimension.FALSE && this._matrix[Location.INTERIOR][Location.BOUNDARY] === Dimension.FALSE && this._matrix[Location.BOUNDARY][Location.INTERIOR] === Dimension.FALSE && this._matrix[Location.BOUNDARY][Location.BOUNDARY] === Dimension.FALSE\n  }\n  isCrosses(dimensionOfGeometryA, dimensionOfGeometryB) {\n    if (dimensionOfGeometryA === Dimension.P && dimensionOfGeometryB === Dimension.L || dimensionOfGeometryA === Dimension.P && dimensionOfGeometryB === Dimension.A || dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.A) \n      return IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) && IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.EXTERIOR])\n    \n    if (dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.P || dimensionOfGeometryA === Dimension.A && dimensionOfGeometryB === Dimension.P || dimensionOfGeometryA === Dimension.A && dimensionOfGeometryB === Dimension.L) \n      return IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) && IntersectionMatrix.isTrue(this._matrix[Location.EXTERIOR][Location.INTERIOR])\n    \n    if (dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.L) \n      return this._matrix[Location.INTERIOR][Location.INTERIOR] === 0\n    \n    return false\n  }\n  get interfaces_() {\n    return [Cloneable]\n  }\n}\n","import Arrays from '../../../../java/util/Arrays'\nimport System from '../../../../java/lang/System'\nexport default class IntArrayList {\n  constructor() {\n    IntArrayList.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._data = null\n    this._size = 0\n    if (arguments.length === 0) {\n      IntArrayList.constructor_.call(this, 10)\n    } else if (arguments.length === 1) {\n      const initialCapacity = arguments[0]\n      this._data = new Array(initialCapacity).fill(null)\n    }\n  }\n  size() {\n    return this._size\n  }\n  addAll(values) {\n    if (values === null) return null\n    if (values.length === 0) return null\n    this.ensureCapacity(this._size + values.length)\n    System.arraycopy(values, 0, this._data, this._size, values.length)\n    this._size += values.length\n  }\n  ensureCapacity(capacity) {\n    if (capacity <= this._data.length) return null\n    const newLength = Math.max(capacity, this._data.length * 2)\n    this._data = Arrays.copyOf(this._data, newLength)\n  }\n  toArray() {\n    const array = new Array(this._size).fill(null)\n    System.arraycopy(this._data, 0, array, 0, this._size)\n    return array\n  }\n  add(value) {\n    this.ensureCapacity(this._size + 1)\n    this._data[this._size] = value\n    ++ this._size\n  }\n}\n","import IntArrayList from '../../util/IntArrayList'\nimport ArrayList from '../../../../../java/util/ArrayList'\nimport Quadrant from '../Quadrant'\nexport default class MonotoneChainIndexer {\n  static toIntArray(list) {\n    const array = new Array(list.size()).fill(null)\n    for (let i = 0; i < array.length; i++) \n      array[i] = list.get(i).intValue()\n    \n    return array\n  }\n  getChainStartIndices(pts) {\n    let start = 0\n    const startIndexList = new IntArrayList(Math.trunc(pts.length / 2))\n    startIndexList.add(start)\n    do {\n      const last = this.findChainEnd(pts, start)\n      startIndexList.add(last)\n      start = last\n    } while (start < pts.length - 1)\n    return startIndexList.toArray()\n  }\n  findChainEnd(pts, start) {\n    const chainQuad = Quadrant.quadrant(pts[start], pts[start + 1])\n    let last = start + 1\n    while (last < pts.length) {\n      const quad = Quadrant.quadrant(pts[last - 1], pts[last])\n      if (quad !== chainQuad) break\n      last++\n    }\n    return last - 1\n  }\n  OLDgetChainStartIndices(pts) {\n    let start = 0\n    const startIndexList = new ArrayList()\n    startIndexList.add(start)\n    do {\n      const last = this.findChainEnd(pts, start)\n      startIndexList.add(last)\n      start = last\n    } while (start < pts.length - 1)\n    const startIndex = MonotoneChainIndexer.toIntArray(startIndexList)\n    return startIndex\n  }\n}\n","import MonotoneChainIndexer from './MonotoneChainIndexer'\nimport Envelope from '../../geom/Envelope'\nexport default class MonotoneChainEdge {\n  constructor() {\n    MonotoneChainEdge.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this.e = null\n    this.pts = null\n    this.startIndex = null\n    const e = arguments[0]\n    this.e = e\n    this.pts = e.getCoordinates()\n    const mcb = new MonotoneChainIndexer()\n    this.startIndex = mcb.getChainStartIndices(this.pts)\n  }\n  getCoordinates() {\n    return this.pts\n  }\n  getMaxX(chainIndex) {\n    const x1 = this.pts[this.startIndex[chainIndex]].x\n    const x2 = this.pts[this.startIndex[chainIndex + 1]].x\n    return x1 > x2 ? x1 : x2\n  }\n  getMinX(chainIndex) {\n    const x1 = this.pts[this.startIndex[chainIndex]].x\n    const x2 = this.pts[this.startIndex[chainIndex + 1]].x\n    return x1 < x2 ? x1 : x2\n  }\n  computeIntersectsForChain() {\n    if (arguments.length === 4) {\n      const chainIndex0 = arguments[0], mce = arguments[1], chainIndex1 = arguments[2], si = arguments[3]\n      this.computeIntersectsForChain(this.startIndex[chainIndex0], this.startIndex[chainIndex0 + 1], mce, mce.startIndex[chainIndex1], mce.startIndex[chainIndex1 + 1], si)\n    } else if (arguments.length === 6) {\n      const start0 = arguments[0], end0 = arguments[1], mce = arguments[2], start1 = arguments[3], end1 = arguments[4], ei = arguments[5]\n      if (end0 - start0 === 1 && end1 - start1 === 1) {\n        ei.addIntersections(this.e, start0, mce.e, start1)\n        return null\n      }\n      if (!this.overlaps(start0, end0, mce, start1, end1)) return null\n      const mid0 = Math.trunc((start0 + end0) / 2)\n      const mid1 = Math.trunc((start1 + end1) / 2)\n      if (start0 < mid0) {\n        if (start1 < mid1) this.computeIntersectsForChain(start0, mid0, mce, start1, mid1, ei)\n        if (mid1 < end1) this.computeIntersectsForChain(start0, mid0, mce, mid1, end1, ei)\n      }\n      if (mid0 < end0) {\n        if (start1 < mid1) this.computeIntersectsForChain(mid0, end0, mce, start1, mid1, ei)\n        if (mid1 < end1) this.computeIntersectsForChain(mid0, end0, mce, mid1, end1, ei)\n      }\n    }\n  }\n  overlaps(start0, end0, mce, start1, end1) {\n    return Envelope.intersects(this.pts[start0], this.pts[end0], mce.pts[start1], mce.pts[end1])\n  }\n  getStartIndexes() {\n    return this.startIndex\n  }\n  computeIntersects(mce, si) {\n    for (let i = 0; i < this.startIndex.length - 1; i++) \n      for (let j = 0; j < mce.startIndex.length - 1; j++) \n        this.computeIntersectsForChain(i, mce, j, si)\n      \n    \n  }\n}\n","import Location from '../geom/Location'\nimport Position from './Position'\nexport default class Depth {\n  constructor() {\n    Depth.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._depth = Array(2).fill().map(() => Array(3))\n    for (let i = 0; i < 2; i++) \n      for (let j = 0; j < 3; j++) \n        this._depth[i][j] = Depth.NULL_VALUE\n      \n    \n  }\n  static depthAtLocation(location) {\n    if (location === Location.EXTERIOR) return 0\n    if (location === Location.INTERIOR) return 1\n    return Depth.NULL_VALUE\n  }\n  getDepth(geomIndex, posIndex) {\n    return this._depth[geomIndex][posIndex]\n  }\n  setDepth(geomIndex, posIndex, depthValue) {\n    this._depth[geomIndex][posIndex] = depthValue\n  }\n  isNull() {\n    if (arguments.length === 0) {\n      for (let i = 0; i < 2; i++) \n        for (let j = 0; j < 3; j++) \n          if (this._depth[i][j] !== Depth.NULL_VALUE) return false\n        \n      \n      return true\n    } else if (arguments.length === 1) {\n      const geomIndex = arguments[0]\n      return this._depth[geomIndex][1] === Depth.NULL_VALUE\n    } else if (arguments.length === 2) {\n      const geomIndex = arguments[0], posIndex = arguments[1]\n      return this._depth[geomIndex][posIndex] === Depth.NULL_VALUE\n    }\n  }\n  normalize() {\n    for (let i = 0; i < 2; i++) \n      if (!this.isNull(i)) {\n        let minDepth = this._depth[i][1]\n        if (this._depth[i][2] < minDepth) minDepth = this._depth[i][2]\n        if (minDepth < 0) minDepth = 0\n        for (let j = 1; j < 3; j++) {\n          let newValue = 0\n          if (this._depth[i][j] > minDepth) newValue = 1\n          this._depth[i][j] = newValue\n        }\n      }\n    \n  }\n  getDelta(geomIndex) {\n    return this._depth[geomIndex][Position.RIGHT] - this._depth[geomIndex][Position.LEFT]\n  }\n  getLocation(geomIndex, posIndex) {\n    if (this._depth[geomIndex][posIndex] <= 0) return Location.EXTERIOR\n    return Location.INTERIOR\n  }\n  toString() {\n    return 'A: ' + this._depth[0][1] + ',' + this._depth[0][2] + ' B: ' + this._depth[1][1] + ',' + this._depth[1][2]\n  }\n  add() {\n    if (arguments.length === 1) {\n      const lbl = arguments[0]\n      for (let i = 0; i < 2; i++) \n        for (let j = 1; j < 3; j++) {\n          const loc = lbl.getLocation(i, j)\n          if (loc === Location.EXTERIOR || loc === Location.INTERIOR) \n            if (this.isNull(i, j)) \n              this._depth[i][j] = Depth.depthAtLocation(loc)\n            else this._depth[i][j] += Depth.depthAtLocation(loc)\n          \n        }\n      \n    } else if (arguments.length === 3) {\n      const geomIndex = arguments[0], posIndex = arguments[1], location = arguments[2]\n      if (location === Location.INTERIOR) this._depth[geomIndex][posIndex]++\n    }\n  }\n}\nDepth.NULL_VALUE = -1\n","import EdgeIntersectionList from './EdgeIntersectionList'\nimport IntersectionMatrix from '../geom/IntersectionMatrix'\nimport MonotoneChainEdge from './index/MonotoneChainEdge'\nimport Position from './Position'\nimport Coordinate from '../geom/Coordinate'\nimport Label from './Label'\nimport Envelope from '../geom/Envelope'\nimport StringBuilder from '../../../../java/lang/StringBuilder'\nimport Depth from './Depth'\nimport GraphComponent from './GraphComponent'\nexport default class Edge extends GraphComponent {\n  constructor() {\n    super()\n    Edge.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this.pts = null\n    this._env = null\n    this.eiList = new EdgeIntersectionList(this)\n    this._name = null\n    this._mce = null\n    this._isIsolated = true\n    this._depth = new Depth()\n    this._depthDelta = 0\n    if (arguments.length === 1) {\n      const pts = arguments[0]\n      Edge.constructor_.call(this, pts, null)\n    } else if (arguments.length === 2) {\n      const pts = arguments[0], label = arguments[1]\n      this.pts = pts\n      this._label = label\n    }\n  }\n  static updateIM() {\n    if (arguments.length === 2 && (arguments[1] instanceof IntersectionMatrix && arguments[0] instanceof Label)) {\n      const label = arguments[0], im = arguments[1]\n      im.setAtLeastIfValid(label.getLocation(0, Position.ON), label.getLocation(1, Position.ON), 1)\n      if (label.isArea()) {\n        im.setAtLeastIfValid(label.getLocation(0, Position.LEFT), label.getLocation(1, Position.LEFT), 2)\n        im.setAtLeastIfValid(label.getLocation(0, Position.RIGHT), label.getLocation(1, Position.RIGHT), 2)\n      }\n    } else {\n      return super.updateIM.apply(this, arguments)\n    }\n  }\n  getDepth() {\n    return this._depth\n  }\n  getCollapsedEdge() {\n    const newPts = new Array(2).fill(null)\n    newPts[0] = this.pts[0]\n    newPts[1] = this.pts[1]\n    const newe = new Edge(newPts, Label.toLineLabel(this._label))\n    return newe\n  }\n  isIsolated() {\n    return this._isIsolated\n  }\n  getCoordinates() {\n    return this.pts\n  }\n  setIsolated(isIsolated) {\n    this._isIsolated = isIsolated\n  }\n  setName(name) {\n    this._name = name\n  }\n  equals(o) {\n    if (!(o instanceof Edge)) return false\n    const e = o\n    if (this.pts.length !== e.pts.length) return false\n    let isEqualForward = true\n    let isEqualReverse = true\n    let iRev = this.pts.length\n    for (let i = 0; i < this.pts.length; i++) {\n      if (!this.pts[i].equals2D(e.pts[i])) \n        isEqualForward = false\n      \n      if (!this.pts[i].equals2D(e.pts[-- iRev])) \n        isEqualReverse = false\n      \n      if (!isEqualForward && !isEqualReverse) return false\n    }\n    return true\n  }\n  getCoordinate() {\n    if (arguments.length === 0) {\n      if (this.pts.length > 0) return this.pts[0]\n      return null\n    } else if (arguments.length === 1) {\n      const i = arguments[0]\n      return this.pts[i]\n    }\n  }\n  print(out) {\n    out.print('edge ' + this._name + ': ')\n    out.print('LINESTRING (')\n    for (let i = 0; i < this.pts.length; i++) {\n      if (i > 0) out.print(',')\n      out.print(this.pts[i].x + ' ' + this.pts[i].y)\n    }\n    out.print(')  ' + this._label + ' ' + this._depthDelta)\n  }\n  computeIM(im) {\n    Edge.updateIM(this._label, im)\n  }\n  isCollapsed() {\n    if (!this._label.isArea()) return false\n    if (this.pts.length !== 3) return false\n    if (this.pts[0].equals(this.pts[2])) return true\n    return false\n  }\n  isClosed() {\n    return this.pts[0].equals(this.pts[this.pts.length - 1])\n  }\n  getMaximumSegmentIndex() {\n    return this.pts.length - 1\n  }\n  getDepthDelta() {\n    return this._depthDelta\n  }\n  getNumPoints() {\n    return this.pts.length\n  }\n  printReverse(out) {\n    out.print('edge ' + this._name + ': ')\n    for (let i = this.pts.length - 1; i >= 0; i--) \n      out.print(this.pts[i] + ' ')\n    \n    out.println('')\n  }\n  getMonotoneChainEdge() {\n    if (this._mce === null) this._mce = new MonotoneChainEdge(this)\n    return this._mce\n  }\n  getEnvelope() {\n    if (this._env === null) {\n      this._env = new Envelope()\n      for (let i = 0; i < this.pts.length; i++) \n        this._env.expandToInclude(this.pts[i])\n      \n    }\n    return this._env\n  }\n  addIntersection(li, segmentIndex, geomIndex, intIndex) {\n    const intPt = new Coordinate(li.getIntersection(intIndex))\n    let normalizedSegmentIndex = segmentIndex\n    let dist = li.getEdgeDistance(geomIndex, intIndex)\n    const nextSegIndex = normalizedSegmentIndex + 1\n    if (nextSegIndex < this.pts.length) {\n      const nextPt = this.pts[nextSegIndex]\n      if (intPt.equals2D(nextPt)) {\n        normalizedSegmentIndex = nextSegIndex\n        dist = 0.0\n      }\n    }\n    const ei = this.eiList.add(intPt, normalizedSegmentIndex, dist)\n  }\n  toString() {\n    const builder = new StringBuilder()\n    builder.append('edge ' + this._name + ': ')\n    builder.append('LINESTRING (')\n    for (let i = 0; i < this.pts.length; i++) {\n      if (i > 0) builder.append(',')\n      builder.append(this.pts[i].x + ' ' + this.pts[i].y)\n    }\n    builder.append(')  ' + this._label + ' ' + this._depthDelta)\n    return builder.toString()\n  }\n  isPointwiseEqual(e) {\n    if (this.pts.length !== e.pts.length) return false\n    for (let i = 0; i < this.pts.length; i++) \n      if (!this.pts[i].equals2D(e.pts[i])) \n        return false\n      \n    \n    return true\n  }\n  setDepthDelta(depthDelta) {\n    this._depthDelta = depthDelta\n  }\n  getEdgeIntersectionList() {\n    return this.eiList\n  }\n  addIntersections(li, segmentIndex, geomIndex) {\n    for (let i = 0; i < li.getIntersectionNum(); i++) \n      this.addIntersection(li, segmentIndex, geomIndex, i)\n    \n  }\n}\n","import Location from '../../geom/Location'\nimport BufferSubgraph from './BufferSubgraph'\nimport PolygonBuilder from '../overlay/PolygonBuilder'\nimport GeometryFactory from '../../geom/GeometryFactory'\nimport Position from '../../geomgraph/Position'\nimport MCIndexNoder from '../../noding/MCIndexNoder'\nimport OffsetCurveBuilder from './OffsetCurveBuilder'\nimport Collections from '../../../../../java/util/Collections'\nimport SubgraphDepthLocater from './SubgraphDepthLocater'\nimport OffsetCurveSetBuilder from './OffsetCurveSetBuilder'\nimport Label from '../../geomgraph/Label'\nimport OverlayNodeFactory from '../overlay/OverlayNodeFactory'\nimport EdgeList from '../../geomgraph/EdgeList'\nimport ArrayList from '../../../../../java/util/ArrayList'\nimport RobustLineIntersector from '../../algorithm/RobustLineIntersector'\nimport IntersectionAdder from '../../noding/IntersectionAdder'\nimport Edge from '../../geomgraph/Edge'\nimport PlanarGraph from '../../geomgraph/PlanarGraph'\nexport default class BufferBuilder {\n  constructor() {\n    BufferBuilder.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._bufParams = null\n    this._workingPrecisionModel = null\n    this._workingNoder = null\n    this._geomFact = null\n    this._graph = null\n    this._edgeList = new EdgeList()\n    const bufParams = arguments[0]\n    this._bufParams = bufParams\n  }\n  static depthDelta(label) {\n    const lLoc = label.getLocation(0, Position.LEFT)\n    const rLoc = label.getLocation(0, Position.RIGHT)\n    if (lLoc === Location.INTERIOR && rLoc === Location.EXTERIOR) return 1; else if (lLoc === Location.EXTERIOR && rLoc === Location.INTERIOR) return -1\n    return 0\n  }\n  static convertSegStrings(it) {\n    const fact = new GeometryFactory()\n    const lines = new ArrayList()\n    while (it.hasNext()) {\n      const ss = it.next()\n      const line = fact.createLineString(ss.getCoordinates())\n      lines.add(line)\n    }\n    return fact.buildGeometry(lines)\n  }\n  setWorkingPrecisionModel(pm) {\n    this._workingPrecisionModel = pm\n  }\n  insertUniqueEdge(e) {\n    const existingEdge = this._edgeList.findEqualEdge(e)\n    if (existingEdge !== null) {\n      const existingLabel = existingEdge.getLabel()\n      let labelToMerge = e.getLabel()\n      if (!existingEdge.isPointwiseEqual(e)) {\n        labelToMerge = new Label(e.getLabel())\n        labelToMerge.flip()\n      }\n      existingLabel.merge(labelToMerge)\n      const mergeDelta = BufferBuilder.depthDelta(labelToMerge)\n      const existingDelta = existingEdge.getDepthDelta()\n      const newDelta = existingDelta + mergeDelta\n      existingEdge.setDepthDelta(newDelta)\n    } else {\n      this._edgeList.add(e)\n      e.setDepthDelta(BufferBuilder.depthDelta(e.getLabel()))\n    }\n  }\n  buildSubgraphs(subgraphList, polyBuilder) {\n    const processedGraphs = new ArrayList()\n    for (let i = subgraphList.iterator(); i.hasNext(); ) {\n      const subgraph = i.next()\n      const p = subgraph.getRightmostCoordinate()\n      const locater = new SubgraphDepthLocater(processedGraphs)\n      const outsideDepth = locater.getDepth(p)\n      subgraph.computeDepth(outsideDepth)\n      subgraph.findResultEdges()\n      processedGraphs.add(subgraph)\n      polyBuilder.add(subgraph.getDirectedEdges(), subgraph.getNodes())\n    }\n  }\n  createSubgraphs(graph) {\n    const subgraphList = new ArrayList()\n    for (let i = graph.getNodes().iterator(); i.hasNext(); ) {\n      const node = i.next()\n      if (!node.isVisited()) {\n        const subgraph = new BufferSubgraph()\n        subgraph.create(node)\n        subgraphList.add(subgraph)\n      }\n    }\n    Collections.sort(subgraphList, Collections.reverseOrder())\n    return subgraphList\n  }\n  createEmptyResultGeometry() {\n    const emptyGeom = this._geomFact.createPolygon()\n    return emptyGeom\n  }\n  getNoder(precisionModel) {\n    if (this._workingNoder !== null) return this._workingNoder\n    const noder = new MCIndexNoder()\n    const li = new RobustLineIntersector()\n    li.setPrecisionModel(precisionModel)\n    noder.setSegmentIntersector(new IntersectionAdder(li))\n    return noder\n  }\n  buffer(g, distance) {\n    let precisionModel = this._workingPrecisionModel\n    if (precisionModel === null) precisionModel = g.getPrecisionModel()\n    this._geomFact = g.getFactory()\n    const curveBuilder = new OffsetCurveBuilder(precisionModel, this._bufParams)\n    const curveSetBuilder = new OffsetCurveSetBuilder(g, distance, curveBuilder)\n    const bufferSegStrList = curveSetBuilder.getCurves()\n    if (bufferSegStrList.size() <= 0) \n      return this.createEmptyResultGeometry()\n    \n    this.computeNodedEdges(bufferSegStrList, precisionModel)\n    this._graph = new PlanarGraph(new OverlayNodeFactory())\n    this._graph.addEdges(this._edgeList.getEdges())\n    const subgraphList = this.createSubgraphs(this._graph)\n    const polyBuilder = new PolygonBuilder(this._geomFact)\n    this.buildSubgraphs(subgraphList, polyBuilder)\n    const resultPolyList = polyBuilder.getPolygons()\n    if (resultPolyList.size() <= 0) \n      return this.createEmptyResultGeometry()\n    \n    const resultGeom = this._geomFact.buildGeometry(resultPolyList)\n    return resultGeom\n  }\n  computeNodedEdges(bufferSegStrList, precisionModel) {\n    const noder = this.getNoder(precisionModel)\n    noder.computeNodes(bufferSegStrList)\n    const nodedSegStrings = noder.getNodedSubstrings()\n    for (let i = nodedSegStrings.iterator(); i.hasNext(); ) {\n      const segStr = i.next()\n      const pts = segStr.getCoordinates()\n      if (pts.length === 2 && pts[0].equals2D(pts[1])) continue\n      const oldLabel = segStr.getData()\n      const edge = new Edge(segStr.getCoordinates(), new Label(oldLabel))\n      this.insertUniqueEdge(edge)\n    }\n  }\n  setNoder(noder) {\n    this._workingNoder = noder\n  }\n}\n","import hasInterface from '../../../../hasInterface'\nimport Collection from '../../../../java/util/Collection'\nimport Noder from './Noder'\nimport Coordinate from '../geom/Coordinate'\nimport NodedSegmentString from './NodedSegmentString'\nimport System from '../../../../java/lang/System'\nimport CoordinateArrays from '../geom/CoordinateArrays'\nimport ArrayList from '../../../../java/util/ArrayList'\nexport default class ScaledNoder {\n  constructor() {\n    ScaledNoder.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._noder = null\n    this._scaleFactor = null\n    this._offsetX = null\n    this._offsetY = null\n    this._isScaled = false\n    if (arguments.length === 2) {\n      const noder = arguments[0], scaleFactor = arguments[1]\n      ScaledNoder.constructor_.call(this, noder, scaleFactor, 0, 0)\n    } else if (arguments.length === 4) {\n      const noder = arguments[0], scaleFactor = arguments[1], offsetX = arguments[2], offsetY = arguments[3]\n      this._noder = noder\n      this._scaleFactor = scaleFactor\n      this._isScaled = !this.isIntegerPrecision()\n    }\n  }\n  rescale() {\n    if (hasInterface(arguments[0], Collection)) {\n      const segStrings = arguments[0]\n      for (let i = segStrings.iterator(); i.hasNext(); ) {\n        const ss = i.next()\n        this.rescale(ss.getCoordinates())\n      }\n    } else if (arguments[0] instanceof Array) {\n      const pts = arguments[0]\n      for (let i = 0; i < pts.length; i++) {\n        pts[i].x = pts[i].x / this._scaleFactor + this._offsetX\n        pts[i].y = pts[i].y / this._scaleFactor + this._offsetY\n      }\n      if (pts.length === 2 && pts[0].equals2D(pts[1])) \n        System.out.println(pts)\n      \n    }\n  }\n  scale() {\n    if (hasInterface(arguments[0], Collection)) {\n      const segStrings = arguments[0]\n      const nodedSegmentStrings = new ArrayList(segStrings.size())\n      for (let i = segStrings.iterator(); i.hasNext(); ) {\n        const ss = i.next()\n        nodedSegmentStrings.add(new NodedSegmentString(this.scale(ss.getCoordinates()), ss.getData()))\n      }\n      return nodedSegmentStrings\n    } else if (arguments[0] instanceof Array) {\n      const pts = arguments[0]\n      const roundPts = new Array(pts.length).fill(null)\n      for (let i = 0; i < pts.length; i++) \n        roundPts[i] = new Coordinate(Math.round((pts[i].x - this._offsetX) * this._scaleFactor), Math.round((pts[i].y - this._offsetY) * this._scaleFactor), pts[i].getZ())\n      \n      const roundPtsNoDup = CoordinateArrays.removeRepeatedPoints(roundPts)\n      return roundPtsNoDup\n    }\n  }\n  isIntegerPrecision() {\n    return this._scaleFactor === 1.0\n  }\n  getNodedSubstrings() {\n    const splitSS = this._noder.getNodedSubstrings()\n    if (this._isScaled) this.rescale(splitSS)\n    return splitSS\n  }\n  computeNodes(inputSegStrings) {\n    let intSegStrings = inputSegStrings\n    if (this._isScaled) intSegStrings = this.scale(inputSegStrings)\n    this._noder.computeNodes(intSegStrings)\n  }\n  get interfaces_() {\n    return [Noder]\n  }\n}\n","import GeometryFactory from '../geom/GeometryFactory'\nimport RobustLineIntersector from '../algorithm/RobustLineIntersector'\nimport RuntimeException from '../../../../java/lang/RuntimeException'\nexport default class NodingValidator {\n  constructor() {\n    NodingValidator.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._li = new RobustLineIntersector()\n    this._segStrings = null\n    const segStrings = arguments[0]\n    this._segStrings = segStrings\n  }\n  checkEndPtVertexIntersections() {\n    if (arguments.length === 0) {\n      for (let i = this._segStrings.iterator(); i.hasNext(); ) {\n        const ss = i.next()\n        const pts = ss.getCoordinates()\n        this.checkEndPtVertexIntersections(pts[0], this._segStrings)\n        this.checkEndPtVertexIntersections(pts[pts.length - 1], this._segStrings)\n      }\n    } else if (arguments.length === 2) {\n      const testPt = arguments[0], segStrings = arguments[1]\n      for (let i = segStrings.iterator(); i.hasNext(); ) {\n        const ss = i.next()\n        const pts = ss.getCoordinates()\n        for (let j = 1; j < pts.length - 1; j++) \n          if (pts[j].equals(testPt)) throw new RuntimeException('found endpt/interior pt intersection at index ' + j + ' :pt ' + testPt)\n        \n      }\n    }\n  }\n  checkInteriorIntersections() {\n    if (arguments.length === 0) {\n      for (let i = this._segStrings.iterator(); i.hasNext(); ) {\n        const ss0 = i.next()\n        for (let j = this._segStrings.iterator(); j.hasNext(); ) {\n          const ss1 = j.next()\n          this.checkInteriorIntersections(ss0, ss1)\n        }\n      }\n    } else if (arguments.length === 2) {\n      const ss0 = arguments[0], ss1 = arguments[1]\n      const pts0 = ss0.getCoordinates()\n      const pts1 = ss1.getCoordinates()\n      for (let i0 = 0; i0 < pts0.length - 1; i0++) \n        for (let i1 = 0; i1 < pts1.length - 1; i1++) \n          this.checkInteriorIntersections(ss0, i0, ss1, i1)\n        \n      \n    } else if (arguments.length === 4) {\n      const e0 = arguments[0], segIndex0 = arguments[1], e1 = arguments[2], segIndex1 = arguments[3]\n      if (e0 === e1 && segIndex0 === segIndex1) return null\n      const p00 = e0.getCoordinates()[segIndex0]\n      const p01 = e0.getCoordinates()[segIndex0 + 1]\n      const p10 = e1.getCoordinates()[segIndex1]\n      const p11 = e1.getCoordinates()[segIndex1 + 1]\n      this._li.computeIntersection(p00, p01, p10, p11)\n      if (this._li.hasIntersection()) \n        if (this._li.isProper() || this.hasInteriorIntersection(this._li, p00, p01) || this.hasInteriorIntersection(this._li, p10, p11)) \n          throw new RuntimeException('found non-noded intersection at ' + p00 + '-' + p01 + ' and ' + p10 + '-' + p11)\n        \n      \n    }\n  }\n  checkValid() {\n    this.checkEndPtVertexIntersections()\n    this.checkInteriorIntersections()\n    this.checkCollapses()\n  }\n  checkCollapses() {\n    if (arguments.length === 0) {\n      for (let i = this._segStrings.iterator(); i.hasNext(); ) {\n        const ss = i.next()\n        this.checkCollapses(ss)\n      }\n    } else if (arguments.length === 1) {\n      const ss = arguments[0]\n      const pts = ss.getCoordinates()\n      for (let i = 0; i < pts.length - 2; i++) \n        this.checkCollapse(pts[i], pts[i + 1], pts[i + 2])\n      \n    }\n  }\n  hasInteriorIntersection(li, p0, p1) {\n    for (let i = 0; i < li.getIntersectionNum(); i++) {\n      const intPt = li.getIntersection(i)\n      if (!(intPt.equals(p0) || intPt.equals(p1))) return true\n    }\n    return false\n  }\n  checkCollapse(p0, p1, p2) {\n    if (p0.equals(p2)) throw new RuntimeException('found non-noded collapse at ' + NodingValidator.fact.createLineString([p0, p1, p2]))\n  }\n}\nNodingValidator.fact = new GeometryFactory()\n","import Coordinate from '../../geom/Coordinate'\nimport IllegalArgumentException from '../../../../../java/lang/IllegalArgumentException'\nimport Envelope from '../../geom/Envelope'\nimport Assert from '../../util/Assert'\nexport default class HotPixel {\n  constructor() {\n    HotPixel.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._li = null\n    this._pt = null\n    this._originalPt = null\n    this._ptScaled = null\n    this._p0Scaled = null\n    this._p1Scaled = null\n    this._scaleFactor = null\n    this._minx = null\n    this._maxx = null\n    this._miny = null\n    this._maxy = null\n    this._corner = new Array(4).fill(null)\n    this._safeEnv = null\n    const pt = arguments[0], scaleFactor = arguments[1], li = arguments[2]\n    this._originalPt = pt\n    this._pt = pt\n    this._scaleFactor = scaleFactor\n    this._li = li\n    if (scaleFactor <= 0) throw new IllegalArgumentException('Scale factor must be non-zero')\n    if (scaleFactor !== 1.0) {\n      this._pt = new Coordinate(this.scale(pt.x), this.scale(pt.y))\n      this._p0Scaled = new Coordinate()\n      this._p1Scaled = new Coordinate()\n    }\n    this.initCorners(this._pt)\n  }\n  intersectsScaled(p0, p1) {\n    const segMinx = Math.min(p0.x, p1.x)\n    const segMaxx = Math.max(p0.x, p1.x)\n    const segMiny = Math.min(p0.y, p1.y)\n    const segMaxy = Math.max(p0.y, p1.y)\n    const isOutsidePixelEnv = this._maxx < segMinx || this._minx > segMaxx || this._maxy < segMiny || this._miny > segMaxy\n    if (isOutsidePixelEnv) return false\n    const intersects = this.intersectsToleranceSquare(p0, p1)\n    Assert.isTrue(!(isOutsidePixelEnv && intersects), 'Found bad envelope test')\n    return intersects\n  }\n  initCorners(pt) {\n    const tolerance = 0.5\n    this._minx = pt.x - tolerance\n    this._maxx = pt.x + tolerance\n    this._miny = pt.y - tolerance\n    this._maxy = pt.y + tolerance\n    this._corner[0] = new Coordinate(this._maxx, this._maxy)\n    this._corner[1] = new Coordinate(this._minx, this._maxy)\n    this._corner[2] = new Coordinate(this._minx, this._miny)\n    this._corner[3] = new Coordinate(this._maxx, this._miny)\n  }\n  intersects(p0, p1) {\n    if (this._scaleFactor === 1.0) return this.intersectsScaled(p0, p1)\n    this.copyScaled(p0, this._p0Scaled)\n    this.copyScaled(p1, this._p1Scaled)\n    return this.intersectsScaled(this._p0Scaled, this._p1Scaled)\n  }\n  scale(val) {\n    return Math.round(val * this._scaleFactor)\n  }\n  getCoordinate() {\n    return this._originalPt\n  }\n  copyScaled(p, pScaled) {\n    pScaled.x = this.scale(p.x)\n    pScaled.y = this.scale(p.y)\n  }\n  getSafeEnvelope() {\n    if (this._safeEnv === null) {\n      const safeTolerance = HotPixel.SAFE_ENV_EXPANSION_FACTOR / this._scaleFactor\n      this._safeEnv = new Envelope(this._originalPt.x - safeTolerance, this._originalPt.x + safeTolerance, this._originalPt.y - safeTolerance, this._originalPt.y + safeTolerance)\n    }\n    return this._safeEnv\n  }\n  intersectsPixelClosure(p0, p1) {\n    this._li.computeIntersection(p0, p1, this._corner[0], this._corner[1])\n    if (this._li.hasIntersection()) return true\n    this._li.computeIntersection(p0, p1, this._corner[1], this._corner[2])\n    if (this._li.hasIntersection()) return true\n    this._li.computeIntersection(p0, p1, this._corner[2], this._corner[3])\n    if (this._li.hasIntersection()) return true\n    this._li.computeIntersection(p0, p1, this._corner[3], this._corner[0])\n    if (this._li.hasIntersection()) return true\n    return false\n  }\n  intersectsToleranceSquare(p0, p1) {\n    let intersectsLeft = false\n    let intersectsBottom = false\n    this._li.computeIntersection(p0, p1, this._corner[0], this._corner[1])\n    if (this._li.isProper()) return true\n    this._li.computeIntersection(p0, p1, this._corner[1], this._corner[2])\n    if (this._li.isProper()) return true\n    if (this._li.hasIntersection()) intersectsLeft = true\n    this._li.computeIntersection(p0, p1, this._corner[2], this._corner[3])\n    if (this._li.isProper()) return true\n    if (this._li.hasIntersection()) intersectsBottom = true\n    this._li.computeIntersection(p0, p1, this._corner[3], this._corner[0])\n    if (this._li.isProper()) return true\n    if (intersectsLeft && intersectsBottom) return true\n    if (p0.equals(this._pt)) return true\n    if (p1.equals(this._pt)) return true\n    return false\n  }\n  addSnappedNode(segStr, segIndex) {\n    const p0 = segStr.getCoordinate(segIndex)\n    const p1 = segStr.getCoordinate(segIndex + 1)\n    if (this.intersects(p0, p1)) {\n      segStr.addIntersection(this.getCoordinate(), segIndex)\n      return true\n    }\n    return false\n  }\n}\nHotPixel.SAFE_ENV_EXPANSION_FACTOR = 0.75\n","import LineSegment from '../../geom/LineSegment'\nexport default class MonotoneChainSelectAction {\n  constructor() {\n    MonotoneChainSelectAction.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this.selectedSegment = new LineSegment()\n  }\n  select() {\n    if (arguments.length === 1) {\n      const seg = arguments[0]\n    } else if (arguments.length === 2) {\n      const mc = arguments[0], startIndex = arguments[1]\n      mc.getLineSegment(startIndex, this.selectedSegment)\n      this.select(this.selectedSegment)\n    }\n  }\n}\n","import MonotoneChainSelectAction from '../../index/chain/MonotoneChainSelectAction'\nimport MonotoneChain from '../../index/chain/MonotoneChain'\nimport ItemVisitor from '../../index/ItemVisitor'\nexport default class MCIndexPointSnapper {\n  constructor() {\n    MCIndexPointSnapper.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._index = null\n    const index = arguments[0]\n    this._index = index\n  }\n  snap() {\n    if (arguments.length === 1) {\n      const hotPixel = arguments[0]\n      return this.snap(hotPixel, null, -1)\n    } else if (arguments.length === 3) {\n      const hotPixel = arguments[0], parentEdge = arguments[1], hotPixelVertexIndex = arguments[2]\n      const pixelEnv = hotPixel.getSafeEnvelope()\n      const hotPixelSnapAction = new HotPixelSnapAction(hotPixel, parentEdge, hotPixelVertexIndex)\n      this._index.query(pixelEnv, new (class {\n        get interfaces_() {\n          return [ItemVisitor]\n        }\n        visitItem(item) {\n          const testChain = item\n          testChain.select(pixelEnv, hotPixelSnapAction)\n        }\n      })())\n      return hotPixelSnapAction.isNodeAdded()\n    }\n  }\n}\nclass HotPixelSnapAction extends MonotoneChainSelectAction {\n  constructor() {\n    super()\n    HotPixelSnapAction.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._hotPixel = null\n    this._parentEdge = null\n    this._hotPixelVertexIndex = null\n    this._isNodeAdded = false\n    const hotPixel = arguments[0], parentEdge = arguments[1], hotPixelVertexIndex = arguments[2]\n    this._hotPixel = hotPixel\n    this._parentEdge = parentEdge\n    this._hotPixelVertexIndex = hotPixelVertexIndex\n  }\n  isNodeAdded() {\n    return this._isNodeAdded\n  }\n  select() {\n    if (arguments.length === 2 && (Number.isInteger(arguments[1]) && arguments[0] instanceof MonotoneChain)) {\n      const mc = arguments[0], startIndex = arguments[1]\n      const ss = mc.getContext()\n      if (this._parentEdge === ss) \n        if (startIndex === this._hotPixelVertexIndex || startIndex + 1 === this._hotPixelVertexIndex) return null\n      \n      this._isNodeAdded |= this._hotPixel.addSnappedNode(ss, startIndex)\n    } else {\n      return super.select.apply(this, arguments)\n    }\n  }\n}\nMCIndexPointSnapper.HotPixelSnapAction = HotPixelSnapAction\n","import SegmentIntersector from './SegmentIntersector'\nimport ArrayList from '../../../../java/util/ArrayList'\nexport default class InteriorIntersectionFinderAdder {\n  constructor() {\n    InteriorIntersectionFinderAdder.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._li = null\n    this._interiorIntersections = null\n    const li = arguments[0]\n    this._li = li\n    this._interiorIntersections = new ArrayList()\n  }\n  processIntersections(e0, segIndex0, e1, segIndex1) {\n    if (e0 === e1 && segIndex0 === segIndex1) return null\n    const p00 = e0.getCoordinates()[segIndex0]\n    const p01 = e0.getCoordinates()[segIndex0 + 1]\n    const p10 = e1.getCoordinates()[segIndex1]\n    const p11 = e1.getCoordinates()[segIndex1 + 1]\n    this._li.computeIntersection(p00, p01, p10, p11)\n    if (this._li.hasIntersection()) \n      if (this._li.isInteriorIntersection()) {\n        for (let intIndex = 0; intIndex < this._li.getIntersectionNum(); intIndex++) \n          this._interiorIntersections.add(this._li.getIntersection(intIndex))\n        \n        e0.addIntersections(this._li, segIndex0, 0)\n        e1.addIntersections(this._li, segIndex1, 1)\n      }\n    \n  }\n  isDone() {\n    return false\n  }\n  getInteriorIntersections() {\n    return this._interiorIntersections\n  }\n  get interfaces_() {\n    return [SegmentIntersector]\n  }\n}\n","import NodingValidator from '../NodingValidator'\nimport hasInterface from '../../../../../hasInterface'\nimport Collection from '../../../../../java/util/Collection'\nimport Noder from '../Noder'\nimport MCIndexNoder from '../MCIndexNoder'\nimport NodedSegmentString from '../NodedSegmentString'\nimport HotPixel from './HotPixel'\nimport Exception from '../../../../../java/lang/Exception'\nimport MCIndexPointSnapper from './MCIndexPointSnapper'\nimport RobustLineIntersector from '../../algorithm/RobustLineIntersector'\nimport InteriorIntersectionFinderAdder from '../InteriorIntersectionFinderAdder'\nexport default class MCIndexSnapRounder {\n  constructor() {\n    MCIndexSnapRounder.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._pm = null\n    this._li = null\n    this._scaleFactor = null\n    this._noder = null\n    this._pointSnapper = null\n    this._nodedSegStrings = null\n    const pm = arguments[0]\n    this._pm = pm\n    this._li = new RobustLineIntersector()\n    this._li.setPrecisionModel(pm)\n    this._scaleFactor = pm.getScale()\n  }\n  checkCorrectness(inputSegmentStrings) {\n    const resultSegStrings = NodedSegmentString.getNodedSubstrings(inputSegmentStrings)\n    const nv = new NodingValidator(resultSegStrings)\n    try {\n      nv.checkValid()\n    } catch (ex) {\n      if (ex instanceof Exception) \n        ex.printStackTrace()\n      else throw ex\n    } finally {}\n  }\n  getNodedSubstrings() {\n    return NodedSegmentString.getNodedSubstrings(this._nodedSegStrings)\n  }\n  snapRound(segStrings, li) {\n    const intersections = this.findInteriorIntersections(segStrings, li)\n    this.computeIntersectionSnaps(intersections)\n    this.computeVertexSnaps(segStrings)\n  }\n  findInteriorIntersections(segStrings, li) {\n    const intFinderAdder = new InteriorIntersectionFinderAdder(li)\n    this._noder.setSegmentIntersector(intFinderAdder)\n    this._noder.computeNodes(segStrings)\n    return intFinderAdder.getInteriorIntersections()\n  }\n  computeVertexSnaps() {\n    if (hasInterface(arguments[0], Collection)) {\n      const edges = arguments[0]\n      for (let i0 = edges.iterator(); i0.hasNext(); ) {\n        const edge0 = i0.next()\n        this.computeVertexSnaps(edge0)\n      }\n    } else if (arguments[0] instanceof NodedSegmentString) {\n      const e = arguments[0]\n      const pts0 = e.getCoordinates()\n      for (let i = 0; i < pts0.length; i++) {\n        const hotPixel = new HotPixel(pts0[i], this._scaleFactor, this._li)\n        const isNodeAdded = this._pointSnapper.snap(hotPixel, e, i)\n        if (isNodeAdded) \n          e.addIntersection(pts0[i], i)\n        \n      }\n    }\n  }\n  computeNodes(inputSegmentStrings) {\n    this._nodedSegStrings = inputSegmentStrings\n    this._noder = new MCIndexNoder()\n    this._pointSnapper = new MCIndexPointSnapper(this._noder.getIndex())\n    this.snapRound(inputSegmentStrings, this._li)\n  }\n  computeIntersectionSnaps(snapPts) {\n    for (let it = snapPts.iterator(); it.hasNext(); ) {\n      const snapPt = it.next()\n      const hotPixel = new HotPixel(snapPt, this._scaleFactor, this._li)\n      this._pointSnapper.snap(hotPixel)\n    }\n  }\n  get interfaces_() {\n    return [Noder]\n  }\n}\n","import BufferParameters from './BufferParameters'\nimport Geometry from '../../geom/Geometry'\nimport BufferBuilder from './BufferBuilder'\nimport ScaledNoder from '../../noding/ScaledNoder'\nimport TopologyException from '../../geom/TopologyException'\nimport MathUtil from '../../math/MathUtil'\nimport PrecisionModel from '../../geom/PrecisionModel'\nimport RuntimeException from '../../../../../java/lang/RuntimeException'\nimport MCIndexSnapRounder from '../../noding/snapround/MCIndexSnapRounder'\nexport default class BufferOp {\n  constructor() {\n    BufferOp.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._argGeom = null\n    this._distance = null\n    this._bufParams = new BufferParameters()\n    this._resultGeometry = null\n    this._saveException = null\n    if (arguments.length === 1) {\n      const g = arguments[0]\n      this._argGeom = g\n    } else if (arguments.length === 2) {\n      const g = arguments[0], bufParams = arguments[1]\n      this._argGeom = g\n      this._bufParams = bufParams\n    }\n  }\n  static bufferOp() {\n    if (arguments.length === 2) {\n      const g = arguments[0], distance = arguments[1]\n      const gBuf = new BufferOp(g)\n      const geomBuf = gBuf.getResultGeometry(distance)\n      return geomBuf\n    } else if (arguments.length === 3) {\n      if (Number.isInteger(arguments[2]) && (arguments[0] instanceof Geometry && typeof arguments[1] === 'number')) {\n        const g = arguments[0], distance = arguments[1], quadrantSegments = arguments[2]\n        const bufOp = new BufferOp(g)\n        bufOp.setQuadrantSegments(quadrantSegments)\n        const geomBuf = bufOp.getResultGeometry(distance)\n        return geomBuf\n      } else if (arguments[2] instanceof BufferParameters && (arguments[0] instanceof Geometry && typeof arguments[1] === 'number')) {\n        const g = arguments[0], distance = arguments[1], params = arguments[2]\n        const bufOp = new BufferOp(g, params)\n        const geomBuf = bufOp.getResultGeometry(distance)\n        return geomBuf\n      }\n    } else if (arguments.length === 4) {\n      const g = arguments[0], distance = arguments[1], quadrantSegments = arguments[2], endCapStyle = arguments[3]\n      const bufOp = new BufferOp(g)\n      bufOp.setQuadrantSegments(quadrantSegments)\n      bufOp.setEndCapStyle(endCapStyle)\n      const geomBuf = bufOp.getResultGeometry(distance)\n      return geomBuf\n    }\n  }\n  static precisionScaleFactor(g, distance, maxPrecisionDigits) {\n    const env = g.getEnvelopeInternal()\n    const envMax = MathUtil.max(Math.abs(env.getMaxX()), Math.abs(env.getMaxY()), Math.abs(env.getMinX()), Math.abs(env.getMinY()))\n    const expandByDistance = distance > 0.0 ? distance : 0.0\n    const bufEnvMax = envMax + 2 * expandByDistance\n    const bufEnvPrecisionDigits = Math.trunc(Math.log(bufEnvMax) / Math.log(10) + 1.0)\n    const minUnitLog10 = maxPrecisionDigits - bufEnvPrecisionDigits\n    const scaleFactor = Math.pow(10.0, minUnitLog10)\n    return scaleFactor\n  }\n  bufferFixedPrecision(fixedPM) {\n    const noder = new ScaledNoder(new MCIndexSnapRounder(new PrecisionModel(1.0)), fixedPM.getScale())\n    const bufBuilder = new BufferBuilder(this._bufParams)\n    bufBuilder.setWorkingPrecisionModel(fixedPM)\n    bufBuilder.setNoder(noder)\n    this._resultGeometry = bufBuilder.buffer(this._argGeom, this._distance)\n  }\n  bufferReducedPrecision() {\n    if (arguments.length === 0) {\n      for (let precDigits = BufferOp.MAX_PRECISION_DIGITS; precDigits >= 0; precDigits--) {\n        try {\n          this.bufferReducedPrecision(precDigits)\n        } catch (ex) {\n          if (ex instanceof TopologyException) \n            this._saveException = ex\n          else throw ex\n        } finally {}\n        if (this._resultGeometry !== null) return null\n      }\n      throw this._saveException\n    } else if (arguments.length === 1) {\n      const precisionDigits = arguments[0]\n      const sizeBasedScaleFactor = BufferOp.precisionScaleFactor(this._argGeom, this._distance, precisionDigits)\n      const fixedPM = new PrecisionModel(sizeBasedScaleFactor)\n      this.bufferFixedPrecision(fixedPM)\n    }\n  }\n  computeGeometry() {\n    this.bufferOriginalPrecision()\n    if (this._resultGeometry !== null) return null\n    const argPM = this._argGeom.getFactory().getPrecisionModel()\n    if (argPM.getType() === PrecisionModel.FIXED) this.bufferFixedPrecision(argPM); else this.bufferReducedPrecision()\n  }\n  setQuadrantSegments(quadrantSegments) {\n    this._bufParams.setQuadrantSegments(quadrantSegments)\n  }\n  bufferOriginalPrecision() {\n    try {\n      const bufBuilder = new BufferBuilder(this._bufParams)\n      this._resultGeometry = bufBuilder.buffer(this._argGeom, this._distance)\n    } catch (ex) {\n      if (ex instanceof RuntimeException) \n        this._saveException = ex\n      else throw ex\n    } finally {}\n  }\n  getResultGeometry(distance) {\n    this._distance = distance\n    this.computeGeometry()\n    return this._resultGeometry\n  }\n  setEndCapStyle(endCapStyle) {\n    this._bufParams.setEndCapStyle(endCapStyle)\n  }\n}\nBufferOp.CAP_ROUND = BufferParameters.CAP_ROUND\nBufferOp.CAP_BUTT = BufferParameters.CAP_FLAT\nBufferOp.CAP_FLAT = BufferParameters.CAP_FLAT\nBufferOp.CAP_SQUARE = BufferParameters.CAP_SQUARE\nBufferOp.MAX_PRECISION_DIGITS = 12\n","import Coordinate from '../geom/Coordinate'\nimport GeometryFactory from '../geom/GeometryFactory'\n\nconst geometryTypes = ['Point', 'MultiPoint', 'LineString', 'MultiLineString', 'Polygon', 'MultiPolygon']\n\n/**\n * Class for reading and writing Well-Known Text.Create a new parser for GeoJSON\n * NOTE: Adapted from OpenLayers 2.11 implementation.\n */\n\n/**\n * Create a new parser for GeoJSON\n *\n * @param {GeometryFactory} geometryFactory\n * @return An instance of GeoJsonParser.\n * @constructor\n * @private\n */\nexport default class GeoJSONParser {\n  constructor(geometryFactory) {\n    this.geometryFactory = geometryFactory || new GeometryFactory()\n  }\n\n  /**\n   * Deserialize a GeoJSON object and return the Geometry or Feature(Collection) with JSTS Geometries\n   *\n   * @param {}\n   *          A GeoJSON object.\n   * @return {} A Geometry instance or object representing a Feature(Collection) with Geometry instances.\n   * @private\n   */\n  read(json) {\n    let obj\n    if (typeof json === 'string')\n      obj = JSON.parse(json)\n    else obj = json\n\n    const type = obj.type\n\n    if (!parse[type]) throw new Error('Unknown GeoJSON type: ' + obj.type)\n\n    if (geometryTypes.indexOf(type) !== -1)\n      return parse[type].call(this, obj.coordinates)\n    else if (type === 'GeometryCollection') return parse[type].call(this, obj.geometries)\n\n    // feature or feature collection\n    return parse[type].call(this, obj)\n  }\n\n  /**\n   * Serialize a Geometry object into GeoJSON\n   *\n   * @param {Geometry}\n   *          geometry A Geometry or array of Geometries.\n   * @return {Object} A GeoJSON object represting the input Geometry/Geometries.\n   * @private\n   */\n  write(geometry) {\n    const type = geometry.getGeometryType()\n\n    if (!extract[type]) throw new Error('Geometry is not supported')\n\n    return extract[type].call(this, geometry)\n  }\n}\n\nconst parse = {\n  /**\n   * Parse a GeoJSON Feature object\n   *\n   * @param {Object}\n   *          obj Object to parse.\n   *\n   * @return {Object} Feature with geometry/bbox converted to JSTS Geometries.\n   */\n  Feature: function(obj) {\n    const feature = {}\n\n    for (const key in obj) feature[key] = obj[key]\n\n    if (obj.geometry) {\n      const type = obj.geometry.type\n      if (!parse[type]) throw new Error('Unknown GeoJSON type: ' + obj.type)\n      feature.geometry = this.read(obj.geometry)\n    }\n\n    if (obj.bbox) feature.bbox = parse.bbox.call(this, obj.bbox)\n\n    return feature\n  },\n\n  /**\n   * Parse a GeoJSON FeatureCollection object\n   *\n   * @param {Object}\n   *          obj Object to parse.\n   *\n   * @return {Object} FeatureCollection with geometry/bbox converted to JSTS Geometries.\n   */\n  FeatureCollection: function(obj) {\n    const featureCollection = {}\n\n    if (obj.features) {\n      featureCollection.features = []\n\n      for (let i = 0; i < obj.features.length; ++i) featureCollection.features.push(this.read(obj.features[i]))\n    }\n\n    if (obj.bbox) featureCollection.bbox = this.parse.bbox.call(this, obj.bbox)\n\n    return featureCollection\n  },\n\n  /**\n   * Convert the ordinates in an array to an array of Coordinates\n   *\n   * @param {Array}\n   *          array Array with {Number}s.\n   *\n   * @return {Array} Array with Coordinates.\n   */\n  coordinates: function(array) {\n    const coordinates = []\n    for (let i = 0; i < array.length; ++i) {\n      const sub = array[i]\n      coordinates.push(new Coordinate(...sub))\n    }\n    return coordinates\n  },\n\n  /**\n   * Convert the bbox to a LinearRing\n   *\n   * @param {Array}\n   *          array Array with [xMin, yMin, xMax, yMax].\n   *\n   * @return {Array} Array with Coordinates.\n   */\n  bbox: function(array) {\n    return this.geometryFactory.createLinearRing([\n      new Coordinate(array[0], array[1]),\n      new Coordinate(array[2], array[1]),\n      new Coordinate(array[2], array[3]),\n      new Coordinate(array[0], array[3]),\n      new Coordinate(array[0], array[1])\n    ])\n  },\n\n  /**\n   * Convert an Array with ordinates to a Point\n   *\n   * @param {Array}\n   *          array Array with ordinates.\n   *\n   * @return {Point} Point.\n   */\n  Point: function(array) {\n    const coordinate = new Coordinate(...array)\n    return this.geometryFactory.createPoint(coordinate)\n  },\n\n  /**\n   * Convert an Array with coordinates to a MultiPoint\n   *\n   * @param {Array}\n   *          array Array with coordinates.\n   *\n   * @return {MultiPoint} MultiPoint.\n   */\n  MultiPoint: function(array) {\n    const points = []\n    for (let i = 0; i < array.length; ++i) points.push(parse.Point.call(this, array[i]))\n    return this.geometryFactory.createMultiPoint(points)\n  },\n\n  /**\n   * Convert an Array with coordinates to a LineString\n   *\n   * @param {Array}\n   *          array Array with coordinates.\n   *\n   * @return {LineString} LineString.\n   */\n  LineString: function(array) {\n    const coordinates = parse.coordinates.call(this, array)\n    return this.geometryFactory.createLineString(coordinates)\n  },\n\n  /**\n   * Convert an Array with coordinates to a MultiLineString\n   *\n   * @param {Array}\n   *          array Array with coordinates.\n   *\n   * @return {MultiLineString} MultiLineString.\n   */\n  MultiLineString: function(array) {\n    const lineStrings = []\n    for (let i = 0; i < array.length; ++i) lineStrings.push(parse.LineString.call(this, array[i]))\n    return this.geometryFactory.createMultiLineString(lineStrings)\n  },\n\n  /**\n   * Convert an Array to a Polygon\n   *\n   * @param {Array}\n   *          array Array with shell and holes.\n   *\n   * @return {Polygon} Polygon.\n   */\n  Polygon: function(array) {\n    const shellCoordinates = parse.coordinates.call(this, array[0])\n    const shell = this.geometryFactory.createLinearRing(shellCoordinates)\n    const holes = []\n    for (let i = 1; i < array.length; ++i) {\n      const hole = array[i]\n      const coordinates = parse.coordinates.call(this, hole)\n      const linearRing = this.geometryFactory.createLinearRing(coordinates)\n      holes.push(linearRing)\n    }\n    return this.geometryFactory.createPolygon(shell, holes)\n  },\n\n  /**\n   * Convert an Array to a MultiPolygon\n   *\n   * @param {Array}\n   *          array Array of arrays with shell and rings.\n   *\n   * @return {MultiPolygon} MultiPolygon.\n   */\n  MultiPolygon: function(array) {\n    const polygons = []\n    for (let i = 0; i < array.length; ++i) {\n      const polygon = array[i]\n      polygons.push(parse.Polygon.call(this, polygon))\n    }\n    return this.geometryFactory.createMultiPolygon(polygons)\n  },\n\n  /**\n   * Convert an Array to a GeometryCollection\n   *\n   * @param {Array}\n   *          array Array of GeoJSON geometries.\n   *\n   * @return {GeometryCollection} GeometryCollection.\n   */\n  GeometryCollection: function(array) {\n    const geometries = []\n    for (let i = 0; i < array.length; ++i) {\n      const geometry = array[i]\n      geometries.push(this.read(geometry))\n    }\n    return this.geometryFactory.createGeometryCollection(geometries)\n  }\n}\n\nconst extract = {\n  /**\n   * Convert a Coordinate to an Array\n   *\n   * @param {Coordinate}\n   *          coordinate Coordinate to convert.\n   *\n   * @return {Array} Array of ordinates.\n   */\n  coordinate: function(coordinate) {\n    const a = [coordinate.x, coordinate.y]\n    if (coordinate.z)\n      a.push(coordinate.z)\n    if (coordinate.m)\n      a.push(coordinate.m)\n    return a\n  },\n\n  /**\n   * Convert a Point to a GeoJSON object\n   *\n   * @param {Point}\n   *          point Point to convert.\n   *\n   * @return {Array} Array of 2 ordinates (paired to a coordinate).\n   */\n  Point: function(point) {\n    const array = extract.coordinate.call(this, point.getCoordinate())\n    return {\n      type: 'Point',\n      coordinates: array\n    }\n  },\n\n  /**\n   * Convert a MultiPoint to a GeoJSON object\n   *\n   * @param {MultiPoint}\n   *          multipoint MultiPoint to convert.\n   *\n   * @return {Array} Array of coordinates.\n   */\n  MultiPoint: function(multipoint) {\n    const array = []\n    for (let i = 0; i < multipoint._geometries.length; ++i) {\n      const point = multipoint._geometries[i]\n      const geoJson = extract.Point.call(this, point)\n      array.push(geoJson.coordinates)\n    }\n    return {\n      type: 'MultiPoint',\n      coordinates: array\n    }\n  },\n\n  /**\n   * Convert a LineString to a GeoJSON object\n   *\n   * @param {LineString}\n   *          linestring LineString to convert.\n   *\n   * @return {Array} Array of coordinates.\n   */\n  LineString: function(linestring) {\n    const array = []\n    const coordinates = linestring.getCoordinates()\n    for (let i = 0; i < coordinates.length; ++i) {\n      const coordinate = coordinates[i]\n      array.push(extract.coordinate.call(this, coordinate))\n    }\n    return {\n      type: 'LineString',\n      coordinates: array\n    }\n  },\n\n  /**\n   * Convert a MultiLineString to a GeoJSON object\n   *\n   * @param {MultiLineString}\n   *          multilinestring MultiLineString to convert.\n   *\n   * @return {Array} Array of Array of coordinates.\n   */\n  MultiLineString: function(multilinestring) {\n    const array = []\n    for (let i = 0; i < multilinestring._geometries.length; ++i) {\n      const linestring = multilinestring._geometries[i]\n      const geoJson = extract.LineString.call(this, linestring)\n      array.push(geoJson.coordinates)\n    }\n    return {\n      type: 'MultiLineString',\n      coordinates: array\n    }\n  },\n\n  /**\n   * Convert a Polygon to a GeoJSON object\n   *\n   * @param {Polygon}\n   *          polygon Polygon to convert.\n   *\n   * @return {Array} Array with shell, holes.\n   */\n  Polygon: function(polygon) {\n    const array = []\n    const shellGeoJson = extract.LineString.call(this, polygon._shell)\n    array.push(shellGeoJson.coordinates)\n    for (let i = 0; i < polygon._holes.length; ++i) {\n      const hole = polygon._holes[i]\n      const holeGeoJson = extract.LineString.call(this, hole)\n      array.push(holeGeoJson.coordinates)\n    }\n    return {\n      type: 'Polygon',\n      coordinates: array\n    }\n  },\n\n  /**\n   * Convert a MultiPolygon to a GeoJSON object\n   *\n   * @param {MultiPolygon}\n   *          multipolygon MultiPolygon to convert.\n   *\n   * @return {Array} Array of polygons.\n   */\n  MultiPolygon: function(multipolygon) {\n    const array = []\n    for (let i = 0; i < multipolygon._geometries.length; ++i) {\n      const polygon = multipolygon._geometries[i]\n      const geoJson = extract.Polygon.call(this, polygon)\n      array.push(geoJson.coordinates)\n    }\n    return {\n      type: 'MultiPolygon',\n      coordinates: array\n    }\n  },\n\n  /**\n   * Convert a GeometryCollection to a GeoJSON object\n   *\n   * @param {GeometryCollection}\n   *          collection GeometryCollection to convert.\n   *\n   * @return {Array} Array of geometries.\n   */\n  GeometryCollection: function(collection) {\n    const array = []\n    for (let i = 0; i < collection._geometries.length; ++i) {\n      const geometry = collection._geometries[i]\n      const type = geometry.getGeometryType()\n      array.push(extract[type].call(this, geometry))\n    }\n    return {\n      type: 'GeometryCollection',\n      geometries: array\n    }\n  }\n}\n","import BufferOp from \"jsts/org/locationtech/jts/operation/buffer/BufferOp\";\nimport GeoJSONReader from \"jsts/org/locationtech/jts/io/GeoJSONReader\";\nimport GeoJSONWriter from \"jsts/org/locationtech/jts/io/GeoJSONWriter\";\n\nconst jsts = {\n  BufferOp,\n  GeoJSONReader,\n  GeoJSONWriter,\n};\n\nexport default jsts;\n","/**\n * @module org/locationtech/jts/io/GeoJSONReader\n */\n\nimport GeometryFactory from '../geom/GeometryFactory'\nimport GeoJSONParser from './GeoJSONParser'\n\n/**\n * Converts a geometry in GeoJSON to a {@link Geometry}.\n */\nexport default class GeoJSONReader {\n  /**\n   * A <code>GeoJSONReader</code> is parameterized by a <code>GeometryFactory</code>,\n   * to allow it to create <code>Geometry</code> objects of the appropriate\n   * implementation. In particular, the <code>GeometryFactory</code> determines\n   * the <code>PrecisionModel</code> and <code>SRID</code> that is used.\n   *\n   * @param {GeometryFactory} geometryFactory\n   */\n  constructor(geometryFactory) {\n    this.parser = new GeoJSONParser(geometryFactory || new GeometryFactory())\n  }\n\n  /**\n   * Reads a GeoJSON representation of a {@link Geometry}\n   *\n   * Will also parse GeoJSON Features/FeatureCollections as custom objects.\n   *\n   * @param {Object|String} geoJson a GeoJSON Object or String.\n   * @return {Geometry|Object} a <code>Geometry or Feature/FeatureCollection representation.</code>\n   * @memberof module:org/locationtech/jts/io/GeoJSONReader#\n   */\n  read(geoJson) {\n    const geometry = this.parser.read(geoJson)\n    return geometry\n  }\n}\n","/**\n * @module org/locationtech/jts/io/GeoJSONWriter\n */\n\nimport GeoJSONParser from './GeoJSONParser'\n\n/**\n * Writes the GeoJSON representation of a {@link Geometry}. The\n * The GeoJSON format is defined <A\n * HREF=\"http://geojson.org/geojson-spec.html\">here</A>.\n */\nexport default class GeoJSONWriter {\n  /**\n   * The <code>GeoJSONWriter</code> outputs coordinates rounded to the precision\n   * model. Only the maximum number of decimal places necessary to represent the\n   * ordinates to the required precision will be output.\n   *\n   * @param {GeometryFactory} geometryFactory\n   * @constructor\n   */\n  constructor() {\n    this.parser = new GeoJSONParser(this.geometryFactory)\n  }\n\n  /**\n   * Converts a <code>Geometry</code> to its GeoJSON representation.\n   *\n   * @param {Geometry}\n   *          geometry a <code>Geometry</code> to process.\n   * @return {Object} The GeoJSON representation of the Geometry.\n   * @memberof module:org/locationtech/jts/io/GeoJSONWriter#\n   */\n  write(geometry) {\n    return this.parser.write(geometry)\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}