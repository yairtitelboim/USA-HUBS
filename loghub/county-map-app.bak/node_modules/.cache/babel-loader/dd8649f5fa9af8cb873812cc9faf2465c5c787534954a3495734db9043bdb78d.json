{"ast":null,"code":"// index.ts\nimport { centerMean } from \"@turf/center-mean\";\nimport { distance } from \"@turf/distance\";\nimport { centroid } from \"@turf/centroid\";\nimport { isNumber, point, isObject, featureCollection } from \"@turf/helpers\";\nimport { featureEach } from \"@turf/meta\";\nfunction centerMedian(features, options = {}) {\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var counter = options.counter || 10;\n  if (!isNumber(counter)) throw new Error(\"counter must be a number\");\n  var weightTerm = options.weight;\n  var meanCenter = centerMean(features, {\n    weight: options.weight\n  });\n  var centroids = featureCollection([]);\n  featureEach(features, function (feature) {\n    var _a;\n    centroids.features.push(centroid(feature, {\n      properties: {\n        weight: (_a = feature.properties) == null ? void 0 : _a[weightTerm]\n      }\n    }));\n  });\n  const properties = {\n    tolerance: options.tolerance,\n    medianCandidates: []\n  };\n  return findMedian(meanCenter.geometry.coordinates, [0, 0], centroids, properties, counter);\n}\nfunction findMedian(candidateMedian, previousCandidate, centroids, properties, counter) {\n  var tolerance = properties.tolerance || 1e-3;\n  var candidateXsum = 0;\n  var candidateYsum = 0;\n  var kSum = 0;\n  var centroidCount = 0;\n  featureEach(centroids, function (theCentroid) {\n    var _a;\n    var weightValue = (_a = theCentroid.properties) == null ? void 0 : _a.weight;\n    var weight = weightValue === void 0 || weightValue === null ? 1 : weightValue;\n    weight = Number(weight);\n    if (!isNumber(weight)) throw new Error(\"weight value must be a number\");\n    if (weight > 0) {\n      centroidCount += 1;\n      var distanceFromCandidate = weight * distance(theCentroid, candidateMedian);\n      if (distanceFromCandidate === 0) distanceFromCandidate = 1;\n      var k = weight / distanceFromCandidate;\n      candidateXsum += theCentroid.geometry.coordinates[0] * k;\n      candidateYsum += theCentroid.geometry.coordinates[1] * k;\n      kSum += k;\n    }\n  });\n  if (centroidCount < 1) throw new Error(\"no features to measure\");\n  var candidateX = candidateXsum / kSum;\n  var candidateY = candidateYsum / kSum;\n  if (centroidCount === 1 || counter === 0 || Math.abs(candidateX - previousCandidate[0]) < tolerance && Math.abs(candidateY - previousCandidate[1]) < tolerance) {\n    return point([candidateX, candidateY], {\n      medianCandidates: properties.medianCandidates\n    });\n  } else {\n    properties.medianCandidates.push([candidateX, candidateY]);\n    return findMedian([candidateX, candidateY], candidateMedian, centroids, properties, counter - 1);\n  }\n}\nvar turf_center_median_default = centerMedian;\nexport { centerMedian, turf_center_median_default as default };","map":{"version":3,"names":["centerMean","distance","centroid","isNumber","point","isObject","featureCollection","featureEach","centerMedian","features","options","Error","counter","weightTerm","weight","meanCenter","centroids","feature","_a","push","properties","tolerance","medianCandidates","findMedian","geometry","coordinates","candidateMedian","previousCandidate","candidateXsum","candidateYsum","kSum","centroidCount","theCentroid","weightValue","Number","distanceFromCandidate","k","candidateX","candidateY","Math","abs","turf_center_median_default"],"sources":["/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/center-median/index.ts"],"sourcesContent":["import { FeatureCollection, Feature, Point, Position } from \"geojson\";\nimport { centerMean } from \"@turf/center-mean\";\nimport { distance } from \"@turf/distance\";\nimport { centroid } from \"@turf/centroid\";\nimport { isNumber, point, isObject, featureCollection } from \"@turf/helpers\";\nimport { featureEach } from \"@turf/meta\";\n\n/**\n * Takes a {@link FeatureCollection} of points and calculates the median center,\n * algorithimically. The median center is understood as the point that is\n * requires the least total travel from all other points.\n *\n * Turfjs has four different functions for calculating the center of a set of\n * data. Each is useful depending on circumstance.\n *\n * `@turf/center` finds the simple center of a dataset, by finding the\n * midpoint between the extents of the data. That is, it divides in half the\n * farthest east and farthest west point as well as the farthest north and\n * farthest south.\n *\n * `@turf/center-of-mass` imagines that the dataset is a sheet of paper.\n * The center of mass is where the sheet would balance on a fingertip.\n *\n * `@turf/center-mean` takes the averages of all the coordinates and\n * produces a value that respects that. Unlike `@turf/center`, it is\n * sensitive to clusters and outliers. It lands in the statistical middle of a\n * dataset, not the geographical. It can also be weighted, meaning certain\n * points are more important than others.\n *\n * `@turf/center-median` takes the mean center and tries to find, iteratively,\n * a new point that requires the least amount of travel from all the points in\n * the dataset. It is not as sensitive to outliers as `@turf/center-mean`, but it is\n * attracted to clustered data. It, too, can be weighted.\n *\n * **Bibliography**\n *\n * Harold W. Kuhn and Robert E. Kuenne, “An Efficient Algorithm for the\n * Numerical Solution of the Generalized Weber Problem in Spatial\n * Economics,” _Journal of Regional Science_ 4, no. 2 (1962): 21–33,\n * doi:{@link https://doi.org/10.1111/j.1467-9787.1962.tb00902.x}.\n *\n * James E. Burt, Gerald M. Barber, and David L. Rigby, _Elementary\n * Statistics for Geographers_, 3rd ed., New York: The Guilford\n * Press, 2009, 150–151.\n *\n * @function\n * @param {FeatureCollection<any>} features Any GeoJSON Feature Collection\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.weight] the property name used to weight the center\n * @param {number} [options.tolerance=0.001] the difference in distance between candidate medians at which point the algorighim stops iterating.\n * @param {number} [options.counter=10] how many attempts to find the median, should the tolerance be insufficient.\n * @returns {Feature<Point>} The median center of the collection\n * @example\n * var points = turf.points([[0, 0], [1, 0], [0, 1], [5, 8]]);\n * var medianCenter = turf.centerMedian(points);\n *\n * //addToMap\n * var addToMap = [points, medianCenter]\n */\nfunction centerMedian(\n  features: FeatureCollection<any>,\n  options: { weight?: string; tolerance?: number; counter?: number } = {}\n): Feature<\n  Point,\n  {\n    medianCandidates: Array<Position>;\n    [key: string]: any;\n  }\n> {\n  // Optional params\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var counter = options.counter || 10;\n  if (!isNumber(counter)) throw new Error(\"counter must be a number\");\n  var weightTerm = options.weight;\n\n  // Calculate mean center:\n  var meanCenter = centerMean(features, { weight: options.weight });\n\n  // Calculate center of every feature:\n  var centroids = featureCollection<Point>([]);\n  featureEach(features, function (feature) {\n    centroids.features.push(\n      centroid(feature, {\n        properties: { weight: feature.properties?.[weightTerm!] },\n      })\n    );\n  });\n\n  const properties: MedianProperties = {\n    tolerance: options.tolerance,\n    medianCandidates: [],\n  };\n\n  return findMedian(\n    meanCenter.geometry.coordinates,\n    [0, 0],\n    centroids,\n    properties,\n    counter\n  ) as Feature<\n    Point,\n    {\n      medianCandidates: Array<Position>;\n      [key: string]: any;\n    }\n  >;\n}\n\ninterface MedianProperties {\n  tolerance?: number;\n  medianCandidates: Position[];\n}\n\n/**\n * Recursive function to find new candidate medians.\n *\n * @private\n * @param {Position} candidateMedian current candidate median\n * @param {Position} previousCandidate the previous candidate median\n * @param {FeatureCollection<Point>} centroids the collection of centroids whose median we are determining\n * @param {number} counter how many attempts to try before quitting.\n * @returns {Feature<Point>} the median center of the dataset.\n */\nfunction findMedian(\n  candidateMedian: Position,\n  previousCandidate: Position,\n  centroids: FeatureCollection<Point>,\n  properties: MedianProperties,\n  counter: number\n): Feature<Point> {\n  var tolerance = properties.tolerance || 0.001;\n  var candidateXsum = 0;\n  var candidateYsum = 0;\n  var kSum = 0;\n  var centroidCount = 0;\n  featureEach(centroids, function (theCentroid) {\n    var weightValue = theCentroid.properties?.weight;\n    var weight =\n      weightValue === undefined || weightValue === null ? 1 : weightValue;\n    weight = Number(weight);\n    if (!isNumber(weight)) throw new Error(\"weight value must be a number\");\n    if (weight > 0) {\n      centroidCount += 1;\n      var distanceFromCandidate =\n        weight * distance(theCentroid, candidateMedian);\n      if (distanceFromCandidate === 0) distanceFromCandidate = 1;\n      var k = weight / distanceFromCandidate;\n      candidateXsum += theCentroid.geometry.coordinates[0] * k;\n      candidateYsum += theCentroid.geometry.coordinates[1] * k;\n      kSum += k;\n    }\n  });\n  if (centroidCount < 1) throw new Error(\"no features to measure\");\n  var candidateX = candidateXsum / kSum;\n  var candidateY = candidateYsum / kSum;\n  if (\n    centroidCount === 1 ||\n    counter === 0 ||\n    (Math.abs(candidateX - previousCandidate[0]) < tolerance &&\n      Math.abs(candidateY - previousCandidate[1]) < tolerance)\n  ) {\n    return point([candidateX, candidateY], {\n      medianCandidates: properties.medianCandidates,\n    });\n  } else {\n    properties.medianCandidates.push([candidateX, candidateY]);\n    return findMedian(\n      [candidateX, candidateY],\n      candidateMedian,\n      centroids,\n      properties,\n      counter - 1\n    );\n  }\n}\n\nexport { centerMedian };\nexport default centerMedian;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}