{"ast":null,"code":"// index.ts\nimport { point } from \"@turf/helpers\";\nfunction kinks(featureIn) {\n  let coordinates;\n  let feature;\n  const results = {\n    type: \"FeatureCollection\",\n    features: []\n  };\n  if (featureIn.type === \"Feature\") {\n    feature = featureIn.geometry;\n  } else {\n    feature = featureIn;\n  }\n  if (feature.type === \"LineString\") {\n    coordinates = [feature.coordinates];\n  } else if (feature.type === \"MultiLineString\") {\n    coordinates = feature.coordinates;\n  } else if (feature.type === \"MultiPolygon\") {\n    coordinates = [].concat(...feature.coordinates);\n  } else if (feature.type === \"Polygon\") {\n    coordinates = feature.coordinates;\n  } else {\n    throw new Error(\"Input must be a LineString, MultiLineString, Polygon, or MultiPolygon Feature or Geometry\");\n  }\n  coordinates.forEach(line1 => {\n    coordinates.forEach(line2 => {\n      for (let i = 0; i < line1.length - 1; i++) {\n        for (let k = i; k < line2.length - 1; k++) {\n          if (line1 === line2) {\n            if (Math.abs(i - k) === 1) {\n              continue;\n            }\n            if (\n            // segments are first and last segment of lineString\n            i === 0 && k === line1.length - 2 &&\n            // lineString is closed\n            line1[i][0] === line1[line1.length - 1][0] && line1[i][1] === line1[line1.length - 1][1]) {\n              continue;\n            }\n          }\n          const intersection = lineIntersects(line1[i][0], line1[i][1], line1[i + 1][0], line1[i + 1][1], line2[k][0], line2[k][1], line2[k + 1][0], line2[k + 1][1]);\n          if (intersection) {\n            results.features.push(point([intersection[0], intersection[1]]));\n          }\n        }\n      }\n    });\n  });\n  return results;\n}\nfunction lineIntersects(line1StartX, line1StartY, line1EndX, line1EndY, line2StartX, line2StartY, line2EndX, line2EndY) {\n  let denominator;\n  let a;\n  let b;\n  let numerator1;\n  let numerator2;\n  const result = {\n    x: null,\n    y: null,\n    onLine1: false,\n    onLine2: false\n  };\n  denominator = (line2EndY - line2StartY) * (line1EndX - line1StartX) - (line2EndX - line2StartX) * (line1EndY - line1StartY);\n  if (denominator === 0) {\n    if (result.x !== null && result.y !== null) {\n      return result;\n    } else {\n      return false;\n    }\n  }\n  a = line1StartY - line2StartY;\n  b = line1StartX - line2StartX;\n  numerator1 = (line2EndX - line2StartX) * a - (line2EndY - line2StartY) * b;\n  numerator2 = (line1EndX - line1StartX) * a - (line1EndY - line1StartY) * b;\n  a = numerator1 / denominator;\n  b = numerator2 / denominator;\n  result.x = line1StartX + a * (line1EndX - line1StartX);\n  result.y = line1StartY + a * (line1EndY - line1StartY);\n  if (a >= 0 && a <= 1) {\n    result.onLine1 = true;\n  }\n  if (b >= 0 && b <= 1) {\n    result.onLine2 = true;\n  }\n  if (result.onLine1 && result.onLine2) {\n    return [result.x, result.y];\n  } else {\n    return false;\n  }\n}\nvar turf_kinks_default = kinks;\nexport { turf_kinks_default as default, kinks };","map":{"version":3,"names":["point","kinks","featureIn","coordinates","feature","results","type","features","geometry","concat","Error","forEach","line1","line2","i","length","k","Math","abs","intersection","lineIntersects","push","line1StartX","line1StartY","line1EndX","line1EndY","line2StartX","line2StartY","line2EndX","line2EndY","denominator","a","b","numerator1","numerator2","result","x","y","onLine1","onLine2","turf_kinks_default"],"sources":["/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/kinks/index.ts"],"sourcesContent":["import {\n  Feature,\n  FeatureCollection,\n  LineString,\n  MultiLineString,\n  MultiPolygon,\n  Point,\n  Polygon,\n} from \"geojson\";\nimport { point } from \"@turf/helpers\";\n\n/**\n * Takes a {@link LineString|linestring}, {@link MultiLineString|multi-linestring},\n * {@link MultiPolygon|multi-polygon} or {@link Polygon|polygon} and\n * returns {@link Point|points} at all self-intersections.\n *\n * @function\n * @param {Feature<LineString|MultiLineString|MultiPolygon|Polygon>} featureIn input feature\n * @returns {FeatureCollection<Point>} self-intersections\n * @example\n * var poly = turf.polygon([[\n *   [-12.034835, 8.901183],\n *   [-12.060413, 8.899826],\n *   [-12.03638, 8.873199],\n *   [-12.059383, 8.871418],\n *   [-12.034835, 8.901183]\n * ]]);\n *\n * var kinks = turf.kinks(poly);\n *\n * //addToMap\n * var addToMap = [poly, kinks]\n */\nfunction kinks<T extends LineString | MultiLineString | Polygon | MultiPolygon>(\n  featureIn: Feature<T> | T\n): FeatureCollection<Point> {\n  let coordinates: any;\n  let feature: any;\n  const results: FeatureCollection<Point> = {\n    type: \"FeatureCollection\",\n    features: [],\n  };\n  if (featureIn.type === \"Feature\") {\n    feature = featureIn.geometry;\n  } else {\n    feature = featureIn;\n  }\n  if (feature.type === \"LineString\") {\n    coordinates = [feature.coordinates];\n  } else if (feature.type === \"MultiLineString\") {\n    coordinates = feature.coordinates;\n  } else if (feature.type === \"MultiPolygon\") {\n    coordinates = [].concat(...feature.coordinates);\n  } else if (feature.type === \"Polygon\") {\n    coordinates = feature.coordinates;\n  } else {\n    throw new Error(\n      \"Input must be a LineString, MultiLineString, \" +\n        \"Polygon, or MultiPolygon Feature or Geometry\"\n    );\n  }\n  coordinates.forEach((line1: any) => {\n    coordinates.forEach((line2: any) => {\n      for (let i = 0; i < line1.length - 1; i++) {\n        // start iteration at i, intersections for k < i have already\n        // been checked in previous outer loop iterations\n        for (let k = i; k < line2.length - 1; k++) {\n          if (line1 === line2) {\n            // segments are adjacent and always share a vertex, not a kink\n            if (Math.abs(i - k) === 1) {\n              continue;\n            }\n            // first and last segment in a closed lineString or ring always share a vertex, not a kink\n            if (\n              // segments are first and last segment of lineString\n              i === 0 &&\n              k === line1.length - 2 &&\n              // lineString is closed\n              line1[i][0] === line1[line1.length - 1][0] &&\n              line1[i][1] === line1[line1.length - 1][1]\n            ) {\n              continue;\n            }\n          }\n\n          const intersection: any = lineIntersects(\n            line1[i][0],\n            line1[i][1],\n            line1[i + 1][0],\n            line1[i + 1][1],\n            line2[k][0],\n            line2[k][1],\n            line2[k + 1][0],\n            line2[k + 1][1]\n          );\n          if (intersection) {\n            results.features.push(point([intersection[0], intersection[1]]));\n          }\n        }\n      }\n    });\n  });\n  return results;\n}\n\n// modified from http://jsfiddle.net/justin_c_rounds/Gd2S2/light/\nfunction lineIntersects(\n  line1StartX: any,\n  line1StartY: any,\n  line1EndX: any,\n  line1EndY: any,\n  line2StartX: any,\n  line2StartY: any,\n  line2EndX: any,\n  line2EndY: any\n) {\n  // if the lines intersect, the result contains the x and y of the\n  // intersection (treating the lines as infinite) and booleans for whether\n  // line segment 1 or line segment 2 contain the point\n  let denominator;\n  let a;\n  let b;\n  let numerator1;\n  let numerator2;\n  const result = {\n    x: null,\n    y: null,\n    onLine1: false,\n    onLine2: false,\n  };\n  denominator =\n    (line2EndY - line2StartY) * (line1EndX - line1StartX) -\n    (line2EndX - line2StartX) * (line1EndY - line1StartY);\n  if (denominator === 0) {\n    if (result.x !== null && result.y !== null) {\n      return result;\n    } else {\n      return false;\n    }\n  }\n  a = line1StartY - line2StartY;\n  b = line1StartX - line2StartX;\n  numerator1 = (line2EndX - line2StartX) * a - (line2EndY - line2StartY) * b;\n  numerator2 = (line1EndX - line1StartX) * a - (line1EndY - line1StartY) * b;\n  a = numerator1 / denominator;\n  b = numerator2 / denominator;\n\n  // if we cast these lines infinitely in both directions, they intersect here:\n  result.x = line1StartX + a * (line1EndX - line1StartX);\n  result.y = line1StartY + a * (line1EndY - line1StartY);\n\n  // if line1 is a segment and line2 is infinite, they intersect if:\n  if (a >= 0 && a <= 1) {\n    result.onLine1 = true;\n  }\n  // if line2 is a segment and line1 is infinite, they intersect if:\n  if (b >= 0 && b <= 1) {\n    result.onLine2 = true;\n  }\n  // if line1 and line2 are segments, they intersect if both of the above are true\n  if (result.onLine1 && result.onLine2) {\n    return [result.x, result.y];\n  } else {\n    return false;\n  }\n}\n\nexport { kinks };\nexport default kinks;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}