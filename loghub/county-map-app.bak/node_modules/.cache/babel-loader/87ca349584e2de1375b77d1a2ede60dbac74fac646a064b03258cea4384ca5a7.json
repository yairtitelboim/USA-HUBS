{"ast":null,"code":"// index.ts\nimport { clone } from \"@turf/clone\";\nimport { coordAll, featureEach } from \"@turf/meta\";\nimport skmeans from \"skmeans\";\nfunction clustersKmeans(points, options = {}) {\n  var count = points.features.length;\n  options.numberOfClusters = options.numberOfClusters || Math.round(Math.sqrt(count / 2));\n  if (options.numberOfClusters > count) options.numberOfClusters = count;\n  if (options.mutate !== true) points = clone(points);\n  var data = coordAll(points);\n  var initialCentroids = data.slice(0, options.numberOfClusters);\n  var skmeansResult = skmeans(data, options.numberOfClusters, initialCentroids);\n  var centroids = {};\n  skmeansResult.centroids.forEach(function (coord, idx) {\n    centroids[idx] = coord;\n  });\n  featureEach(points, function (point, index) {\n    var clusterId = skmeansResult.idxs[index];\n    point.properties.cluster = clusterId;\n    point.properties.centroid = centroids[clusterId];\n  });\n  return points;\n}\nvar turf_clusters_kmeans_default = clustersKmeans;\nexport { clustersKmeans, turf_clusters_kmeans_default as default };","map":{"version":3,"names":["clone","coordAll","featureEach","skmeans","clustersKmeans","points","options","count","features","length","numberOfClusters","Math","round","sqrt","mutate","data","initialCentroids","slice","skmeansResult","centroids","forEach","coord","idx","point","index","clusterId","idxs","properties","cluster","centroid","turf_clusters_kmeans_default"],"sources":["/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/clusters-kmeans/index.ts"],"sourcesContent":["import { FeatureCollection, Point, GeoJsonProperties } from \"geojson\";\nimport { clone } from \"@turf/clone\";\nimport { coordAll, featureEach } from \"@turf/meta\";\nimport skmeans from \"skmeans\";\n\ntype KmeansProps = GeoJsonProperties & {\n  cluster?: number;\n  centroid?: [number, number];\n};\n\n/**\n * Takes a set of {@link Point|points} and partition them into clusters using the k-mean .\n * It uses the [k-means algorithm](https://en.wikipedia.org/wiki/K-means_clustering)\n *\n * @function\n * @param {FeatureCollection<Point>} points to be clustered\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.numberOfClusters=Math.sqrt(numberOfPoints/2)] numberOfClusters that will be generated\n * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated (significant performance increase if true)\n * @returns {FeatureCollection<Point>} Clustered Points with an additional two properties associated to each Feature:\n * - {number} cluster - the associated clusterId\n * - {[number, number]} centroid - Centroid of the cluster [Longitude, Latitude]\n * @example\n * // create random points with random z-values in their properties\n * var points = turf.randomPoint(100, {bbox: [0, 30, 20, 50]});\n * var options = {numberOfClusters: 7};\n * var clustered = turf.clustersKmeans(points, options);\n *\n * //addToMap\n * var addToMap = [clustered];\n */\nfunction clustersKmeans(\n  points: FeatureCollection<Point>,\n  options: {\n    numberOfClusters?: number;\n    mutate?: boolean;\n  } = {}\n): FeatureCollection<Point, KmeansProps> {\n  // Default Params\n  var count = points.features.length;\n  options.numberOfClusters =\n    options.numberOfClusters || Math.round(Math.sqrt(count / 2));\n\n  // numberOfClusters can't be greater than the number of points\n  // fallbacks to count\n  if (options.numberOfClusters > count) options.numberOfClusters = count;\n\n  // Clone points to prevent any mutations (enabled by default)\n  if (options.mutate !== true) points = clone(points);\n\n  // collect points coordinates\n  var data = coordAll(points);\n\n  // create seed to avoid skmeans to drift\n  var initialCentroids = data.slice(0, options.numberOfClusters);\n\n  // create skmeans clusters\n  var skmeansResult = skmeans(data, options.numberOfClusters, initialCentroids);\n\n  // store centroids {clusterId: [number, number]}\n  var centroids: Record<string, number[]> = {};\n  (skmeansResult.centroids as number[][]).forEach(function (\n    coord: number[],\n    idx: number\n  ) {\n    centroids[idx] = coord;\n  });\n\n  // add associated cluster number\n  featureEach(points, function (point, index) {\n    var clusterId = skmeansResult.idxs[index];\n    point.properties!.cluster = clusterId;\n    point.properties!.centroid = centroids[clusterId];\n  });\n\n  return points as FeatureCollection<Point, KmeansProps>;\n}\n\nexport { clustersKmeans, KmeansProps };\nexport default clustersKmeans;\n"],"mappings":";AACA,SAASA,KAAA,QAAa;AACtB,SAASC,QAAA,EAAUC,WAAA,QAAmB;AACtC,OAAOC,OAAA,MAAa;AA4BpB,SAASC,eACPC,MAAA,EACAC,OAAA,GAGI,CAAC,GACkC;EAEvC,IAAIC,KAAA,GAAQF,MAAA,CAAOG,QAAA,CAASC,MAAA;EAC5BH,OAAA,CAAQI,gBAAA,GACNJ,OAAA,CAAQI,gBAAA,IAAoBC,IAAA,CAAKC,KAAA,CAAMD,IAAA,CAAKE,IAAA,CAAKN,KAAA,GAAQ,CAAC,CAAC;EAI7D,IAAID,OAAA,CAAQI,gBAAA,GAAmBH,KAAA,EAAOD,OAAA,CAAQI,gBAAA,GAAmBH,KAAA;EAGjE,IAAID,OAAA,CAAQQ,MAAA,KAAW,MAAMT,MAAA,GAASL,KAAA,CAAMK,MAAM;EAGlD,IAAIU,IAAA,GAAOd,QAAA,CAASI,MAAM;EAG1B,IAAIW,gBAAA,GAAmBD,IAAA,CAAKE,KAAA,CAAM,GAAGX,OAAA,CAAQI,gBAAgB;EAG7D,IAAIQ,aAAA,GAAgBf,OAAA,CAAQY,IAAA,EAAMT,OAAA,CAAQI,gBAAA,EAAkBM,gBAAgB;EAG5E,IAAIG,SAAA,GAAsC,CAAC;EAC1CD,aAAA,CAAcC,SAAA,CAAyBC,OAAA,CAAQ,UAC9CC,KAAA,EACAC,GAAA,EACA;IACAH,SAAA,CAAUG,GAAG,IAAID,KAAA;EACnB,CAAC;EAGDnB,WAAA,CAAYG,MAAA,EAAQ,UAAUkB,KAAA,EAAOC,KAAA,EAAO;IAC1C,IAAIC,SAAA,GAAYP,aAAA,CAAcQ,IAAA,CAAKF,KAAK;IACxCD,KAAA,CAAMI,UAAA,CAAYC,OAAA,GAAUH,SAAA;IAC5BF,KAAA,CAAMI,UAAA,CAAYE,QAAA,GAAWV,SAAA,CAAUM,SAAS;EAClD,CAAC;EAED,OAAOpB,MAAA;AACT;AAGA,IAAOyB,4BAAA,GAAQ1B,cAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}