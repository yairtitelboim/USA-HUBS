{"ast":null,"code":"// index.ts\nimport { getGeom } from \"@turf/invariant\";\nfunction booleanConcave(polygon) {\n  const coords = getGeom(polygon).coordinates;\n  if (coords[0].length <= 4) {\n    return false;\n  }\n  let sign = false;\n  const n = coords[0].length - 1;\n  for (let i = 0; i < n; i++) {\n    const dx1 = coords[0][(i + 2) % n][0] - coords[0][(i + 1) % n][0];\n    const dy1 = coords[0][(i + 2) % n][1] - coords[0][(i + 1) % n][1];\n    const dx2 = coords[0][i][0] - coords[0][(i + 1) % n][0];\n    const dy2 = coords[0][i][1] - coords[0][(i + 1) % n][1];\n    const zcrossproduct = dx1 * dy2 - dy1 * dx2;\n    if (i === 0) {\n      sign = zcrossproduct > 0;\n    } else if (sign !== zcrossproduct > 0) {\n      return true;\n    }\n  }\n  return false;\n}\nvar turf_boolean_concave_default = booleanConcave;\nexport { booleanConcave, turf_boolean_concave_default as default };","map":{"version":3,"names":["getGeom","booleanConcave","polygon","coords","coordinates","length","sign","n","i","dx1","dy1","dx2","dy2","zcrossproduct","turf_boolean_concave_default"],"sources":["/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/boolean-concave/index.ts"],"sourcesContent":["import { Feature, Polygon } from \"geojson\";\nimport { getGeom } from \"@turf/invariant\";\n\n/**\n * Takes a polygon and return true or false as to whether it is concave or not.\n *\n * @function\n * @param {Feature<Polygon>} polygon to be evaluated\n * @returns {boolean} true/false\n * @example\n * var convexPolygon = turf.polygon([[[0,0],[0,1],[1,1],[1,0],[0,0]]]);\n *\n * turf.booleanConcave(convexPolygon)\n * //=false\n */\nfunction booleanConcave(polygon: Feature<Polygon> | Polygon) {\n  // Taken from https://stackoverflow.com/a/1881201 & https://stackoverflow.com/a/25304159\n  const coords = getGeom(polygon).coordinates;\n  if (coords[0].length <= 4) {\n    return false;\n  }\n\n  let sign = false;\n  const n = coords[0].length - 1;\n  for (let i = 0; i < n; i++) {\n    const dx1 = coords[0][(i + 2) % n][0] - coords[0][(i + 1) % n][0];\n    const dy1 = coords[0][(i + 2) % n][1] - coords[0][(i + 1) % n][1];\n    const dx2 = coords[0][i][0] - coords[0][(i + 1) % n][0];\n    const dy2 = coords[0][i][1] - coords[0][(i + 1) % n][1];\n    const zcrossproduct = dx1 * dy2 - dy1 * dx2;\n    if (i === 0) {\n      sign = zcrossproduct > 0;\n    } else if (sign !== zcrossproduct > 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport { booleanConcave };\nexport default booleanConcave;\n"],"mappings":";AACA,SAASA,OAAA,QAAe;AAcxB,SAASC,eAAeC,OAAA,EAAqC;EAE3D,MAAMC,MAAA,GAASH,OAAA,CAAQE,OAAO,EAAEE,WAAA;EAChC,IAAID,MAAA,CAAO,CAAC,EAAEE,MAAA,IAAU,GAAG;IACzB,OAAO;EACT;EAEA,IAAIC,IAAA,GAAO;EACX,MAAMC,CAAA,GAAIJ,MAAA,CAAO,CAAC,EAAEE,MAAA,GAAS;EAC7B,SAASG,CAAA,GAAI,GAAGA,CAAA,GAAID,CAAA,EAAGC,CAAA,IAAK;IAC1B,MAAMC,GAAA,GAAMN,MAAA,CAAO,CAAC,GAAGK,CAAA,GAAI,KAAKD,CAAC,EAAE,CAAC,IAAIJ,MAAA,CAAO,CAAC,GAAGK,CAAA,GAAI,KAAKD,CAAC,EAAE,CAAC;IAChE,MAAMG,GAAA,GAAMP,MAAA,CAAO,CAAC,GAAGK,CAAA,GAAI,KAAKD,CAAC,EAAE,CAAC,IAAIJ,MAAA,CAAO,CAAC,GAAGK,CAAA,GAAI,KAAKD,CAAC,EAAE,CAAC;IAChE,MAAMI,GAAA,GAAMR,MAAA,CAAO,CAAC,EAAEK,CAAC,EAAE,CAAC,IAAIL,MAAA,CAAO,CAAC,GAAGK,CAAA,GAAI,KAAKD,CAAC,EAAE,CAAC;IACtD,MAAMK,GAAA,GAAMT,MAAA,CAAO,CAAC,EAAEK,CAAC,EAAE,CAAC,IAAIL,MAAA,CAAO,CAAC,GAAGK,CAAA,GAAI,KAAKD,CAAC,EAAE,CAAC;IACtD,MAAMM,aAAA,GAAgBJ,GAAA,GAAMG,GAAA,GAAMF,GAAA,GAAMC,GAAA;IACxC,IAAIH,CAAA,KAAM,GAAG;MACXF,IAAA,GAAOO,aAAA,GAAgB;IACzB,WAAWP,IAAA,KAASO,aAAA,GAAgB,GAAG;MACrC,OAAO;IACT;EACF;EACA,OAAO;AACT;AAGA,IAAOC,4BAAA,GAAQb,cAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}