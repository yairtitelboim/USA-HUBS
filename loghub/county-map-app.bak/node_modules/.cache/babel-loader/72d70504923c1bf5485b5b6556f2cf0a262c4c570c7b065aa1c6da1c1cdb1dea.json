{"ast":null,"code":"// index.ts\nimport { lineString } from \"@turf/helpers\";\nimport { getGeom } from \"@turf/invariant\";\n\n// lib/spline.ts\nvar Spline = class {\n  constructor(options) {\n    this.points = options.points || [];\n    this.duration = options.duration || 1e4;\n    this.sharpness = options.sharpness || 0.85;\n    this.centers = [];\n    this.controls = [];\n    this.stepLength = options.stepLength || 60;\n    this.length = this.points.length;\n    this.delay = 0;\n    for (let i = 0; i < this.length; i++) {\n      this.points[i].z = this.points[i].z || 0;\n    }\n    for (let i = 0; i < this.length - 1; i++) {\n      const p1 = this.points[i];\n      const p2 = this.points[i + 1];\n      this.centers.push({\n        x: (p1.x + p2.x) / 2,\n        y: (p1.y + p2.y) / 2,\n        z: (p1.z + p2.z) / 2\n      });\n    }\n    this.controls.push([this.points[0], this.points[0]]);\n    for (let i = 0; i < this.centers.length - 1; i++) {\n      const dx = this.points[i + 1].x - (this.centers[i].x + this.centers[i + 1].x) / 2;\n      const dy = this.points[i + 1].y - (this.centers[i].y + this.centers[i + 1].y) / 2;\n      const dz = this.points[i + 1].z - (this.centers[i].y + this.centers[i + 1].z) / 2;\n      this.controls.push([{\n        x: (1 - this.sharpness) * this.points[i + 1].x + this.sharpness * (this.centers[i].x + dx),\n        y: (1 - this.sharpness) * this.points[i + 1].y + this.sharpness * (this.centers[i].y + dy),\n        z: (1 - this.sharpness) * this.points[i + 1].z + this.sharpness * (this.centers[i].z + dz)\n      }, {\n        x: (1 - this.sharpness) * this.points[i + 1].x + this.sharpness * (this.centers[i + 1].x + dx),\n        y: (1 - this.sharpness) * this.points[i + 1].y + this.sharpness * (this.centers[i + 1].y + dy),\n        z: (1 - this.sharpness) * this.points[i + 1].z + this.sharpness * (this.centers[i + 1].z + dz)\n      }]);\n    }\n    this.controls.push([this.points[this.length - 1], this.points[this.length - 1]]);\n    this.steps = this.cacheSteps(this.stepLength);\n    return this;\n  }\n  /**\n   * Caches an array of equidistant (more or less) points on the curve.\n   */\n  cacheSteps(mindist) {\n    const steps = [];\n    let laststep = this.pos(0);\n    steps.push(0);\n    for (let t = 0; t < this.duration; t += 10) {\n      const step = this.pos(t);\n      const dist = Math.sqrt((step.x - laststep.x) * (step.x - laststep.x) + (step.y - laststep.y) * (step.y - laststep.y) + (step.z - laststep.z) * (step.z - laststep.z));\n      if (dist > mindist) {\n        steps.push(t);\n        laststep = step;\n      }\n    }\n    return steps;\n  }\n  /**\n   * returns angle and speed in the given point in the curve\n   */\n  vector(t) {\n    const p1 = this.pos(t + 10);\n    const p2 = this.pos(t - 10);\n    return {\n      angle: 180 * Math.atan2(p1.y - p2.y, p1.x - p2.x) / 3.14,\n      speed: Math.sqrt((p2.x - p1.x) * (p2.x - p1.x) + (p2.y - p1.y) * (p2.y - p1.y) + (p2.z - p1.z) * (p2.z - p1.z))\n    };\n  }\n  /**\n   * Gets the position of the point, given time.\n   *\n   * WARNING: The speed is not constant. The time it takes between control points is constant.\n   *\n   * For constant speed, use Spline.steps[i];\n   */\n  pos(time) {\n    let t = time - this.delay;\n    if (t < 0) {\n      t = 0;\n    }\n    if (t > this.duration) {\n      t = this.duration - 1;\n    }\n    const t2 = t / this.duration;\n    if (t2 >= 1) {\n      return this.points[this.length - 1];\n    }\n    const n = Math.floor((this.points.length - 1) * t2);\n    const t1 = (this.length - 1) * t2 - n;\n    return bezier(t1, this.points[n], this.controls[n][1], this.controls[n + 1][0], this.points[n + 1]);\n  }\n};\nfunction bezier(t, p1, c1, c2, p2) {\n  const b = B(t);\n  const pos = {\n    x: p2.x * b[0] + c2.x * b[1] + c1.x * b[2] + p1.x * b[3],\n    y: p2.y * b[0] + c2.y * b[1] + c1.y * b[2] + p1.y * b[3],\n    z: p2.z * b[0] + c2.z * b[1] + c1.z * b[2] + p1.z * b[3]\n  };\n  return pos;\n}\nfunction B(t) {\n  const t2 = t * t;\n  const t3 = t2 * t;\n  return [t3, 3 * t2 * (1 - t), 3 * t * (1 - t) * (1 - t), (1 - t) * (1 - t) * (1 - t)];\n}\n\n// index.ts\nfunction bezierSpline(line, options = {}) {\n  const resolution = options.resolution || 1e4;\n  const sharpness = options.sharpness || 0.85;\n  const coords = [];\n  const points = getGeom(line).coordinates.map(pt => {\n    return {\n      x: pt[0],\n      y: pt[1]\n    };\n  });\n  const spline = new Spline({\n    duration: resolution,\n    points,\n    sharpness\n  });\n  const pushCoord = time => {\n    var pos = spline.pos(time);\n    if (Math.floor(time / 100) % 2 === 0) {\n      coords.push([pos.x, pos.y]);\n    }\n  };\n  for (var i = 0; i < spline.duration; i += 10) {\n    pushCoord(i);\n  }\n  pushCoord(spline.duration);\n  return lineString(coords, options.properties);\n}\nvar turf_bezier_spline_default = bezierSpline;\nexport { bezierSpline, turf_bezier_spline_default as default };","map":{"version":3,"names":["lineString","getGeom","Spline","constructor","options","points","duration","sharpness","centers","controls","stepLength","length","delay","i","z","p1","p2","push","x","y","dx","dy","dz","steps","cacheSteps","mindist","laststep","pos","t","step","dist","Math","sqrt","vector","angle","atan2","speed","time","t2","n","floor","t1","bezier","c1","c2","b","B","t3","bezierSpline","line","resolution","coords","coordinates","map","pt","spline","pushCoord","properties","turf_bezier_spline_default"],"sources":["/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/bezier-spline/index.ts","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/bezier-spline/lib/spline.ts"],"sourcesContent":["import { Feature, LineString, GeoJsonProperties } from \"geojson\";\nimport { lineString } from \"@turf/helpers\";\nimport { getGeom } from \"@turf/invariant\";\nimport { Spline } from \"./lib/spline.js\";\n\n/**\n * Takes a {@link LineString|line} and returns a curved version\n * by applying a [Bezier spline](http://en.wikipedia.org/wiki/B%C3%A9zier_spline)\n * algorithm.\n *\n * The bezier spline implementation is by [Leszek Rybicki](http://leszek.rybicki.cc/).\n *\n * @function\n * @param {Feature<LineString>} line input LineString\n * @param {Object} [options={}] Optional parameters\n * @param {Object} [options.properties={}] Translate properties to output\n * @param {number} [options.resolution=10000] time in milliseconds between points\n * @param {number} [options.sharpness=0.85] a measure of how curvy the path should be between splines\n * @returns {Feature<LineString>} curved line\n * @example\n * var line = turf.lineString([\n *   [-76.091308, 18.427501],\n *   [-76.695556, 18.729501],\n *   [-76.552734, 19.40443],\n *   [-74.61914, 19.134789],\n *   [-73.652343, 20.07657],\n *   [-73.157958, 20.210656]\n * ]);\n *\n * var curved = turf.bezierSpline(line);\n *\n * //addToMap\n * var addToMap = [line, curved]\n * curved.properties = { stroke: '#0F0' };\n */\nfunction bezierSpline<P extends GeoJsonProperties = GeoJsonProperties>(\n  line: Feature<LineString> | LineString,\n  options: {\n    properties?: P;\n    resolution?: number;\n    sharpness?: number;\n  } = {}\n): Feature<LineString, P> {\n  // Optional params\n  const resolution = options.resolution || 10000;\n  const sharpness = options.sharpness || 0.85;\n\n  const coords: [number, number][] = [];\n  const points = getGeom(line).coordinates.map((pt) => {\n    return { x: pt[0], y: pt[1] };\n  });\n  const spline = new Spline({\n    duration: resolution,\n    points,\n    sharpness,\n  });\n\n  const pushCoord = (time: number) => {\n    var pos = spline.pos(time);\n    if (Math.floor(time / 100) % 2 === 0) {\n      coords.push([pos.x, pos.y]);\n    }\n  };\n\n  for (var i = 0; i < spline.duration; i += 10) {\n    pushCoord(i);\n  }\n  pushCoord(spline.duration);\n\n  return lineString(coords, options.properties);\n}\n\nexport { bezierSpline };\nexport default bezierSpline;\n","interface Point {\n  x: number;\n  y: number;\n  z: number;\n}\n\n/**\n * BezierSpline\n * https://github.com/leszekr/bezier-spline-js\n *\n * @private\n * @copyright\n * Copyright (c) 2013 Leszek Rybicki\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\nclass Spline {\n  public duration: number;\n  public points: Point[];\n  public sharpness: number;\n  public centers: Point[];\n  public controls: Array<[Point, Point]>;\n  public stepLength: number;\n  public length: number;\n  public delay: number;\n  public steps: number[];\n\n  constructor(options?: any) {\n    this.points = options.points || [];\n    this.duration = options.duration || 10000;\n    this.sharpness = options.sharpness || 0.85;\n    this.centers = [];\n    this.controls = [];\n    this.stepLength = options.stepLength || 60;\n    this.length = this.points.length;\n    this.delay = 0;\n\n    // this is to ensure compatibility with the 2d version\n    for (let i = 0; i < this.length; i++) {\n      this.points[i].z = this.points[i].z || 0;\n    }\n    for (let i = 0; i < this.length - 1; i++) {\n      const p1 = this.points[i];\n      const p2 = this.points[i + 1];\n      this.centers.push({\n        x: (p1.x + p2.x) / 2,\n        y: (p1.y + p2.y) / 2,\n        z: (p1.z + p2.z) / 2,\n      });\n    }\n    this.controls.push([this.points[0], this.points[0]]);\n    for (let i = 0; i < this.centers.length - 1; i++) {\n      const dx =\n        this.points[i + 1].x - (this.centers[i].x + this.centers[i + 1].x) / 2;\n      const dy =\n        this.points[i + 1].y - (this.centers[i].y + this.centers[i + 1].y) / 2;\n      const dz =\n        this.points[i + 1].z - (this.centers[i].y + this.centers[i + 1].z) / 2;\n      this.controls.push([\n        {\n          x:\n            (1.0 - this.sharpness) * this.points[i + 1].x +\n            this.sharpness * (this.centers[i].x + dx),\n          y:\n            (1.0 - this.sharpness) * this.points[i + 1].y +\n            this.sharpness * (this.centers[i].y + dy),\n          z:\n            (1.0 - this.sharpness) * this.points[i + 1].z +\n            this.sharpness * (this.centers[i].z + dz),\n        },\n        {\n          x:\n            (1.0 - this.sharpness) * this.points[i + 1].x +\n            this.sharpness * (this.centers[i + 1].x + dx),\n          y:\n            (1.0 - this.sharpness) * this.points[i + 1].y +\n            this.sharpness * (this.centers[i + 1].y + dy),\n          z:\n            (1.0 - this.sharpness) * this.points[i + 1].z +\n            this.sharpness * (this.centers[i + 1].z + dz),\n        },\n      ]);\n    }\n    this.controls.push([\n      this.points[this.length - 1],\n      this.points[this.length - 1],\n    ]);\n    this.steps = this.cacheSteps(this.stepLength);\n    return this;\n  }\n  /**\n   * Caches an array of equidistant (more or less) points on the curve.\n   */\n  public cacheSteps(mindist: number) {\n    const steps = [];\n    let laststep = this.pos(0);\n    steps.push(0);\n    for (let t = 0; t < this.duration; t += 10) {\n      const step = this.pos(t);\n      const dist = Math.sqrt(\n        (step.x - laststep.x) * (step.x - laststep.x) +\n          (step.y - laststep.y) * (step.y - laststep.y) +\n          (step.z - laststep.z) * (step.z - laststep.z)\n      );\n      if (dist > mindist) {\n        steps.push(t);\n        laststep = step;\n      }\n    }\n    return steps;\n  }\n\n  /**\n   * returns angle and speed in the given point in the curve\n   */\n  public vector(t: number) {\n    const p1 = this.pos(t + 10);\n    const p2 = this.pos(t - 10);\n    return {\n      angle: (180 * Math.atan2(p1.y - p2.y, p1.x - p2.x)) / 3.14,\n      speed: Math.sqrt(\n        (p2.x - p1.x) * (p2.x - p1.x) +\n          (p2.y - p1.y) * (p2.y - p1.y) +\n          (p2.z - p1.z) * (p2.z - p1.z)\n      ),\n    };\n  }\n\n  /**\n   * Gets the position of the point, given time.\n   *\n   * WARNING: The speed is not constant. The time it takes between control points is constant.\n   *\n   * For constant speed, use Spline.steps[i];\n   */\n  public pos(time: number) {\n    let t = time - this.delay;\n    if (t < 0) {\n      t = 0;\n    }\n    if (t > this.duration) {\n      t = this.duration - 1;\n    }\n    // t = t-this.delay;\n    const t2 = t / this.duration;\n    if (t2 >= 1) {\n      return this.points[this.length - 1];\n    }\n\n    const n = Math.floor((this.points.length - 1) * t2);\n    const t1 = (this.length - 1) * t2 - n;\n    return bezier(\n      t1,\n      this.points[n],\n      this.controls[n][1],\n      this.controls[n + 1][0],\n      this.points[n + 1]\n    );\n  }\n}\n\nfunction bezier(t: number, p1: Point, c1: Point, c2: Point, p2: Point) {\n  const b = B(t);\n  const pos = {\n    x: p2.x * b[0] + c2.x * b[1] + c1.x * b[2] + p1.x * b[3],\n    y: p2.y * b[0] + c2.y * b[1] + c1.y * b[2] + p1.y * b[3],\n    z: p2.z * b[0] + c2.z * b[1] + c1.z * b[2] + p1.z * b[3],\n  };\n  return pos;\n}\nfunction B(t: number) {\n  const t2 = t * t;\n  const t3 = t2 * t;\n  return [\n    t3,\n    3 * t2 * (1 - t),\n    3 * t * (1 - t) * (1 - t),\n    (1 - t) * (1 - t) * (1 - t),\n  ];\n}\n\nexport { Spline, Point };\nexport default Spline;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}