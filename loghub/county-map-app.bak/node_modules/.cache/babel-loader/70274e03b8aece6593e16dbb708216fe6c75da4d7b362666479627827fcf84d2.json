{"ast":null,"code":"// index.ts\nimport { area } from \"@turf/area\";\nimport { bbox } from \"@turf/bbox\";\nimport { bboxPolygon } from \"@turf/bbox-polygon\";\nimport { centroid } from \"@turf/centroid\";\nimport { distance } from \"@turf/distance\";\nimport { nearestPoint } from \"@turf/nearest-point\";\nimport { featureEach } from \"@turf/meta\";\nimport { convertArea, featureCollection } from \"@turf/helpers\";\nfunction nearestNeighborAnalysis(dataset, options) {\n  options = options || {};\n  const studyArea = options.studyArea || bboxPolygon(bbox(dataset));\n  const properties = options.properties || {};\n  const units = options.units || \"kilometers\";\n  const features = [];\n  featureEach(dataset, feature => {\n    features.push(centroid(feature));\n  });\n  const n = features.length;\n  const observedMeanDistance = features.map((feature, index) => {\n    const otherFeatures = featureCollection(features.filter((f, i) => {\n      return i !== index;\n    }));\n    return distance(feature, nearestPoint(feature, otherFeatures).geometry.coordinates, {\n      units\n    });\n  }).reduce((sum, value) => {\n    return sum + value;\n  }, 0) / n;\n  const populationDensity = n / convertArea(area(studyArea), \"meters\", units);\n  const expectedMeanDistance = 1 / (2 * Math.sqrt(populationDensity));\n  const variance = 0.26136 / Math.sqrt(n * populationDensity);\n  properties.nearestNeighborAnalysis = {\n    units,\n    arealUnits: units + \"\\xB2\",\n    observedMeanDistance,\n    expectedMeanDistance,\n    nearestNeighborIndex: observedMeanDistance / expectedMeanDistance,\n    numberOfPoints: n,\n    zScore: (observedMeanDistance - expectedMeanDistance) / variance\n  };\n  studyArea.properties = properties;\n  return studyArea;\n}\nvar turf_nearest_neighbor_analysis_default = nearestNeighborAnalysis;\nexport { turf_nearest_neighbor_analysis_default as default, nearestNeighborAnalysis };","map":{"version":3,"names":["area","bbox","bboxPolygon","centroid","distance","nearestPoint","featureEach","convertArea","featureCollection","nearestNeighborAnalysis","dataset","options","studyArea","properties","units","features","feature","push","n","length","observedMeanDistance","map","index","otherFeatures","filter","f","i","geometry","coordinates","reduce","sum","value","populationDensity","expectedMeanDistance","Math","sqrt","variance","arealUnits","nearestNeighborIndex","numberOfPoints","zScore","turf_nearest_neighbor_analysis_default"],"sources":["/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/nearest-neighbor-analysis/index.ts"],"sourcesContent":["import {\n  FeatureCollection,\n  Feature,\n  Point,\n  Polygon,\n  GeoJsonProperties,\n} from \"geojson\";\nimport { area } from \"@turf/area\";\nimport { bbox } from \"@turf/bbox\";\nimport { bboxPolygon } from \"@turf/bbox-polygon\";\nimport { centroid } from \"@turf/centroid\";\nimport { distance } from \"@turf/distance\";\nimport { nearestPoint } from \"@turf/nearest-point\";\nimport { featureEach } from \"@turf/meta\";\nimport {\n  convertArea,\n  featureCollection,\n  Units,\n  AreaUnits,\n} from \"@turf/helpers\";\n\n/**\n * Nearest neighbour statistics.\n *\n * @typedef {object} NearestNeighborStatistics\n * @property {(Units & AreaUnits)} units\n * @property {string} arealUnits\n * @property {number} observedMeanDistance\n * @property {number} expectedMeanDistance\n * @property {number} numberOfPoints\n * @property {number} zScore\n */\ninterface NearestNeighborStatistics {\n  units: Units & AreaUnits;\n  arealUnits: string;\n  observedMeanDistance: number;\n  expectedMeanDistance: number;\n  numberOfPoints: number;\n  zScore: number;\n}\n\n/**\n * Nearest neighbour study area polygon feature.\n *\n * @typedef {object} NearestNeighborStudyArea\n * @extends Feature<Polygon>\n * @property {GeoJsonProperties} properties\n * @property {NearestNeighborStatistics} properties.nearestNeighborAnalysis\n */\ninterface NearestNeighborStudyArea extends Feature<Polygon> {\n  properties: {\n    nearestNeighborAnalysis: NearestNeighborStatistics;\n    [key: string]: any;\n  };\n}\n\n/**\n * Nearest Neighbor Analysis calculates an index based the average distances\n * between points in the dataset, thereby providing inference as to whether the\n * data is clustered, dispersed, or randomly distributed within the study area.\n *\n * It returns a {@link Feature}<{@link Polygon}> of the study area, with the results of\n * the analysis attached as part of of the `nearestNeighborAnalysis` property\n * of the study area's `properties`. The attached\n * [_z_-score](https://en.wikipedia.org/wiki/Standard_score) indicates how many\n * standard deviations above or below the expected mean distance the data's\n * observed mean distance is. The more negative, the more clustered. The more\n * positive, the more evenly dispersed. A _z_-score between -2 and 2 indicates\n * a seemingly random distribution. That is, within _p_ of less than 0.05, the\n * distribution appears statistically significantly neither clustered nor\n * dispersed.\n *\n * **Remarks**\n *\n * - Though the analysis will work on any {@link FeatureCollection} type, it\n * works best with {@link Point} collections.\n *\n * - This analysis is _very_ sensitive to the study area provided.\n * If no {@link Feature}<{@link Polygon}> is passed as the study area, the function draws a box\n * around the data, which may distort the findings. This analysis works best\n * with a bounded area of interest within with the data is either clustered,\n * dispersed, or randomly distributed. For example, a city's subway stops may\n * look extremely clustered if the study area is an entire state. On the other\n * hand, they may look rather evenly dispersed if the study area is limited to\n * the city's downtown.\n *\n * **Bibliography**\n *\n * Philip J. Clark and Francis C. Evans, “Distance to Nearest Neighbor as a\n * Measure of Spatial Relationships in Populations,” _Ecology_ 35, no. 4\n * (1954): 445–453, doi:[10.2307/1931034](http://doi.org/10.2307/1931034).\n *\n * @function\n * @param {FeatureCollection<any>} dataset FeatureCollection (pref. of points) to study\n * @param {Object} [options={}] Optional parameters\n * @param {Feature<Polygon>} [options.studyArea] polygon representing the study area\n * @param {Units & AreaUnits} [options.units='kilometers'] unit of measurement for distances and, squared, area.\n * @param {GeoJsonProperties} [options.properties={}] properties\n * @returns {NearestNeighborStudyArea}  A polygon of the study area or an approximation of one.\n * @example\n * var bbox = [-65, 40, -63, 42];\n * var dataset = turf.randomPoint(100, { bbox: bbox });\n * var nearestNeighborStudyArea = turf.nearestNeighborAnalysis(dataset);\n *\n * //addToMap\n * var addToMap = [dataset, nearestNeighborStudyArea];\n */\nfunction nearestNeighborAnalysis(\n  dataset: FeatureCollection<any>,\n  options?: {\n    studyArea?: Feature<Polygon>;\n    units?: Units & AreaUnits;\n    properties?: GeoJsonProperties;\n  }\n): NearestNeighborStudyArea {\n  // Optional params\n  options = options || {};\n  const studyArea = options.studyArea || bboxPolygon(bbox(dataset));\n  const properties = options.properties || {};\n  const units = options.units || \"kilometers\";\n\n  const features: Array<Feature<Point>> = [];\n  featureEach(dataset, (feature) => {\n    features.push(centroid(feature));\n  });\n  const n = features.length;\n  const observedMeanDistance =\n    features\n      .map((feature, index) => {\n        const otherFeatures = featureCollection<Point>(\n          features.filter((f, i) => {\n            return i !== index;\n          })\n        );\n        // Have to add the ! to make typescript validation pass\n        // see https://stackoverflow.com/a/40350534/1979085\n        return distance(\n          feature,\n          nearestPoint(feature, otherFeatures).geometry!.coordinates,\n          { units }\n        );\n      })\n      .reduce((sum, value) => {\n        return sum + value;\n      }, 0) / n;\n\n  const populationDensity = n / convertArea(area(studyArea), \"meters\", units);\n  const expectedMeanDistance = 1 / (2 * Math.sqrt(populationDensity));\n  const variance = 0.26136 / Math.sqrt(n * populationDensity);\n  properties.nearestNeighborAnalysis = {\n    units: units,\n    arealUnits: units + \"²\",\n    observedMeanDistance: observedMeanDistance,\n    expectedMeanDistance: expectedMeanDistance,\n    nearestNeighborIndex: observedMeanDistance / expectedMeanDistance,\n    numberOfPoints: n,\n    zScore: (observedMeanDistance - expectedMeanDistance) / variance,\n  };\n  studyArea.properties = properties;\n\n  return studyArea as NearestNeighborStudyArea;\n}\n\nexport {\n  nearestNeighborAnalysis,\n  NearestNeighborStatistics,\n  NearestNeighborStudyArea,\n};\nexport default nearestNeighborAnalysis;\n"],"mappings":";AAOA,SAASA,IAAA,QAAY;AACrB,SAASC,IAAA,QAAY;AACrB,SAASC,WAAA,QAAmB;AAC5B,SAASC,QAAA,QAAgB;AACzB,SAASC,QAAA,QAAgB;AACzB,SAASC,YAAA,QAAoB;AAC7B,SAASC,WAAA,QAAmB;AAC5B,SACEC,WAAA,EACAC,iBAAA,QAGK;AAwFP,SAASC,wBACPC,OAAA,EACAC,OAAA,EAK0B;EAE1BA,OAAA,GAAUA,OAAA,IAAW,CAAC;EACtB,MAAMC,SAAA,GAAYD,OAAA,CAAQC,SAAA,IAAaV,WAAA,CAAYD,IAAA,CAAKS,OAAO,CAAC;EAChE,MAAMG,UAAA,GAAaF,OAAA,CAAQE,UAAA,IAAc,CAAC;EAC1C,MAAMC,KAAA,GAAQH,OAAA,CAAQG,KAAA,IAAS;EAE/B,MAAMC,QAAA,GAAkC,EAAC;EACzCT,WAAA,CAAYI,OAAA,EAAUM,OAAA,IAAY;IAChCD,QAAA,CAASE,IAAA,CAAKd,QAAA,CAASa,OAAO,CAAC;EACjC,CAAC;EACD,MAAME,CAAA,GAAIH,QAAA,CAASI,MAAA;EACnB,MAAMC,oBAAA,GACJL,QAAA,CACGM,GAAA,CAAI,CAACL,OAAA,EAASM,KAAA,KAAU;IACvB,MAAMC,aAAA,GAAgBf,iBAAA,CACpBO,QAAA,CAASS,MAAA,CAAO,CAACC,CAAA,EAAGC,CAAA,KAAM;MACxB,OAAOA,CAAA,KAAMJ,KAAA;IACf,CAAC,CACH;IAGA,OAAOlB,QAAA,CACLY,OAAA,EACAX,YAAA,CAAaW,OAAA,EAASO,aAAa,EAAEI,QAAA,CAAUC,WAAA,EAC/C;MAAEd;IAAM,CACV;EACF,CAAC,EACAe,MAAA,CAAO,CAACC,GAAA,EAAKC,KAAA,KAAU;IACtB,OAAOD,GAAA,GAAMC,KAAA;EACf,GAAG,CAAC,IAAIb,CAAA;EAEZ,MAAMc,iBAAA,GAAoBd,CAAA,GAAIX,WAAA,CAAYP,IAAA,CAAKY,SAAS,GAAG,UAAUE,KAAK;EAC1E,MAAMmB,oBAAA,GAAuB,KAAK,IAAIC,IAAA,CAAKC,IAAA,CAAKH,iBAAiB;EACjE,MAAMI,QAAA,GAAW,UAAUF,IAAA,CAAKC,IAAA,CAAKjB,CAAA,GAAIc,iBAAiB;EAC1DnB,UAAA,CAAWJ,uBAAA,GAA0B;IACnCK,KAAA;IACAuB,UAAA,EAAYvB,KAAA,GAAQ;IACpBM,oBAAA;IACAa,oBAAA;IACAK,oBAAA,EAAsBlB,oBAAA,GAAuBa,oBAAA;IAC7CM,cAAA,EAAgBrB,CAAA;IAChBsB,MAAA,GAASpB,oBAAA,GAAuBa,oBAAA,IAAwBG;EAC1D;EACAxB,SAAA,CAAUC,UAAA,GAAaA,UAAA;EAEvB,OAAOD,SAAA;AACT;AAOA,IAAO6B,sCAAA,GAAQhC,uBAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}