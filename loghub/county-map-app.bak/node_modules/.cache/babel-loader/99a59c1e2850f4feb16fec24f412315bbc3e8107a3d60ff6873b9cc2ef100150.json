{"ast":null,"code":"// index.ts\nimport { area } from \"@turf/area\";\nimport { bbox as turfBBox } from \"@turf/bbox\";\nimport { bboxPolygon } from \"@turf/bbox-polygon\";\nimport { getCoord } from \"@turf/invariant\";\nimport { squareGrid } from \"@turf/square-grid\";\nfunction quadratAnalysis(pointFeatureSet, options) {\n  options = options || {};\n  const studyBbox = options.studyBbox || turfBBox(pointFeatureSet);\n  const confidenceLevel = options.confidenceLevel || 20;\n  const points = pointFeatureSet.features;\n  const numOfPoints = points.length;\n  const sizeOfArea = area(bboxPolygon(studyBbox));\n  const lengthOfSide = Math.sqrt(sizeOfArea / numOfPoints * 2);\n  const grid = squareGrid(studyBbox, lengthOfSide, {\n    units: \"meters\"\n  });\n  const quadrats = grid.features;\n  const quadratIdDict = {};\n  for (let i = 0; i < quadrats.length; i++) {\n    quadratIdDict[i] = {\n      box: turfBBox(quadrats[i]),\n      cnt: 0\n    };\n  }\n  let sumOfPoint = 0;\n  for (const pt of points) {\n    for (const key of Object.keys(quadratIdDict)) {\n      const box = quadratIdDict[key].box;\n      if (inBBox(getCoord(pt), box)) {\n        quadratIdDict[key].cnt += 1;\n        sumOfPoint += 1;\n        break;\n      }\n    }\n  }\n  let maxCnt = 0;\n  for (const key of Object.keys(quadratIdDict)) {\n    const cnt = quadratIdDict[key].cnt;\n    if (cnt > maxCnt) {\n      maxCnt = cnt;\n    }\n  }\n  const expectedDistribution = [];\n  const numOfQuadrat = Object.keys(quadratIdDict).length;\n  const lambda = sumOfPoint / numOfQuadrat;\n  let cumulativeProbility = 0;\n  for (let x = 0; x < maxCnt + 1; x++) {\n    cumulativeProbility += Math.exp(-lambda) * Math.pow(lambda, x) / factorial(x);\n    expectedDistribution.push(cumulativeProbility);\n  }\n  const observedDistribution = [];\n  let cumulativeObservedQuads = 0;\n  for (let x = 0; x < maxCnt + 1; x++) {\n    for (const key of Object.keys(quadratIdDict)) {\n      if (quadratIdDict[key].cnt === x) {\n        cumulativeObservedQuads += 1;\n      }\n    }\n    const p = cumulativeObservedQuads / numOfQuadrat;\n    observedDistribution.push(p);\n  }\n  let maxDifference = 0;\n  for (let x = 0; x < maxCnt + 1; x++) {\n    const difference = Math.abs(expectedDistribution[x] - observedDistribution[x]);\n    if (difference > maxDifference) {\n      maxDifference = difference;\n    }\n  }\n  const k = K_TABLE[confidenceLevel];\n  const criticalValue = k / Math.sqrt(numOfQuadrat);\n  const result = {\n    criticalValue,\n    isRandom: true,\n    maxAbsoluteDifference: maxDifference,\n    observedDistribution\n  };\n  if (maxDifference > criticalValue) {\n    result.isRandom = false;\n  }\n  return result;\n}\nvar K_TABLE = {\n  20: 1.07275,\n  15: 1.13795,\n  10: 1.22385,\n  5: 1.3581,\n  2: 1.51743,\n  1: 1.62762\n};\nfunction inBBox(pt, bbox) {\n  return bbox[0] <= pt[0] && bbox[1] <= pt[1] && bbox[2] >= pt[0] && bbox[3] >= pt[1];\n}\nfunction factorial(num) {\n  const f = [];\n  function inner(n) {\n    if (n === 0 || n === 1) {\n      return 1;\n    }\n    if (f[n] > 0) {\n      return f[n];\n    }\n    return f[n] = inner(n - 1) * n;\n  }\n  return inner(num);\n}\nvar turf_quadrat_analysis_default = quadratAnalysis;\nexport { turf_quadrat_analysis_default as default, quadratAnalysis };","map":{"version":3,"names":["area","bbox","turfBBox","bboxPolygon","getCoord","squareGrid","quadratAnalysis","pointFeatureSet","options","studyBbox","confidenceLevel","points","features","numOfPoints","length","sizeOfArea","lengthOfSide","Math","sqrt","grid","units","quadrats","quadratIdDict","i","box","cnt","sumOfPoint","pt","key","Object","keys","inBBox","maxCnt","expectedDistribution","numOfQuadrat","lambda","cumulativeProbility","x","exp","pow","factorial","push","observedDistribution","cumulativeObservedQuads","p","maxDifference","difference","abs","k","K_TABLE","criticalValue","result","isRandom","maxAbsoluteDifference","num","f","inner","n","turf_quadrat_analysis_default"],"sources":["/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/quadrat-analysis/index.ts"],"sourcesContent":["import { BBox, FeatureCollection, Point } from \"geojson\";\nimport { area } from \"@turf/area\";\nimport { bbox as turfBBox } from \"@turf/bbox\";\nimport { bboxPolygon } from \"@turf/bbox-polygon\";\nimport { getCoord } from \"@turf/invariant\";\nimport { squareGrid } from \"@turf/square-grid\";\n\ninterface QuadratAnalysisResult {\n  criticalValue: number;\n  maxAbsoluteDifference: number;\n  isRandom: boolean;\n  observedDistribution: number[];\n}\n\n/**\n * Quadrat analysis lays a set of equal-size areas(quadrat) over the study area and counts\n * the number of features in each quadrat and creates a frequency table.\n * The table lists the number of quadrats containing no features,\n * the number containing one feature, two features, and so on,\n * all the way up to the quadrat containing the most features.\n * The method then creates the frequency table for the random distribution, usually based on a Poisson distribution.\n * The method uses the distribution to calculate the probability for 0 feature occuring,\n * 1 feature occuring, 2 features, and so on,\n * and lists these probabilities in the frequency table.\n * By comparing the two frequency tables, you can see whether the features create a pattern.\n * If the table for the observed distribution has more quadrats containing many features than the\n * table for the random distribution dose, then the features create a clustered pattern.\n *\n * It is hard to judge the frequency tables are similar or different just by looking at them.\n * So, we can use serval statistical tests to find out how much the frequency tables differ.\n * We use Kolmogorov-Smirnov test.This method calculates cumulative probabilities for both distributions,\n * and then compares the cumulative probabilities at each class level and selects the largest absolute difference D.\n * Then, the test compares D to the critical value for a confidence level you specify.\n * If D is greater than the critical value, the difference between  the observed distribution and\n * the random distribution is significant. The greater the value the bigger the difference.\n *\n * Traditionally, squares are used for the shape of the quadrats, in a regular grid(square-grid).\n * Some researchers suggest that the quadrat size equal twice the size of mean area per feature,\n * which is simply the area of the study area divided by the number of features.\n *\n *\n * @function\n * @param {FeatureCollection<Point>} pointFeatureSet point set to study\n * @param {Object} [options={}] optional parameters\n * @param {[number, number, number, number]} [options.studyBbox] bbox representing the study area\n * @param {20 | 15 | 10 | 5 | 2 | 1} [options.confidenceLevel=20] a confidence level.\n * The unit is percentage . 5 means 95%, value must be in {@link K_TABLE}\n * @returns {QuadratAnalysisResult} result\n * @example\n *\n * var bbox = [-65, 40, -63, 42];\n * var dataset = turf.randomPoint(100, { bbox: bbox });\n * var result = turf.quadratAnalysis(dataset);\n *\n */\nfunction quadratAnalysis(\n  pointFeatureSet: FeatureCollection<Point>,\n  options: {\n    studyBbox?: [number, number, number, number];\n    confidenceLevel?: 20 | 15 | 10 | 5 | 2 | 1;\n  }\n): QuadratAnalysisResult {\n  options = options || {};\n  const studyBbox = options.studyBbox || turfBBox(pointFeatureSet);\n  const confidenceLevel = options.confidenceLevel || 20;\n  const points = pointFeatureSet.features;\n\n  // create square-grid\n  const numOfPoints = points.length;\n  const sizeOfArea = area(bboxPolygon(studyBbox));\n  const lengthOfSide = Math.sqrt((sizeOfArea / numOfPoints) * 2);\n  const grid = squareGrid(studyBbox, lengthOfSide, {\n    units: \"meters\",\n  });\n  const quadrats = grid.features;\n\n  // count the number of features in each quadrat\n  const quadratIdDict: { [key: string]: { box: BBox; cnt: number } } = {};\n  for (let i = 0; i < quadrats.length; i++) {\n    quadratIdDict[i] = {\n      box: turfBBox(quadrats[i]),\n      cnt: 0,\n    };\n  }\n\n  let sumOfPoint = 0;\n  for (const pt of points) {\n    for (const key of Object.keys(quadratIdDict)) {\n      const box = quadratIdDict[key].box;\n      if (inBBox(getCoord(pt), box)) {\n        quadratIdDict[key].cnt += 1;\n        sumOfPoint += 1;\n        break;\n      }\n    }\n  }\n\n  // the most amount of features in quadrat\n  let maxCnt = 0;\n  for (const key of Object.keys(quadratIdDict)) {\n    const cnt = quadratIdDict[key].cnt;\n    if (cnt > maxCnt) {\n      maxCnt = cnt;\n    }\n  }\n\n  const expectedDistribution = [];\n  const numOfQuadrat = Object.keys(quadratIdDict).length;\n  const lambda = sumOfPoint / numOfQuadrat;\n\n  // get the cumulative probability of the random distribution\n  let cumulativeProbility = 0.0;\n  for (let x = 0; x < maxCnt + 1; x++) {\n    cumulativeProbility +=\n      (Math.exp(-lambda) * Math.pow(lambda, x)) / factorial(x);\n    expectedDistribution.push(cumulativeProbility);\n  }\n\n  // get the cumulative probability of the observed distribution\n  const observedDistribution = [];\n  let cumulativeObservedQuads = 0;\n  for (let x = 0; x < maxCnt + 1; x++) {\n    for (const key of Object.keys(quadratIdDict)) {\n      if (quadratIdDict[key].cnt === x) {\n        cumulativeObservedQuads += 1;\n      }\n    }\n    const p = cumulativeObservedQuads / numOfQuadrat;\n    observedDistribution.push(p);\n  }\n\n  // get the largest absolute difference between two distributions\n  let maxDifference = 0;\n  for (let x = 0; x < maxCnt + 1; x++) {\n    const difference = Math.abs(\n      expectedDistribution[x] - observedDistribution[x]\n    );\n    if (difference > maxDifference) {\n      maxDifference = difference;\n    }\n  }\n\n  const k = K_TABLE[confidenceLevel];\n\n  // statistical test\n  const criticalValue = k / Math.sqrt(numOfQuadrat);\n  const result: QuadratAnalysisResult = {\n    criticalValue,\n    isRandom: true,\n    maxAbsoluteDifference: maxDifference,\n    observedDistribution,\n  };\n\n  if (maxDifference > criticalValue) {\n    result.isRandom = false;\n  }\n\n  return result;\n}\n\n/**\n * the confidence level\n *\n * @constant\n * @type {Object}\n * @property {number} 20 1.07275\n * @property {number} 15 1.13795\n * @property {number} 10 1.22385\n * @property {number} 5 1.3581\n * @property {number} 2 1.51743\n * @property {number} 1 1.62762\n */\nconst K_TABLE = {\n  20: 1.07275,\n  15: 1.13795,\n  10: 1.22385,\n  5: 1.3581,\n  2: 1.51743,\n  1: 1.62762,\n};\n\n/**\n * the return type of the quadratAnalysis\n *\n * @typedef {object} QuadratAnalysisResult\n * @property {number} criticalValue\n * @property {number} maxAbsoluteDifference\n * @property {boolean} isRandom\n * @property {Array<number>} observedDistribution the cumulative distribution of observed features,\n * the index represents the number of features in the quadrat.\n */\n\n/**\n * inBBox from @turf/boolean-point-in-polygon\n *\n * @private\n * @param {Array<number>} pt point [x,y]\n * @param {BBox} bbox BBox [west, south, east, north]\n * @returns {boolean} true/false if point is inside BBox\n */\nfunction inBBox(pt: number[], bbox: BBox) {\n  return (\n    bbox[0] <= pt[0] && bbox[1] <= pt[1] && bbox[2] >= pt[0] && bbox[3] >= pt[1]\n  );\n}\n\n/**\n * https://stackoverflow.com/questions/3959211/fast-factorial-function-in-javascript\n * @private\n * @param {number} num Number\n * @returns {number} the factorial of num\n */\nfunction factorial(num: number) {\n  const f: number[] = [];\n  function inner(n: number): number {\n    if (n === 0 || n === 1) {\n      return 1;\n    }\n    if (f[n] > 0) {\n      return f[n];\n    }\n    return (f[n] = inner(n - 1) * n);\n  }\n  return inner(num);\n}\n\nexport { QuadratAnalysisResult, quadratAnalysis };\nexport default quadratAnalysis;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}