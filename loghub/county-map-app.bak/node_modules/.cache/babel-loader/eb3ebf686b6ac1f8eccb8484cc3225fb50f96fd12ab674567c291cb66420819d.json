{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\n\n// index.ts\nimport { bbox } from \"@turf/bbox\";\nimport { area } from \"@turf/area\";\nimport { booleanPointInPolygon } from \"@turf/boolean-point-in-polygon\";\nimport { explode } from \"@turf/explode\";\nimport { collectionOf as collectionOf2 } from \"@turf/invariant\";\nimport { polygon, multiPolygon, featureCollection, isObject as isObject2 } from \"@turf/helpers\";\n\n// lib/grid-to-matrix.js\nimport { getCoords, collectionOf } from \"@turf/invariant\";\nimport { featureEach } from \"@turf/meta\";\nimport { isObject } from \"@turf/helpers\";\nfunction gridToMatrix(grid, options) {\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var zProperty = options.zProperty || \"elevation\";\n  var flip = options.flip;\n  var flags = options.flags;\n  collectionOf(grid, \"Point\", \"input must contain Points\");\n  var pointsMatrix = sortPointsByLatLng(grid, flip);\n  var matrix = [];\n  for (var r = 0; r < pointsMatrix.length; r++) {\n    var pointRow = pointsMatrix[r];\n    var row = [];\n    for (var c = 0; c < pointRow.length; c++) {\n      var point = pointRow[c];\n      if (point.properties[zProperty]) row.push(point.properties[zProperty]);else row.push(0);\n      if (flags === true) point.properties.matrixPosition = [r, c];\n    }\n    matrix.push(row);\n  }\n  return matrix;\n}\nfunction sortPointsByLatLng(points, flip) {\n  var pointsByLatitude = {};\n  featureEach(points, function (point) {\n    var lat = getCoords(point)[1];\n    if (!pointsByLatitude[lat]) pointsByLatitude[lat] = [];\n    pointsByLatitude[lat].push(point);\n  });\n  var orderedRowsByLatitude = Object.keys(pointsByLatitude).map(function (lat) {\n    var row = pointsByLatitude[lat];\n    var rowOrderedByLongitude = row.sort(function (a, b) {\n      return getCoords(a)[0] - getCoords(b)[0];\n    });\n    return rowOrderedByLongitude;\n  });\n  var pointMatrix = orderedRowsByLatitude.sort(function (a, b) {\n    if (flip) return getCoords(a[0])[1] - getCoords(b[0])[1];else return getCoords(b[0])[1] - getCoords(a[0])[1];\n  });\n  return pointMatrix;\n}\n\n// index.ts\nimport { isoBands } from \"marchingsquares\";\nfunction isobands(pointGrid, breaks, options) {\n  options = options || {};\n  if (!isObject2(options)) throw new Error(\"options is invalid\");\n  const zProperty = options.zProperty || \"elevation\";\n  const commonProperties = options.commonProperties || {};\n  const breaksProperties = options.breaksProperties || [];\n  collectionOf2(pointGrid, \"Point\", \"Input must contain Points\");\n  if (!breaks) throw new Error(\"breaks is required\");\n  if (!Array.isArray(breaks)) throw new Error(\"breaks is not an Array\");\n  if (!isObject2(commonProperties)) throw new Error(\"commonProperties is not an Object\");\n  if (!Array.isArray(breaksProperties)) throw new Error(\"breaksProperties is not an Array\");\n  const matrix = gridToMatrix(pointGrid, {\n    zProperty,\n    flip: true\n  });\n  let contours = createContourLines(matrix, breaks, zProperty);\n  contours = rescaleContours(contours, matrix, pointGrid);\n  const multipolygons = contours.map((contour, index) => {\n    if (breaksProperties[index] && !isObject2(breaksProperties[index])) {\n      throw new Error(\"Each mappedProperty is required to be an Object\");\n    }\n    const contourProperties = __spreadValues(__spreadValues({}, commonProperties), breaksProperties[index]);\n    contourProperties[zProperty] = contour[zProperty];\n    const multiP = multiPolygon(contour.groupedRings, contourProperties);\n    return multiP;\n  });\n  return featureCollection(multipolygons);\n}\nfunction createContourLines(matrix, breaks, property) {\n  const contours = [];\n  for (let i = 1; i < breaks.length; i++) {\n    const lowerBand = +breaks[i - 1];\n    const upperBand = +breaks[i];\n    const isobandsCoords = isoBands(matrix, lowerBand, upperBand - lowerBand);\n    const nestedRings = orderByArea(isobandsCoords);\n    const groupedRings = groupNestedRings(nestedRings);\n    contours.push({\n      groupedRings,\n      [property]: lowerBand + \"-\" + upperBand\n    });\n  }\n  return contours;\n}\nfunction rescaleContours(contours, matrix, points) {\n  const gridBbox = bbox(points);\n  const originalWidth = gridBbox[2] - gridBbox[0];\n  const originalHeigth = gridBbox[3] - gridBbox[1];\n  const x0 = gridBbox[0];\n  const y0 = gridBbox[1];\n  const matrixWidth = matrix[0].length - 1;\n  const matrixHeight = matrix.length - 1;\n  const scaleX = originalWidth / matrixWidth;\n  const scaleY = originalHeigth / matrixHeight;\n  return contours.map(function (contour) {\n    contour.groupedRings = contour.groupedRings.map(function (lineRingSet) {\n      return lineRingSet.map(function (lineRing) {\n        return lineRing.map(point => [point[0] * scaleX + x0, point[1] * scaleY + y0]);\n      });\n    });\n    return contour;\n  });\n}\nfunction orderByArea(ringsCoords) {\n  const ringsWithArea = ringsCoords.map(function (coords) {\n    return {\n      ring: coords,\n      area: area(polygon([coords]))\n    };\n  });\n  ringsWithArea.sort(function (a, b) {\n    return b.area - a.area;\n  });\n  return ringsWithArea.map(function (x) {\n    return x.ring;\n  });\n}\nfunction groupNestedRings(orderedLinearRings) {\n  const lrList = orderedLinearRings.map(lr => {\n    return {\n      lrCoordinates: lr,\n      grouped: false\n    };\n  });\n  const groupedLinearRingsCoords = [];\n  while (!allGrouped(lrList)) {\n    for (let i = 0; i < lrList.length; i++) {\n      if (!lrList[i].grouped) {\n        const group = [];\n        group.push(lrList[i].lrCoordinates);\n        lrList[i].grouped = true;\n        const outerMostPoly = polygon([lrList[i].lrCoordinates]);\n        for (let j = i + 1; j < lrList.length; j++) {\n          if (!lrList[j].grouped) {\n            const lrPoly = polygon([lrList[j].lrCoordinates]);\n            if (isInside(lrPoly, outerMostPoly)) {\n              group.push(lrList[j].lrCoordinates);\n              lrList[j].grouped = true;\n            }\n          }\n        }\n        groupedLinearRingsCoords.push(group);\n      }\n    }\n  }\n  return groupedLinearRingsCoords;\n}\nfunction isInside(testPolygon, targetPolygon) {\n  const points = explode(testPolygon);\n  for (let i = 0; i < points.features.length; i++) {\n    if (!booleanPointInPolygon(points.features[i], targetPolygon)) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction allGrouped(list) {\n  for (let i = 0; i < list.length; i++) {\n    if (list[i].grouped === false) {\n      return false;\n    }\n  }\n  return true;\n}\nvar turf_isobands_default = isobands;\nexport { turf_isobands_default as default, isobands };","map":{"version":3,"names":["bbox","area","booleanPointInPolygon","explode","collectionOf","collectionOf2","polygon","multiPolygon","featureCollection","isObject","isObject2","getCoords","featureEach","gridToMatrix","grid","options","Error","zProperty","flip","flags","pointsMatrix","sortPointsByLatLng","matrix","r","length","pointRow","row","c","point","properties","push","matrixPosition","points","pointsByLatitude","lat","orderedRowsByLatitude","Object","keys","map","rowOrderedByLongitude","sort","a","b","pointMatrix","isoBands","isobands","pointGrid","breaks","commonProperties","breaksProperties","Array","isArray","contours","createContourLines","rescaleContours","multipolygons","contour","index","contourProperties","__spreadValues","multiP","groupedRings","property","i","lowerBand","upperBand","isobandsCoords","nestedRings","orderByArea","groupNestedRings","gridBbox","originalWidth","originalHeigth","x0","y0","matrixWidth","matrixHeight","scaleX","scaleY","lineRingSet","lineRing","ringsCoords","ringsWithArea","coords","ring","x","orderedLinearRings","lrList","lr","lrCoordinates","grouped","groupedLinearRingsCoords","allGrouped","group","outerMostPoly","j","lrPoly","isInside","testPolygon","targetPolygon","features","list","turf_isobands_default"],"sources":["/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/isobands/index.ts","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/isobands/lib/grid-to-matrix.js"],"sourcesContent":["import { bbox } from \"@turf/bbox\";\nimport { area } from \"@turf/area\";\nimport { booleanPointInPolygon } from \"@turf/boolean-point-in-polygon\";\nimport { explode } from \"@turf/explode\";\nimport { collectionOf } from \"@turf/invariant\";\nimport {\n  polygon,\n  multiPolygon,\n  featureCollection,\n  isObject,\n} from \"@turf/helpers\";\n\nimport {\n  FeatureCollection,\n  Point,\n  GeoJsonProperties,\n  MultiPolygon,\n  Position,\n  Polygon,\n  Feature,\n} from \"geojson\";\n\nimport { gridToMatrix } from \"./lib/grid-to-matrix.js\";\nimport { isoBands } from \"marchingsquares\";\n\ntype GroupRingProps = { [prop: string]: string };\ntype GroupedRings =\n  | {\n      groupedRings: Position[][][];\n    }\n  | GroupRingProps;\n\n/**\n * Takes a square or rectangular grid {@link FeatureCollection} of {@link Point} features with z-values and an array of\n * value breaks and generates filled contour isobands.\n *\n * @function\n * @param {FeatureCollection<Point>} pointGrid input points - must be square or rectangular\n * @param {Array<number>} breaks where to draw contours\n * @param {Object} [options={}] options on output\n * @param {string} [options.zProperty='elevation'] the property name in `points` from which z-values will be pulled\n * @param {Object} [options.commonProperties={}] GeoJSON properties passed to ALL isobands\n * @param {Array<Object>} [options.breaksProperties=[]] GeoJSON properties passed, in order, to the correspondent isoband (order defined by breaks)\n * @returns {FeatureCollection<MultiPolygon>} a FeatureCollection of {@link MultiPolygon} features representing isobands\n */\nfunction isobands(\n  pointGrid: FeatureCollection<Point>,\n  breaks: number[],\n  options?: {\n    zProperty?: string;\n    commonProperties?: GeoJsonProperties;\n    breaksProperties?: GeoJsonProperties[];\n  }\n): FeatureCollection<MultiPolygon> {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  const zProperty = options.zProperty || \"elevation\";\n  const commonProperties = options.commonProperties || {};\n  const breaksProperties = options.breaksProperties || [];\n\n  // Validation\n  collectionOf(pointGrid, \"Point\", \"Input must contain Points\");\n  if (!breaks) throw new Error(\"breaks is required\");\n  if (!Array.isArray(breaks)) throw new Error(\"breaks is not an Array\");\n  if (!isObject(commonProperties))\n    throw new Error(\"commonProperties is not an Object\");\n  if (!Array.isArray(breaksProperties))\n    throw new Error(\"breaksProperties is not an Array\");\n\n  // Isoband methods\n  const matrix = gridToMatrix(pointGrid, { zProperty: zProperty, flip: true });\n  let contours = createContourLines(matrix, breaks, zProperty);\n  contours = rescaleContours(contours, matrix, pointGrid);\n\n  const multipolygons = contours.map((contour, index) => {\n    if (breaksProperties[index] && !isObject(breaksProperties[index])) {\n      throw new Error(\"Each mappedProperty is required to be an Object\");\n    }\n    // collect all properties\n    const contourProperties = {\n      ...commonProperties,\n      ...breaksProperties[index],\n    };\n\n    contourProperties[zProperty] = (contour as GroupRingProps)[zProperty];\n\n    const multiP = multiPolygon(\n      contour.groupedRings as Position[][][],\n      contourProperties\n    );\n    return multiP;\n  });\n\n  return featureCollection(multipolygons);\n}\n\n/**\n * Creates the contours lines (featuresCollection of polygon features) from the 2D data grid\n *\n * Marchingsquares process the grid data as a 3D representation of a function on a 2D plane, therefore it\n * assumes the points (x-y coordinates) are one 'unit' distance. The result of the IsoBands function needs to be\n * rescaled, with turfjs, to the original area and proportions on the map\n *\n * @private\n * @param {Array<Array<number>>} matrix Grid Data\n * @param {Array<number>} breaks Breaks\n * @param {string} [property='elevation'] Property\n * @returns {Array<any>} contours\n */\nfunction createContourLines(\n  matrix: number[][],\n  breaks: number[],\n  property: string\n): GroupedRings[] {\n  const contours: GroupedRings[] = [];\n  for (let i = 1; i < breaks.length; i++) {\n    const lowerBand = +breaks[i - 1]; // make sure the breaks value is a number\n    const upperBand = +breaks[i];\n\n    const isobandsCoords = isoBands(matrix, lowerBand, upperBand - lowerBand);\n    // as per GeoJson rules for creating a Polygon, make sure the first element\n    // in the array of LinearRings represents the exterior ring (i.e. biggest area),\n    // and any subsequent elements represent interior rings (i.e. smaller area);\n    // this avoids rendering issues of the MultiPolygons on the map\n    const nestedRings = orderByArea(isobandsCoords);\n    const groupedRings = groupNestedRings(nestedRings);\n\n    contours.push({\n      groupedRings: groupedRings as Position[][][],\n      [property]: lowerBand + \"-\" + upperBand,\n    });\n  }\n  return contours;\n}\n\n/**\n * Transform isobands of 2D grid to polygons for the map\n *\n * @private\n * @param {Array<any>} contours Contours\n * @param {Array<Array<number>>} matrix Grid Data\n * @param {Object} points Points by Latitude\n * @returns {Array<any>} contours\n */\nfunction rescaleContours(\n  contours: GroupedRings[],\n  matrix: number[][],\n  points: FeatureCollection<Point>\n): GroupedRings[] {\n  // get dimensions (on the map) of the original grid\n  const gridBbox = bbox(points); // [ minX, minY, maxX, maxY ]\n  const originalWidth = gridBbox[2] - gridBbox[0];\n  const originalHeigth = gridBbox[3] - gridBbox[1];\n\n  // get origin, which is the first point of the last row on the rectangular data on the map\n  const x0 = gridBbox[0];\n  const y0 = gridBbox[1];\n  // get number of cells per side\n  const matrixWidth = matrix[0].length - 1;\n  const matrixHeight = matrix.length - 1;\n  // calculate the scaling factor between matrix and rectangular grid on the map\n  const scaleX = originalWidth / matrixWidth;\n  const scaleY = originalHeigth / matrixHeight;\n\n  // resize and shift each point/line of the isobands\n  return contours.map(function (contour) {\n    contour.groupedRings = (contour.groupedRings as Position[][][]).map(\n      function (lineRingSet) {\n        return lineRingSet.map(function (lineRing) {\n          return lineRing.map((point: Position) => [\n            point[0] * scaleX + x0,\n            point[1] * scaleY + y0,\n          ]);\n        });\n      }\n    );\n\n    return contour;\n  });\n}\n\n/*  utility functions */\n\n/**\n * Returns an array of coordinates (of LinearRings) in descending order by area\n *\n * @private\n * @param {Array<LineString>} ringsCoords array of closed LineString\n * @returns {Array} array of the input LineString ordered by area\n */\nfunction orderByArea(ringsCoords: Position[][]): Position[][] {\n  const ringsWithArea = ringsCoords.map(function (coords) {\n    // associate each lineRing with its area\n    return { ring: coords, area: area(polygon([coords])) };\n  });\n  ringsWithArea.sort(function (a, b) {\n    // bigger --> smaller\n    return b.area - a.area;\n  });\n  // create a new array of linearRings coordinates ordered by their area\n  return ringsWithArea.map(function (x) {\n    return x.ring;\n  });\n}\n\n/**\n * Returns an array of arrays of coordinates, each representing\n * a set of (coordinates of) nested LinearRings,\n * i.e. the first ring contains all the others\n *\n * @private\n * @param {Array} orderedLinearRings array of coordinates (of LinearRings) in descending order by area\n * @returns {Array<Array>} Array of coordinates of nested LinearRings\n */\nfunction groupNestedRings(orderedLinearRings: Position[][]): Position[][][] {\n  // create a list of the (coordinates of) LinearRings\n  const lrList = orderedLinearRings.map((lr) => {\n    return { lrCoordinates: lr, grouped: false };\n  });\n  const groupedLinearRingsCoords: Position[][][] = [];\n\n  while (!allGrouped(lrList)) {\n    for (let i = 0; i < lrList.length; i++) {\n      if (!lrList[i].grouped) {\n        // create new group starting with the larger not already grouped ring\n        const group: Position[][] = [];\n        group.push(lrList[i].lrCoordinates);\n        lrList[i].grouped = true;\n        const outerMostPoly = polygon([lrList[i].lrCoordinates]);\n        // group all the rings contained by the outermost ring\n        for (let j = i + 1; j < lrList.length; j++) {\n          if (!lrList[j].grouped) {\n            const lrPoly = polygon([lrList[j].lrCoordinates]);\n            if (isInside(lrPoly, outerMostPoly)) {\n              group.push(lrList[j].lrCoordinates);\n              lrList[j].grouped = true;\n            }\n          }\n        }\n        // insert the new group\n        groupedLinearRingsCoords.push(group);\n      }\n    }\n  }\n  return groupedLinearRingsCoords;\n}\n\n/**\n * @private\n * @param {Polygon} testPolygon polygon of interest\n * @param {Polygon} targetPolygon polygon you want to compare with\n * @returns {boolean} true if test-Polygon is inside target-Polygon\n */\nfunction isInside(\n  testPolygon: Feature<Polygon>,\n  targetPolygon: Feature<Polygon>\n): boolean {\n  const points = explode(testPolygon);\n  for (let i = 0; i < points.features.length; i++) {\n    if (!booleanPointInPolygon(points.features[i], targetPolygon)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * @private\n * @param {Array<Object>} list list of objects which might contain the 'group' attribute\n * @returns {boolean} true if all the objects in the list are marked as grouped\n */\nfunction allGrouped(\n  list: { grouped: boolean; lrCoordinates: Position[] }[]\n): boolean {\n  for (let i = 0; i < list.length; i++) {\n    if (list[i].grouped === false) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport { isobands };\nexport default isobands;\n","import { getCoords, collectionOf } from \"@turf/invariant\";\nimport { featureEach } from \"@turf/meta\";\nimport { isObject } from \"@turf/helpers\";\n\n/**\n * Takes a {@link Point} grid and returns a correspondent matrix {Array<Array<number>>}\n * of the 'property' values\n *\n * @name gridToMatrix\n * @param {FeatureCollection<Point>} grid of points\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.zProperty='elevation'] the property name in `points` from which z-values will be pulled\n * @param {boolean} [options.flip=false] returns the matrix upside-down\n * @param {boolean} [options.flags=false] flags, adding a `matrixPosition` array field ([row, column]) to its properties,\n * the grid points with coordinates on the matrix\n * @returns {Array<Array<number>>} matrix of property values\n * @example\n *   var extent = [-70.823364, -33.553984, -70.473175, -33.302986];\n *   var cellSize = 3;\n *   var grid = turf.pointGrid(extent, cellSize);\n *   // add a random property to each point between 0 and 60\n *   for (var i = 0; i < grid.features.length; i++) {\n *     grid.features[i].properties.elevation = (Math.random() * 60);\n *   }\n *   gridToMatrix(grid);\n *   //= [\n *     [ 1, 13, 10,  9, 10, 13, 18],\n *     [34,  8,  5,  4,  5,  8, 13],\n *     [10,  5,  2,  1,  2,  5,  4],\n *     [ 0,  4, 56, 19,  1,  4,  9],\n *     [10,  5,  2,  1,  2,  5, 10],\n *     [57,  8,  5,  4,  5,  0, 57],\n *     [ 3, 13, 10,  9,  5, 13, 18],\n *     [18, 13, 10,  9, 78, 13, 18]\n *   ]\n */\nfunction gridToMatrix(grid, options) {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var zProperty = options.zProperty || \"elevation\";\n  var flip = options.flip;\n  var flags = options.flags;\n\n  // validation\n  collectionOf(grid, \"Point\", \"input must contain Points\");\n\n  var pointsMatrix = sortPointsByLatLng(grid, flip);\n\n  var matrix = [];\n  // create property matrix from sorted points\n  // looping order matters here\n  for (var r = 0; r < pointsMatrix.length; r++) {\n    var pointRow = pointsMatrix[r];\n    var row = [];\n    for (var c = 0; c < pointRow.length; c++) {\n      var point = pointRow[c];\n      // Check if zProperty exist\n      if (point.properties[zProperty]) row.push(point.properties[zProperty]);\n      else row.push(0);\n      // add flags\n      if (flags === true) point.properties.matrixPosition = [r, c];\n    }\n    matrix.push(row);\n  }\n\n  return matrix;\n}\n\n/**\n * Sorts points by latitude and longitude, creating a 2-dimensional array of points\n *\n * @private\n * @param {FeatureCollection<Point>} points GeoJSON Point features\n * @param {boolean} [flip=false] returns the matrix upside-down\n * @returns {Array<Array<Point>>} points ordered by latitude and longitude\n */\nfunction sortPointsByLatLng(points, flip) {\n  var pointsByLatitude = {};\n\n  // divide points by rows with the same latitude\n  featureEach(points, function (point) {\n    var lat = getCoords(point)[1];\n    if (!pointsByLatitude[lat]) pointsByLatitude[lat] = [];\n    pointsByLatitude[lat].push(point);\n  });\n\n  // sort points (with the same latitude) by longitude\n  var orderedRowsByLatitude = Object.keys(pointsByLatitude).map(function (lat) {\n    var row = pointsByLatitude[lat];\n    var rowOrderedByLongitude = row.sort(function (a, b) {\n      return getCoords(a)[0] - getCoords(b)[0];\n    });\n    return rowOrderedByLongitude;\n  });\n\n  // sort rows (of points with the same latitude) by latitude\n  var pointMatrix = orderedRowsByLatitude.sort(function (a, b) {\n    if (flip) return getCoords(a[0])[1] - getCoords(b[0])[1];\n    else return getCoords(b[0])[1] - getCoords(a[0])[1];\n  });\n\n  return pointMatrix;\n}\n\nexport { gridToMatrix };\nexport default gridToMatrix;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}