{"ast":null,"code":"// index.ts\nimport { centroid } from \"@turf/centroid\";\nimport { rhumbBearing } from \"@turf/rhumb-bearing\";\nimport { rhumbDistance } from \"@turf/rhumb-distance\";\nimport { rhumbDestination } from \"@turf/rhumb-destination\";\nimport { clone } from \"@turf/clone\";\nimport { coordEach } from \"@turf/meta\";\nimport { getCoords } from \"@turf/invariant\";\nimport { isObject } from \"@turf/helpers\";\nfunction transformRotate(geojson, angle, options) {\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  const pivot = options.pivot;\n  const mutate = options.mutate;\n  if (!geojson) throw new Error(\"geojson is required\");\n  if (angle === void 0 || angle === null || isNaN(angle)) throw new Error(\"angle is required\");\n  if (angle === 0) return geojson;\n  const pivotCoord = pivot != null ? pivot : centroid(geojson);\n  if (mutate === false || mutate === void 0) geojson = clone(geojson);\n  coordEach(geojson, function (pointCoords) {\n    const initialAngle = rhumbBearing(pivotCoord, pointCoords);\n    const finalAngle = initialAngle + angle;\n    const distance = rhumbDistance(pivotCoord, pointCoords);\n    const newCoords = getCoords(rhumbDestination(pivotCoord, distance, finalAngle));\n    pointCoords[0] = newCoords[0];\n    pointCoords[1] = newCoords[1];\n  });\n  return geojson;\n}\nvar turf_transform_rotate_default = transformRotate;\nexport { turf_transform_rotate_default as default, transformRotate };","map":{"version":3,"names":["centroid","rhumbBearing","rhumbDistance","rhumbDestination","clone","coordEach","getCoords","isObject","transformRotate","geojson","angle","options","Error","pivot","mutate","isNaN","pivotCoord","pointCoords","initialAngle","finalAngle","distance","newCoords","turf_transform_rotate_default"],"sources":["/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/transform-rotate/index.ts"],"sourcesContent":["import { GeoJSON, GeometryCollection } from \"geojson\";\nimport { centroid } from \"@turf/centroid\";\nimport { rhumbBearing } from \"@turf/rhumb-bearing\";\nimport { rhumbDistance } from \"@turf/rhumb-distance\";\nimport { rhumbDestination } from \"@turf/rhumb-destination\";\nimport { clone } from \"@turf/clone\";\nimport { coordEach } from \"@turf/meta\";\nimport { getCoords } from \"@turf/invariant\";\nimport { isObject, Coord } from \"@turf/helpers\";\n\n/**\n * Rotates any geojson Feature or Geometry of a specified angle, around its `centroid` or a given `pivot` point.\n *\n * @function\n * @param {GeoJSON} geojson object to be rotated\n * @param {number} angle of rotation in decimal degrees, positive clockwise\n * @param {Object} [options={}] Optional parameters\n * @param {Coord} [options.pivot='centroid'] point around which the rotation will be performed\n * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated (significant performance increase if true)\n * @returns {GeoJSON} the rotated GeoJSON feature\n * @example\n * const poly = turf.polygon([[[0,29],[3.5,29],[2.5,32],[0,29]]]);\n * const options = {pivot: [0, 25]};\n * const rotatedPoly = turf.transformRotate(poly, 10, options);\n *\n * //addToMap\n * const addToMap = [poly, rotatedPoly];\n * rotatedPoly.properties = {stroke: '#F00', 'stroke-width': 4};\n */\nfunction transformRotate<T extends GeoJSON | GeometryCollection>(\n  geojson: T,\n  angle: number,\n  options?: {\n    pivot?: Coord;\n    mutate?: boolean;\n  }\n): T {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  const pivot = options.pivot;\n  const mutate = options.mutate;\n\n  // Input validation\n  if (!geojson) throw new Error(\"geojson is required\");\n  if (angle === undefined || angle === null || isNaN(angle))\n    throw new Error(\"angle is required\");\n\n  // Shortcut no-rotation\n  if (angle === 0) return geojson;\n\n  // Use centroid of GeoJSON if pivot is not provided\n  const pivotCoord = pivot ?? centroid(geojson);\n\n  // Clone geojson to avoid side effects\n  if (mutate === false || mutate === undefined) geojson = clone(geojson);\n\n  // Rotate each coordinate\n  coordEach(geojson, function (pointCoords) {\n    const initialAngle = rhumbBearing(pivotCoord, pointCoords);\n    const finalAngle = initialAngle + angle;\n    const distance = rhumbDistance(pivotCoord, pointCoords);\n    const newCoords = getCoords(\n      rhumbDestination(pivotCoord, distance, finalAngle)\n    );\n    pointCoords[0] = newCoords[0];\n    pointCoords[1] = newCoords[1];\n  });\n  return geojson;\n}\n\nexport { transformRotate };\nexport default transformRotate;\n"],"mappings":";AACA,SAASA,QAAA,QAAgB;AACzB,SAASC,YAAA,QAAoB;AAC7B,SAASC,aAAA,QAAqB;AAC9B,SAASC,gBAAA,QAAwB;AACjC,SAASC,KAAA,QAAa;AACtB,SAASC,SAAA,QAAiB;AAC1B,SAASC,SAAA,QAAiB;AAC1B,SAASC,QAAA,QAAuB;AAqBhC,SAASC,gBACPC,OAAA,EACAC,KAAA,EACAC,OAAA,EAIG;EAEHA,OAAA,GAAUA,OAAA,IAAW,CAAC;EACtB,IAAI,CAACJ,QAAA,CAASI,OAAO,GAAG,MAAM,IAAIC,KAAA,CAAM,oBAAoB;EAC5D,MAAMC,KAAA,GAAQF,OAAA,CAAQE,KAAA;EACtB,MAAMC,MAAA,GAASH,OAAA,CAAQG,MAAA;EAGvB,IAAI,CAACL,OAAA,EAAS,MAAM,IAAIG,KAAA,CAAM,qBAAqB;EACnD,IAAIF,KAAA,KAAU,UAAaA,KAAA,KAAU,QAAQK,KAAA,CAAML,KAAK,GACtD,MAAM,IAAIE,KAAA,CAAM,mBAAmB;EAGrC,IAAIF,KAAA,KAAU,GAAG,OAAOD,OAAA;EAGxB,MAAMO,UAAA,GAAaH,KAAA,WAAAA,KAAA,GAASb,QAAA,CAASS,OAAO;EAG5C,IAAIK,MAAA,KAAW,SAASA,MAAA,KAAW,QAAWL,OAAA,GAAUL,KAAA,CAAMK,OAAO;EAGrEJ,SAAA,CAAUI,OAAA,EAAS,UAAUQ,WAAA,EAAa;IACxC,MAAMC,YAAA,GAAejB,YAAA,CAAae,UAAA,EAAYC,WAAW;IACzD,MAAME,UAAA,GAAaD,YAAA,GAAeR,KAAA;IAClC,MAAMU,QAAA,GAAWlB,aAAA,CAAcc,UAAA,EAAYC,WAAW;IACtD,MAAMI,SAAA,GAAYf,SAAA,CAChBH,gBAAA,CAAiBa,UAAA,EAAYI,QAAA,EAAUD,UAAU,CACnD;IACAF,WAAA,CAAY,CAAC,IAAII,SAAA,CAAU,CAAC;IAC5BJ,WAAA,CAAY,CAAC,IAAII,SAAA,CAAU,CAAC;EAC9B,CAAC;EACD,OAAOZ,OAAA;AACT;AAGA,IAAOa,6BAAA,GAAQd,eAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}