{"ast":null,"code":"// index.ts\nimport { featureCollection } from \"@turf/helpers\";\n\n// lib/util.ts\nimport { booleanPointInPolygon } from \"@turf/boolean-point-in-polygon\";\nimport { point } from \"@turf/helpers\";\nfunction mathSign(x) {\n  return (x > 0) - (x < 0) || +x;\n}\nfunction orientationIndex(p1, p2, q) {\n  const dx1 = p2[0] - p1[0],\n    dy1 = p2[1] - p1[1],\n    dx2 = q[0] - p2[0],\n    dy2 = q[1] - p2[1];\n  return mathSign(dx1 * dy2 - dx2 * dy1);\n}\nfunction envelopeIsEqual(env1, env2) {\n  const envX1 = env1.geometry.coordinates[0].map(c => c[0]),\n    envY1 = env1.geometry.coordinates[0].map(c => c[1]),\n    envX2 = env2.geometry.coordinates[0].map(c => c[0]),\n    envY2 = env2.geometry.coordinates[0].map(c => c[1]);\n  return Math.max.apply(null, envX1) === Math.max.apply(null, envX2) && Math.max.apply(null, envY1) === Math.max.apply(null, envY2) && Math.min.apply(null, envX1) === Math.min.apply(null, envX2) && Math.min.apply(null, envY1) === Math.min.apply(null, envY2);\n}\nfunction envelopeContains(self, env) {\n  return env.geometry.coordinates[0].every(c => booleanPointInPolygon(point(c), self));\n}\nfunction coordinatesEqual(coord1, coord2) {\n  return coord1[0] === coord2[0] && coord1[1] === coord2[1];\n}\n\n// lib/Node.ts\nvar Node = class _Node {\n  static buildId(coordinates) {\n    return coordinates.join(\",\");\n  }\n  constructor(coordinates) {\n    this.id = _Node.buildId(coordinates);\n    this.coordinates = coordinates;\n    this.innerEdges = [];\n    this.outerEdges = [];\n    this.outerEdgesSorted = false;\n  }\n  removeInnerEdge(edge) {\n    this.innerEdges = this.innerEdges.filter(e => e.from.id !== edge.from.id);\n  }\n  removeOuterEdge(edge) {\n    this.outerEdges = this.outerEdges.filter(e => e.to.id !== edge.to.id);\n  }\n  /**\n   * Outer edges are stored CCW order.\n   *\n   * @memberof Node\n   * @param {Edge} edge - Edge to add as an outerEdge.\n   */\n  addOuterEdge(edge) {\n    this.outerEdges.push(edge);\n    this.outerEdgesSorted = false;\n  }\n  /**\n   * Sorts outer edges in CCW way.\n   *\n   * @memberof Node\n   * @private\n   */\n  sortOuterEdges() {\n    if (!this.outerEdgesSorted) {\n      this.outerEdges.sort((a, b) => {\n        const aNode = a.to,\n          bNode = b.to;\n        if (aNode.coordinates[0] - this.coordinates[0] >= 0 && bNode.coordinates[0] - this.coordinates[0] < 0) return 1;\n        if (aNode.coordinates[0] - this.coordinates[0] < 0 && bNode.coordinates[0] - this.coordinates[0] >= 0) return -1;\n        if (aNode.coordinates[0] - this.coordinates[0] === 0 && bNode.coordinates[0] - this.coordinates[0] === 0) {\n          if (aNode.coordinates[1] - this.coordinates[1] >= 0 || bNode.coordinates[1] - this.coordinates[1] >= 0) return aNode.coordinates[1] - bNode.coordinates[1];\n          return bNode.coordinates[1] - aNode.coordinates[1];\n        }\n        const det = orientationIndex(this.coordinates, aNode.coordinates, bNode.coordinates);\n        if (det < 0) return 1;\n        if (det > 0) return -1;\n        const d1 = Math.pow(aNode.coordinates[0] - this.coordinates[0], 2) + Math.pow(aNode.coordinates[1] - this.coordinates[1], 2),\n          d2 = Math.pow(bNode.coordinates[0] - this.coordinates[0], 2) + Math.pow(bNode.coordinates[1] - this.coordinates[1], 2);\n        return d1 - d2;\n      });\n      this.outerEdgesSorted = true;\n    }\n  }\n  /**\n   * Retrieves outer edges.\n   *\n   * They are sorted if they aren't in the CCW order.\n   *\n   * @memberof Node\n   * @returns {Edge[]} - List of outer edges sorted in a CCW order.\n   */\n  getOuterEdges() {\n    this.sortOuterEdges();\n    return this.outerEdges;\n  }\n  getOuterEdge(i) {\n    this.sortOuterEdges();\n    return this.outerEdges[i];\n  }\n  addInnerEdge(edge) {\n    this.innerEdges.push(edge);\n  }\n};\n\n// lib/Edge.ts\nimport { lineString } from \"@turf/helpers\";\nvar Edge = class _Edge {\n  /**\n   * Creates or get the symetric Edge.\n   *\n   * @returns {Edge} - Symetric Edge.\n   */\n  getSymetric() {\n    if (!this.symetric) {\n      this.symetric = new _Edge(this.to, this.from);\n      this.symetric.symetric = this;\n    }\n    return this.symetric;\n  }\n  /**\n   * @param {Node} from - start node of the Edge\n   * @param {Node} to - end node of the edge\n   */\n  constructor(from, to) {\n    this.from = from;\n    this.to = to;\n    this.next = void 0;\n    this.label = void 0;\n    this.symetric = void 0;\n    this.ring = void 0;\n    this.from.addOuterEdge(this);\n    this.to.addInnerEdge(this);\n  }\n  /**\n   * Removes edge from from and to nodes.\n   */\n  deleteEdge() {\n    this.from.removeOuterEdge(this);\n    this.to.removeInnerEdge(this);\n  }\n  /**\n   * Compares Edge equallity.\n   *\n   * An edge is equal to another, if the from and to nodes are the same.\n   *\n   * @param {Edge} edge - Another Edge\n   * @returns {boolean} - True if Edges are equal, False otherwise\n   */\n  isEqual(edge) {\n    return this.from.id === edge.from.id && this.to.id === edge.to.id;\n  }\n  toString() {\n    return `Edge { ${this.from.id} -> ${this.to.id} }`;\n  }\n  /**\n   * Returns a LineString representation of the Edge\n   *\n   * @returns {Feature<LineString>} - LineString representation of the Edge\n   */\n  toLineString() {\n    return lineString([this.from.coordinates, this.to.coordinates]);\n  }\n  /**\n   * Comparator of two edges.\n   *\n   * Implementation of geos::planargraph::DirectedEdge::compareTo.\n   *\n   * @param {Edge} edge - Another edge to compare with this one\n   * @returns {number} -1 if this Edge has a greater angle with the positive x-axis than b,\n   *          0 if the Edges are colinear,\n   *          1 otherwise\n   */\n  compareTo(edge) {\n    return orientationIndex(edge.from.coordinates, edge.to.coordinates, this.to.coordinates);\n  }\n};\n\n// lib/EdgeRing.ts\nimport { multiPoint, polygon, point as point2 } from \"@turf/helpers\";\nimport { envelope } from \"@turf/envelope\";\nimport { booleanPointInPolygon as booleanPointInPolygon2 } from \"@turf/boolean-point-in-polygon\";\nvar EdgeRing = class {\n  constructor() {\n    this.edges = [];\n    this.polygon = void 0;\n    this.envelope = void 0;\n  }\n  /**\n   * Add an edge to the ring, inserting it in the last position.\n   *\n   * @memberof EdgeRing\n   * @param {Edge} edge - Edge to be inserted\n   */\n  push(edge) {\n    this.edges.push(edge);\n    this.polygon = this.envelope = void 0;\n  }\n  /**\n   * Get Edge.\n   *\n   * @memberof EdgeRing\n   * @param {number} i - Index\n   * @returns {Edge} - Edge in the i position\n   */\n  get(i) {\n    return this.edges[i];\n  }\n  /**\n   * Getter of length property.\n   *\n   * @memberof EdgeRing\n   * @returns {number} - Length of the edge ring.\n   */\n  get length() {\n    return this.edges.length;\n  }\n  /**\n   * Similar to Array.prototype.forEach for the list of Edges in the EdgeRing.\n   *\n   * @memberof EdgeRing\n   * @param {Function} f - The same function to be passed to Array.prototype.forEach\n   */\n  forEach(f) {\n    this.edges.forEach(f);\n  }\n  /**\n   * Similar to Array.prototype.map for the list of Edges in the EdgeRing.\n   *\n   * @memberof EdgeRing\n   * @param {Function} f - The same function to be passed to Array.prototype.map\n   * @returns {Array} - The mapped values in the function\n   */\n  map(f) {\n    return this.edges.map(f);\n  }\n  /**\n   * Similar to Array.prototype.some for the list of Edges in the EdgeRing.\n   *\n   * @memberof EdgeRing\n   * @param {Function} f - The same function to be passed to Array.prototype.some\n   * @returns {boolean} - True if an Edge check the condition\n   */\n  some(f) {\n    return this.edges.some(f);\n  }\n  /**\n   * Check if the ring is valid in geomtry terms.\n   *\n   * A ring must have either 0 or 4 or more points. The first and the last must be\n   * equal (in 2D)\n   * geos::geom::LinearRing::validateConstruction\n   *\n   * @memberof EdgeRing\n   * @returns {boolean} - Validity of the EdgeRing\n   */\n  isValid() {\n    return true;\n  }\n  /**\n   * Tests whether this ring is a hole.\n   *\n   * A ring is a hole if it is oriented counter-clockwise.\n   * Similar implementation of geos::algorithm::CGAlgorithms::isCCW\n   *\n   * @memberof EdgeRing\n   * @returns {boolean} - true: if it is a hole\n   */\n  isHole() {\n    const hiIndex = this.edges.reduce((high, edge, i) => {\n        if (edge.from.coordinates[1] > this.edges[high].from.coordinates[1]) high = i;\n        return high;\n      }, 0),\n      iPrev = (hiIndex === 0 ? this.length : hiIndex) - 1,\n      iNext = (hiIndex + 1) % this.length,\n      disc = orientationIndex(this.edges[iPrev].from.coordinates, this.edges[hiIndex].from.coordinates, this.edges[iNext].from.coordinates);\n    if (disc === 0) return this.edges[iPrev].from.coordinates[0] > this.edges[iNext].from.coordinates[0];\n    return disc > 0;\n  }\n  /**\n   * Creates a MultiPoint representing the EdgeRing (discarts edges directions).\n   *\n   * @memberof EdgeRing\n   * @returns {Feature<MultiPoint>} - Multipoint representation of the EdgeRing\n   */\n  toMultiPoint() {\n    return multiPoint(this.edges.map(edge => edge.from.coordinates));\n  }\n  /**\n   * Creates a Polygon representing the EdgeRing.\n   *\n   * @memberof EdgeRing\n   * @returns {Feature<Polygon>} - Polygon representation of the Edge Ring\n   */\n  toPolygon() {\n    if (this.polygon) return this.polygon;\n    const coordinates = this.edges.map(edge => edge.from.coordinates);\n    coordinates.push(this.edges[0].from.coordinates);\n    return this.polygon = polygon([coordinates]);\n  }\n  /**\n   * Calculates the envelope of the EdgeRing.\n   *\n   * @memberof EdgeRing\n   * @returns {Feature<Polygon>} - envelope\n   */\n  getEnvelope() {\n    if (this.envelope) return this.envelope;\n    return this.envelope = envelope(this.toPolygon());\n  }\n  /**\n   * `geos::operation::polygonize::EdgeRing::findEdgeRingContaining`\n   *\n   * @param {EdgeRing} testEdgeRing - EdgeRing to look in the list\n   * @param {EdgeRing[]} shellList - List of EdgeRing in which to search\n   *\n   * @returns {EdgeRing} - EdgeRing which contains the testEdgeRing\n   */\n  static findEdgeRingContaining(testEdgeRing, shellList) {\n    const testEnvelope = testEdgeRing.getEnvelope();\n    let minEnvelope, minShell;\n    shellList.forEach(shell => {\n      const tryEnvelope = shell.getEnvelope();\n      if (minShell) minEnvelope = minShell.getEnvelope();\n      if (envelopeIsEqual(tryEnvelope, testEnvelope)) return;\n      if (envelopeContains(tryEnvelope, testEnvelope)) {\n        const testEdgeRingCoordinates = testEdgeRing.map(edge => edge.from.coordinates);\n        let testPoint;\n        for (const pt of testEdgeRingCoordinates) {\n          if (!shell.some(edge => coordinatesEqual(pt, edge.from.coordinates))) {\n            testPoint = pt;\n          }\n        }\n        if (testPoint && shell.inside(point2(testPoint))) {\n          if (!minShell || envelopeContains(minEnvelope, tryEnvelope)) minShell = shell;\n        }\n      }\n    });\n    return minShell;\n  }\n  /**\n   * Checks if the point is inside the edgeRing\n   *\n   * @param {Feature<Point>} pt - Point to check if it is inside the edgeRing\n   * @returns {boolean} - True if it is inside, False otherwise\n   */\n  inside(pt) {\n    return booleanPointInPolygon2(pt, this.toPolygon());\n  }\n};\n\n// lib/Graph.ts\nimport { flattenEach, coordReduce } from \"@turf/meta\";\nimport { featureOf } from \"@turf/invariant\";\nfunction validateGeoJson(geoJson) {\n  if (!geoJson) throw new Error(\"No geojson passed\");\n  if (geoJson.type !== \"FeatureCollection\" && geoJson.type !== \"GeometryCollection\" && geoJson.type !== \"MultiLineString\" && geoJson.type !== \"LineString\" && geoJson.type !== \"Feature\") throw new Error(`Invalid input type '${geoJson.type}'. Geojson must be FeatureCollection, GeometryCollection, LineString, MultiLineString or Feature`);\n}\nvar Graph = class _Graph {\n  /**\n   * Creates a graph from a GeoJSON.\n   *\n   * @param {FeatureCollection<LineString>} geoJson - it must comply with the restrictions detailed in the index\n   * @returns {Graph} - The newly created graph\n   * @throws {Error} if geoJson is invalid.\n   */\n  static fromGeoJson(geoJson) {\n    validateGeoJson(geoJson);\n    const graph = new _Graph();\n    flattenEach(geoJson, feature => {\n      featureOf(feature, \"LineString\", \"Graph::fromGeoJson\");\n      coordReduce(feature, (prev, cur) => {\n        if (prev) {\n          const start = graph.getNode(prev),\n            end = graph.getNode(cur);\n          graph.addEdge(start, end);\n        }\n        return cur;\n      });\n    });\n    return graph;\n  }\n  /**\n   * Creates or get a Node.\n   *\n   * @param {number[]} coordinates - Coordinates of the node\n   * @returns {Node} - The created or stored node\n   */\n  getNode(coordinates) {\n    const id = Node.buildId(coordinates);\n    let node = this.nodes[id];\n    if (!node) node = this.nodes[id] = new Node(coordinates);\n    return node;\n  }\n  /**\n   * Adds an Edge and its symetricall.\n   *\n   * Edges are added symetrically, i.e.: we also add its symetric\n   *\n   * @param {Node} from - Node which starts the Edge\n   * @param {Node} to - Node which ends the Edge\n   */\n  addEdge(from, to) {\n    const edge = new Edge(from, to),\n      symetricEdge = edge.getSymetric();\n    this.edges.push(edge);\n    this.edges.push(symetricEdge);\n  }\n  constructor() {\n    this.edges = [];\n    this.nodes = {};\n  }\n  /**\n   * Removes Dangle Nodes (nodes with grade 1).\n   */\n  deleteDangles() {\n    Object.keys(this.nodes).map(id => this.nodes[id]).forEach(node => this._removeIfDangle(node));\n  }\n  /**\n   * Check if node is dangle, if so, remove it.\n   *\n   * It calls itself recursively, removing a dangling node might cause another dangling node\n   *\n   * @param {Node} node - Node to check if it's a dangle\n   */\n  _removeIfDangle(node) {\n    if (node.innerEdges.length <= 1) {\n      const outerNodes = node.getOuterEdges().map(e => e.to);\n      this.removeNode(node);\n      outerNodes.forEach(n => this._removeIfDangle(n));\n    }\n  }\n  /**\n   * Delete cut-edges (bridge edges).\n   *\n   * The graph will be traversed, all the edges will be labeled according the ring\n   * in which they are. (The label is a number incremented by 1). Edges with the same\n   * label are cut-edges.\n   */\n  deleteCutEdges() {\n    this._computeNextCWEdges();\n    this._findLabeledEdgeRings();\n    this.edges.forEach(edge => {\n      if (edge.label === edge.symetric.label) {\n        this.removeEdge(edge.symetric);\n        this.removeEdge(edge);\n      }\n    });\n  }\n  /**\n   * Set the `next` property of each Edge.\n   *\n   * The graph will be transversed in a CW form, so, we set the next of the symetrical edge as the previous one.\n   * OuterEdges are sorted CCW.\n   *\n   * @param {Node} [node] - If no node is passed, the function calls itself for every node in the Graph\n   */\n  _computeNextCWEdges(node) {\n    if (typeof node === \"undefined\") {\n      Object.keys(this.nodes).forEach(id => this._computeNextCWEdges(this.nodes[id]));\n    } else {\n      node.getOuterEdges().forEach((edge, i) => {\n        node.getOuterEdge((i === 0 ? node.getOuterEdges().length : i) - 1).symetric.next = edge;\n      });\n    }\n  }\n  /**\n   * Computes the next edge pointers going CCW around the given node, for the given edgering label.\n   *\n   * This algorithm has the effect of converting maximal edgerings into minimal edgerings\n   *\n   * XXX: method literally transcribed from `geos::operation::polygonize::PolygonizeGraph::computeNextCCWEdges`,\n   * could be written in a more javascript way.\n   *\n   * @param {Node} node - Node\n   * @param {number} label - Ring's label\n   */\n  _computeNextCCWEdges(node, label) {\n    const edges = node.getOuterEdges();\n    let firstOutDE, prevInDE;\n    for (let i = edges.length - 1; i >= 0; --i) {\n      let de = edges[i],\n        sym = de.symetric,\n        outDE,\n        inDE;\n      if (de.label === label) outDE = de;\n      if (sym.label === label) inDE = sym;\n      if (!outDE || !inDE) continue;\n      if (inDE) prevInDE = inDE;\n      if (outDE) {\n        if (prevInDE) {\n          prevInDE.next = outDE;\n          prevInDE = void 0;\n        }\n        if (!firstOutDE) firstOutDE = outDE;\n      }\n    }\n    if (prevInDE) prevInDE.next = firstOutDE;\n  }\n  /**\n   * Finds rings and labels edges according to which rings are.\n   *\n   * The label is a number which is increased for each ring.\n   *\n   * @returns {Edge[]} edges that start rings\n   */\n  _findLabeledEdgeRings() {\n    const edgeRingStarts = [];\n    let label = 0;\n    this.edges.forEach(edge => {\n      if (edge.label >= 0) return;\n      edgeRingStarts.push(edge);\n      let e = edge;\n      do {\n        e.label = label;\n        e = e.next;\n      } while (!edge.isEqual(e));\n      label++;\n    });\n    return edgeRingStarts;\n  }\n  /**\n   * Computes the EdgeRings formed by the edges in this graph.\n   *\n   * @returns {EdgeRing[]} - A list of all the EdgeRings in the graph.\n   */\n  getEdgeRings() {\n    this._computeNextCWEdges();\n    this.edges.forEach(edge => {\n      edge.label = void 0;\n    });\n    this._findLabeledEdgeRings().forEach(edge => {\n      this._findIntersectionNodes(edge).forEach(node => {\n        this._computeNextCCWEdges(node, edge.label);\n      });\n    });\n    const edgeRingList = [];\n    this.edges.forEach(edge => {\n      if (edge.ring) return;\n      edgeRingList.push(this._findEdgeRing(edge));\n    });\n    return edgeRingList;\n  }\n  /**\n   * Find all nodes in a Maxima EdgeRing which are self-intersection nodes.\n   *\n   * @param {Node} startEdge - Start Edge of the Ring\n   * @returns {Node[]} - intersection nodes\n   */\n  _findIntersectionNodes(startEdge) {\n    const intersectionNodes = [];\n    let edge = startEdge;\n    do {\n      let degree = 0;\n      edge.from.getOuterEdges().forEach(e => {\n        if (e.label === startEdge.label) ++degree;\n      });\n      if (degree > 1) intersectionNodes.push(edge.from);\n      edge = edge.next;\n    } while (!startEdge.isEqual(edge));\n    return intersectionNodes;\n  }\n  /**\n   * Get the edge-ring which starts from the provided Edge.\n   *\n   * @param {Edge} startEdge - starting edge of the edge ring\n   * @returns {EdgeRing} - EdgeRing which start Edge is the provided one.\n   */\n  _findEdgeRing(startEdge) {\n    let edge = startEdge;\n    const edgeRing = new EdgeRing();\n    do {\n      edgeRing.push(edge);\n      edge.ring = edgeRing;\n      edge = edge.next;\n    } while (!startEdge.isEqual(edge));\n    return edgeRing;\n  }\n  /**\n   * Removes a node from the Graph.\n   *\n   * It also removes edges asociated to that node\n   * @param {Node} node - Node to be removed\n   */\n  removeNode(node) {\n    node.getOuterEdges().forEach(edge => this.removeEdge(edge));\n    node.innerEdges.forEach(edge => this.removeEdge(edge));\n    delete this.nodes[node.id];\n  }\n  /**\n   * Remove edge from the graph and deletes the edge.\n   *\n   * @param {Edge} edge - Edge to be removed\n   */\n  removeEdge(edge) {\n    this.edges = this.edges.filter(e => !e.isEqual(edge));\n    edge.deleteEdge();\n  }\n};\n\n// index.ts\nfunction polygonize(geoJson) {\n  const graph = Graph.fromGeoJson(geoJson);\n  graph.deleteDangles();\n  graph.deleteCutEdges();\n  const holes = [],\n    shells = [];\n  graph.getEdgeRings().filter(edgeRing => edgeRing.isValid()).forEach(edgeRing => {\n    if (edgeRing.isHole()) holes.push(edgeRing);else shells.push(edgeRing);\n  });\n  holes.forEach(hole => {\n    if (EdgeRing.findEdgeRingContaining(hole, shells)) shells.push(hole);\n  });\n  return featureCollection(shells.map(shell => shell.toPolygon()));\n}\nvar turf_polygonize_default = polygonize;\nexport { turf_polygonize_default as default, polygonize };","map":{"version":3,"names":["featureCollection","booleanPointInPolygon","point","mathSign","x","orientationIndex","p1","p2","q","dx1","dy1","dx2","dy2","envelopeIsEqual","env1","env2","envX1","geometry","coordinates","map","c","envY1","envX2","envY2","Math","max","apply","min","envelopeContains","self","env","every","coordinatesEqual","coord1","coord2","Node","_Node","buildId","join","constructor","id","innerEdges","outerEdges","outerEdgesSorted","removeInnerEdge","edge","filter","e","from","removeOuterEdge","to","addOuterEdge","push","sortOuterEdges","sort","a","b","aNode","bNode","det","d1","pow","d2","getOuterEdges","getOuterEdge","i","addInnerEdge","lineString","Edge","_Edge","getSymetric","symetric","next","label","ring","deleteEdge","isEqual","toString","toLineString","compareTo","multiPoint","polygon","point2","envelope","booleanPointInPolygon2","EdgeRing","edges","get","length","forEach","f","some","isValid","isHole","hiIndex","reduce","high","iPrev","iNext","disc","toMultiPoint","toPolygon","getEnvelope","findEdgeRingContaining","testEdgeRing","shellList","testEnvelope","minEnvelope","minShell","shell","tryEnvelope","testEdgeRingCoordinates","testPoint","pt","inside","flattenEach","coordReduce","featureOf","validateGeoJson","geoJson","Error","type","Graph","_Graph","fromGeoJson","graph","feature","prev","cur","start","getNode","end","addEdge","node","nodes","symetricEdge","deleteDangles","Object","keys","_removeIfDangle","outerNodes","removeNode","n","deleteCutEdges","_computeNextCWEdges","_findLabeledEdgeRings","removeEdge","_computeNextCCWEdges","firstOutDE","prevInDE","de","sym","outDE","inDE","edgeRingStarts","getEdgeRings","_findIntersectionNodes","edgeRingList","_findEdgeRing","startEdge","intersectionNodes","degree","edgeRing","polygonize","holes","shells","hole","turf_polygonize_default"],"sources":["/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/polygonize/index.ts","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/polygonize/lib/util.ts","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/polygonize/lib/Node.ts","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/polygonize/lib/Edge.ts","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/polygonize/lib/EdgeRing.ts","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/polygonize/lib/Graph.ts"],"sourcesContent":["import {\n  Feature,\n  FeatureCollection,\n  LineString,\n  MultiLineString,\n  Polygon,\n} from \"geojson\";\nimport { featureCollection } from \"@turf/helpers\";\nimport { Graph } from \"./lib/Graph.js\";\nimport { EdgeRing } from \"./lib/EdgeRing.js\";\n\n/**\n * Polygonizes {@link LineString|(Multi)LineString(s)} into {@link Polygons}.\n *\n * Implementation of GEOSPolygonize function (`geos::operation::polygonize::Polygonizer`).\n *\n * Polygonizes a set of lines that represents edges in a planar graph. Edges must be correctly\n * noded, i.e., they must only meet at their endpoints.\n *\n * The implementation correctly handles:\n *\n * - Dangles: edges which have one or both ends which are not incident on another edge endpoint.\n * - Cut Edges (bridges): edges that are connected at both ends but which do not form part of a polygon.\n *\n * @function\n * @param {FeatureCollection|Geometry|Feature<LineString|MultiLineString>} geoJson Lines in order to polygonize\n * @returns {FeatureCollection<Polygon>} Polygons created\n * @throws {Error} if geoJson is invalid.\n */\nfunction polygonize<T extends LineString | MultiLineString>(\n  geoJson: Feature<T> | FeatureCollection<T> | T\n): FeatureCollection<Polygon> {\n  const graph = Graph.fromGeoJson(geoJson);\n\n  // 1. Remove dangle node\n  graph.deleteDangles();\n\n  // 2. Remove cut-edges (bridge edges)\n  graph.deleteCutEdges();\n\n  // 3. Get all holes and shells\n  const holes: EdgeRing[] = [],\n    shells: EdgeRing[] = [];\n\n  graph\n    .getEdgeRings()\n    .filter((edgeRing) => edgeRing.isValid())\n    .forEach((edgeRing) => {\n      if (edgeRing.isHole()) holes.push(edgeRing);\n      else shells.push(edgeRing);\n    });\n\n  // 4. Assign Holes to Shells\n  holes.forEach((hole) => {\n    if (EdgeRing.findEdgeRingContaining(hole, shells)) shells.push(hole);\n  });\n\n  // 5. EdgeRings to Polygons\n  return featureCollection(shells.map((shell) => shell.toPolygon()));\n}\n\nexport { polygonize };\nexport default polygonize;\n","import { Feature, Polygon } from \"geojson\";\nimport { booleanPointInPolygon } from \"@turf/boolean-point-in-polygon\";\nimport { point } from \"@turf/helpers\";\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign#Polyfill\nfunction mathSign(x: number) {\n  return ((x > 0) as unknown as number) - ((x < 0) as unknown as number) || +x;\n}\n\n/**\n * Returns the direction of the point q relative to the vector p1 -> p2.\n *\n * Implementation of geos::algorithm::CGAlgorithm::orientationIndex()\n * (same as geos::algorithm::CGAlgorithm::computeOrientation())\n *\n * @param {number[]} p1 - the origin point of the vector\n * @param {number[]} p2 - the final point of the vector\n * @param {number[]} q - the point to compute the direction to\n *\n * @returns {number} - 1 if q is ccw (left) from p1->p2,\n *    -1 if q is cw (right) from p1->p2,\n *     0 if q is colinear with p1->p2\n */\nexport function orientationIndex(p1: number[], p2: number[], q: number[]) {\n  const dx1 = p2[0] - p1[0],\n    dy1 = p2[1] - p1[1],\n    dx2 = q[0] - p2[0],\n    dy2 = q[1] - p2[1];\n\n  return mathSign(dx1 * dy2 - dx2 * dy1);\n}\n\n/**\n * Checks if two envelopes are equal.\n *\n * The function assumes that the arguments are envelopes, i.e.: Rectangular polygon\n *\n * @param {Feature<Polygon>} env1 - Envelope\n * @param {Feature<Polygon>} env2 - Envelope\n * @returns {boolean} - True if the envelopes are equal\n */\nexport function envelopeIsEqual(\n  env1: Feature<Polygon>,\n  env2: Feature<Polygon>\n) {\n  const envX1 = env1.geometry.coordinates[0].map((c) => c[0]),\n    envY1 = env1.geometry.coordinates[0].map((c) => c[1]),\n    envX2 = env2.geometry.coordinates[0].map((c) => c[0]),\n    envY2 = env2.geometry.coordinates[0].map((c) => c[1]);\n\n  return (\n    Math.max.apply(null, envX1) === Math.max.apply(null, envX2) &&\n    Math.max.apply(null, envY1) === Math.max.apply(null, envY2) &&\n    Math.min.apply(null, envX1) === Math.min.apply(null, envX2) &&\n    Math.min.apply(null, envY1) === Math.min.apply(null, envY2)\n  );\n}\n\n/**\n * Check if a envelope is contained in other one.\n *\n * The function assumes that the arguments are envelopes, i.e.: Convex polygon\n * XXX: Envelopes are rectangular, checking if a point is inside a rectangule is something easy,\n * this could be further improved.\n *\n * @param {Feature<Polygon>} self - Envelope\n * @param {Feature<Polygon>} env - Envelope\n * @returns {boolean} - True if env is contained in self\n */\nexport function envelopeContains(\n  self: Feature<Polygon>,\n  env: Feature<Polygon>\n) {\n  return env.geometry.coordinates[0].every((c) =>\n    booleanPointInPolygon(point(c), self)\n  );\n}\n\n/**\n * Checks if two coordinates are equal.\n *\n * @param {number[]} coord1 - First coordinate\n * @param {number[]} coord2 - Second coordinate\n * @returns {boolean} - True if coordinates are equal\n */\nexport function coordinatesEqual(coord1: number[], coord2: number[]) {\n  return coord1[0] === coord2[0] && coord1[1] === coord2[1];\n}\n","import { orientationIndex } from \"./util.js\";\nimport { Edge } from \"./Edge.js\";\n\n/**\n * Node\n */\nclass Node {\n  static buildId(coordinates: number[]) {\n    return coordinates.join(\",\");\n  }\n\n  public id: string;\n  public coordinates: number[];\n  public innerEdges: Edge[];\n  private outerEdges: Edge[];\n  private outerEdgesSorted: boolean;\n\n  constructor(coordinates: number[]) {\n    this.id = Node.buildId(coordinates);\n    this.coordinates = coordinates; //< {Number[]}\n    this.innerEdges = []; //< {Edge[]}\n\n    // We wil store to (out) edges in an CCW order as geos::planargraph::DirectedEdgeStar does\n    this.outerEdges = []; //< {Edge[]}\n    this.outerEdgesSorted = false; //< {Boolean} flag that stores if the outer Edges had been sorted\n  }\n\n  removeInnerEdge(edge: Edge) {\n    this.innerEdges = this.innerEdges.filter((e) => e.from.id !== edge.from.id);\n  }\n\n  removeOuterEdge(edge: Edge) {\n    this.outerEdges = this.outerEdges.filter((e) => e.to.id !== edge.to.id);\n  }\n\n  /**\n   * Outer edges are stored CCW order.\n   *\n   * @memberof Node\n   * @param {Edge} edge - Edge to add as an outerEdge.\n   */\n  addOuterEdge(edge: Edge) {\n    this.outerEdges.push(edge);\n    this.outerEdgesSorted = false;\n  }\n\n  /**\n   * Sorts outer edges in CCW way.\n   *\n   * @memberof Node\n   * @private\n   */\n  sortOuterEdges() {\n    if (!this.outerEdgesSorted) {\n      //this.outerEdges.sort((a, b) => a.compareTo(b));\n      // Using this comparator in order to be deterministic\n      this.outerEdges.sort((a, b) => {\n        const aNode = a.to,\n          bNode = b.to;\n\n        if (\n          aNode.coordinates[0] - this.coordinates[0] >= 0 &&\n          bNode.coordinates[0] - this.coordinates[0] < 0\n        )\n          return 1;\n        if (\n          aNode.coordinates[0] - this.coordinates[0] < 0 &&\n          bNode.coordinates[0] - this.coordinates[0] >= 0\n        )\n          return -1;\n\n        if (\n          aNode.coordinates[0] - this.coordinates[0] === 0 &&\n          bNode.coordinates[0] - this.coordinates[0] === 0\n        ) {\n          if (\n            aNode.coordinates[1] - this.coordinates[1] >= 0 ||\n            bNode.coordinates[1] - this.coordinates[1] >= 0\n          )\n            return aNode.coordinates[1] - bNode.coordinates[1];\n          return bNode.coordinates[1] - aNode.coordinates[1];\n        }\n\n        const det = orientationIndex(\n          this.coordinates,\n          aNode.coordinates,\n          bNode.coordinates\n        );\n        if (det < 0) return 1;\n        if (det > 0) return -1;\n\n        const d1 =\n            Math.pow(aNode.coordinates[0] - this.coordinates[0], 2) +\n            Math.pow(aNode.coordinates[1] - this.coordinates[1], 2),\n          d2 =\n            Math.pow(bNode.coordinates[0] - this.coordinates[0], 2) +\n            Math.pow(bNode.coordinates[1] - this.coordinates[1], 2);\n\n        return d1 - d2;\n      });\n      this.outerEdgesSorted = true;\n    }\n  }\n\n  /**\n   * Retrieves outer edges.\n   *\n   * They are sorted if they aren't in the CCW order.\n   *\n   * @memberof Node\n   * @returns {Edge[]} - List of outer edges sorted in a CCW order.\n   */\n  getOuterEdges() {\n    this.sortOuterEdges();\n    return this.outerEdges;\n  }\n\n  getOuterEdge(i: number) {\n    this.sortOuterEdges();\n    return this.outerEdges[i];\n  }\n\n  addInnerEdge(edge: Edge) {\n    this.innerEdges.push(edge);\n  }\n}\n\nexport { Node };\nexport default Node;\n","import { lineString } from \"@turf/helpers\";\nimport { orientationIndex } from \"./util.js\";\nimport { Node } from \"./Node.js\";\nimport { EdgeRing } from \"./EdgeRing.js\";\n\n/**\n * This class is inspired by GEOS's geos::operation::polygonize::PolygonizeDirectedEdge\n */\nclass Edge {\n  public label?: number;\n  public symetric?: Edge;\n  public from: Node;\n  public to: Node;\n  public next?: Edge;\n  public ring?: EdgeRing;\n\n  /**\n   * Creates or get the symetric Edge.\n   *\n   * @returns {Edge} - Symetric Edge.\n   */\n  getSymetric() {\n    if (!this.symetric) {\n      this.symetric = new Edge(this.to, this.from);\n      this.symetric.symetric = this;\n    }\n\n    return this.symetric;\n  }\n\n  /**\n   * @param {Node} from - start node of the Edge\n   * @param {Node} to - end node of the edge\n   */\n  constructor(from: Node, to: Node) {\n    this.from = from; //< start\n    this.to = to; //< End\n\n    this.next = undefined; //< The edge to be computed after\n    this.label = undefined; //< Used in order to detect Cut Edges (Bridges)\n    this.symetric = undefined; //< The symetric edge of this\n    this.ring = undefined; //< EdgeRing in which the Edge is\n\n    this.from.addOuterEdge(this);\n    this.to.addInnerEdge(this);\n  }\n\n  /**\n   * Removes edge from from and to nodes.\n   */\n  deleteEdge() {\n    this.from.removeOuterEdge(this);\n    this.to.removeInnerEdge(this);\n  }\n\n  /**\n   * Compares Edge equallity.\n   *\n   * An edge is equal to another, if the from and to nodes are the same.\n   *\n   * @param {Edge} edge - Another Edge\n   * @returns {boolean} - True if Edges are equal, False otherwise\n   */\n  isEqual(edge: Edge) {\n    return this.from.id === edge.from.id && this.to.id === edge.to.id;\n  }\n\n  toString() {\n    return `Edge { ${this.from.id} -> ${this.to.id} }`;\n  }\n\n  /**\n   * Returns a LineString representation of the Edge\n   *\n   * @returns {Feature<LineString>} - LineString representation of the Edge\n   */\n  toLineString() {\n    return lineString([this.from.coordinates, this.to.coordinates]);\n  }\n\n  /**\n   * Comparator of two edges.\n   *\n   * Implementation of geos::planargraph::DirectedEdge::compareTo.\n   *\n   * @param {Edge} edge - Another edge to compare with this one\n   * @returns {number} -1 if this Edge has a greater angle with the positive x-axis than b,\n   *          0 if the Edges are colinear,\n   *          1 otherwise\n   */\n  compareTo(edge: Edge) {\n    return orientationIndex(\n      edge.from.coordinates,\n      edge.to.coordinates,\n      this.to.coordinates\n    );\n  }\n}\n\nexport { Edge };\nexport default Edge;\n","import { Polygon, Feature, Point, Position } from \"geojson\";\nimport {\n  orientationIndex,\n  envelopeIsEqual,\n  envelopeContains,\n  coordinatesEqual,\n} from \"./util.js\";\nimport { multiPoint, polygon, point } from \"@turf/helpers\";\nimport { envelope } from \"@turf/envelope\";\nimport { booleanPointInPolygon } from \"@turf/boolean-point-in-polygon\";\nimport { Edge } from \"./Edge.js\";\n\n/**\n * Ring of edges which form a polygon.\n *\n * The ring may be either an outer shell or a hole.\n *\n * This class is inspired in GEOS's geos::operation::polygonize::EdgeRing\n */\nclass EdgeRing {\n  private edges: Edge[];\n  private polygon?: Feature<\n    Polygon,\n    {\n      [name: string]: any;\n    }\n  >;\n  private envelope?: Feature<\n    Polygon,\n    {\n      [name: string]: any;\n    }\n  >;\n\n  constructor() {\n    this.edges = [];\n    this.polygon = undefined; //< Caches Polygon representation\n    this.envelope = undefined; //< Caches Envelope representation\n  }\n\n  /**\n   * Add an edge to the ring, inserting it in the last position.\n   *\n   * @memberof EdgeRing\n   * @param {Edge} edge - Edge to be inserted\n   */\n  push(edge: Edge) {\n    this.edges.push(edge);\n    this.polygon = this.envelope = undefined;\n  }\n\n  /**\n   * Get Edge.\n   *\n   * @memberof EdgeRing\n   * @param {number} i - Index\n   * @returns {Edge} - Edge in the i position\n   */\n  get(i: number) {\n    return this.edges[i];\n  }\n\n  /**\n   * Getter of length property.\n   *\n   * @memberof EdgeRing\n   * @returns {number} - Length of the edge ring.\n   */\n  get length() {\n    return this.edges.length;\n  }\n\n  /**\n   * Similar to Array.prototype.forEach for the list of Edges in the EdgeRing.\n   *\n   * @memberof EdgeRing\n   * @param {Function} f - The same function to be passed to Array.prototype.forEach\n   */\n  forEach(f: (edge: Edge, index: number, array: Edge[]) => void) {\n    this.edges.forEach(f);\n  }\n\n  /**\n   * Similar to Array.prototype.map for the list of Edges in the EdgeRing.\n   *\n   * @memberof EdgeRing\n   * @param {Function} f - The same function to be passed to Array.prototype.map\n   * @returns {Array} - The mapped values in the function\n   */\n  map<T>(f: (edge: Edge, index: number, array: Edge[]) => T): T[] {\n    return this.edges.map(f);\n  }\n\n  /**\n   * Similar to Array.prototype.some for the list of Edges in the EdgeRing.\n   *\n   * @memberof EdgeRing\n   * @param {Function} f - The same function to be passed to Array.prototype.some\n   * @returns {boolean} - True if an Edge check the condition\n   */\n  some(f: (edge: Edge, index: number, array: Edge[]) => boolean) {\n    return this.edges.some(f);\n  }\n\n  /**\n   * Check if the ring is valid in geomtry terms.\n   *\n   * A ring must have either 0 or 4 or more points. The first and the last must be\n   * equal (in 2D)\n   * geos::geom::LinearRing::validateConstruction\n   *\n   * @memberof EdgeRing\n   * @returns {boolean} - Validity of the EdgeRing\n   */\n  isValid() {\n    // TODO: stub\n    return true;\n  }\n\n  /**\n   * Tests whether this ring is a hole.\n   *\n   * A ring is a hole if it is oriented counter-clockwise.\n   * Similar implementation of geos::algorithm::CGAlgorithms::isCCW\n   *\n   * @memberof EdgeRing\n   * @returns {boolean} - true: if it is a hole\n   */\n  isHole() {\n    // XXX: Assuming Ring is valid\n    // Find highest point\n    const hiIndex = this.edges.reduce((high, edge, i) => {\n        if (edge.from.coordinates[1] > this.edges[high].from.coordinates[1])\n          high = i;\n        return high;\n      }, 0),\n      iPrev = (hiIndex === 0 ? this.length : hiIndex) - 1,\n      iNext = (hiIndex + 1) % this.length,\n      disc = orientationIndex(\n        this.edges[iPrev].from.coordinates,\n        this.edges[hiIndex].from.coordinates,\n        this.edges[iNext].from.coordinates\n      );\n\n    if (disc === 0)\n      return (\n        this.edges[iPrev].from.coordinates[0] >\n        this.edges[iNext].from.coordinates[0]\n      );\n    return disc > 0;\n  }\n\n  /**\n   * Creates a MultiPoint representing the EdgeRing (discarts edges directions).\n   *\n   * @memberof EdgeRing\n   * @returns {Feature<MultiPoint>} - Multipoint representation of the EdgeRing\n   */\n  toMultiPoint() {\n    return multiPoint(this.edges.map((edge) => edge.from.coordinates));\n  }\n\n  /**\n   * Creates a Polygon representing the EdgeRing.\n   *\n   * @memberof EdgeRing\n   * @returns {Feature<Polygon>} - Polygon representation of the Edge Ring\n   */\n  toPolygon() {\n    if (this.polygon) return this.polygon;\n    const coordinates = this.edges.map((edge) => edge.from.coordinates);\n    coordinates.push(this.edges[0].from.coordinates);\n    return (this.polygon = polygon([coordinates]));\n  }\n\n  /**\n   * Calculates the envelope of the EdgeRing.\n   *\n   * @memberof EdgeRing\n   * @returns {Feature<Polygon>} - envelope\n   */\n  getEnvelope() {\n    if (this.envelope) return this.envelope;\n    return (this.envelope = envelope(this.toPolygon()) as Feature<\n      Polygon,\n      { [name: string]: any }\n    >);\n  }\n\n  /**\n   * `geos::operation::polygonize::EdgeRing::findEdgeRingContaining`\n   *\n   * @param {EdgeRing} testEdgeRing - EdgeRing to look in the list\n   * @param {EdgeRing[]} shellList - List of EdgeRing in which to search\n   *\n   * @returns {EdgeRing} - EdgeRing which contains the testEdgeRing\n   */\n  static findEdgeRingContaining(\n    testEdgeRing: EdgeRing,\n    shellList: EdgeRing[]\n  ): EdgeRing | undefined {\n    const testEnvelope = testEdgeRing.getEnvelope();\n\n    let minEnvelope: Feature<Polygon>, minShell: EdgeRing | undefined;\n    shellList.forEach((shell) => {\n      const tryEnvelope = shell.getEnvelope();\n\n      if (minShell) minEnvelope = minShell.getEnvelope();\n\n      // the hole envelope cannot equal the shell envelope\n      if (envelopeIsEqual(tryEnvelope, testEnvelope)) return;\n\n      if (envelopeContains(tryEnvelope, testEnvelope)) {\n        const testEdgeRingCoordinates = testEdgeRing.map(\n          (edge) => edge.from.coordinates\n        );\n\n        let testPoint: Position | undefined;\n        for (const pt of testEdgeRingCoordinates) {\n          if (\n            !shell.some((edge) => coordinatesEqual(pt, edge.from.coordinates))\n          ) {\n            testPoint = pt;\n          }\n        }\n\n        if (testPoint && shell.inside(point(testPoint))) {\n          if (!minShell || envelopeContains(minEnvelope, tryEnvelope))\n            minShell = shell;\n        }\n      }\n    });\n\n    return minShell;\n  }\n\n  /**\n   * Checks if the point is inside the edgeRing\n   *\n   * @param {Feature<Point>} pt - Point to check if it is inside the edgeRing\n   * @returns {boolean} - True if it is inside, False otherwise\n   */\n  inside(pt: Feature<Point>) {\n    return booleanPointInPolygon(pt, this.toPolygon());\n  }\n}\n\nexport { EdgeRing };\nexport default EdgeRing;\n","import { Node } from \"./Node.js\";\nimport { Edge } from \"./Edge.js\";\nimport { EdgeRing } from \"./EdgeRing.js\";\nimport { flattenEach, coordReduce } from \"@turf/meta\";\nimport { featureOf } from \"@turf/invariant\";\nimport {\n  FeatureCollection,\n  LineString,\n  MultiLineString,\n  Feature,\n} from \"geojson\";\nimport { AllGeoJSON } from \"@turf/helpers\";\n\n/**\n * Validates the geoJson.\n *\n * @param {GeoJSON} geoJson - input geoJson.\n * @throws {Error} if geoJson is invalid.\n */\nfunction validateGeoJson(geoJson: AllGeoJSON) {\n  if (!geoJson) throw new Error(\"No geojson passed\");\n\n  if (\n    geoJson.type !== \"FeatureCollection\" &&\n    geoJson.type !== \"GeometryCollection\" &&\n    geoJson.type !== \"MultiLineString\" &&\n    geoJson.type !== \"LineString\" &&\n    geoJson.type !== \"Feature\"\n  )\n    throw new Error(\n      `Invalid input type '${geoJson.type}'. Geojson must be FeatureCollection, GeometryCollection, LineString, MultiLineString or Feature`\n    );\n}\n\n/**\n * Represents a planar graph of edges and nodes that can be used to compute a polygonization.\n *\n * Although, this class is inspired by GEOS's `geos::operation::polygonize::PolygonizeGraph`,\n * it isn't a rewrite. As regards algorithm, this class implements the same logic, but it\n * isn't a javascript transcription of the C++ source.\n *\n * This graph is directed (both directions are created)\n */\nclass Graph {\n  private nodes: { [id: string]: Node };\n  private edges: Edge[];\n\n  /**\n   * Creates a graph from a GeoJSON.\n   *\n   * @param {FeatureCollection<LineString>} geoJson - it must comply with the restrictions detailed in the index\n   * @returns {Graph} - The newly created graph\n   * @throws {Error} if geoJson is invalid.\n   */\n  static fromGeoJson(\n    geoJson:\n      | FeatureCollection<LineString | MultiLineString>\n      | LineString\n      | MultiLineString\n      | Feature<LineString | MultiLineString>\n  ) {\n    validateGeoJson(geoJson);\n\n    const graph = new Graph();\n    flattenEach(geoJson, (feature) => {\n      featureOf(feature, \"LineString\", \"Graph::fromGeoJson\");\n      // When a LineString if formed by many segments, split them\n      coordReduce<number[]>(feature, (prev, cur) => {\n        if (prev) {\n          const start = graph.getNode(prev),\n            end = graph.getNode(cur);\n\n          graph.addEdge(start, end);\n        }\n        return cur;\n      });\n    });\n\n    return graph;\n  }\n\n  /**\n   * Creates or get a Node.\n   *\n   * @param {number[]} coordinates - Coordinates of the node\n   * @returns {Node} - The created or stored node\n   */\n  getNode(coordinates: number[]) {\n    const id = Node.buildId(coordinates);\n    let node = this.nodes[id];\n    if (!node) node = this.nodes[id] = new Node(coordinates);\n\n    return node;\n  }\n\n  /**\n   * Adds an Edge and its symetricall.\n   *\n   * Edges are added symetrically, i.e.: we also add its symetric\n   *\n   * @param {Node} from - Node which starts the Edge\n   * @param {Node} to - Node which ends the Edge\n   */\n  addEdge(from: Node, to: Node) {\n    const edge = new Edge(from, to),\n      symetricEdge = edge.getSymetric();\n\n    this.edges.push(edge);\n    this.edges.push(symetricEdge);\n  }\n\n  constructor() {\n    this.edges = []; //< {Edge[]} dirEdges\n\n    // The key is the `id` of the Node (ie: coordinates.join(','))\n    this.nodes = {};\n  }\n\n  /**\n   * Removes Dangle Nodes (nodes with grade 1).\n   */\n  deleteDangles() {\n    Object.keys(this.nodes)\n      .map((id) => this.nodes[id])\n      .forEach((node) => this._removeIfDangle(node));\n  }\n\n  /**\n   * Check if node is dangle, if so, remove it.\n   *\n   * It calls itself recursively, removing a dangling node might cause another dangling node\n   *\n   * @param {Node} node - Node to check if it's a dangle\n   */\n  _removeIfDangle(node: Node) {\n    // As edges are directed and symetrical, we count only innerEdges\n    if (node.innerEdges.length <= 1) {\n      const outerNodes = node.getOuterEdges().map((e) => e.to);\n      this.removeNode(node);\n      outerNodes.forEach((n) => this._removeIfDangle(n));\n    }\n  }\n\n  /**\n   * Delete cut-edges (bridge edges).\n   *\n   * The graph will be traversed, all the edges will be labeled according the ring\n   * in which they are. (The label is a number incremented by 1). Edges with the same\n   * label are cut-edges.\n   */\n  deleteCutEdges() {\n    this._computeNextCWEdges();\n    this._findLabeledEdgeRings();\n\n    // Cut-edges (bridges) are edges where both edges have the same label\n    this.edges.forEach((edge) => {\n      if (edge.label === edge.symetric!.label) {\n        this.removeEdge(edge.symetric!);\n        this.removeEdge(edge);\n      }\n    });\n  }\n\n  /**\n   * Set the `next` property of each Edge.\n   *\n   * The graph will be transversed in a CW form, so, we set the next of the symetrical edge as the previous one.\n   * OuterEdges are sorted CCW.\n   *\n   * @param {Node} [node] - If no node is passed, the function calls itself for every node in the Graph\n   */\n  _computeNextCWEdges(node?: Node) {\n    if (typeof node === \"undefined\") {\n      Object.keys(this.nodes).forEach((id) =>\n        this._computeNextCWEdges(this.nodes[id])\n      );\n    } else {\n      node.getOuterEdges().forEach((edge, i) => {\n        node.getOuterEdge(\n          (i === 0 ? node.getOuterEdges().length : i) - 1\n        ).symetric!.next = edge;\n      });\n    }\n  }\n\n  /**\n   * Computes the next edge pointers going CCW around the given node, for the given edgering label.\n   *\n   * This algorithm has the effect of converting maximal edgerings into minimal edgerings\n   *\n   * XXX: method literally transcribed from `geos::operation::polygonize::PolygonizeGraph::computeNextCCWEdges`,\n   * could be written in a more javascript way.\n   *\n   * @param {Node} node - Node\n   * @param {number} label - Ring's label\n   */\n  _computeNextCCWEdges(node: Node, label: number) {\n    const edges = node.getOuterEdges();\n    let firstOutDE, prevInDE;\n\n    for (let i = edges.length - 1; i >= 0; --i) {\n      let de = edges[i],\n        sym = de.symetric,\n        outDE,\n        inDE;\n\n      if (de.label === label) outDE = de;\n\n      if (sym!.label === label) inDE = sym;\n\n      if (!outDE || !inDE)\n        // This edge is not in edgering\n        continue;\n\n      if (inDE) prevInDE = inDE;\n\n      if (outDE) {\n        if (prevInDE) {\n          prevInDE.next = outDE;\n          prevInDE = undefined;\n        }\n\n        if (!firstOutDE) firstOutDE = outDE;\n      }\n    }\n\n    if (prevInDE) prevInDE.next = firstOutDE;\n  }\n\n  /**\n   * Finds rings and labels edges according to which rings are.\n   *\n   * The label is a number which is increased for each ring.\n   *\n   * @returns {Edge[]} edges that start rings\n   */\n  _findLabeledEdgeRings() {\n    const edgeRingStarts: Edge[] = [];\n    let label = 0;\n    this.edges.forEach((edge) => {\n      if (edge.label! >= 0) return;\n\n      edgeRingStarts.push(edge);\n\n      let e = edge;\n      do {\n        e.label = label;\n        e = e.next!;\n      } while (!edge.isEqual(e));\n\n      label++;\n    });\n\n    return edgeRingStarts;\n  }\n\n  /**\n   * Computes the EdgeRings formed by the edges in this graph.\n   *\n   * @returns {EdgeRing[]} - A list of all the EdgeRings in the graph.\n   */\n  getEdgeRings() {\n    this._computeNextCWEdges();\n\n    // Clear labels\n    this.edges.forEach((edge) => {\n      edge.label = undefined;\n    });\n\n    this._findLabeledEdgeRings().forEach((edge) => {\n      // convertMaximalToMinimalEdgeRings\n      this._findIntersectionNodes(edge).forEach((node) => {\n        this._computeNextCCWEdges(node, edge.label!);\n      });\n    });\n\n    const edgeRingList: EdgeRing[] = [];\n\n    // find all edgerings\n    this.edges.forEach((edge) => {\n      if (edge.ring) return;\n      edgeRingList.push(this._findEdgeRing(edge));\n    });\n\n    return edgeRingList;\n  }\n\n  /**\n   * Find all nodes in a Maxima EdgeRing which are self-intersection nodes.\n   *\n   * @param {Node} startEdge - Start Edge of the Ring\n   * @returns {Node[]} - intersection nodes\n   */\n  _findIntersectionNodes(startEdge: Edge) {\n    const intersectionNodes = [];\n    let edge = startEdge;\n    do {\n      // getDegree\n      let degree = 0;\n      edge.from.getOuterEdges().forEach((e) => {\n        if (e.label === startEdge.label) ++degree;\n      });\n\n      if (degree > 1) intersectionNodes.push(edge.from);\n\n      edge = edge.next!;\n    } while (!startEdge.isEqual(edge));\n\n    return intersectionNodes;\n  }\n\n  /**\n   * Get the edge-ring which starts from the provided Edge.\n   *\n   * @param {Edge} startEdge - starting edge of the edge ring\n   * @returns {EdgeRing} - EdgeRing which start Edge is the provided one.\n   */\n  _findEdgeRing(startEdge: Edge) {\n    let edge = startEdge;\n    const edgeRing = new EdgeRing();\n\n    do {\n      edgeRing.push(edge);\n      edge.ring = edgeRing;\n      edge = edge.next!;\n    } while (!startEdge.isEqual(edge));\n\n    return edgeRing;\n  }\n\n  /**\n   * Removes a node from the Graph.\n   *\n   * It also removes edges asociated to that node\n   * @param {Node} node - Node to be removed\n   */\n  removeNode(node: Node) {\n    node.getOuterEdges().forEach((edge) => this.removeEdge(edge));\n    node.innerEdges.forEach((edge) => this.removeEdge(edge));\n    delete this.nodes[node.id];\n  }\n\n  /**\n   * Remove edge from the graph and deletes the edge.\n   *\n   * @param {Edge} edge - Edge to be removed\n   */\n  removeEdge(edge: Edge) {\n    this.edges = this.edges.filter((e) => !e.isEqual(edge));\n    edge.deleteEdge();\n  }\n}\n\nexport { Graph };\nexport default Graph;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}