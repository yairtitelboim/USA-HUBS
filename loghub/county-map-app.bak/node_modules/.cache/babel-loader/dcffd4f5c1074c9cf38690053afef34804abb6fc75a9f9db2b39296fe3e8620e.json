{"ast":null,"code":"// index.ts\nimport { degreesToRadians, polygon, isObject, isNumber } from \"@turf/helpers\";\nimport { rhumbDestination } from \"@turf/rhumb-destination\";\nimport { transformRotate } from \"@turf/transform-rotate\";\nimport { getCoord } from \"@turf/invariant\";\nfunction ellipse(center, xSemiAxis, ySemiAxis, options) {\n  options = options || {};\n  const steps = options.steps || 64;\n  const units = options.units || \"kilometers\";\n  const angle = options.angle || 0;\n  const pivot = options.pivot || center;\n  const properties = options.properties || {};\n  if (!center) throw new Error(\"center is required\");\n  if (!xSemiAxis) throw new Error(\"xSemiAxis is required\");\n  if (!ySemiAxis) throw new Error(\"ySemiAxis is required\");\n  if (!isObject(options)) throw new Error(\"options must be an object\");\n  if (!isNumber(steps)) throw new Error(\"steps must be a number\");\n  if (!isNumber(angle)) throw new Error(\"angle must be a number\");\n  const centerCoords = getCoord(center);\n  if (units !== \"degrees\") {\n    const xDest = rhumbDestination(center, xSemiAxis, 90, {\n      units\n    });\n    const yDest = rhumbDestination(center, ySemiAxis, 0, {\n      units\n    });\n    xSemiAxis = getCoord(xDest)[0] - centerCoords[0];\n    ySemiAxis = getCoord(yDest)[1] - centerCoords[1];\n  }\n  const coordinates = [];\n  for (let i = 0; i < steps; i += 1) {\n    const stepAngle = i * -360 / steps;\n    let x = xSemiAxis * ySemiAxis / Math.sqrt(Math.pow(ySemiAxis, 2) + Math.pow(xSemiAxis, 2) * Math.pow(getTanDeg(stepAngle), 2));\n    let y = xSemiAxis * ySemiAxis / Math.sqrt(Math.pow(xSemiAxis, 2) + Math.pow(ySemiAxis, 2) / Math.pow(getTanDeg(stepAngle), 2));\n    if (stepAngle < -90 && stepAngle >= -270) x = -x;\n    if (stepAngle < -180 && stepAngle >= -360) y = -y;\n    if (units === \"degrees\") {\n      const angleRad = degreesToRadians(angle);\n      const newx = x * Math.cos(angleRad) + y * Math.sin(angleRad);\n      const newy = y * Math.cos(angleRad) - x * Math.sin(angleRad);\n      x = newx;\n      y = newy;\n    }\n    coordinates.push([x + centerCoords[0], y + centerCoords[1]]);\n  }\n  coordinates.push(coordinates[0]);\n  if (units === \"degrees\") {\n    return polygon([coordinates], properties);\n  } else {\n    return transformRotate(polygon([coordinates], properties), angle, {\n      pivot\n    });\n  }\n}\nfunction getTanDeg(deg) {\n  const rad = deg * Math.PI / 180;\n  return Math.tan(rad);\n}\nvar turf_ellipse_default = ellipse;\nexport { turf_ellipse_default as default, ellipse };","map":{"version":3,"names":["degreesToRadians","polygon","isObject","isNumber","rhumbDestination","transformRotate","getCoord","ellipse","center","xSemiAxis","ySemiAxis","options","steps","units","angle","pivot","properties","Error","centerCoords","xDest","yDest","coordinates","i","stepAngle","x","Math","sqrt","pow","getTanDeg","y","angleRad","newx","cos","sin","newy","push","deg","rad","PI","tan","turf_ellipse_default"],"sources":["/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/ellipse/index.ts"],"sourcesContent":["import {\n  degreesToRadians,\n  polygon,\n  isObject,\n  isNumber,\n  Coord,\n  Units,\n} from \"@turf/helpers\";\nimport { rhumbDestination } from \"@turf/rhumb-destination\";\nimport { transformRotate } from \"@turf/transform-rotate\";\nimport { getCoord } from \"@turf/invariant\";\nimport { GeoJsonProperties, Feature, Polygon } from \"geojson\";\n\n/**\n * Takes a {@link Point} and calculates the ellipse polygon given two semi-axes expressed in variable units and steps for precision.\n *\n * @param {Coord} center center point\n * @param {number} xSemiAxis semi (major) axis of the ellipse along the x-axis\n * @param {number} ySemiAxis semi (minor) axis of the ellipse along the y-axis\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.angle=0] angle of rotation in decimal degrees, positive clockwise\n * @param {Coord} [options.pivot=center] point around which any rotation will be performed\n * @param {number} [options.steps=64] number of steps\n * @param {string} [options.units='kilometers'] unit of measurement for axes\n * @param {Object} [options.properties={}] properties\n * @returns {Feature<Polygon>} ellipse polygon\n * @example\n * var center = [-75, 40];\n * var xSemiAxis = 5;\n * var ySemiAxis = 2;\n * var ellipse = turf.ellipse(center, xSemiAxis, ySemiAxis);\n *\n * //addToMap\n * var addToMap = [turf.point(center), ellipse]\n */\nfunction ellipse(\n  center: Coord,\n  xSemiAxis: number,\n  ySemiAxis: number,\n  options: {\n    steps?: number;\n    units?: Units;\n    angle?: number;\n    pivot?: Coord;\n    properties?: GeoJsonProperties;\n  }\n): Feature<Polygon> {\n  // Optional params\n  options = options || {};\n  const steps = options.steps || 64;\n  const units = options.units || \"kilometers\";\n  const angle = options.angle || 0;\n  const pivot = options.pivot || center;\n  const properties = options.properties || {};\n\n  // validation\n  if (!center) throw new Error(\"center is required\");\n  if (!xSemiAxis) throw new Error(\"xSemiAxis is required\");\n  if (!ySemiAxis) throw new Error(\"ySemiAxis is required\");\n  if (!isObject(options)) throw new Error(\"options must be an object\");\n  if (!isNumber(steps)) throw new Error(\"steps must be a number\");\n  if (!isNumber(angle)) throw new Error(\"angle must be a number\");\n\n  const centerCoords = getCoord(center);\n  if (units !== \"degrees\") {\n    const xDest = rhumbDestination(center, xSemiAxis, 90, { units });\n    const yDest = rhumbDestination(center, ySemiAxis, 0, { units });\n    xSemiAxis = getCoord(xDest)[0] - centerCoords[0];\n    ySemiAxis = getCoord(yDest)[1] - centerCoords[1];\n  }\n\n  const coordinates: number[][] = [];\n  for (let i = 0; i < steps; i += 1) {\n    const stepAngle = (i * -360) / steps;\n    let x =\n      (xSemiAxis * ySemiAxis) /\n      Math.sqrt(\n        Math.pow(ySemiAxis, 2) +\n          Math.pow(xSemiAxis, 2) * Math.pow(getTanDeg(stepAngle), 2)\n      );\n    let y =\n      (xSemiAxis * ySemiAxis) /\n      Math.sqrt(\n        Math.pow(xSemiAxis, 2) +\n          Math.pow(ySemiAxis, 2) / Math.pow(getTanDeg(stepAngle), 2)\n      );\n\n    if (stepAngle < -90 && stepAngle >= -270) x = -x;\n    if (stepAngle < -180 && stepAngle >= -360) y = -y;\n    if (units === \"degrees\") {\n      const angleRad = degreesToRadians(angle);\n      const newx = x * Math.cos(angleRad) + y * Math.sin(angleRad);\n      const newy = y * Math.cos(angleRad) - x * Math.sin(angleRad);\n      x = newx;\n      y = newy;\n    }\n\n    coordinates.push([x + centerCoords[0], y + centerCoords[1]]);\n  }\n  coordinates.push(coordinates[0]);\n  if (units === \"degrees\") {\n    return polygon([coordinates], properties);\n  } else {\n    return transformRotate(polygon([coordinates], properties), angle, {\n      pivot,\n    });\n  }\n}\n\n/**\n * Get Tan Degrees\n *\n * @private\n * @param {number} deg Degrees\n * @returns {number} Tan Degrees\n */\nfunction getTanDeg(deg: number) {\n  const rad = (deg * Math.PI) / 180;\n  return Math.tan(rad);\n}\n\nexport { ellipse };\nexport default ellipse;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}