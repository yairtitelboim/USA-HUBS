{"ast":null,"code":"// index.ts\nimport { bearing } from \"@turf/bearing\";\nimport { bearingToAzimuth, isObject } from \"@turf/helpers\";\nimport { rhumbBearing } from \"@turf/rhumb-bearing\";\nfunction angle(startPoint, midPoint, endPoint, options = {}) {\n  if (!isObject(options)) {\n    throw new Error(\"options is invalid\");\n  }\n  if (!startPoint) {\n    throw new Error(\"startPoint is required\");\n  }\n  if (!midPoint) {\n    throw new Error(\"midPoint is required\");\n  }\n  if (!endPoint) {\n    throw new Error(\"endPoint is required\");\n  }\n  const A = startPoint;\n  const O = midPoint;\n  const B = endPoint;\n  const azimuthOA = bearingToAzimuth(options.mercator !== true ? bearing(O, A) : rhumbBearing(O, A));\n  let azimuthOB = bearingToAzimuth(options.mercator !== true ? bearing(O, B) : rhumbBearing(O, B));\n  if (azimuthOB < azimuthOA) {\n    azimuthOB = azimuthOB + 360;\n  }\n  const angleAOB = azimuthOB - azimuthOA;\n  if (options.explementary === true) {\n    return 360 - angleAOB;\n  }\n  return angleAOB;\n}\nvar turf_angle_default = angle;\nexport { angle, turf_angle_default as default };","map":{"version":3,"names":["bearing","bearingToAzimuth","isObject","rhumbBearing","angle","startPoint","midPoint","endPoint","options","Error","A","O","B","azimuthOA","mercator","azimuthOB","angleAOB","explementary","turf_angle_default"],"sources":["/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/angle/index.ts"],"sourcesContent":["import { bearing } from \"@turf/bearing\";\nimport { bearingToAzimuth, Coord, isObject } from \"@turf/helpers\";\nimport { rhumbBearing } from \"@turf/rhumb-bearing\";\n\n/**\n * Finds the angle formed by two adjacent segments defined by 3 points. The result will be the (positive clockwise)\n * angle with origin on the `startPoint-midPoint` segment, or its explementary angle if required.\n *\n * @function\n * @param {Coord} startPoint Start Point Coordinates\n * @param {Coord} midPoint Mid Point Coordinates\n * @param {Coord} endPoint End Point Coordinates\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.explementary=false] Returns the explementary angle instead (360 - angle)\n * @param {boolean} [options.mercator=false] if calculations should be performed over Mercator or WGS84 projection\n * @returns {number} Angle between the provided points, or its explementary.\n * @example\n * turf.angle([5, 5], [5, 6], [3, 4]);\n * //=45\n */\nfunction angle(\n  startPoint: Coord,\n  midPoint: Coord,\n  endPoint: Coord,\n  options: {\n    explementary?: boolean;\n    mercator?: boolean;\n  } = {}\n): number {\n  // Optional Parameters\n  if (!isObject(options)) {\n    throw new Error(\"options is invalid\");\n  }\n\n  // Validation\n  if (!startPoint) {\n    throw new Error(\"startPoint is required\");\n  }\n  if (!midPoint) {\n    throw new Error(\"midPoint is required\");\n  }\n  if (!endPoint) {\n    throw new Error(\"endPoint is required\");\n  }\n\n  // Rename to shorter variables\n  const A = startPoint;\n  const O = midPoint;\n  const B = endPoint;\n\n  // Main\n  const azimuthOA = bearingToAzimuth(\n    options.mercator !== true ? bearing(O, A) : rhumbBearing(O, A)\n  );\n  let azimuthOB = bearingToAzimuth(\n    options.mercator !== true ? bearing(O, B) : rhumbBearing(O, B)\n  );\n  // If OB \"trails\" OA advance OB one revolution so we get the clockwise angle.\n  if (azimuthOB < azimuthOA) {\n    azimuthOB = azimuthOB + 360;\n  }\n  const angleAOB = azimuthOB - azimuthOA;\n\n  // Explementary angle\n  if (options.explementary === true) {\n    return 360 - angleAOB;\n  }\n  return angleAOB;\n}\n\nexport { angle };\nexport default angle;\n"],"mappings":";AAAA,SAASA,OAAA,QAAe;AACxB,SAASC,gBAAA,EAAyBC,QAAA,QAAgB;AAClD,SAASC,YAAA,QAAoB;AAkB7B,SAASC,MACPC,UAAA,EACAC,QAAA,EACAC,QAAA,EACAC,OAAA,GAGI,CAAC,GACG;EAER,IAAI,CAACN,QAAA,CAASM,OAAO,GAAG;IACtB,MAAM,IAAIC,KAAA,CAAM,oBAAoB;EACtC;EAGA,IAAI,CAACJ,UAAA,EAAY;IACf,MAAM,IAAII,KAAA,CAAM,wBAAwB;EAC1C;EACA,IAAI,CAACH,QAAA,EAAU;IACb,MAAM,IAAIG,KAAA,CAAM,sBAAsB;EACxC;EACA,IAAI,CAACF,QAAA,EAAU;IACb,MAAM,IAAIE,KAAA,CAAM,sBAAsB;EACxC;EAGA,MAAMC,CAAA,GAAIL,UAAA;EACV,MAAMM,CAAA,GAAIL,QAAA;EACV,MAAMM,CAAA,GAAIL,QAAA;EAGV,MAAMM,SAAA,GAAYZ,gBAAA,CAChBO,OAAA,CAAQM,QAAA,KAAa,OAAOd,OAAA,CAAQW,CAAA,EAAGD,CAAC,IAAIP,YAAA,CAAaQ,CAAA,EAAGD,CAAC,CAC/D;EACA,IAAIK,SAAA,GAAYd,gBAAA,CACdO,OAAA,CAAQM,QAAA,KAAa,OAAOd,OAAA,CAAQW,CAAA,EAAGC,CAAC,IAAIT,YAAA,CAAaQ,CAAA,EAAGC,CAAC,CAC/D;EAEA,IAAIG,SAAA,GAAYF,SAAA,EAAW;IACzBE,SAAA,GAAYA,SAAA,GAAY;EAC1B;EACA,MAAMC,QAAA,GAAWD,SAAA,GAAYF,SAAA;EAG7B,IAAIL,OAAA,CAAQS,YAAA,KAAiB,MAAM;IACjC,OAAO,MAAMD,QAAA;EACf;EACA,OAAOA,QAAA;AACT;AAGA,IAAOE,kBAAA,GAAQd,KAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}