{"ast":null,"code":"// index.js\nimport { bearing } from \"@turf/bearing\";\nimport { distance } from \"@turf/distance\";\nimport { destination } from \"@turf/destination\";\nimport { lineString, isObject } from \"@turf/helpers\";\nfunction lineSliceAlong(line, startDist, stopDist, options) {\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var coords;\n  var slice = [];\n  if (line.type === \"Feature\") coords = line.geometry.coordinates;else if (line.type === \"LineString\") coords = line.coordinates;else throw new Error(\"input must be a LineString Feature or Geometry\");\n  var origCoordsLength = coords.length;\n  var travelled = 0;\n  var overshot, direction, interpolated;\n  for (var i = 0; i < coords.length; i++) {\n    if (startDist >= travelled && i === coords.length - 1) break;else if (travelled > startDist && slice.length === 0) {\n      overshot = startDist - travelled;\n      if (!overshot) {\n        slice.push(coords[i]);\n        return lineString(slice);\n      }\n      direction = bearing(coords[i], coords[i - 1]) - 180;\n      interpolated = destination(coords[i], overshot, direction, options);\n      slice.push(interpolated.geometry.coordinates);\n    }\n    if (travelled >= stopDist) {\n      overshot = stopDist - travelled;\n      if (!overshot) {\n        slice.push(coords[i]);\n        return lineString(slice);\n      }\n      direction = bearing(coords[i], coords[i - 1]) - 180;\n      interpolated = destination(coords[i], overshot, direction, options);\n      slice.push(interpolated.geometry.coordinates);\n      return lineString(slice);\n    }\n    if (travelled >= startDist) {\n      slice.push(coords[i]);\n    }\n    if (i === coords.length - 1) {\n      return lineString(slice);\n    }\n    travelled += distance(coords[i], coords[i + 1], options);\n  }\n  if (travelled < startDist && coords.length === origCoordsLength) throw new Error(\"Start position is beyond line\");\n  var last = coords[coords.length - 1];\n  return lineString([last, last]);\n}\nvar turf_line_slice_along_default = lineSliceAlong;\nexport { turf_line_slice_along_default as default, lineSliceAlong };","map":{"version":3,"names":["bearing","distance","destination","lineString","isObject","lineSliceAlong","line","startDist","stopDist","options","Error","coords","slice","type","geometry","coordinates","origCoordsLength","length","travelled","overshot","direction","interpolated","i","push","last","turf_line_slice_along_default"],"sources":["/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/line-slice-along/index.js"],"sourcesContent":["import { bearing } from \"@turf/bearing\";\nimport { distance } from \"@turf/distance\";\nimport { destination } from \"@turf/destination\";\nimport { lineString, isObject } from \"@turf/helpers\";\n\n/**\n * Takes a {@link LineString|line}, a specified distance along the line to a start {@link Point},\n * and a specified  distance along the line to a stop point\n * and returns a subsection of the line in-between those points.\n *\n * This can be useful for extracting only the part of a route between two distances.\n *\n * @function\n * @param {Feature<LineString>|LineString} line input line\n * @param {number} startDist distance along the line to starting point\n * @param {number} stopDist distance along the line to ending point\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers\n * @returns {Feature<LineString>} sliced line\n * @example\n * var line = turf.lineString([[7, 45], [9, 45], [14, 40], [14, 41]]);\n * var start = 12.5;\n * var stop = 25;\n * var sliced = turf.lineSliceAlong(line, start, stop, {units: 'miles'});\n *\n * //addToMap\n * var addToMap = [line, start, stop, sliced]\n */\nfunction lineSliceAlong(line, startDist, stopDist, options) {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n\n  var coords;\n  var slice = [];\n\n  // Validation\n  if (line.type === \"Feature\") coords = line.geometry.coordinates;\n  else if (line.type === \"LineString\") coords = line.coordinates;\n  else throw new Error(\"input must be a LineString Feature or Geometry\");\n  var origCoordsLength = coords.length;\n  var travelled = 0;\n  var overshot, direction, interpolated;\n  for (var i = 0; i < coords.length; i++) {\n    if (startDist >= travelled && i === coords.length - 1) break;\n    else if (travelled > startDist && slice.length === 0) {\n      overshot = startDist - travelled;\n      if (!overshot) {\n        slice.push(coords[i]);\n        return lineString(slice);\n      }\n      direction = bearing(coords[i], coords[i - 1]) - 180;\n      interpolated = destination(coords[i], overshot, direction, options);\n      slice.push(interpolated.geometry.coordinates);\n    }\n\n    if (travelled >= stopDist) {\n      overshot = stopDist - travelled;\n      if (!overshot) {\n        slice.push(coords[i]);\n        return lineString(slice);\n      }\n      direction = bearing(coords[i], coords[i - 1]) - 180;\n      interpolated = destination(coords[i], overshot, direction, options);\n      slice.push(interpolated.geometry.coordinates);\n      return lineString(slice);\n    }\n\n    if (travelled >= startDist) {\n      slice.push(coords[i]);\n    }\n\n    if (i === coords.length - 1) {\n      return lineString(slice);\n    }\n\n    travelled += distance(coords[i], coords[i + 1], options);\n  }\n\n  if (travelled < startDist && coords.length === origCoordsLength)\n    throw new Error(\"Start position is beyond line\");\n\n  var last = coords[coords.length - 1];\n  return lineString([last, last]);\n}\n\nexport { lineSliceAlong };\nexport default lineSliceAlong;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}