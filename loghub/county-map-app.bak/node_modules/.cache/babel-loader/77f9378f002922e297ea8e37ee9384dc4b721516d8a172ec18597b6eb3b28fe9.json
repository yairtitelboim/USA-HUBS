{"ast":null,"code":"// index.js\nimport { bbox } from \"@turf/bbox\";\nimport { hexGrid } from \"@turf/hex-grid\";\nimport { pointGrid } from \"@turf/point-grid\";\nimport { distance } from \"@turf/distance\";\nimport { centroid } from \"@turf/centroid\";\nimport { squareGrid } from \"@turf/square-grid\";\nimport { triangleGrid } from \"@turf/triangle-grid\";\nimport { clone } from \"@turf/clone\";\nimport { featureCollection, validateBBox } from \"@turf/helpers\";\nimport { featureEach } from \"@turf/meta\";\nimport { collectionOf } from \"@turf/invariant\";\nfunction interpolate(points, cellSize, options) {\n  options = options || {};\n  if (typeof options !== \"object\") throw new Error(\"options is invalid\");\n  var gridType = options.gridType;\n  var property = options.property;\n  var weight = options.weight;\n  var box = options.bbox;\n  if (!points) throw new Error(\"points is required\");\n  collectionOf(points, \"Point\", \"input must contain Points\");\n  if (!cellSize) throw new Error(\"cellSize is required\");\n  if (weight !== void 0 && typeof weight !== \"number\") throw new Error(\"weight must be a number\");\n  property = property || \"elevation\";\n  gridType = gridType || \"square\";\n  weight = weight || 1;\n  box = box != null ? box : bbox(points);\n  validateBBox(box);\n  var grid;\n  switch (gridType) {\n    case \"point\":\n    case \"points\":\n      grid = pointGrid(box, cellSize, options);\n      break;\n    case \"square\":\n    case \"squares\":\n      grid = squareGrid(box, cellSize, options);\n      break;\n    case \"hex\":\n    case \"hexes\":\n      grid = hexGrid(box, cellSize, options);\n      break;\n    case \"triangle\":\n    case \"triangles\":\n      grid = triangleGrid(box, cellSize, options);\n      break;\n    default:\n      throw new Error(\"invalid gridType\");\n  }\n  var results = [];\n  featureEach(grid, function (gridFeature) {\n    var zw = 0;\n    var sw = 0;\n    featureEach(points, function (point) {\n      var gridPoint = gridType === \"point\" ? gridFeature : centroid(gridFeature);\n      var d = distance(gridPoint, point, options);\n      var zValue;\n      if (property !== void 0) zValue = point.properties[property];\n      if (zValue === void 0) zValue = point.geometry.coordinates[2];\n      if (zValue === void 0) throw new Error(\"zValue is missing\");\n      if (d === 0) zw = zValue;\n      var w = 1 / Math.pow(d, weight);\n      sw += w;\n      zw += w * zValue;\n    });\n    var newFeature = clone(gridFeature);\n    newFeature.properties[property] = zw / sw;\n    results.push(newFeature);\n  });\n  return featureCollection(results);\n}\nvar turf_interpolate_default = interpolate;\nexport { turf_interpolate_default as default, interpolate };","map":{"version":3,"names":["bbox","hexGrid","pointGrid","distance","centroid","squareGrid","triangleGrid","clone","featureCollection","validateBBox","featureEach","collectionOf","interpolate","points","cellSize","options","Error","gridType","property","weight","box","grid","results","gridFeature","zw","sw","point","gridPoint","d","zValue","properties","geometry","coordinates","w","Math","pow","newFeature","push","turf_interpolate_default"],"sources":["/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/interpolate/index.js"],"sourcesContent":["import { bbox } from \"@turf/bbox\";\nimport { hexGrid } from \"@turf/hex-grid\";\nimport { pointGrid } from \"@turf/point-grid\";\nimport { distance } from \"@turf/distance\";\nimport { centroid } from \"@turf/centroid\";\nimport { squareGrid } from \"@turf/square-grid\";\nimport { triangleGrid } from \"@turf/triangle-grid\";\nimport { clone } from \"@turf/clone\";\nimport { featureCollection, validateBBox } from \"@turf/helpers\";\nimport { featureEach } from \"@turf/meta\";\nimport { collectionOf } from \"@turf/invariant\";\n\n/**\n * Takes a set of points and estimates their 'property' values on a grid using the [Inverse Distance Weighting (IDW) method](https://en.wikipedia.org/wiki/Inverse_distance_weighting).\n *\n * @function\n * @param {FeatureCollection<Point>} points with known value\n * @param {number} cellSize the distance across each grid point\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.gridType='square'] defines the output format based on a Grid Type (options: 'square' | 'point' | 'hex' | 'triangle')\n * @param {string} [options.property='elevation'] the property name in `points` from which z-values will be pulled, zValue fallbacks to 3rd coordinate if no property exists.\n * @param {string} [options.units='kilometers'] used in calculating cellSize, can be degrees, radians, miles, or kilometers\n * @param {number} [options.weight=1] exponent regulating the distance-decay weighting\n * @param {BBox}   [options.bbox=bbox(points)] Bounding Box Array [west, south, east, north] associated with the FeatureCollection.\n * @returns {FeatureCollection<Point|Polygon>} grid of points or polygons with interpolated 'property'\n * @example\n * var points = turf.randomPoint(30, {bbox: [50, 30, 70, 50]});\n *\n * // add a random property to each point\n * turf.featureEach(points, function(point) {\n *     point.properties.solRad = Math.random() * 50;\n * });\n * var options = {gridType: 'points', property: 'solRad', units: 'miles'};\n * var grid = turf.interpolate(points, 100, options);\n *\n * //addToMap\n * var addToMap = [grid];\n */\nfunction interpolate(points, cellSize, options) {\n  // Optional parameters\n  options = options || {};\n  if (typeof options !== \"object\") throw new Error(\"options is invalid\");\n  var gridType = options.gridType;\n  var property = options.property;\n  var weight = options.weight;\n  var box = options.bbox;\n\n  // validation\n  if (!points) throw new Error(\"points is required\");\n  collectionOf(points, \"Point\", \"input must contain Points\");\n  if (!cellSize) throw new Error(\"cellSize is required\");\n  if (weight !== undefined && typeof weight !== \"number\")\n    throw new Error(\"weight must be a number\");\n\n  // default values\n  property = property || \"elevation\";\n  gridType = gridType || \"square\";\n  weight = weight || 1;\n\n  box = box ?? bbox(points);\n  validateBBox(box);\n  var grid;\n  switch (gridType) {\n    case \"point\":\n    case \"points\":\n      grid = pointGrid(box, cellSize, options);\n      break;\n    case \"square\":\n    case \"squares\":\n      grid = squareGrid(box, cellSize, options);\n      break;\n    case \"hex\":\n    case \"hexes\":\n      grid = hexGrid(box, cellSize, options);\n      break;\n    case \"triangle\":\n    case \"triangles\":\n      grid = triangleGrid(box, cellSize, options);\n      break;\n    default:\n      throw new Error(\"invalid gridType\");\n  }\n  var results = [];\n  featureEach(grid, function (gridFeature) {\n    var zw = 0;\n    var sw = 0;\n    // calculate the distance from each input point to the grid points\n    featureEach(points, function (point) {\n      var gridPoint =\n        gridType === \"point\" ? gridFeature : centroid(gridFeature);\n      var d = distance(gridPoint, point, options);\n      var zValue;\n      // property has priority for zValue, fallbacks to 3rd coordinate from geometry\n      if (property !== undefined) zValue = point.properties[property];\n      if (zValue === undefined) zValue = point.geometry.coordinates[2];\n      if (zValue === undefined) throw new Error(\"zValue is missing\");\n      if (d === 0) zw = zValue;\n      var w = 1.0 / Math.pow(d, weight);\n      sw += w;\n      zw += w * zValue;\n    });\n    // write interpolated value for each grid point\n    var newFeature = clone(gridFeature);\n    newFeature.properties[property] = zw / sw;\n    results.push(newFeature);\n  });\n  return featureCollection(results);\n}\n\nexport { interpolate };\nexport default interpolate;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}