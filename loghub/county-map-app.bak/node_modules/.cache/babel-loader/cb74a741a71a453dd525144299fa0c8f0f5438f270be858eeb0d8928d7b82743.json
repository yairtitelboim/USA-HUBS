{"ast":null,"code":"// index.ts\nimport { getCoords, getType } from \"@turf/invariant\";\nimport { point, featureCollection } from \"@turf/helpers\";\nimport { bbox as calcBbox } from \"@turf/bbox\";\nimport { explode } from \"@turf/explode\";\nimport { nearestPoint } from \"@turf/nearest-point\";\nfunction polygonTangents(pt, polygon) {\n  const pointCoords = getCoords(pt);\n  const polyCoords = getCoords(polygon);\n  let rtan = [];\n  let ltan = [];\n  let eprev;\n  const bbox = calcBbox(polygon);\n  let nearestPtIndex = 0;\n  let nearest = null;\n  if (pointCoords[0] > bbox[0] && pointCoords[0] < bbox[2] && pointCoords[1] > bbox[1] && pointCoords[1] < bbox[3]) {\n    nearest = nearestPoint(pt, explode(polygon));\n    nearestPtIndex = nearest.properties.featureIndex;\n  }\n  const type = getType(polygon);\n  switch (type) {\n    case \"Polygon\":\n      rtan = polyCoords[0][nearestPtIndex];\n      ltan = polyCoords[0][0];\n      if (nearest !== null) {\n        if (nearest.geometry.coordinates[1] < pointCoords[1]) ltan = polyCoords[0][nearestPtIndex];\n      }\n      eprev = isLeft(polyCoords[0][0], polyCoords[0][polyCoords[0].length - 1], pointCoords);\n      [rtan, ltan] = processPolygon(polyCoords[0], pointCoords, eprev, rtan, ltan);\n      break;\n    case \"MultiPolygon\":\n      var closestFeature = 0;\n      var closestVertex = 0;\n      var verticesCounted = 0;\n      for (var i = 0; i < polyCoords[0].length; i++) {\n        closestFeature = i;\n        var verticeFound = false;\n        for (var i2 = 0; i2 < polyCoords[0][i].length; i2++) {\n          closestVertex = i2;\n          if (verticesCounted === nearestPtIndex) {\n            verticeFound = true;\n            break;\n          }\n          verticesCounted++;\n        }\n        if (verticeFound) break;\n      }\n      rtan = polyCoords[0][closestFeature][closestVertex];\n      ltan = polyCoords[0][closestFeature][closestVertex];\n      eprev = isLeft(polyCoords[0][0][0], polyCoords[0][0][polyCoords[0][0].length - 1], pointCoords);\n      polyCoords.forEach(function (ring) {\n        [rtan, ltan] = processPolygon(ring[0], pointCoords, eprev, rtan, ltan);\n      });\n      break;\n  }\n  return featureCollection([point(rtan), point(ltan)]);\n}\nfunction processPolygon(polygonCoords, ptCoords, eprev, rtan, ltan) {\n  for (let i = 0; i < polygonCoords.length; i++) {\n    const currentCoords = polygonCoords[i];\n    let nextCoordPair = polygonCoords[i + 1];\n    if (i === polygonCoords.length - 1) {\n      nextCoordPair = polygonCoords[0];\n    }\n    const enext = isLeft(currentCoords, nextCoordPair, ptCoords);\n    if (eprev <= 0 && enext > 0) {\n      if (!isBelow(ptCoords, currentCoords, rtan)) {\n        rtan = currentCoords;\n      }\n    } else if (eprev > 0 && enext <= 0) {\n      if (!isAbove(ptCoords, currentCoords, ltan)) {\n        ltan = currentCoords;\n      }\n    }\n    eprev = enext;\n  }\n  return [rtan, ltan];\n}\nfunction isAbove(point1, point2, point3) {\n  return isLeft(point1, point2, point3) > 0;\n}\nfunction isBelow(point1, point2, point3) {\n  return isLeft(point1, point2, point3) < 0;\n}\nfunction isLeft(point1, point2, point3) {\n  return (point2[0] - point1[0]) * (point3[1] - point1[1]) - (point3[0] - point1[0]) * (point2[1] - point1[1]);\n}\nvar turf_polygon_tangents_default = polygonTangents;\nexport { turf_polygon_tangents_default as default, polygonTangents };","map":{"version":3,"names":["getCoords","getType","point","featureCollection","bbox","calcBbox","explode","nearestPoint","polygonTangents","pt","polygon","pointCoords","polyCoords","rtan","ltan","eprev","nearestPtIndex","nearest","properties","featureIndex","type","geometry","coordinates","isLeft","length","processPolygon","closestFeature","closestVertex","verticesCounted","i","verticeFound","i2","forEach","ring","polygonCoords","ptCoords","currentCoords","nextCoordPair","enext","isBelow","isAbove","point1","point2","point3","turf_polygon_tangents_default"],"sources":["/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/polygon-tangents/index.ts"],"sourcesContent":["import type {\n  Feature,\n  FeatureCollection,\n  Point,\n  Polygon,\n  Position,\n  MultiPolygon,\n} from \"geojson\";\nimport type { Coord } from \"@turf/helpers\";\nimport { getCoords, getType } from \"@turf/invariant\";\nimport { point, featureCollection } from \"@turf/helpers\";\nimport { bbox as calcBbox } from \"@turf/bbox\";\nimport { explode } from \"@turf/explode\";\nimport { nearestPoint } from \"@turf/nearest-point\";\n\n/**\n * Finds the tangents of a {@link Polygon|(Multi)Polygon} from a {@link Point}.\n *\n * @function\n * @param {Coord} pt to calculate the tangent points from\n * @param {Feature<Polygon|MultiPolygon>} polygon to get tangents from\n * @returns {FeatureCollection<Point>} Feature Collection containing the two tangent points\n * @example\n * var polygon = turf.polygon([[[11, 0], [22, 4], [31, 0], [31, 11], [21, 15], [11, 11], [11, 0]]]);\n * var point = turf.point([61, 5]);\n *\n * var tangents = turf.polygonTangents(point, polygon)\n *\n * //addToMap\n * var addToMap = [tangents, point, polygon];\n */\nfunction polygonTangents<T extends Polygon | MultiPolygon>(\n  pt: Coord,\n  polygon: Feature<T> | T\n): FeatureCollection<Point> {\n  const pointCoords = getCoords(pt);\n  const polyCoords = getCoords(polygon);\n\n  let rtan: Position = [];\n  let ltan: Position = [];\n  let eprev: number;\n  const bbox = calcBbox(polygon);\n  let nearestPtIndex = 0;\n  let nearest = null;\n\n  // If the point lies inside the polygon bbox then we need to be a bit trickier\n  // otherwise points lying inside reflex angles on concave polys can have issues\n  if (\n    pointCoords[0] > bbox[0] &&\n    pointCoords[0] < bbox[2] &&\n    pointCoords[1] > bbox[1] &&\n    pointCoords[1] < bbox[3]\n  ) {\n    nearest = nearestPoint(pt, explode(polygon));\n    nearestPtIndex = nearest.properties.featureIndex;\n  }\n  const type = getType(polygon);\n  switch (type) {\n    case \"Polygon\":\n      rtan = polyCoords[0][nearestPtIndex];\n      ltan = polyCoords[0][0];\n      if (nearest !== null) {\n        if (nearest.geometry.coordinates[1] < pointCoords[1])\n          ltan = polyCoords[0][nearestPtIndex];\n      }\n      eprev = isLeft(\n        polyCoords[0][0],\n        polyCoords[0][polyCoords[0].length - 1],\n        pointCoords\n      );\n      [rtan, ltan] = processPolygon(\n        polyCoords[0],\n        pointCoords,\n        eprev,\n        rtan,\n        ltan\n      );\n      break;\n    case \"MultiPolygon\":\n      var closestFeature = 0;\n      var closestVertex = 0;\n      var verticesCounted = 0;\n      for (var i = 0; i < polyCoords[0].length; i++) {\n        closestFeature = i;\n        var verticeFound = false;\n        for (var i2 = 0; i2 < polyCoords[0][i].length; i2++) {\n          closestVertex = i2;\n          if (verticesCounted === nearestPtIndex) {\n            verticeFound = true;\n            break;\n          }\n          verticesCounted++;\n        }\n        if (verticeFound) break;\n      }\n      rtan = polyCoords[0][closestFeature][closestVertex];\n      ltan = polyCoords[0][closestFeature][closestVertex];\n      eprev = isLeft(\n        polyCoords[0][0][0],\n        polyCoords[0][0][polyCoords[0][0].length - 1],\n        pointCoords\n      );\n      polyCoords.forEach(function (ring) {\n        [rtan, ltan] = processPolygon(ring[0], pointCoords, eprev, rtan, ltan);\n      });\n      break;\n  }\n  return featureCollection([point(rtan), point(ltan)]);\n}\n\nfunction processPolygon(\n  polygonCoords: Position[],\n  ptCoords: Position,\n  eprev: number,\n  rtan: Position,\n  ltan: Position\n) {\n  for (let i = 0; i < polygonCoords.length; i++) {\n    const currentCoords = polygonCoords[i];\n    let nextCoordPair = polygonCoords[i + 1];\n    if (i === polygonCoords.length - 1) {\n      nextCoordPair = polygonCoords[0];\n    }\n    const enext = isLeft(currentCoords, nextCoordPair, ptCoords);\n    if (eprev <= 0 && enext > 0) {\n      if (!isBelow(ptCoords, currentCoords, rtan)) {\n        rtan = currentCoords;\n      }\n    } else if (eprev > 0 && enext <= 0) {\n      if (!isAbove(ptCoords, currentCoords, ltan)) {\n        ltan = currentCoords;\n      }\n    }\n    eprev = enext;\n  }\n  return [rtan, ltan];\n}\n\nfunction isAbove(point1: Position, point2: Position, point3: Position) {\n  return isLeft(point1, point2, point3) > 0;\n}\n\nfunction isBelow(point1: Position, point2: Position, point3: Position) {\n  return isLeft(point1, point2, point3) < 0;\n}\n\nfunction isLeft(point1: Position, point2: Position, point3: Position) {\n  return (\n    (point2[0] - point1[0]) * (point3[1] - point1[1]) -\n    (point3[0] - point1[0]) * (point2[1] - point1[1])\n  );\n}\n\nexport { polygonTangents };\nexport default polygonTangents;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}