{"ast":null,"code":"// index.js\nimport { flattenEach } from \"@turf/meta\";\nimport { getCoords, getType } from \"@turf/invariant\";\nimport { isObject, lineString, multiLineString, lengthToDegrees } from \"@turf/helpers\";\n\n// lib/intersection.js\nfunction ab(segment) {\n  var start = segment[0];\n  var end = segment[1];\n  return [end[0] - start[0], end[1] - start[1]];\n}\nfunction crossProduct(v1, v2) {\n  return v1[0] * v2[1] - v2[0] * v1[1];\n}\nfunction add(v1, v2) {\n  return [v1[0] + v2[0], v1[1] + v2[1]];\n}\nfunction sub(v1, v2) {\n  return [v1[0] - v2[0], v1[1] - v2[1]];\n}\nfunction scalarMult(s, v) {\n  return [s * v[0], s * v[1]];\n}\nfunction intersectSegments(a, b) {\n  var p = a[0];\n  var r = ab(a);\n  var q = b[0];\n  var s = ab(b);\n  var cross = crossProduct(r, s);\n  var qmp = sub(q, p);\n  var numerator = crossProduct(qmp, s);\n  var t = numerator / cross;\n  var intersection2 = add(p, scalarMult(t, r));\n  return intersection2;\n}\nfunction isParallel(a, b) {\n  var r = ab(a);\n  var s = ab(b);\n  return crossProduct(r, s) === 0;\n}\nfunction intersection(a, b) {\n  if (isParallel(a, b)) return false;\n  return intersectSegments(a, b);\n}\n\n// index.js\nfunction lineOffset(geojson, distance, options) {\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var units = options.units;\n  if (!geojson) throw new Error(\"geojson is required\");\n  if (distance === void 0 || distance === null || isNaN(distance)) throw new Error(\"distance is required\");\n  var type = getType(geojson);\n  var properties = geojson.properties;\n  switch (type) {\n    case \"LineString\":\n      return lineOffsetFeature(geojson, distance, units);\n    case \"MultiLineString\":\n      var coords = [];\n      flattenEach(geojson, function (feature) {\n        coords.push(lineOffsetFeature(feature, distance, units).geometry.coordinates);\n      });\n      return multiLineString(coords, properties);\n    default:\n      throw new Error(\"geometry \" + type + \" is not supported\");\n  }\n}\nfunction lineOffsetFeature(line, distance, units) {\n  var segments = [];\n  var offsetDegrees = lengthToDegrees(distance, units);\n  var coords = getCoords(line);\n  var finalCoords = [];\n  coords.forEach(function (currentCoords, index) {\n    if (index !== coords.length - 1) {\n      var segment = processSegment(currentCoords, coords[index + 1], offsetDegrees);\n      segments.push(segment);\n      if (index > 0) {\n        var seg2Coords = segments[index - 1];\n        var intersects = intersection(segment, seg2Coords);\n        if (intersects !== false) {\n          seg2Coords[1] = intersects;\n          segment[0] = intersects;\n        }\n        finalCoords.push(seg2Coords[0]);\n        if (index === coords.length - 2) {\n          finalCoords.push(segment[0]);\n          finalCoords.push(segment[1]);\n        }\n      }\n      if (coords.length === 2) {\n        finalCoords.push(segment[0]);\n        finalCoords.push(segment[1]);\n      }\n    }\n  });\n  return lineString(finalCoords, line.properties);\n}\nfunction processSegment(point1, point2, offset) {\n  var L = Math.sqrt((point1[0] - point2[0]) * (point1[0] - point2[0]) + (point1[1] - point2[1]) * (point1[1] - point2[1]));\n  var out1x = point1[0] + offset * (point2[1] - point1[1]) / L;\n  var out2x = point2[0] + offset * (point2[1] - point1[1]) / L;\n  var out1y = point1[1] + offset * (point1[0] - point2[0]) / L;\n  var out2y = point2[1] + offset * (point1[0] - point2[0]) / L;\n  return [[out1x, out1y], [out2x, out2y]];\n}\nvar turf_line_offset_default = lineOffset;\nexport { turf_line_offset_default as default, lineOffset };","map":{"version":3,"names":["flattenEach","getCoords","getType","isObject","lineString","multiLineString","lengthToDegrees","ab","segment","start","end","crossProduct","v1","v2","add","sub","scalarMult","s","v","intersectSegments","a","b","p","r","q","cross","qmp","numerator","t","intersection2","isParallel","intersection","lineOffset","geojson","distance","options","Error","units","isNaN","type","properties","lineOffsetFeature","coords","feature","push","geometry","coordinates","line","segments","offsetDegrees","finalCoords","forEach","currentCoords","index","length","processSegment","seg2Coords","intersects","point1","point2","offset","L","Math","sqrt","out1x","out2x","out1y","out2y","turf_line_offset_default"],"sources":["/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/line-offset/index.js","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/line-offset/lib/intersection.js"],"sourcesContent":["import { flattenEach } from \"@turf/meta\";\nimport { getCoords, getType } from \"@turf/invariant\";\nimport {\n  isObject,\n  lineString,\n  multiLineString,\n  lengthToDegrees,\n} from \"@turf/helpers\";\nimport { intersection } from \"./lib/intersection.js\";\n\n/**\n * Takes a {@link LineString|line} and returns a {@link LineString|line} at offset by the specified distance.\n *\n * @function\n * @param {Geometry|Feature<LineString|MultiLineString>} geojson input GeoJSON\n * @param {number} distance distance to offset the line (can be of negative value)\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, kilometers, inches, yards, meters\n * @returns {Feature<LineString|MultiLineString>} Line offset from the input line\n * @example\n * var line = turf.lineString([[-83, 30], [-84, 36], [-78, 41]], { \"stroke\": \"#F00\" });\n *\n * var offsetLine = turf.lineOffset(line, 2, {units: 'miles'});\n *\n * //addToMap\n * var addToMap = [offsetLine, line]\n * offsetLine.properties.stroke = \"#00F\"\n */\nfunction lineOffset(geojson, distance, options) {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var units = options.units;\n\n  // Valdiation\n  if (!geojson) throw new Error(\"geojson is required\");\n  if (distance === undefined || distance === null || isNaN(distance))\n    throw new Error(\"distance is required\");\n\n  var type = getType(geojson);\n  var properties = geojson.properties;\n\n  switch (type) {\n    case \"LineString\":\n      return lineOffsetFeature(geojson, distance, units);\n    case \"MultiLineString\":\n      var coords = [];\n      flattenEach(geojson, function (feature) {\n        coords.push(\n          lineOffsetFeature(feature, distance, units).geometry.coordinates\n        );\n      });\n      return multiLineString(coords, properties);\n    default:\n      throw new Error(\"geometry \" + type + \" is not supported\");\n  }\n}\n\n/**\n * Line Offset\n *\n * @private\n * @param {Geometry|Feature<LineString>} line input line\n * @param {number} distance distance to offset the line (can be of negative value)\n * @param {string} [units=kilometers] units\n * @returns {Feature<LineString>} Line offset from the input line\n */\nfunction lineOffsetFeature(line, distance, units) {\n  var segments = [];\n  var offsetDegrees = lengthToDegrees(distance, units);\n  var coords = getCoords(line);\n  var finalCoords = [];\n  coords.forEach(function (currentCoords, index) {\n    if (index !== coords.length - 1) {\n      var segment = processSegment(\n        currentCoords,\n        coords[index + 1],\n        offsetDegrees\n      );\n      segments.push(segment);\n      if (index > 0) {\n        var seg2Coords = segments[index - 1];\n        var intersects = intersection(segment, seg2Coords);\n\n        // Handling for line segments that aren't straight\n        if (intersects !== false) {\n          seg2Coords[1] = intersects;\n          segment[0] = intersects;\n        }\n\n        finalCoords.push(seg2Coords[0]);\n        if (index === coords.length - 2) {\n          finalCoords.push(segment[0]);\n          finalCoords.push(segment[1]);\n        }\n      }\n      // Handling for lines that only have 1 segment\n      if (coords.length === 2) {\n        finalCoords.push(segment[0]);\n        finalCoords.push(segment[1]);\n      }\n    }\n  });\n  return lineString(finalCoords, line.properties);\n}\n\n/**\n * Process Segment\n * Inspiration taken from http://stackoverflow.com/questions/2825412/draw-a-parallel-line\n *\n * @private\n * @param {Array<number>} point1 Point coordinates\n * @param {Array<number>} point2 Point coordinates\n * @param {number} offset Offset\n * @returns {Array<Array<number>>} offset points\n */\nfunction processSegment(point1, point2, offset) {\n  var L = Math.sqrt(\n    (point1[0] - point2[0]) * (point1[0] - point2[0]) +\n      (point1[1] - point2[1]) * (point1[1] - point2[1])\n  );\n\n  var out1x = point1[0] + (offset * (point2[1] - point1[1])) / L;\n  var out2x = point2[0] + (offset * (point2[1] - point1[1])) / L;\n  var out1y = point1[1] + (offset * (point1[0] - point2[0])) / L;\n  var out2y = point2[1] + (offset * (point1[0] - point2[0])) / L;\n  return [\n    [out1x, out1y],\n    [out2x, out2y],\n  ];\n}\n\nexport { lineOffset };\nexport default lineOffset;\n","/**\n * https://github.com/rook2pawn/node-intersection\n *\n * Author @rook2pawn\n */\n\n/**\n * AB\n *\n * @private\n * @param {Array<Array<number>>} segment - 2 vertex line segment\n * @returns {Array<number>} coordinates [x, y]\n */\nfunction ab(segment) {\n  var start = segment[0];\n  var end = segment[1];\n  return [end[0] - start[0], end[1] - start[1]];\n}\n\n/**\n * Cross Product\n *\n * @private\n * @param {Array<number>} v1 coordinates [x, y]\n * @param {Array<number>} v2 coordinates [x, y]\n * @returns {Array<number>} Cross Product\n */\nfunction crossProduct(v1, v2) {\n  return v1[0] * v2[1] - v2[0] * v1[1];\n}\n\n/**\n * Add\n *\n * @private\n * @param {Array<number>} v1 coordinates [x, y]\n * @param {Array<number>} v2 coordinates [x, y]\n * @returns {Array<number>} Add\n */\nfunction add(v1, v2) {\n  return [v1[0] + v2[0], v1[1] + v2[1]];\n}\n\n/**\n * Sub\n *\n * @private\n * @param {Array<number>} v1 coordinates [x, y]\n * @param {Array<number>} v2 coordinates [x, y]\n * @returns {Array<number>} Sub\n */\nfunction sub(v1, v2) {\n  return [v1[0] - v2[0], v1[1] - v2[1]];\n}\n\n/**\n * scalarMult\n *\n * @private\n * @param {number} s scalar\n * @param {Array<number>} v coordinates [x, y]\n * @returns {Array<number>} scalarMult\n */\nfunction scalarMult(s, v) {\n  return [s * v[0], s * v[1]];\n}\n\n/**\n * Intersect Segments\n *\n * @private\n * @param {Array<number>} a coordinates [x, y]\n * @param {Array<number>} b coordinates [x, y]\n * @returns {Array<number>} intersection\n */\nfunction intersectSegments(a, b) {\n  var p = a[0];\n  var r = ab(a);\n  var q = b[0];\n  var s = ab(b);\n\n  var cross = crossProduct(r, s);\n  var qmp = sub(q, p);\n  var numerator = crossProduct(qmp, s);\n  var t = numerator / cross;\n  var intersection = add(p, scalarMult(t, r));\n  return intersection;\n}\n\n/**\n * Is Parallel\n *\n * @private\n * @param {Array<number>} a coordinates [x, y]\n * @param {Array<number>} b coordinates [x, y]\n * @returns {boolean} true if a and b are parallel (or co-linear)\n */\nfunction isParallel(a, b) {\n  var r = ab(a);\n  var s = ab(b);\n  return crossProduct(r, s) === 0;\n}\n\n/**\n * Intersection\n *\n * @private\n * @param {Array<number>} a coordinates [x, y]\n * @param {Array<number>} b coordinates [x, y]\n * @returns {Array<number>|boolean} true if a and b are parallel (or co-linear)\n */\nfunction intersection(a, b) {\n  if (isParallel(a, b)) return false;\n  return intersectSegments(a, b);\n}\n\nexport { intersection };\nexport default intersection;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}