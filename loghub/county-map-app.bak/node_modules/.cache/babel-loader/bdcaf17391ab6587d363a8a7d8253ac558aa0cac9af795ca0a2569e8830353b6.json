{"ast":null,"code":"// index.ts\nimport { polygon as createPolygon, multiPolygon } from \"@turf/helpers\";\nimport * as polyclip from \"polyclip-ts\";\nimport { clone } from \"@turf/clone\";\nfunction mask(polygon, mask2, options) {\n  var _a;\n  const mutate = (_a = options == null ? void 0 : options.mutate) != null ? _a : false;\n  let maskTemplate = mask2;\n  if (mask2 && mutate === false) {\n    maskTemplate = clone(mask2);\n  }\n  const maskPolygon = createMask(maskTemplate);\n  let polygonOuters = null;\n  if (polygon.type === \"FeatureCollection\") {\n    polygonOuters = unionFc(polygon);\n  } else if (polygon.type === \"Feature\") {\n    polygonOuters = createGeomFromPolygonClippingOutput(polyclip.union(polygon.geometry.coordinates));\n  } else {\n    polygonOuters = createGeomFromPolygonClippingOutput(polyclip.union(polygon.coordinates));\n  }\n  polygonOuters.geometry.coordinates.forEach(function (contour) {\n    maskPolygon.geometry.coordinates.push(contour[0]);\n  });\n  return maskPolygon;\n}\nfunction unionFc(fc) {\n  const unioned = fc.features.length === 2 ? polyclip.union(fc.features[0].geometry.coordinates, fc.features[1].geometry.coordinates) : polyclip.union.apply(polyclip, fc.features.map(function (f) {\n    return f.geometry.coordinates;\n  }));\n  return createGeomFromPolygonClippingOutput(unioned);\n}\nfunction createGeomFromPolygonClippingOutput(unioned) {\n  return multiPolygon(unioned);\n}\nfunction createMask(mask2) {\n  const world = [[[180, 90], [-180, 90], [-180, -90], [180, -90], [180, 90]]];\n  let coordinates = world;\n  if (mask2) {\n    if (mask2.type === \"Feature\") {\n      coordinates = mask2.geometry.coordinates;\n    } else {\n      coordinates = mask2.coordinates;\n    }\n  }\n  return createPolygon(coordinates);\n}\nvar turf_mask_default = mask;\nexport { turf_mask_default as default, mask };","map":{"version":3,"names":["polygon","createPolygon","multiPolygon","polyclip","clone","mask","mask2","options","_a","mutate","maskTemplate","maskPolygon","createMask","polygonOuters","type","unionFc","createGeomFromPolygonClippingOutput","union","geometry","coordinates","forEach","contour","push","fc","unioned","features","length","apply","map","f","world","turf_mask_default"],"sources":["/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/mask/index.ts"],"sourcesContent":["import {\n  Feature,\n  FeatureCollection,\n  Polygon,\n  Position,\n  MultiPolygon,\n} from \"geojson\";\nimport { polygon as createPolygon, multiPolygon } from \"@turf/helpers\";\nimport * as polyclip from \"polyclip-ts\";\nimport { clone } from \"@turf/clone\";\n\n/**\n * Takes polygons or multipolygons and an optional mask, and returns an exterior\n * ring polygon with holes.\n *\n * @function\n * @param {Polygon|MultiPolygon|Feature<Polygon|MultiPolygon>|FeatureCollection<Polygon|MultiPolygon>} polygon GeoJSON polygon used as interior rings or holes\n * @param {Polygon|Feature<Polygon>} [mask] GeoJSON polygon used as the exterior ring (if undefined, the world extent is used)\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.mutate=false] allows the `mask` GeoJSON input to be mutated (performance improvement if true)\n * @returns {Feature<Polygon>} Masked Polygon (exterior ring with holes)\n * @example\n * const polygon = turf.polygon([[[112, -21], [116, -36], [146, -39], [153, -24], [133, -10], [112, -21]]]);\n * const mask = turf.polygon([[[90, -55], [170, -55], [170, 10], [90, 10], [90, -55]]]);\n *\n * const masked = turf.mask(polygon, mask);\n *\n * //addToMap\n * const addToMap = [masked]\n */\nfunction mask<T extends Polygon | MultiPolygon>(\n  polygon: T | Feature<T> | FeatureCollection<T>,\n  mask?: Polygon | Feature<Polygon>,\n  options?: { mutate?: boolean }\n): Feature<Polygon> {\n  const mutate = options?.mutate ?? false; // by default, do not mutate\n\n  let maskTemplate = mask;\n  if (mask && mutate === false) {\n    // Clone mask if requested to avoid side effects\n    maskTemplate = clone(mask);\n  }\n\n  // Define initial mask\n  const maskPolygon = createMask(maskTemplate);\n\n  let polygonOuters = null;\n  if (polygon.type === \"FeatureCollection\") {\n    polygonOuters = unionFc(polygon);\n  } else if (polygon.type === \"Feature\") {\n    // Need to cast below as Position[][] isn't quite as strict as Geom, even\n    // though they should be equivalent.\n    polygonOuters = createGeomFromPolygonClippingOutput(\n      polyclip.union(polygon.geometry.coordinates as polyclip.Geom)\n    );\n  } else {\n    // Geometry\n    // Need to cast below as Position[][] isn't quite as strict as Geom, even\n    // though they should be equivalent.\n    polygonOuters = createGeomFromPolygonClippingOutput(\n      polyclip.union(polygon.coordinates as polyclip.Geom)\n    );\n  }\n\n  polygonOuters.geometry.coordinates.forEach(function (contour) {\n    maskPolygon.geometry.coordinates.push(contour[0]);\n  });\n\n  return maskPolygon;\n}\n\nfunction unionFc(fc: FeatureCollection<Polygon | MultiPolygon>) {\n  // Need to cast below as Position[][] isn't quite as strict as Geom, even\n  // though they should be equivalent.\n\n  // Stick with apply() below as spread operator degrades performance. Have\n  // to disable prefer-spread lint rule though.\n  /* eslint-disable prefer-spread */\n  const unioned =\n    fc.features.length === 2\n      ? polyclip.union(\n          fc.features[0].geometry.coordinates as polyclip.Geom,\n          fc.features[1].geometry.coordinates as polyclip.Geom\n        )\n      : polyclip.union.apply(\n          polyclip,\n          fc.features.map(function (f) {\n            return f.geometry.coordinates;\n          }) as [polyclip.Geom, ...polyclip.Geom[]]\n        );\n  /* eslint-enable */\n  return createGeomFromPolygonClippingOutput(unioned);\n}\n\nfunction createGeomFromPolygonClippingOutput(unioned: Position[][][]) {\n  return multiPolygon(unioned);\n}\n\n/**\n * Create Mask Coordinates\n *\n * @private\n * @param {Feature<Polygon>} [mask] default to world if undefined\n * @returns {Feature<Polygon>} mask as a polygon\n */\nfunction createMask(mask: Feature<Polygon> | Polygon | undefined) {\n  const world = [\n    [\n      [180, 90],\n      [-180, 90],\n      [-180, -90],\n      [180, -90],\n      [180, 90],\n    ],\n  ];\n  let coordinates = world;\n  if (mask) {\n    if (mask.type === \"Feature\") {\n      // polygon feature\n      coordinates = mask.geometry.coordinates;\n    } else {\n      // polygon geometry\n      coordinates = mask.coordinates;\n    }\n  }\n  return createPolygon(coordinates);\n}\n\nexport { mask };\nexport default mask;\n"],"mappings":";AAOA,SAASA,OAAA,IAAWC,aAAA,EAAeC,YAAA,QAAoB;AACvD,YAAYC,QAAA,MAAc;AAC1B,SAASC,KAAA,QAAa;AAqBtB,SAASC,KACPL,OAAA,EACAM,KAAA,EACAC,OAAA,EACkB;EAlCpB,IAAAC,EAAA;EAmCE,MAAMC,MAAA,IAASD,EAAA,GAAAD,OAAA,oBAAAA,OAAA,CAASE,MAAA,KAAT,OAAAD,EAAA,GAAmB;EAElC,IAAIE,YAAA,GAAeJ,KAAA;EACnB,IAAIA,KAAA,IAAQG,MAAA,KAAW,OAAO;IAE5BC,YAAA,GAAeN,KAAA,CAAME,KAAI;EAC3B;EAGA,MAAMK,WAAA,GAAcC,UAAA,CAAWF,YAAY;EAE3C,IAAIG,aAAA,GAAgB;EACpB,IAAIb,OAAA,CAAQc,IAAA,KAAS,qBAAqB;IACxCD,aAAA,GAAgBE,OAAA,CAAQf,OAAO;EACjC,WAAWA,OAAA,CAAQc,IAAA,KAAS,WAAW;IAGrCD,aAAA,GAAgBG,mCAAA,CACLb,QAAA,CAAAc,KAAA,CAAMjB,OAAA,CAAQkB,QAAA,CAASC,WAA4B,CAC9D;EACF,OAAO;IAILN,aAAA,GAAgBG,mCAAA,CACLb,QAAA,CAAAc,KAAA,CAAMjB,OAAA,CAAQmB,WAA4B,CACrD;EACF;EAEAN,aAAA,CAAcK,QAAA,CAASC,WAAA,CAAYC,OAAA,CAAQ,UAAUC,OAAA,EAAS;IAC5DV,WAAA,CAAYO,QAAA,CAASC,WAAA,CAAYG,IAAA,CAAKD,OAAA,CAAQ,CAAC,CAAC;EAClD,CAAC;EAED,OAAOV,WAAA;AACT;AAEA,SAASI,QAAQQ,EAAA,EAA+C;EAO9D,MAAMC,OAAA,GACJD,EAAA,CAAGE,QAAA,CAASC,MAAA,KAAW,IACVvB,QAAA,CAAAc,KAAA,CACPM,EAAA,CAAGE,QAAA,CAAS,CAAC,EAAEP,QAAA,CAASC,WAAA,EACxBI,EAAA,CAAGE,QAAA,CAAS,CAAC,EAAEP,QAAA,CAASC,WAC1B,IACShB,QAAA,CAAAc,KAAA,CAAMU,KAAA,CACbxB,QAAA,EACAoB,EAAA,CAAGE,QAAA,CAASG,GAAA,CAAI,UAAUC,CAAA,EAAG;IAC3B,OAAOA,CAAA,CAAEX,QAAA,CAASC,WAAA;EACpB,CAAC,CACH;EAEN,OAAOH,mCAAA,CAAoCQ,OAAO;AACpD;AAEA,SAASR,oCAAoCQ,OAAA,EAAyB;EACpE,OAAOtB,YAAA,CAAasB,OAAO;AAC7B;AASA,SAASZ,WAAWN,KAAA,EAA8C;EAChE,MAAMwB,KAAA,GAAQ,CACZ,CACE,CAAC,KAAK,EAAE,GACR,CAAC,MAAM,EAAE,GACT,CAAC,MAAM,GAAG,GACV,CAAC,KAAK,GAAG,GACT,CAAC,KAAK,EAAE,EACV,CACF;EACA,IAAIX,WAAA,GAAcW,KAAA;EAClB,IAAIxB,KAAA,EAAM;IACR,IAAIA,KAAA,CAAKQ,IAAA,KAAS,WAAW;MAE3BK,WAAA,GAAcb,KAAA,CAAKY,QAAA,CAASC,WAAA;IAC9B,OAAO;MAELA,WAAA,GAAcb,KAAA,CAAKa,WAAA;IACrB;EACF;EACA,OAAOlB,aAAA,CAAckB,WAAW;AAClC;AAGA,IAAOY,iBAAA,GAAQ1B,IAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}