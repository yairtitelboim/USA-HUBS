{"ast":null,"code":"// index.ts\nimport { circle } from \"@turf/circle\";\nimport { destination } from \"@turf/destination\";\nimport { lineString } from \"@turf/helpers\";\nfunction lineArc(center, radius, bearing1, bearing2, options = {}) {\n  const steps = options.steps || 64;\n  const angle1 = convertAngleTo360(bearing1);\n  const angle2 = convertAngleTo360(bearing2);\n  const properties = !Array.isArray(center) && center.type === \"Feature\" ? center.properties : {};\n  if (angle1 === angle2) {\n    return lineString(circle(center, radius, options).geometry.coordinates[0], properties);\n  }\n  const arcStartDegree = angle1;\n  const arcEndDegree = angle1 < angle2 ? angle2 : angle2 + 360;\n  let alpha = arcStartDegree;\n  const coordinates = [];\n  let i = 0;\n  const arcStep = (arcEndDegree - arcStartDegree) / steps;\n  while (alpha <= arcEndDegree) {\n    coordinates.push(destination(center, radius, alpha, options).geometry.coordinates);\n    i++;\n    alpha = arcStartDegree + i * arcStep;\n  }\n  return lineString(coordinates, properties);\n}\nfunction convertAngleTo360(alpha) {\n  let beta = alpha % 360;\n  if (beta < 0) {\n    beta += 360;\n  }\n  return beta;\n}\nvar turf_line_arc_default = lineArc;\nexport { turf_line_arc_default as default, lineArc };","map":{"version":3,"names":["circle","destination","lineString","lineArc","center","radius","bearing1","bearing2","options","steps","angle1","convertAngleTo360","angle2","properties","Array","isArray","type","geometry","coordinates","arcStartDegree","arcEndDegree","alpha","i","arcStep","push","beta","turf_line_arc_default"],"sources":["/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/line-arc/index.ts"],"sourcesContent":["import { Feature, LineString } from \"geojson\";\nimport { circle } from \"@turf/circle\";\nimport { destination } from \"@turf/destination\";\nimport { Coord, lineString, Units } from \"@turf/helpers\";\n\n/**\n * Creates a circular arc, of a circle of the given radius and center point, between bearing1 and bearing2;\n * 0 bearing is North of center point, positive clockwise.\n *\n * @function\n * @param {Coord} center center point\n * @param {number} radius radius of the circle\n * @param {number} bearing1 angle, in decimal degrees, of the first radius of the arc\n * @param {number} bearing2 angle, in decimal degrees, of the second radius of the arc\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.steps=64] number of steps (straight segments) that will constitute the arc\n * @param {string} [options.units='kilometers'] miles, kilometers, degrees, or radians\n * @returns {Feature<LineString>} line arc\n * @example\n * var center = turf.point([-75, 40]);\n * var radius = 5;\n * var bearing1 = 25;\n * var bearing2 = 47;\n *\n * var arc = turf.lineArc(center, radius, bearing1, bearing2);\n *\n * //addToMap\n * var addToMap = [center, arc]\n */\nfunction lineArc(\n  center: Coord,\n  radius: number,\n  bearing1: number,\n  bearing2: number,\n  options: {\n    steps?: number;\n    units?: Units;\n  } = {}\n): Feature<LineString> {\n  // default params\n  const steps = options.steps || 64;\n\n  const angle1 = convertAngleTo360(bearing1);\n  const angle2 = convertAngleTo360(bearing2);\n  const properties =\n    !Array.isArray(center) && center.type === \"Feature\"\n      ? center.properties\n      : {};\n\n  // handle angle parameters\n  if (angle1 === angle2) {\n    return lineString(\n      circle(center, radius, options).geometry.coordinates[0],\n      properties\n    );\n  }\n  const arcStartDegree = angle1;\n  const arcEndDegree = angle1 < angle2 ? angle2 : angle2 + 360;\n\n  let alpha = arcStartDegree;\n  const coordinates = [];\n  let i = 0;\n  // How many degrees we'll swing around between each step.\n  const arcStep = (arcEndDegree - arcStartDegree) / steps;\n  // Add coords to the list, increasing the angle from our start bearing\n  // (alpha) by arcStep degrees until we reach the end bearing.\n  while (alpha <= arcEndDegree) {\n    coordinates.push(\n      destination(center, radius, alpha, options).geometry.coordinates\n    );\n    i++;\n    alpha = arcStartDegree + i * arcStep;\n  }\n  return lineString(coordinates, properties);\n}\n\n/**\n * Takes any angle in  degrees\n * and returns a valid angle between 0-360 degrees\n *\n * @private\n * @param {number} alpha angle between -180-180 degrees\n * @returns {number} angle between 0-360 degrees\n */\nfunction convertAngleTo360(alpha: number) {\n  let beta = alpha % 360;\n  if (beta < 0) {\n    beta += 360;\n  }\n  return beta;\n}\n\nexport { lineArc };\nexport default lineArc;\n"],"mappings":";AACA,SAASA,MAAA,QAAc;AACvB,SAASC,WAAA,QAAmB;AAC5B,SAAgBC,UAAA,QAAyB;AA0BzC,SAASC,QACPC,MAAA,EACAC,MAAA,EACAC,QAAA,EACAC,QAAA,EACAC,OAAA,GAGI,CAAC,GACgB;EAErB,MAAMC,KAAA,GAAQD,OAAA,CAAQC,KAAA,IAAS;EAE/B,MAAMC,MAAA,GAASC,iBAAA,CAAkBL,QAAQ;EACzC,MAAMM,MAAA,GAASD,iBAAA,CAAkBJ,QAAQ;EACzC,MAAMM,UAAA,GACJ,CAACC,KAAA,CAAMC,OAAA,CAAQX,MAAM,KAAKA,MAAA,CAAOY,IAAA,KAAS,YACtCZ,MAAA,CAAOS,UAAA,GACP,CAAC;EAGP,IAAIH,MAAA,KAAWE,MAAA,EAAQ;IACrB,OAAOV,UAAA,CACLF,MAAA,CAAOI,MAAA,EAAQC,MAAA,EAAQG,OAAO,EAAES,QAAA,CAASC,WAAA,CAAY,CAAC,GACtDL,UACF;EACF;EACA,MAAMM,cAAA,GAAiBT,MAAA;EACvB,MAAMU,YAAA,GAAeV,MAAA,GAASE,MAAA,GAASA,MAAA,GAASA,MAAA,GAAS;EAEzD,IAAIS,KAAA,GAAQF,cAAA;EACZ,MAAMD,WAAA,GAAc,EAAC;EACrB,IAAII,CAAA,GAAI;EAER,MAAMC,OAAA,IAAWH,YAAA,GAAeD,cAAA,IAAkBV,KAAA;EAGlD,OAAOY,KAAA,IAASD,YAAA,EAAc;IAC5BF,WAAA,CAAYM,IAAA,CACVvB,WAAA,CAAYG,MAAA,EAAQC,MAAA,EAAQgB,KAAA,EAAOb,OAAO,EAAES,QAAA,CAASC,WACvD;IACAI,CAAA;IACAD,KAAA,GAAQF,cAAA,GAAiBG,CAAA,GAAIC,OAAA;EAC/B;EACA,OAAOrB,UAAA,CAAWgB,WAAA,EAAaL,UAAU;AAC3C;AAUA,SAASF,kBAAkBU,KAAA,EAAe;EACxC,IAAII,IAAA,GAAOJ,KAAA,GAAQ;EACnB,IAAII,IAAA,GAAO,GAAG;IACZA,IAAA,IAAQ;EACV;EACA,OAAOA,IAAA;AACT;AAGA,IAAOC,qBAAA,GAAQvB,OAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}