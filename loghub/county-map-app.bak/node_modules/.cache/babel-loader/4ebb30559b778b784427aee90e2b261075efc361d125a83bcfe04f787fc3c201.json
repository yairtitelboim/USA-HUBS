{"ast":null,"code":"// index.ts\nimport { featureCollection, isObject, multiPolygon } from \"@turf/helpers\";\nimport { collectionOf } from \"@turf/invariant\";\nimport { featureEach } from \"@turf/meta\";\nimport { flatten } from \"@turf/flatten\";\nimport * as polyclip from \"polyclip-ts\";\nfunction dissolve(fc, options = {}) {\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  const {\n    propertyName\n  } = options;\n  collectionOf(fc, \"Polygon\", \"dissolve\");\n  const outFeatures = [];\n  if (!propertyName) {\n    return flatten(multiPolygon(polyclip.union.apply(null,\n    // List of polygons expressed as Position[][][] a.k.a. Geom[]\n    fc.features.map(function (f) {\n      return f.geometry.coordinates;\n    }))));\n  } else {\n    const uniquePropertyVals = {};\n    featureEach(fc, function (feature) {\n      if (feature.properties) {\n        if (!Object.prototype.hasOwnProperty.call(uniquePropertyVals, feature.properties[propertyName])) {\n          uniquePropertyVals[feature.properties[propertyName]] = [];\n        }\n        uniquePropertyVals[feature.properties[propertyName]].push(feature);\n      }\n    });\n    const vals = Object.keys(uniquePropertyVals);\n    for (let i = 0; i < vals.length; i++) {\n      const mp = multiPolygon(polyclip.union.apply(null,\n      // List of polygons expressed as Position[][][] a.k.a. Geom[]\n      uniquePropertyVals[vals[i]].map(function (f) {\n        return f.geometry.coordinates;\n      })));\n      if (mp && mp.properties) {\n        mp.properties[propertyName] = vals[i];\n        outFeatures.push(mp);\n      }\n    }\n  }\n  return flatten(featureCollection(outFeatures));\n}\nvar turf_dissolve_default = dissolve;\nexport { turf_dissolve_default as default, dissolve };","map":{"version":3,"names":["featureCollection","isObject","multiPolygon","collectionOf","featureEach","flatten","polyclip","dissolve","fc","options","Error","propertyName","outFeatures","union","apply","features","map","f","geometry","coordinates","uniquePropertyVals","feature","properties","Object","prototype","hasOwnProperty","call","push","vals","keys","i","length","mp","turf_dissolve_default"],"sources":["/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/dissolve/index.ts"],"sourcesContent":["import { Feature, FeatureCollection, Polygon } from \"geojson\";\nimport { featureCollection, isObject, multiPolygon } from \"@turf/helpers\";\nimport { collectionOf } from \"@turf/invariant\";\nimport { featureEach } from \"@turf/meta\";\nimport { flatten } from \"@turf/flatten\";\nimport * as polyclip from \"polyclip-ts\";\n\n/**\n * Dissolves a FeatureCollection of {@link Polygon} features, filtered by an optional property name:value.\n * Note that {@link MultiPolygon} features within the collection are not supported\n *\n * @function\n * @param {FeatureCollection<Polygon>} featureCollection input feature collection to be dissolved\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.propertyName] features with the same `propertyName` value will be dissolved.\n * @returns {FeatureCollection<Polygon>} a FeatureCollection containing the dissolved polygons\n * @example\n * var features = turf.featureCollection([\n *   turf.polygon([[[0, 0], [0, 1], [1, 1], [1, 0], [0, 0]]], {combine: 'yes'}),\n *   turf.polygon([[[0, -1], [0, 0], [1, 0], [1, -1], [0,-1]]], {combine: 'yes'}),\n *   turf.polygon([[[1,-1],[1, 0], [2, 0], [2, -1], [1, -1]]], {combine: 'no'}),\n * ]);\n *\n * var dissolved = turf.dissolve(features, {propertyName: 'combine'});\n *\n * //addToMap\n * var addToMap = [features, dissolved]\n */\nfunction dissolve(\n  fc: FeatureCollection<Polygon>,\n  options: {\n    propertyName?: string;\n  } = {}\n): FeatureCollection<Polygon> {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  const { propertyName } = options;\n\n  // Input validation\n  collectionOf(fc, \"Polygon\", \"dissolve\");\n\n  // Main\n  const outFeatures = [];\n  if (!propertyName) {\n    return flatten(\n      multiPolygon(\n        polyclip.union.apply(\n          null,\n          // List of polygons expressed as Position[][][] a.k.a. Geom[]\n          fc.features.map(function (f) {\n            return f.geometry.coordinates;\n          }) as [polyclip.Geom, ...polyclip.Geom[]]\n        )\n      )\n    );\n  } else {\n    // Group polygons by the value of their property named by propertyName\n    const uniquePropertyVals: { [key: string]: Feature[] } = {};\n    featureEach(fc, function (feature) {\n      if (feature.properties) {\n        if (\n          !Object.prototype.hasOwnProperty.call(\n            uniquePropertyVals,\n            feature.properties[propertyName]\n          )\n        ) {\n          uniquePropertyVals[feature.properties[propertyName]] =\n            [] as Feature[];\n        }\n        uniquePropertyVals[feature.properties[propertyName]].push(feature);\n      }\n    });\n    const vals = Object.keys(uniquePropertyVals);\n\n    // Export each group of polygons as a separate feature.\n    for (let i = 0; i < vals.length; i++) {\n      const mp = multiPolygon(\n        polyclip.union.apply(\n          null,\n          // List of polygons expressed as Position[][][] a.k.a. Geom[]\n          (uniquePropertyVals[vals[i]] as Feature<Polygon>[]).map(function (f) {\n            return f.geometry.coordinates;\n          }) as [polyclip.Geom, ...polyclip.Geom[]]\n        )\n      );\n      if (mp && mp.properties) {\n        mp.properties[propertyName] = vals[i];\n        outFeatures.push(mp);\n      }\n    }\n  }\n\n  return flatten(featureCollection(outFeatures));\n}\n\nexport { dissolve };\nexport default dissolve;\n"],"mappings":";AACA,SAASA,iBAAA,EAAmBC,QAAA,EAAUC,YAAA,QAAoB;AAC1D,SAASC,YAAA,QAAoB;AAC7B,SAASC,WAAA,QAAmB;AAC5B,SAASC,OAAA,QAAe;AACxB,YAAYC,QAAA,MAAc;AAuB1B,SAASC,SACPC,EAAA,EACAC,OAAA,GAEI,CAAC,GACuB;EAE5BA,OAAA,GAAUA,OAAA,IAAW,CAAC;EACtB,IAAI,CAACR,QAAA,CAASQ,OAAO,GAAG,MAAM,IAAIC,KAAA,CAAM,oBAAoB;EAC5D,MAAM;IAAEC;EAAa,IAAIF,OAAA;EAGzBN,YAAA,CAAaK,EAAA,EAAI,WAAW,UAAU;EAGtC,MAAMI,WAAA,GAAc,EAAC;EACrB,IAAI,CAACD,YAAA,EAAc;IACjB,OAAON,OAAA,CACLH,YAAA,CACWI,QAAA,CAAAO,KAAA,CAAMC,KAAA,CACb;IAAA;IAEAN,EAAA,CAAGO,QAAA,CAASC,GAAA,CAAI,UAAUC,CAAA,EAAG;MAC3B,OAAOA,CAAA,CAAEC,QAAA,CAASC,WAAA;IACpB,CAAC,CACH,CACF,CACF;EACF,OAAO;IAEL,MAAMC,kBAAA,GAAmD,CAAC;IAC1DhB,WAAA,CAAYI,EAAA,EAAI,UAAUa,OAAA,EAAS;MACjC,IAAIA,OAAA,CAAQC,UAAA,EAAY;QACtB,IACE,CAACC,MAAA,CAAOC,SAAA,CAAUC,cAAA,CAAeC,IAAA,CAC/BN,kBAAA,EACAC,OAAA,CAAQC,UAAA,CAAWX,YAAY,CACjC,GACA;UACAS,kBAAA,CAAmBC,OAAA,CAAQC,UAAA,CAAWX,YAAY,CAAC,IACjD,EAAC;QACL;QACAS,kBAAA,CAAmBC,OAAA,CAAQC,UAAA,CAAWX,YAAY,CAAC,EAAEgB,IAAA,CAAKN,OAAO;MACnE;IACF,CAAC;IACD,MAAMO,IAAA,GAAOL,MAAA,CAAOM,IAAA,CAAKT,kBAAkB;IAG3C,SAASU,CAAA,GAAI,GAAGA,CAAA,GAAIF,IAAA,CAAKG,MAAA,EAAQD,CAAA,IAAK;MACpC,MAAME,EAAA,GAAK9B,YAAA,CACAI,QAAA,CAAAO,KAAA,CAAMC,KAAA,CACb;MAAA;MAECM,kBAAA,CAAmBQ,IAAA,CAAKE,CAAC,CAAC,EAAyBd,GAAA,CAAI,UAAUC,CAAA,EAAG;QACnE,OAAOA,CAAA,CAAEC,QAAA,CAASC,WAAA;MACpB,CAAC,CACH,CACF;MACA,IAAIa,EAAA,IAAMA,EAAA,CAAGV,UAAA,EAAY;QACvBU,EAAA,CAAGV,UAAA,CAAWX,YAAY,IAAIiB,IAAA,CAAKE,CAAC;QACpClB,WAAA,CAAYe,IAAA,CAAKK,EAAE;MACrB;IACF;EACF;EAEA,OAAO3B,OAAA,CAAQL,iBAAA,CAAkBY,WAAW,CAAC;AAC/C;AAGA,IAAOqB,qBAAA,GAAQ1B,QAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}