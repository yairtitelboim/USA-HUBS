{"ast":null,"code":"// index.ts\nimport { distance } from \"@turf/distance\";\nimport { feature, featureCollection } from \"@turf/helpers\";\nimport { featureEach } from \"@turf/meta\";\nimport { tin } from \"@turf/tin\";\n\n// lib/turf-dissolve.ts\nimport { clone as clone3 } from \"@turf/clone\";\nimport { isObject as isObject2 } from \"@turf/helpers\";\nimport { getType as getType3 } from \"@turf/invariant\";\nimport { flattenEach as flattenEach2 } from \"@turf/meta\";\n\n// lib/turf-line-dissolve.ts\nimport { clone } from \"@turf/clone\";\nimport { isObject, lineString, multiLineString } from \"@turf/helpers\";\nimport { getType } from \"@turf/invariant\";\nimport { lineReduce } from \"@turf/meta\";\nfunction lineDissolve(geojson, options = {}) {\n  options = options || {};\n  if (!isObject(options)) {\n    throw new Error(\"options is invalid\");\n  }\n  const mutate = options.mutate;\n  if (getType(geojson) !== \"FeatureCollection\") {\n    throw new Error(\"geojson must be a FeatureCollection\");\n  }\n  if (!geojson.features.length) {\n    throw new Error(\"geojson is empty\");\n  }\n  if (mutate === false || mutate === void 0) {\n    geojson = clone(geojson);\n  }\n  const result = [];\n  const lastLine = lineReduce(geojson, (previousLine, currentLine) => {\n    const merged = mergeLineStrings(previousLine, currentLine);\n    if (merged) {\n      return merged;\n    } else {\n      result.push(previousLine);\n      return currentLine;\n    }\n  });\n  if (lastLine) {\n    result.push(lastLine);\n  }\n  if (!result.length) {\n    return null;\n  } else if (result.length === 1) {\n    return result[0];\n  } else {\n    return multiLineString(result.map(line => {\n      return line.coordinates;\n    }));\n  }\n}\nfunction coordId(coord) {\n  return coord[0].toString() + \",\" + coord[1].toString();\n}\nfunction mergeLineStrings(a, b) {\n  const coords1 = a.geometry.coordinates;\n  const coords2 = b.geometry.coordinates;\n  const s1 = coordId(coords1[0]);\n  const e1 = coordId(coords1[coords1.length - 1]);\n  const s2 = coordId(coords2[0]);\n  const e2 = coordId(coords2[coords2.length - 1]);\n  let coords;\n  if (s1 === e2) {\n    coords = coords2.concat(coords1.slice(1));\n  } else if (s2 === e1) {\n    coords = coords1.concat(coords2.slice(1));\n  } else if (s1 === s2) {\n    coords = coords1.slice(1).reverse().concat(coords2);\n  } else if (e1 === e2) {\n    coords = coords1.concat(coords2.reverse().slice(1));\n  } else {\n    return null;\n  }\n  return lineString(coords);\n}\n\n// lib/turf-polygon-dissolve.ts\nimport { clone as clone2 } from \"@turf/clone\";\nimport { geometryCollection } from \"@turf/helpers\";\nimport { getType as getType2 } from \"@turf/invariant\";\nimport { flattenEach } from \"@turf/meta\";\nimport { merge } from \"topojson-client\";\nimport { topology } from \"topojson-server\";\nfunction polygonDissolve(geojson, options = {}) {\n  if (getType2(geojson) !== \"FeatureCollection\") {\n    throw new Error(\"geojson must be a FeatureCollection\");\n  }\n  if (!geojson.features.length) {\n    throw new Error(\"geojson is empty\");\n  }\n  if (options.mutate === false || options.mutate === void 0) {\n    geojson = clone2(geojson);\n  }\n  const geoms = [];\n  flattenEach(geojson, feature2 => {\n    geoms.push(feature2.geometry);\n  });\n  const topo = topology({\n    geoms: geometryCollection(geoms).geometry\n  });\n  const merged = merge(topo, topo.objects.geoms.geometries);\n  return merged;\n}\n\n// lib/turf-dissolve.ts\nfunction dissolve(geojson, options = {}) {\n  options = options || {};\n  if (!isObject2(options)) {\n    throw new Error(\"options is invalid\");\n  }\n  const mutate = options.mutate;\n  if (getType3(geojson) !== \"FeatureCollection\") {\n    throw new Error(\"geojson must be a FeatureCollection\");\n  }\n  if (!geojson.features.length) {\n    throw new Error(\"geojson is empty\");\n  }\n  if (mutate === false || mutate === void 0) {\n    geojson = clone3(geojson);\n  }\n  const type = getHomogenousType(geojson);\n  if (!type) {\n    throw new Error(\"geojson must be homogenous\");\n  }\n  const data = geojson;\n  switch (type) {\n    case \"LineString\":\n      return lineDissolve(data, options);\n    case \"Polygon\":\n      return polygonDissolve(data, options);\n    default:\n      throw new Error(type + \" is not supported\");\n  }\n}\nfunction getHomogenousType(geojson) {\n  const types = {};\n  flattenEach2(geojson, feature2 => {\n    types[feature2.geometry.type] = true;\n  });\n  const keys = Object.keys(types);\n  if (keys.length === 1) {\n    return keys[0];\n  }\n  return null;\n}\n\n// index.ts\nfunction concave(points, options = {}) {\n  const maxEdge = options.maxEdge || Infinity;\n  const cleaned = removeDuplicates(points);\n  const tinPolys = tin(cleaned);\n  tinPolys.features = tinPolys.features.filter(triangle => {\n    const pt1 = triangle.geometry.coordinates[0][0];\n    const pt2 = triangle.geometry.coordinates[0][1];\n    const pt3 = triangle.geometry.coordinates[0][2];\n    const dist1 = distance(pt1, pt2, options);\n    const dist2 = distance(pt2, pt3, options);\n    const dist3 = distance(pt1, pt3, options);\n    return dist1 <= maxEdge && dist2 <= maxEdge && dist3 <= maxEdge;\n  });\n  if (tinPolys.features.length < 1) {\n    return null;\n  }\n  const dissolved = dissolve(tinPolys);\n  if (dissolved.coordinates.length === 1) {\n    dissolved.coordinates = dissolved.coordinates[0];\n    dissolved.type = \"Polygon\";\n  }\n  return feature(dissolved);\n}\nfunction removeDuplicates(points) {\n  const cleaned = [];\n  const existing = {};\n  featureEach(points, pt => {\n    if (!pt.geometry) {\n      return;\n    }\n    const key = pt.geometry.coordinates.join(\"-\");\n    if (!Object.prototype.hasOwnProperty.call(existing, key)) {\n      cleaned.push(pt);\n      existing[key] = true;\n    }\n  });\n  return featureCollection(cleaned);\n}\nvar turf_concave_default = concave;\nexport { concave, turf_concave_default as default };","map":{"version":3,"names":["distance","feature","featureCollection","featureEach","tin","clone","clone3","isObject","isObject2","getType","getType3","flattenEach","flattenEach2","lineString","multiLineString","lineReduce","lineDissolve","geojson","options","Error","mutate","features","length","result","lastLine","previousLine","currentLine","merged","mergeLineStrings","push","map","line","coordinates","coordId","coord","toString","a","b","coords1","geometry","coords2","s1","e1","s2","e2","coords","concat","slice","reverse","clone2","geometryCollection","getType2","merge","topology","polygonDissolve","geoms","feature2","topo","objects","geometries","dissolve","type","getHomogenousType","data","types","keys","Object","concave","points","maxEdge","Infinity","cleaned","removeDuplicates","tinPolys","filter","triangle","pt1","pt2","pt3","dist1","dist2","dist3","dissolved","existing","pt","key","join","prototype","hasOwnProperty","call","turf_concave_default"],"sources":["/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/concave/index.ts","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/concave/lib/turf-dissolve.ts","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/concave/lib/turf-line-dissolve.ts","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/concave/lib/turf-polygon-dissolve.ts"],"sourcesContent":["import { distance } from \"@turf/distance\";\nimport { feature, featureCollection } from \"@turf/helpers\";\nimport {\n  Feature,\n  FeatureCollection,\n  MultiPolygon,\n  Point,\n  Polygon,\n} from \"geojson\";\nimport { Units } from \"@turf/helpers\";\nimport { featureEach } from \"@turf/meta\";\nimport { tin } from \"@turf/tin\";\nimport { dissolve } from \"./lib/turf-dissolve.js\";\n\n/**\n * Takes a set of {@link Point|points} and returns a concave hull Polygon or MultiPolygon.\n * Internally, this uses [turf-tin](https://github.com/Turfjs/turf-tin) to generate geometries.\n *\n * @function\n * @param {FeatureCollection<Point>} points input points\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.maxEdge=Infinity] the length (in 'units') of an edge necessary for part of the\n * hull to become concave.\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers\n * @returns {Feature<(Polygon|MultiPolygon)>|null} a concave hull (null value is returned if unable to compute hull)\n * @example\n * var points = turf.featureCollection([\n *   turf.point([-63.601226, 44.642643]),\n *   turf.point([-63.591442, 44.651436]),\n *   turf.point([-63.580799, 44.648749]),\n *   turf.point([-63.573589, 44.641788]),\n *   turf.point([-63.587665, 44.64533]),\n *   turf.point([-63.595218, 44.64765])\n * ]);\n * var options = {units: 'miles', maxEdge: 1};\n *\n * var hull = turf.concave(points, options);\n *\n * //addToMap\n * var addToMap = [points, hull]\n */\nfunction concave(\n  points: FeatureCollection<Point>,\n  options: { maxEdge?: number; units?: Units } = {}\n): Feature<Polygon | MultiPolygon> | null {\n  const maxEdge = options.maxEdge || Infinity;\n\n  const cleaned = removeDuplicates(points);\n\n  const tinPolys = tin(cleaned);\n  // calculate length of all edges and area of all triangles\n  // and remove triangles that fail the max length test\n  tinPolys.features = tinPolys.features.filter((triangle) => {\n    const pt1 = triangle.geometry.coordinates[0][0];\n    const pt2 = triangle.geometry.coordinates[0][1];\n    const pt3 = triangle.geometry.coordinates[0][2];\n    const dist1 = distance(pt1, pt2, options);\n    const dist2 = distance(pt2, pt3, options);\n    const dist3 = distance(pt1, pt3, options);\n    return dist1 <= maxEdge && dist2 <= maxEdge && dist3 <= maxEdge;\n  });\n\n  if (tinPolys.features.length < 1) {\n    return null;\n  }\n\n  // merge the adjacent triangles\n  const dissolved: any = dissolve(tinPolys);\n\n  // geojson-dissolve always returns a MultiPolygon\n  if (dissolved.coordinates.length === 1) {\n    dissolved.coordinates = dissolved.coordinates[0];\n    dissolved.type = \"Polygon\";\n  }\n  return feature(dissolved);\n}\n\n/**\n * Removes duplicated points in a collection returning a new collection\n *\n * @private\n * @param {FeatureCollection<Point>} points to be cleaned\n * @returns {FeatureCollection<Point>} cleaned set of points\n */\nfunction removeDuplicates(\n  points: FeatureCollection<Point>\n): FeatureCollection<Point> {\n  const cleaned: Array<Feature<Point>> = [];\n  const existing: { [key: string]: boolean } = {};\n\n  featureEach(points, (pt) => {\n    if (!pt.geometry) {\n      return;\n    }\n    const key = pt.geometry.coordinates.join(\"-\");\n    if (!Object.prototype.hasOwnProperty.call(existing, key)) {\n      cleaned.push(pt);\n      existing[key] = true;\n    }\n  });\n  return featureCollection(cleaned);\n}\n\nexport { concave };\nexport default concave;\n","import {\n  Feature,\n  FeatureCollection,\n  LineString,\n  MultiLineString,\n  MultiPolygon,\n  Polygon,\n} from \"geojson\";\nimport { clone } from \"@turf/clone\";\nimport { isObject } from \"@turf/helpers\";\nimport { getType } from \"@turf/invariant\";\nimport { flattenEach } from \"@turf/meta\";\nimport { lineDissolve } from \"./turf-line-dissolve.js\";\nimport { polygonDissolve } from \"./turf-polygon-dissolve.js\";\n\n/**\n * Transform function: attempts to dissolve geojson objects where possible\n * [GeoJSON] -> GeoJSON geometry\n *\n * @private\n * @param {FeatureCollection<LineString|MultiLineString|Polygon|MultiPolygon>} geojson Features to dissolved\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.mutate=false] Prevent input mutation\n * @returns {Feature<MultiLineString|MultiPolygon>} Dissolved Features\n */\nfunction dissolve(\n  geojson: FeatureCollection<\n    LineString | MultiLineString | Polygon | MultiPolygon\n  >,\n  options: {\n    mutate?: boolean;\n  } = {}\n): Feature<LineString | MultiLineString | Polygon | MultiPolygon> | null {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) {\n    throw new Error(\"options is invalid\");\n  }\n  const mutate = options.mutate;\n\n  // Validation\n  if (getType(geojson) !== \"FeatureCollection\") {\n    throw new Error(\"geojson must be a FeatureCollection\");\n  }\n  if (!geojson.features.length) {\n    throw new Error(\"geojson is empty\");\n  }\n\n  // Clone geojson to avoid side effects\n  // Topojson modifies in place, so we need to deep clone first\n  if (mutate === false || mutate === undefined) {\n    geojson = clone(geojson);\n  }\n\n  // Assert homogenity\n  const type = getHomogenousType(geojson);\n  if (!type) {\n    throw new Error(\"geojson must be homogenous\");\n  }\n\n  // Data => Typescript hack\n  const data: any = geojson;\n\n  switch (type) {\n    case \"LineString\":\n      return lineDissolve(data, options);\n    case \"Polygon\":\n      return polygonDissolve(data, options);\n    default:\n      throw new Error(type + \" is not supported\");\n  }\n}\n\n/**\n * Checks if GeoJSON is Homogenous\n *\n * @private\n * @param {GeoJSON} geojson GeoJSON\n * @returns {string|null} Homogenous type or null if multiple types\n */\nfunction getHomogenousType(geojson: any) {\n  const types: { [key: string]: boolean } = {};\n  flattenEach(geojson, (feature) => {\n    types[feature.geometry.type] = true;\n  });\n  const keys = Object.keys(types);\n  if (keys.length === 1) {\n    return keys[0];\n  }\n  return null;\n}\n\nexport { dissolve };\nexport default dissolve;\n","import {\n  Feature,\n  FeatureCollection,\n  LineString,\n  MultiLineString,\n} from \"geojson\";\nimport { clone } from \"@turf/clone\";\nimport { isObject, lineString, multiLineString } from \"@turf/helpers\";\nimport { getType } from \"@turf/invariant\";\nimport { lineReduce } from \"@turf/meta\";\n\n/**\n * Merges all connected (non-forking, non-junctioning) line strings into single lineStrings.\n * [LineString] -> LineString|MultiLineString\n *\n * @param {FeatureCollection<LineString|MultiLineString>} geojson Lines to dissolve\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.mutate=false] Prevent input mutation\n * @returns {Feature<LineString|MultiLineString>} Dissolved lines\n */\nfunction lineDissolve(\n  geojson: FeatureCollection<LineString | MultiLineString>,\n  options: { mutate?: boolean } = {}\n): Feature<LineString | MultiLineString> | null {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) {\n    throw new Error(\"options is invalid\");\n  }\n  const mutate = options.mutate;\n\n  // Validation\n  if (getType(geojson) !== \"FeatureCollection\") {\n    throw new Error(\"geojson must be a FeatureCollection\");\n  }\n  if (!geojson.features.length) {\n    throw new Error(\"geojson is empty\");\n  }\n\n  // Clone geojson to avoid side effects\n  if (mutate === false || mutate === undefined) {\n    geojson = clone(geojson);\n  }\n\n  const result: any[] = [];\n  const lastLine = lineReduce(\n    geojson,\n    (previousLine: any, currentLine: any) => {\n      // Attempt to merge this LineString with the other LineStrings, updating\n      // the reference as it is merged with others and grows.\n      const merged = mergeLineStrings(previousLine, currentLine);\n\n      // Accumulate the merged LineString\n      if (merged) {\n        return merged;\n        // Put the unmerged LineString back into the list\n      } else {\n        result.push(previousLine);\n        return currentLine;\n      }\n    }\n  );\n  // Append the last line\n  if (lastLine) {\n    result.push(lastLine);\n  }\n\n  // Return null if no lines were dissolved\n  if (!result.length) {\n    return null;\n    // Return LineString if only 1 line was dissolved\n  } else if (result.length === 1) {\n    return result[0];\n    // Return MultiLineString if multiple lines were dissolved with gaps\n  } else {\n    return multiLineString(\n      result.map((line) => {\n        return line.coordinates;\n      })\n    );\n  }\n}\n\n// [Number, Number] -> String\nfunction coordId(coord: number[]) {\n  return coord[0].toString() + \",\" + coord[1].toString();\n}\n\n/**\n * LineString, LineString -> LineString\n *\n * @private\n * @param {Feature<LineString>} a line1\n * @param {Feature<LineString>} b line2\n * @returns {Feature<LineString>|null} Merged LineString\n */\nfunction mergeLineStrings(a: Feature<LineString>, b: Feature<LineString>) {\n  const coords1 = a.geometry.coordinates;\n  const coords2 = b.geometry.coordinates;\n\n  const s1 = coordId(coords1[0]);\n  const e1 = coordId(coords1[coords1.length - 1]);\n  const s2 = coordId(coords2[0]);\n  const e2 = coordId(coords2[coords2.length - 1]);\n\n  // TODO: handle case where more than one of these is true!\n  let coords;\n  if (s1 === e2) {\n    coords = coords2.concat(coords1.slice(1));\n  } else if (s2 === e1) {\n    coords = coords1.concat(coords2.slice(1));\n  } else if (s1 === s2) {\n    coords = coords1.slice(1).reverse().concat(coords2);\n  } else if (e1 === e2) {\n    coords = coords1.concat(coords2.reverse().slice(1));\n  } else {\n    return null;\n  }\n\n  return lineString(coords);\n}\n\nexport { lineDissolve };\nexport default lineDissolve;\n","import { Feature, FeatureCollection, MultiPolygon, Polygon } from \"geojson\";\nimport { clone } from \"@turf/clone\";\nimport { geometryCollection } from \"@turf/helpers\";\nimport { getType } from \"@turf/invariant\";\nimport { flattenEach } from \"@turf/meta\";\nimport { merge } from \"topojson-client\";\nimport { topology } from \"topojson-server\";\n\n/**\n * Dissolves all overlapping (Multi)Polygon\n *\n * @param {FeatureCollection<Polygon|MultiPolygon>} geojson Polygons to dissolve\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.mutate=false] Prevent input mutation\n * @returns {Feature<Polygon|MultiPolygon>} Dissolved Polygons\n */\nfunction polygonDissolve(\n  geojson: FeatureCollection<Polygon | MultiPolygon>,\n  options: { mutate?: boolean } = {}\n): Feature<Polygon | MultiPolygon> | null {\n  // Validation\n  if (getType(geojson) !== \"FeatureCollection\") {\n    throw new Error(\"geojson must be a FeatureCollection\");\n  }\n  if (!geojson.features.length) {\n    throw new Error(\"geojson is empty\");\n  }\n\n  // Clone geojson to avoid side effects\n  // Topojson modifies in place, so we need to deep clone first\n  if (options.mutate === false || options.mutate === undefined) {\n    geojson = clone(geojson);\n  }\n\n  const geoms: any[] = [];\n  flattenEach(geojson, (feature) => {\n    geoms.push(feature.geometry);\n  });\n  const topo: any = topology({ geoms: geometryCollection(geoms).geometry });\n  const merged: any = merge(topo, topo.objects.geoms.geometries);\n  return merged;\n}\n\nexport { polygonDissolve };\nexport default polygonDissolve;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}