{"ast":null,"code":"// index.ts\nimport { booleanWithin as within } from \"@turf/boolean-within\";\nimport { distance } from \"@turf/distance\";\nimport { point, featureCollection } from \"@turf/helpers\";\nfunction pointGrid(bbox, cellSide, options = {}) {\n  if (options.mask && !options.units) options.units = \"kilometers\";\n  var results = [];\n  var west = bbox[0];\n  var south = bbox[1];\n  var east = bbox[2];\n  var north = bbox[3];\n  var xFraction = cellSide / distance([west, south], [east, south], options);\n  var cellWidth = xFraction * (east - west);\n  var yFraction = cellSide / distance([west, south], [west, north], options);\n  var cellHeight = yFraction * (north - south);\n  var bboxWidth = east - west;\n  var bboxHeight = north - south;\n  var columns = Math.floor(bboxWidth / cellWidth);\n  var rows = Math.floor(bboxHeight / cellHeight);\n  var deltaX = (bboxWidth - columns * cellWidth) / 2;\n  var deltaY = (bboxHeight - rows * cellHeight) / 2;\n  var currentX = west + deltaX;\n  while (currentX <= east) {\n    var currentY = south + deltaY;\n    while (currentY <= north) {\n      var cellPt = point([currentX, currentY], options.properties);\n      if (options.mask) {\n        if (within(cellPt, options.mask)) results.push(cellPt);\n      } else {\n        results.push(cellPt);\n      }\n      currentY += cellHeight;\n    }\n    currentX += cellWidth;\n  }\n  return featureCollection(results);\n}\nvar turf_point_grid_default = pointGrid;\nexport { turf_point_grid_default as default, pointGrid };","map":{"version":3,"names":["booleanWithin","within","distance","point","featureCollection","pointGrid","bbox","cellSide","options","mask","units","results","west","south","east","north","xFraction","cellWidth","yFraction","cellHeight","bboxWidth","bboxHeight","columns","Math","floor","rows","deltaX","deltaY","currentX","currentY","cellPt","properties","push","turf_point_grid_default"],"sources":["/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/point-grid/index.ts"],"sourcesContent":["import {\n  BBox,\n  Feature,\n  Polygon,\n  MultiPolygon,\n  FeatureCollection,\n  Point,\n  GeoJsonProperties,\n} from \"geojson\";\nimport { booleanWithin as within } from \"@turf/boolean-within\";\nimport { distance } from \"@turf/distance\";\nimport { point, featureCollection, Units } from \"@turf/helpers\";\n\n/**\n * Creates a grid of points\n *\n * @function\n * @param {BBox} bbox extent of grid in [minX, minY, maxX, maxY] order\n * @param {number} cellSide the distance between points\n * @param {Object} [options={}] Optional parameters\n * @param {Units} [options.units='kilometers'] the units of the cellSide value.  Supports all valid Turf {@link https://github.com/Turfjs/turf/blob/master/packages/turf-helpers/README_UNITS.md Units}\n * @param {Feature<Polygon|MultiPolygon>} [options.mask] if passed a Polygon or MultiPolygon, the grid Points will be created only inside it\n * @param {Object} [options.properties={}] passed to each point of the grid\n * @returns {FeatureCollection<Point>} grid of points\n * @example\n * var extent = [-70.823364, -33.553984, -70.473175, -33.302986];\n * var cellSide = 3;\n * var options = {units: 'miles'};\n *\n * var grid = turf.pointGrid(extent, cellSide, options);\n *\n * //addToMap\n * var addToMap = [grid];\n */\nfunction pointGrid<P extends GeoJsonProperties = GeoJsonProperties>(\n  bbox: BBox,\n  cellSide: number,\n  options: {\n    units?: Units;\n    mask?: Feature<Polygon | MultiPolygon>;\n    properties?: P;\n  } = {}\n): FeatureCollection<Point, P> {\n  // Default parameters\n  if (options.mask && !options.units) options.units = \"kilometers\";\n\n  // Containers\n  var results = [];\n\n  // Typescript handles the Type Validation\n  // if (cellSide === null || cellSide === undefined) throw new Error('cellSide is required');\n  // if (!isNumber(cellSide)) throw new Error('cellSide is invalid');\n  // if (!bbox) throw new Error('bbox is required');\n  // if (!Array.isArray(bbox)) throw new Error('bbox must be array');\n  // if (bbox.length !== 4) throw new Error('bbox must contain 4 numbers');\n  // if (mask && ['Polygon', 'MultiPolygon'].indexOf(getType(mask)) === -1) throw new Error('options.mask must be a (Multi)Polygon');\n\n  var west = bbox[0];\n  var south = bbox[1];\n  var east = bbox[2];\n  var north = bbox[3];\n\n  var xFraction = cellSide / distance([west, south], [east, south], options);\n  var cellWidth = xFraction * (east - west);\n  var yFraction = cellSide / distance([west, south], [west, north], options);\n  var cellHeight = yFraction * (north - south);\n\n  var bboxWidth = east - west;\n  var bboxHeight = north - south;\n  var columns = Math.floor(bboxWidth / cellWidth);\n  var rows = Math.floor(bboxHeight / cellHeight);\n\n  // adjust origin of the grid\n  var deltaX = (bboxWidth - columns * cellWidth) / 2;\n  var deltaY = (bboxHeight - rows * cellHeight) / 2;\n\n  var currentX = west + deltaX;\n  while (currentX <= east) {\n    var currentY = south + deltaY;\n    while (currentY <= north) {\n      var cellPt = point([currentX, currentY], options.properties);\n      if (options.mask) {\n        if (within(cellPt, options.mask)) results.push(cellPt);\n      } else {\n        results.push(cellPt);\n      }\n      currentY += cellHeight;\n    }\n    currentX += cellWidth;\n  }\n\n  return featureCollection(results);\n}\n\nexport { pointGrid };\nexport default pointGrid;\n"],"mappings":";AASA,SAASA,aAAA,IAAiBC,MAAA,QAAc;AACxC,SAASC,QAAA,QAAgB;AACzB,SAASC,KAAA,EAAOC,iBAAA,QAAgC;AAuBhD,SAASC,UACPC,IAAA,EACAC,QAAA,EACAC,OAAA,GAII,CAAC,GACwB;EAE7B,IAAIA,OAAA,CAAQC,IAAA,IAAQ,CAACD,OAAA,CAAQE,KAAA,EAAOF,OAAA,CAAQE,KAAA,GAAQ;EAGpD,IAAIC,OAAA,GAAU,EAAC;EAUf,IAAIC,IAAA,GAAON,IAAA,CAAK,CAAC;EACjB,IAAIO,KAAA,GAAQP,IAAA,CAAK,CAAC;EAClB,IAAIQ,IAAA,GAAOR,IAAA,CAAK,CAAC;EACjB,IAAIS,KAAA,GAAQT,IAAA,CAAK,CAAC;EAElB,IAAIU,SAAA,GAAYT,QAAA,GAAWL,QAAA,CAAS,CAACU,IAAA,EAAMC,KAAK,GAAG,CAACC,IAAA,EAAMD,KAAK,GAAGL,OAAO;EACzE,IAAIS,SAAA,GAAYD,SAAA,IAAaF,IAAA,GAAOF,IAAA;EACpC,IAAIM,SAAA,GAAYX,QAAA,GAAWL,QAAA,CAAS,CAACU,IAAA,EAAMC,KAAK,GAAG,CAACD,IAAA,EAAMG,KAAK,GAAGP,OAAO;EACzE,IAAIW,UAAA,GAAaD,SAAA,IAAaH,KAAA,GAAQF,KAAA;EAEtC,IAAIO,SAAA,GAAYN,IAAA,GAAOF,IAAA;EACvB,IAAIS,UAAA,GAAaN,KAAA,GAAQF,KAAA;EACzB,IAAIS,OAAA,GAAUC,IAAA,CAAKC,KAAA,CAAMJ,SAAA,GAAYH,SAAS;EAC9C,IAAIQ,IAAA,GAAOF,IAAA,CAAKC,KAAA,CAAMH,UAAA,GAAaF,UAAU;EAG7C,IAAIO,MAAA,IAAUN,SAAA,GAAYE,OAAA,GAAUL,SAAA,IAAa;EACjD,IAAIU,MAAA,IAAUN,UAAA,GAAaI,IAAA,GAAON,UAAA,IAAc;EAEhD,IAAIS,QAAA,GAAWhB,IAAA,GAAOc,MAAA;EACtB,OAAOE,QAAA,IAAYd,IAAA,EAAM;IACvB,IAAIe,QAAA,GAAWhB,KAAA,GAAQc,MAAA;IACvB,OAAOE,QAAA,IAAYd,KAAA,EAAO;MACxB,IAAIe,MAAA,GAAS3B,KAAA,CAAM,CAACyB,QAAA,EAAUC,QAAQ,GAAGrB,OAAA,CAAQuB,UAAU;MAC3D,IAAIvB,OAAA,CAAQC,IAAA,EAAM;QAChB,IAAIR,MAAA,CAAO6B,MAAA,EAAQtB,OAAA,CAAQC,IAAI,GAAGE,OAAA,CAAQqB,IAAA,CAAKF,MAAM;MACvD,OAAO;QACLnB,OAAA,CAAQqB,IAAA,CAAKF,MAAM;MACrB;MACAD,QAAA,IAAYV,UAAA;IACd;IACAS,QAAA,IAAYX,SAAA;EACd;EAEA,OAAOb,iBAAA,CAAkBO,OAAO;AAClC;AAGA,IAAOsB,uBAAA,GAAQ5B,SAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}