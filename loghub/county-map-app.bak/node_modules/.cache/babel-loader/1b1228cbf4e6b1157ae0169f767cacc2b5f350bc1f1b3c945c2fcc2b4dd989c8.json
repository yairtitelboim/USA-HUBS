{"ast":null,"code":"// index.ts\nimport { explode } from \"@turf/explode\";\nimport { center as centroid } from \"@turf/center\";\nimport { nearestPoint } from \"@turf/nearest-point\";\nimport { booleanPointInPolygon } from \"@turf/boolean-point-in-polygon\";\nimport { featureCollection, feature, point } from \"@turf/helpers\";\nfunction pointOnFeature(geojson) {\n  const fc = normalize(geojson);\n  const cent = centroid(fc);\n  let onSurface = false;\n  let i = 0;\n  while (!onSurface && i < fc.features.length) {\n    const geom = fc.features[i].geometry;\n    let x, y, x1, y1, x2, y2;\n    let onLine = false;\n    if (geom.type === \"Point\") {\n      if (cent.geometry.coordinates[0] === geom.coordinates[0] && cent.geometry.coordinates[1] === geom.coordinates[1]) {\n        onSurface = true;\n      }\n    } else if (geom.type === \"MultiPoint\") {\n      let onMultiPoint = false;\n      let k = 0;\n      while (!onMultiPoint && k < geom.coordinates.length) {\n        if (cent.geometry.coordinates[0] === geom.coordinates[k][0] && cent.geometry.coordinates[1] === geom.coordinates[k][1]) {\n          onSurface = true;\n          onMultiPoint = true;\n        }\n        k++;\n      }\n    } else if (geom.type === \"LineString\") {\n      let k = 0;\n      while (!onLine && k < geom.coordinates.length - 1) {\n        x = cent.geometry.coordinates[0];\n        y = cent.geometry.coordinates[1];\n        x1 = geom.coordinates[k][0];\n        y1 = geom.coordinates[k][1];\n        x2 = geom.coordinates[k + 1][0];\n        y2 = geom.coordinates[k + 1][1];\n        if (pointOnSegment(x, y, x1, y1, x2, y2)) {\n          onLine = true;\n          onSurface = true;\n        }\n        k++;\n      }\n    } else if (geom.type === \"MultiLineString\") {\n      let j = 0;\n      while (j < geom.coordinates.length) {\n        onLine = false;\n        let k = 0;\n        const line = geom.coordinates[j];\n        while (!onLine && k < line.length - 1) {\n          x = cent.geometry.coordinates[0];\n          y = cent.geometry.coordinates[1];\n          x1 = line[k][0];\n          y1 = line[k][1];\n          x2 = line[k + 1][0];\n          y2 = line[k + 1][1];\n          if (pointOnSegment(x, y, x1, y1, x2, y2)) {\n            onLine = true;\n            onSurface = true;\n          }\n          k++;\n        }\n        j++;\n      }\n    } else if (geom.type === \"Polygon\" || geom.type === \"MultiPolygon\") {\n      if (booleanPointInPolygon(cent, geom)) {\n        onSurface = true;\n      }\n    }\n    i++;\n  }\n  if (onSurface) {\n    return cent;\n  } else {\n    const vertices = featureCollection([]);\n    for (let f = 0; f < fc.features.length; f++) {\n      vertices.features = vertices.features.concat(explode(fc.features[f]).features);\n    }\n    return point(nearestPoint(cent, vertices).geometry.coordinates);\n  }\n}\nfunction normalize(geojson) {\n  if (geojson.type !== \"FeatureCollection\") {\n    if (geojson.type !== \"Feature\") {\n      return featureCollection([feature(geojson)]);\n    }\n    return featureCollection([geojson]);\n  }\n  return geojson;\n}\nfunction pointOnSegment(x, y, x1, y1, x2, y2) {\n  const ab = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n  const ap = Math.sqrt((x - x1) * (x - x1) + (y - y1) * (y - y1));\n  const pb = Math.sqrt((x2 - x) * (x2 - x) + (y2 - y) * (y2 - y));\n  return ab === ap + pb;\n}\nvar turf_point_on_feature_default = pointOnFeature;\nexport { turf_point_on_feature_default as default, pointOnFeature };","map":{"version":3,"names":["explode","center","centroid","nearestPoint","booleanPointInPolygon","featureCollection","feature","point","pointOnFeature","geojson","fc","normalize","cent","onSurface","i","features","length","geom","geometry","x","y","x1","y1","x2","y2","onLine","type","coordinates","onMultiPoint","k","pointOnSegment","j","line","vertices","f","concat","ab","Math","sqrt","ap","pb","turf_point_on_feature_default"],"sources":["/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/point-on-feature/index.ts"],"sourcesContent":["import type { Feature, Point } from \"geojson\";\nimport type { AllGeoJSON } from \"@turf/helpers\";\nimport { explode } from \"@turf/explode\";\nimport { center as centroid } from \"@turf/center\";\nimport { nearestPoint } from \"@turf/nearest-point\";\nimport { booleanPointInPolygon } from \"@turf/boolean-point-in-polygon\";\nimport { featureCollection, feature, point } from \"@turf/helpers\";\n\n/**\n * Takes a Feature or FeatureCollection and returns a {@link Point} guaranteed to be on the surface of the feature.\n *\n * * Given a {@link Polygon}, the point will be in the area of the polygon\n * * Given a {@link LineString}, the point will be along the string\n * * Given a {@link Point}, the point will the same as the input\n *\n * @function\n * @param {GeoJSON} geojson any Feature or FeatureCollection\n * @returns {Feature<Point>} a point on the surface of `input`\n * @example\n * var polygon = turf.polygon([[\n *   [116, -36],\n *   [131, -32],\n *   [146, -43],\n *   [155, -25],\n *   [133, -9],\n *   [111, -22],\n *   [116, -36]\n * ]]);\n *\n * var pointOnPolygon = turf.pointOnFeature(polygon);\n *\n * //addToMap\n * var addToMap = [polygon, pointOnPolygon];\n */\nfunction pointOnFeature(geojson: AllGeoJSON): Feature<Point> {\n  // normalize\n  const fc = normalize(geojson);\n\n  // get centroid\n  const cent = centroid(fc);\n\n  // check to see if centroid is on surface\n  let onSurface = false;\n  let i = 0;\n  while (!onSurface && i < fc.features.length) {\n    const geom = fc.features[i].geometry;\n    let x, y, x1, y1, x2, y2;\n    let onLine = false;\n    if (geom.type === \"Point\") {\n      if (\n        cent.geometry.coordinates[0] === geom.coordinates[0] &&\n        cent.geometry.coordinates[1] === geom.coordinates[1]\n      ) {\n        onSurface = true;\n      }\n    } else if (geom.type === \"MultiPoint\") {\n      let onMultiPoint = false;\n      let k = 0;\n      while (!onMultiPoint && k < geom.coordinates.length) {\n        if (\n          cent.geometry.coordinates[0] === geom.coordinates[k][0] &&\n          cent.geometry.coordinates[1] === geom.coordinates[k][1]\n        ) {\n          onSurface = true;\n          onMultiPoint = true;\n        }\n        k++;\n      }\n    } else if (geom.type === \"LineString\") {\n      let k = 0;\n      while (!onLine && k < geom.coordinates.length - 1) {\n        x = cent.geometry.coordinates[0];\n        y = cent.geometry.coordinates[1];\n        x1 = geom.coordinates[k][0];\n        y1 = geom.coordinates[k][1];\n        x2 = geom.coordinates[k + 1][0];\n        y2 = geom.coordinates[k + 1][1];\n        if (pointOnSegment(x, y, x1, y1, x2, y2)) {\n          onLine = true;\n          onSurface = true;\n        }\n        k++;\n      }\n    } else if (geom.type === \"MultiLineString\") {\n      let j = 0;\n      while (j < geom.coordinates.length) {\n        onLine = false;\n        let k = 0;\n        const line = geom.coordinates[j];\n        while (!onLine && k < line.length - 1) {\n          x = cent.geometry.coordinates[0];\n          y = cent.geometry.coordinates[1];\n          x1 = line[k][0];\n          y1 = line[k][1];\n          x2 = line[k + 1][0];\n          y2 = line[k + 1][1];\n          if (pointOnSegment(x, y, x1, y1, x2, y2)) {\n            onLine = true;\n            onSurface = true;\n          }\n          k++;\n        }\n        j++;\n      }\n    } else if (geom.type === \"Polygon\" || geom.type === \"MultiPolygon\") {\n      if (booleanPointInPolygon(cent, geom)) {\n        onSurface = true;\n      }\n    }\n    i++;\n  }\n  if (onSurface) {\n    return cent;\n  } else {\n    const vertices = featureCollection<Point>([]);\n    for (let f = 0; f < fc.features.length; f++) {\n      vertices.features = vertices.features.concat(\n        explode(fc.features[f]).features\n      );\n    }\n    // Remove distanceToPoint properties from nearestPoint()\n    return point(nearestPoint(cent, vertices).geometry.coordinates);\n  }\n}\n\n/**\n * Normalizes any GeoJSON to a FeatureCollection\n *\n * @private\n * @name normalize\n * @param {GeoJSON} geojson Any GeoJSON\n * @returns {FeatureCollection} FeatureCollection\n */\nfunction normalize(geojson: AllGeoJSON) {\n  if (geojson.type !== \"FeatureCollection\") {\n    if (geojson.type !== \"Feature\") {\n      return featureCollection([feature(geojson)]);\n    }\n    return featureCollection([geojson]);\n  }\n  return geojson;\n}\n\nfunction pointOnSegment(\n  x: number,\n  y: number,\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number\n) {\n  const ab = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n  const ap = Math.sqrt((x - x1) * (x - x1) + (y - y1) * (y - y1));\n  const pb = Math.sqrt((x2 - x) * (x2 - x) + (y2 - y) * (y2 - y));\n  return ab === ap + pb;\n}\n\nexport { pointOnFeature };\nexport default pointOnFeature;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}