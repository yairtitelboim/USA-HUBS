{"ast":null,"code":"// index.ts\nimport { convertLength, degreesToRadians, earthRadius, point } from \"@turf/helpers\";\nimport { getCoord } from \"@turf/invariant\";\nfunction rhumbDestination(origin, distance, bearing, options = {}) {\n  const wasNegativeDistance = distance < 0;\n  let distanceInMeters = convertLength(Math.abs(distance), options.units, \"meters\");\n  if (wasNegativeDistance) distanceInMeters = -Math.abs(distanceInMeters);\n  const coords = getCoord(origin);\n  const destination = calculateRhumbDestination(coords, distanceInMeters, bearing);\n  destination[0] += destination[0] - coords[0] > 180 ? -360 : coords[0] - destination[0] > 180 ? 360 : 0;\n  return point(destination, options.properties);\n}\nfunction calculateRhumbDestination(origin, distance, bearing, radius) {\n  radius = radius === void 0 ? earthRadius : Number(radius);\n  const delta = distance / radius;\n  const lambda1 = origin[0] * Math.PI / 180;\n  const phi1 = degreesToRadians(origin[1]);\n  const theta = degreesToRadians(bearing);\n  const DeltaPhi = delta * Math.cos(theta);\n  let phi2 = phi1 + DeltaPhi;\n  if (Math.abs(phi2) > Math.PI / 2) {\n    phi2 = phi2 > 0 ? Math.PI - phi2 : -Math.PI - phi2;\n  }\n  const DeltaPsi = Math.log(Math.tan(phi2 / 2 + Math.PI / 4) / Math.tan(phi1 / 2 + Math.PI / 4));\n  const q = Math.abs(DeltaPsi) > 1e-11 ? DeltaPhi / DeltaPsi : Math.cos(phi1);\n  const DeltaLambda = delta * Math.sin(theta) / q;\n  const lambda2 = lambda1 + DeltaLambda;\n  return [(lambda2 * 180 / Math.PI + 540) % 360 - 180, phi2 * 180 / Math.PI];\n}\nvar turf_rhumb_destination_default = rhumbDestination;\nexport { turf_rhumb_destination_default as default, rhumbDestination };","map":{"version":3,"names":["convertLength","degreesToRadians","earthRadius","point","getCoord","rhumbDestination","origin","distance","bearing","options","wasNegativeDistance","distanceInMeters","Math","abs","units","coords","destination","calculateRhumbDestination","properties","radius","Number","delta","lambda1","PI","phi1","theta","DeltaPhi","cos","phi2","DeltaPsi","log","tan","q","DeltaLambda","sin","lambda2","turf_rhumb_destination_default"],"sources":["/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/rhumb-destination/index.ts"],"sourcesContent":["// https://en.wikipedia.org/wiki/Rhumb_line\nimport { Feature, Point, GeoJsonProperties } from \"geojson\";\nimport {\n  convertLength,\n  Coord,\n  degreesToRadians,\n  earthRadius,\n  point,\n  Units,\n} from \"@turf/helpers\";\nimport { getCoord } from \"@turf/invariant\";\n\n/**\n * Returns the destination {@link Point} having travelled the given distance along a Rhumb line from the\n * origin Point with the (varant) given bearing.\n *\n * @function\n * @param {Coord} origin starting point\n * @param {number} distance distance from the starting point\n * @param {number} bearing varant bearing angle ranging from -180 to 180 degrees from north\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers\n * @param {Object} [options.properties={}] translate properties to destination point\n * @returns {Feature<Point>} Destination point.\n * @example\n * var pt = turf.point([-75.343, 39.984], {\"marker-color\": \"F00\"});\n * var distance = 50;\n * var bearing = 90;\n * var options = {units: 'miles'};\n *\n * var destination = turf.rhumbDestination(pt, distance, bearing, options);\n *\n * //addToMap\n * var addToMap = [pt, destination]\n * destination.properties['marker-color'] = '#00F';\n */\nfunction rhumbDestination<P extends GeoJsonProperties = GeoJsonProperties>(\n  origin: Coord,\n  distance: number,\n  bearing: number,\n  options: {\n    units?: Units;\n    properties?: P;\n  } = {}\n): Feature<Point, P> {\n  const wasNegativeDistance = distance < 0;\n  let distanceInMeters = convertLength(\n    Math.abs(distance),\n    options.units,\n    \"meters\"\n  );\n  if (wasNegativeDistance) distanceInMeters = -Math.abs(distanceInMeters);\n  const coords = getCoord(origin);\n  const destination = calculateRhumbDestination(\n    coords,\n    distanceInMeters,\n    bearing\n  );\n\n  // compensate the crossing of the 180th meridian (https://macwright.org/2016/09/26/the-180th-meridian.html)\n  // solution from https://github.com/mapbox/mapbox-gl-js/issues/3250#issuecomment-294887678\n  destination[0] +=\n    destination[0] - coords[0] > 180\n      ? -360\n      : coords[0] - destination[0] > 180\n        ? 360\n        : 0;\n  return point(destination, options.properties);\n}\n\n/**\n * Returns the destination point having travelled along a rhumb line from origin point the given\n * distance on the  given bearing.\n * Adapted from Geodesy: http://www.movable-type.co.uk/scripts/latlong.html#rhumblines\n *\n * @private\n * @param   {Array<number>} origin - point\n * @param   {number} distance - Distance travelled, in same units as earth radius (default: metres).\n * @param   {number} bearing - Bearing in degrees from north.\n * @param   {number} [radius=6371e3] - (Mean) radius of earth (defaults to radius in metres).\n * @returns {Array<number>} Destination point.\n */\nfunction calculateRhumbDestination(\n  origin: number[],\n  distance: number,\n  bearing: number,\n  radius?: number\n) {\n  // φ => phi\n  // λ => lambda\n  // ψ => psi\n  // Δ => Delta\n  // δ => delta\n  // θ => theta\n\n  radius = radius === undefined ? earthRadius : Number(radius);\n\n  const delta = distance / radius; // angular distance in radians\n  const lambda1 = (origin[0] * Math.PI) / 180; // to radians, but without normalize to 𝜋\n  const phi1 = degreesToRadians(origin[1]);\n  const theta = degreesToRadians(bearing);\n\n  const DeltaPhi = delta * Math.cos(theta);\n  let phi2 = phi1 + DeltaPhi;\n\n  // check for some daft bugger going past the pole, normalise latitude if so\n  if (Math.abs(phi2) > Math.PI / 2) {\n    phi2 = phi2 > 0 ? Math.PI - phi2 : -Math.PI - phi2;\n  }\n\n  const DeltaPsi = Math.log(\n    Math.tan(phi2 / 2 + Math.PI / 4) / Math.tan(phi1 / 2 + Math.PI / 4)\n  );\n  // E-W course becomes ill-conditioned with 0/0\n  const q = Math.abs(DeltaPsi) > 10e-12 ? DeltaPhi / DeltaPsi : Math.cos(phi1);\n\n  const DeltaLambda = (delta * Math.sin(theta)) / q;\n  const lambda2 = lambda1 + DeltaLambda;\n\n  return [\n    (((lambda2 * 180) / Math.PI + 540) % 360) - 180,\n    (phi2 * 180) / Math.PI,\n  ]; // normalise to −180..+180°\n}\n\nexport { rhumbDestination };\nexport default rhumbDestination;\n"],"mappings":";AAEA,SACEA,aAAA,EAEAC,gBAAA,EACAC,WAAA,EACAC,KAAA,QAEK;AACP,SAASC,QAAA,QAAgB;AA0BzB,SAASC,iBACPC,MAAA,EACAC,QAAA,EACAC,OAAA,EACAC,OAAA,GAGI,CAAC,GACc;EACnB,MAAMC,mBAAA,GAAsBH,QAAA,GAAW;EACvC,IAAII,gBAAA,GAAmBX,aAAA,CACrBY,IAAA,CAAKC,GAAA,CAAIN,QAAQ,GACjBE,OAAA,CAAQK,KAAA,EACR,QACF;EACA,IAAIJ,mBAAA,EAAqBC,gBAAA,GAAmB,CAACC,IAAA,CAAKC,GAAA,CAAIF,gBAAgB;EACtE,MAAMI,MAAA,GAASX,QAAA,CAASE,MAAM;EAC9B,MAAMU,WAAA,GAAcC,yBAAA,CAClBF,MAAA,EACAJ,gBAAA,EACAH,OACF;EAIAQ,WAAA,CAAY,CAAC,KACXA,WAAA,CAAY,CAAC,IAAID,MAAA,CAAO,CAAC,IAAI,MACzB,OACAA,MAAA,CAAO,CAAC,IAAIC,WAAA,CAAY,CAAC,IAAI,MAC3B,MACA;EACR,OAAOb,KAAA,CAAMa,WAAA,EAAaP,OAAA,CAAQS,UAAU;AAC9C;AAcA,SAASD,0BACPX,MAAA,EACAC,QAAA,EACAC,OAAA,EACAW,MAAA,EACA;EAQAA,MAAA,GAASA,MAAA,KAAW,SAAYjB,WAAA,GAAckB,MAAA,CAAOD,MAAM;EAE3D,MAAME,KAAA,GAAQd,QAAA,GAAWY,MAAA;EACzB,MAAMG,OAAA,GAAWhB,MAAA,CAAO,CAAC,IAAIM,IAAA,CAAKW,EAAA,GAAM;EACxC,MAAMC,IAAA,GAAOvB,gBAAA,CAAiBK,MAAA,CAAO,CAAC,CAAC;EACvC,MAAMmB,KAAA,GAAQxB,gBAAA,CAAiBO,OAAO;EAEtC,MAAMkB,QAAA,GAAWL,KAAA,GAAQT,IAAA,CAAKe,GAAA,CAAIF,KAAK;EACvC,IAAIG,IAAA,GAAOJ,IAAA,GAAOE,QAAA;EAGlB,IAAId,IAAA,CAAKC,GAAA,CAAIe,IAAI,IAAIhB,IAAA,CAAKW,EAAA,GAAK,GAAG;IAChCK,IAAA,GAAOA,IAAA,GAAO,IAAIhB,IAAA,CAAKW,EAAA,GAAKK,IAAA,GAAO,CAAChB,IAAA,CAAKW,EAAA,GAAKK,IAAA;EAChD;EAEA,MAAMC,QAAA,GAAWjB,IAAA,CAAKkB,GAAA,CACpBlB,IAAA,CAAKmB,GAAA,CAAIH,IAAA,GAAO,IAAIhB,IAAA,CAAKW,EAAA,GAAK,CAAC,IAAIX,IAAA,CAAKmB,GAAA,CAAIP,IAAA,GAAO,IAAIZ,IAAA,CAAKW,EAAA,GAAK,CAAC,CACpE;EAEA,MAAMS,CAAA,GAAIpB,IAAA,CAAKC,GAAA,CAAIgB,QAAQ,IAAI,QAASH,QAAA,GAAWG,QAAA,GAAWjB,IAAA,CAAKe,GAAA,CAAIH,IAAI;EAE3E,MAAMS,WAAA,GAAeZ,KAAA,GAAQT,IAAA,CAAKsB,GAAA,CAAIT,KAAK,IAAKO,CAAA;EAChD,MAAMG,OAAA,GAAUb,OAAA,GAAUW,WAAA;EAE1B,OAAO,EACFE,OAAA,GAAU,MAAOvB,IAAA,CAAKW,EAAA,GAAK,OAAO,MAAO,KAC3CK,IAAA,GAAO,MAAOhB,IAAA,CAAKW,EAAA,CACtB;AACF;AAGA,IAAOa,8BAAA,GAAQ/B,gBAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}