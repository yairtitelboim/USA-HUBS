{"ast":null,"code":"// index.ts\nimport { cleanCoords } from \"@turf/clean-coords\";\nimport { clone } from \"@turf/clone\";\nimport { geomEach } from \"@turf/meta\";\nimport { isObject } from \"@turf/helpers\";\n\n// lib/simplify.js\nfunction getSqDist(p1, p2) {\n  var dx = p1[0] - p2[0],\n    dy = p1[1] - p2[1];\n  return dx * dx + dy * dy;\n}\nfunction getSqSegDist(p, p1, p2) {\n  var x = p1[0],\n    y = p1[1],\n    dx = p2[0] - x,\n    dy = p2[1] - y;\n  if (dx !== 0 || dy !== 0) {\n    var t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);\n    if (t > 1) {\n      x = p2[0];\n      y = p2[1];\n    } else if (t > 0) {\n      x += dx * t;\n      y += dy * t;\n    }\n  }\n  dx = p[0] - x;\n  dy = p[1] - y;\n  return dx * dx + dy * dy;\n}\nfunction simplifyRadialDist(points, sqTolerance) {\n  var prevPoint = points[0],\n    newPoints = [prevPoint],\n    point;\n  for (var i = 1, len = points.length; i < len; i++) {\n    point = points[i];\n    if (getSqDist(point, prevPoint) > sqTolerance) {\n      newPoints.push(point);\n      prevPoint = point;\n    }\n  }\n  if (prevPoint !== point) newPoints.push(point);\n  return newPoints;\n}\nfunction simplifyDPStep(points, first, last, sqTolerance, simplified) {\n  var maxSqDist = sqTolerance,\n    index;\n  for (var i = first + 1; i < last; i++) {\n    var sqDist = getSqSegDist(points[i], points[first], points[last]);\n    if (sqDist > maxSqDist) {\n      index = i;\n      maxSqDist = sqDist;\n    }\n  }\n  if (maxSqDist > sqTolerance) {\n    if (index - first > 1) simplifyDPStep(points, first, index, sqTolerance, simplified);\n    simplified.push(points[index]);\n    if (last - index > 1) simplifyDPStep(points, index, last, sqTolerance, simplified);\n  }\n}\nfunction simplifyDouglasPeucker(points, sqTolerance) {\n  var last = points.length - 1;\n  var simplified = [points[0]];\n  simplifyDPStep(points, 0, last, sqTolerance, simplified);\n  simplified.push(points[last]);\n  return simplified;\n}\nfunction simplify(points, tolerance, highestQuality) {\n  if (points.length <= 2) return points;\n  var sqTolerance = tolerance !== void 0 ? tolerance * tolerance : 1;\n  points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);\n  points = simplifyDouglasPeucker(points, sqTolerance);\n  return points;\n}\n\n// index.ts\nfunction simplify2(geojson, options = {}) {\n  var _a, _b, _c;\n  options = options != null ? options : {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  const tolerance = (_a = options.tolerance) != null ? _a : 1;\n  const highQuality = (_b = options.highQuality) != null ? _b : false;\n  const mutate = (_c = options.mutate) != null ? _c : false;\n  if (!geojson) throw new Error(\"geojson is required\");\n  if (tolerance && tolerance < 0) throw new Error(\"invalid tolerance\");\n  if (mutate !== true) geojson = clone(geojson);\n  geomEach(geojson, function (geom) {\n    simplifyGeom(geom, tolerance, highQuality);\n  });\n  return geojson;\n}\nfunction simplifyGeom(geometry, tolerance, highQuality) {\n  const type = geometry.type;\n  if (type === \"Point\" || type === \"MultiPoint\") return geometry;\n  cleanCoords(geometry, {\n    mutate: true\n  });\n  if (type !== \"GeometryCollection\") {\n    switch (type) {\n      case \"LineString\":\n        geometry.coordinates = simplify(geometry.coordinates, tolerance, highQuality);\n        break;\n      case \"MultiLineString\":\n        geometry.coordinates = geometry.coordinates.map(lines => simplify(lines, tolerance, highQuality));\n        break;\n      case \"Polygon\":\n        geometry.coordinates = simplifyPolygon(geometry.coordinates, tolerance, highQuality);\n        break;\n      case \"MultiPolygon\":\n        geometry.coordinates = geometry.coordinates.map(rings => simplifyPolygon(rings, tolerance, highQuality));\n    }\n  }\n  return geometry;\n}\nfunction simplifyPolygon(coordinates, tolerance, highQuality) {\n  return coordinates.map(function (ring) {\n    if (ring.length < 4) {\n      throw new Error(\"invalid polygon\");\n    }\n    let ringTolerance = tolerance;\n    let simpleRing = simplify(ring, ringTolerance, highQuality);\n    while (!checkValidity(simpleRing)) {\n      ringTolerance -= ringTolerance * 0.01;\n      simpleRing = simplify(ring, ringTolerance, highQuality);\n    }\n    if (simpleRing[simpleRing.length - 1][0] !== simpleRing[0][0] || simpleRing[simpleRing.length - 1][1] !== simpleRing[0][1]) {\n      simpleRing.push(simpleRing[0]);\n    }\n    return simpleRing;\n  });\n}\nfunction checkValidity(ring) {\n  if (ring.length < 3) return false;\n  return !(ring.length === 3 && ring[2][0] === ring[0][0] && ring[2][1] === ring[0][1]);\n}\nvar turf_simplify_default = simplify2;\nexport { turf_simplify_default as default, simplify2 as simplify };","map":{"version":3,"names":["cleanCoords","clone","geomEach","isObject","getSqDist","p1","p2","dx","dy","getSqSegDist","p","x","y","t","simplifyRadialDist","points","sqTolerance","prevPoint","newPoints","point","i","len","length","push","simplifyDPStep","first","last","simplified","maxSqDist","index","sqDist","simplifyDouglasPeucker","simplify","tolerance","highestQuality","simplify2","geojson","options","_a","_b","_c","Error","highQuality","mutate","geom","simplifyGeom","geometry","type","coordinates","map","lines","simplifyPolygon","rings","ring","ringTolerance","simpleRing","checkValidity","turf_simplify_default"],"sources":["/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/simplify/index.ts","/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/simplify/lib/simplify.js"],"sourcesContent":["import { Geometry, Position } from \"geojson\";\nimport { cleanCoords } from \"@turf/clean-coords\";\nimport { clone } from \"@turf/clone\";\nimport { geomEach } from \"@turf/meta\";\nimport { AllGeoJSON, isObject } from \"@turf/helpers\";\nimport { simplify as simplifyJS } from \"./lib/simplify.js\";\n\n/**\n * Takes a {@link GeoJSON} object and returns a simplified version. Internally uses the 2d version of\n * [simplify-js](http://mourner.github.io/simplify-js/) to perform simplification using the Ramer-Douglas-Peucker algorithm.\n *\n *\n * @function\n * @param {GeoJSON} geojson object to be simplified\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.tolerance=1] simplification tolerance\n * @param {boolean} [options.highQuality=false] whether or not to spend more time to create a higher-quality simplification with a different algorithm\n * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated (significant performance increase if true)\n * @returns {GeoJSON} a simplified GeoJSON\n * @example\n * var geojson = turf.polygon([[\n *   [-70.603637, -33.399918],\n *   [-70.614624, -33.395332],\n *   [-70.639343, -33.392466],\n *   [-70.659942, -33.394759],\n *   [-70.683975, -33.404504],\n *   [-70.697021, -33.419406],\n *   [-70.701141, -33.434306],\n *   [-70.700454, -33.446339],\n *   [-70.694274, -33.458369],\n *   [-70.682601, -33.465816],\n *   [-70.668869, -33.472117],\n *   [-70.646209, -33.473835],\n *   [-70.624923, -33.472117],\n *   [-70.609817, -33.468107],\n *   [-70.595397, -33.458369],\n *   [-70.587158, -33.442901],\n *   [-70.587158, -33.426283],\n *   [-70.590591, -33.414248],\n *   [-70.594711, -33.406224],\n *   [-70.603637, -33.399918]\n * ]]);\n * var options = {tolerance: 0.01, highQuality: false};\n * var simplified = turf.simplify(geojson, options);\n *\n * //addToMap\n * var addToMap = [geojson, simplified]\n */\nfunction simplify<T extends AllGeoJSON>(\n  geojson: T,\n  options: {\n    tolerance?: number;\n    highQuality?: boolean;\n    mutate?: boolean;\n  } = {}\n): T {\n  // Optional parameters\n  options = options ?? {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  const tolerance = options.tolerance ?? 1;\n  const highQuality = options.highQuality ?? false;\n  const mutate = options.mutate ?? false;\n\n  if (!geojson) throw new Error(\"geojson is required\");\n  if (tolerance && tolerance < 0) throw new Error(\"invalid tolerance\");\n\n  // Clone geojson to avoid side effects\n  if (mutate !== true) geojson = clone(geojson);\n\n  geomEach(geojson, function (geom) {\n    simplifyGeom(geom, tolerance, highQuality);\n  });\n  return geojson;\n}\n\n/**\n * Simplifies a feature's coordinates\n *\n * @private\n * @param {Geometry} geometry to be simplified\n * @param {number} [tolerance=1] simplification tolerance\n * @param {boolean} [highQuality=false] whether or not to spend more time to create a higher-quality simplification with a different algorithm\n * @returns {Geometry} output\n */\nfunction simplifyGeom(\n  geometry: Geometry,\n  tolerance: number,\n  highQuality: boolean\n) {\n  const type = geometry.type;\n\n  // \"unsimplyfiable\" geometry types\n  if (type === \"Point\" || type === \"MultiPoint\") return geometry;\n\n  // Remove any extra coordinates\n  cleanCoords(geometry, { mutate: true });\n\n  if (type !== \"GeometryCollection\") {\n    // TODO should this cater for GeometryCollections too?\n    switch (type) {\n      case \"LineString\":\n        geometry.coordinates = simplifyJS(\n          geometry.coordinates,\n          tolerance,\n          highQuality\n        );\n        break;\n      case \"MultiLineString\":\n        geometry.coordinates = geometry.coordinates.map((lines) =>\n          simplifyJS(lines, tolerance, highQuality)\n        );\n        break;\n      case \"Polygon\":\n        geometry.coordinates = simplifyPolygon(\n          geometry.coordinates,\n          tolerance,\n          highQuality\n        );\n        break;\n      case \"MultiPolygon\":\n        geometry.coordinates = geometry.coordinates.map((rings) =>\n          simplifyPolygon(rings, tolerance, highQuality)\n        );\n    }\n  }\n\n  return geometry;\n}\n\n/**\n * Simplifies the coordinates of a Polygon with simplify-js\n *\n * @private\n * @param {Array<number>} coordinates to be processed\n * @param {number} tolerance simplification tolerance\n * @param {boolean} highQuality whether or not to spend more time to create a higher-quality\n * @returns {Array<Array<Array<number>>>} simplified coords\n */\nfunction simplifyPolygon(\n  coordinates: Position[][],\n  tolerance: number,\n  highQuality: boolean\n) {\n  return coordinates.map(function (ring) {\n    if (ring.length < 4) {\n      throw new Error(\"invalid polygon\");\n    }\n    let ringTolerance = tolerance;\n    let simpleRing = simplifyJS(ring, ringTolerance, highQuality);\n    // remove 1 percent of tolerance until enough points to make a triangle\n    while (!checkValidity(simpleRing)) {\n      ringTolerance -= ringTolerance * 0.01;\n      simpleRing = simplifyJS(ring, ringTolerance, highQuality);\n    }\n    if (\n      simpleRing[simpleRing.length - 1][0] !== simpleRing[0][0] ||\n      simpleRing[simpleRing.length - 1][1] !== simpleRing[0][1]\n    ) {\n      simpleRing.push(simpleRing[0]);\n    }\n    return simpleRing;\n  });\n}\n\n/**\n * Returns true if ring has at least 3 coordinates and its first coordinate is the same as its last\n *\n * @private\n * @param {Array<number>} ring coordinates to be checked\n * @returns {boolean} true if valid\n */\nfunction checkValidity(ring: Position[]) {\n  if (ring.length < 3) return false;\n  //if the last point is the same as the first, it's not a triangle\n  return !(\n    ring.length === 3 &&\n    ring[2][0] === ring[0][0] &&\n    ring[2][1] === ring[0][1]\n  );\n}\n\nexport { simplify };\nexport default simplify;\n","/*\n (c) 2013, Vladimir Agafonkin\n Simplify.js, a high-performance JS polyline simplification library\n mourner.github.io/simplify-js\n*/\n\n// to suit your point format, run search/replace for '.x' and '.y';\n// for 3D version, see 3d branch (configurability would draw significant performance overhead)\n\n// square distance between 2 points\nfunction getSqDist(p1, p2) {\n  var dx = p1[0] - p2[0],\n    dy = p1[1] - p2[1];\n\n  return dx * dx + dy * dy;\n}\n\n// square distance from a point to a segment\nfunction getSqSegDist(p, p1, p2) {\n  var x = p1[0],\n    y = p1[1],\n    dx = p2[0] - x,\n    dy = p2[1] - y;\n\n  if (dx !== 0 || dy !== 0) {\n    var t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);\n\n    if (t > 1) {\n      x = p2[0];\n      y = p2[1];\n    } else if (t > 0) {\n      x += dx * t;\n      y += dy * t;\n    }\n  }\n\n  dx = p[0] - x;\n  dy = p[1] - y;\n\n  return dx * dx + dy * dy;\n}\n// rest of the code doesn't care about point format\n\n// basic distance-based simplification\nfunction simplifyRadialDist(points, sqTolerance) {\n  var prevPoint = points[0],\n    newPoints = [prevPoint],\n    point;\n\n  for (var i = 1, len = points.length; i < len; i++) {\n    point = points[i];\n\n    if (getSqDist(point, prevPoint) > sqTolerance) {\n      newPoints.push(point);\n      prevPoint = point;\n    }\n  }\n\n  if (prevPoint !== point) newPoints.push(point);\n\n  return newPoints;\n}\n\nfunction simplifyDPStep(points, first, last, sqTolerance, simplified) {\n  var maxSqDist = sqTolerance,\n    index;\n\n  for (var i = first + 1; i < last; i++) {\n    var sqDist = getSqSegDist(points[i], points[first], points[last]);\n\n    if (sqDist > maxSqDist) {\n      index = i;\n      maxSqDist = sqDist;\n    }\n  }\n\n  if (maxSqDist > sqTolerance) {\n    if (index - first > 1)\n      simplifyDPStep(points, first, index, sqTolerance, simplified);\n    simplified.push(points[index]);\n    if (last - index > 1)\n      simplifyDPStep(points, index, last, sqTolerance, simplified);\n  }\n}\n\n// simplification using Ramer-Douglas-Peucker algorithm\nfunction simplifyDouglasPeucker(points, sqTolerance) {\n  var last = points.length - 1;\n\n  var simplified = [points[0]];\n  simplifyDPStep(points, 0, last, sqTolerance, simplified);\n  simplified.push(points[last]);\n\n  return simplified;\n}\n\n// both algorithms combined for awesome performance\nfunction simplify(points, tolerance, highestQuality) {\n  if (points.length <= 2) return points;\n\n  var sqTolerance = tolerance !== undefined ? tolerance * tolerance : 1;\n\n  points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);\n  points = simplifyDouglasPeucker(points, sqTolerance);\n\n  return points;\n}\n\nexport { simplify };\nexport default simplify;\n"],"mappings":";AACA,SAASA,WAAA,QAAmB;AAC5B,SAASC,KAAA,QAAa;AACtB,SAASC,QAAA,QAAgB;AACzB,SAAqBC,QAAA,QAAgB;;;ACMrC,SAASC,UAAUC,EAAA,EAAIC,EAAA,EAAI;EACzB,IAAIC,EAAA,GAAKF,EAAA,CAAG,CAAC,IAAIC,EAAA,CAAG,CAAC;IACnBE,EAAA,GAAKH,EAAA,CAAG,CAAC,IAAIC,EAAA,CAAG,CAAC;EAEnB,OAAOC,EAAA,GAAKA,EAAA,GAAKC,EAAA,GAAKA,EAAA;AACxB;AAGA,SAASC,aAAaC,CAAA,EAAGL,EAAA,EAAIC,EAAA,EAAI;EAC/B,IAAIK,CAAA,GAAIN,EAAA,CAAG,CAAC;IACVO,CAAA,GAAIP,EAAA,CAAG,CAAC;IACRE,EAAA,GAAKD,EAAA,CAAG,CAAC,IAAIK,CAAA;IACbH,EAAA,GAAKF,EAAA,CAAG,CAAC,IAAIM,CAAA;EAEf,IAAIL,EAAA,KAAO,KAAKC,EAAA,KAAO,GAAG;IACxB,IAAIK,CAAA,KAAMH,CAAA,CAAE,CAAC,IAAIC,CAAA,IAAKJ,EAAA,IAAMG,CAAA,CAAE,CAAC,IAAIE,CAAA,IAAKJ,EAAA,KAAOD,EAAA,GAAKA,EAAA,GAAKC,EAAA,GAAKA,EAAA;IAE9D,IAAIK,CAAA,GAAI,GAAG;MACTF,CAAA,GAAIL,EAAA,CAAG,CAAC;MACRM,CAAA,GAAIN,EAAA,CAAG,CAAC;IACV,WAAWO,CAAA,GAAI,GAAG;MAChBF,CAAA,IAAKJ,EAAA,GAAKM,CAAA;MACVD,CAAA,IAAKJ,EAAA,GAAKK,CAAA;IACZ;EACF;EAEAN,EAAA,GAAKG,CAAA,CAAE,CAAC,IAAIC,CAAA;EACZH,EAAA,GAAKE,CAAA,CAAE,CAAC,IAAIE,CAAA;EAEZ,OAAOL,EAAA,GAAKA,EAAA,GAAKC,EAAA,GAAKA,EAAA;AACxB;AAIA,SAASM,mBAAmBC,MAAA,EAAQC,WAAA,EAAa;EAC/C,IAAIC,SAAA,GAAYF,MAAA,CAAO,CAAC;IACtBG,SAAA,GAAY,CAACD,SAAS;IACtBE,KAAA;EAEF,SAASC,CAAA,GAAI,GAAGC,GAAA,GAAMN,MAAA,CAAOO,MAAA,EAAQF,CAAA,GAAIC,GAAA,EAAKD,CAAA,IAAK;IACjDD,KAAA,GAAQJ,MAAA,CAAOK,CAAC;IAEhB,IAAIhB,SAAA,CAAUe,KAAA,EAAOF,SAAS,IAAID,WAAA,EAAa;MAC7CE,SAAA,CAAUK,IAAA,CAAKJ,KAAK;MACpBF,SAAA,GAAYE,KAAA;IACd;EACF;EAEA,IAAIF,SAAA,KAAcE,KAAA,EAAOD,SAAA,CAAUK,IAAA,CAAKJ,KAAK;EAE7C,OAAOD,SAAA;AACT;AAEA,SAASM,eAAeT,MAAA,EAAQU,KAAA,EAAOC,IAAA,EAAMV,WAAA,EAAaW,UAAA,EAAY;EACpE,IAAIC,SAAA,GAAYZ,WAAA;IACda,KAAA;EAEF,SAAST,CAAA,GAAIK,KAAA,GAAQ,GAAGL,CAAA,GAAIM,IAAA,EAAMN,CAAA,IAAK;IACrC,IAAIU,MAAA,GAASrB,YAAA,CAAaM,MAAA,CAAOK,CAAC,GAAGL,MAAA,CAAOU,KAAK,GAAGV,MAAA,CAAOW,IAAI,CAAC;IAEhE,IAAII,MAAA,GAASF,SAAA,EAAW;MACtBC,KAAA,GAAQT,CAAA;MACRQ,SAAA,GAAYE,MAAA;IACd;EACF;EAEA,IAAIF,SAAA,GAAYZ,WAAA,EAAa;IAC3B,IAAIa,KAAA,GAAQJ,KAAA,GAAQ,GAClBD,cAAA,CAAeT,MAAA,EAAQU,KAAA,EAAOI,KAAA,EAAOb,WAAA,EAAaW,UAAU;IAC9DA,UAAA,CAAWJ,IAAA,CAAKR,MAAA,CAAOc,KAAK,CAAC;IAC7B,IAAIH,IAAA,GAAOG,KAAA,GAAQ,GACjBL,cAAA,CAAeT,MAAA,EAAQc,KAAA,EAAOH,IAAA,EAAMV,WAAA,EAAaW,UAAU;EAC/D;AACF;AAGA,SAASI,uBAAuBhB,MAAA,EAAQC,WAAA,EAAa;EACnD,IAAIU,IAAA,GAAOX,MAAA,CAAOO,MAAA,GAAS;EAE3B,IAAIK,UAAA,GAAa,CAACZ,MAAA,CAAO,CAAC,CAAC;EAC3BS,cAAA,CAAeT,MAAA,EAAQ,GAAGW,IAAA,EAAMV,WAAA,EAAaW,UAAU;EACvDA,UAAA,CAAWJ,IAAA,CAAKR,MAAA,CAAOW,IAAI,CAAC;EAE5B,OAAOC,UAAA;AACT;AAGA,SAASK,SAASjB,MAAA,EAAQkB,SAAA,EAAWC,cAAA,EAAgB;EACnD,IAAInB,MAAA,CAAOO,MAAA,IAAU,GAAG,OAAOP,MAAA;EAE/B,IAAIC,WAAA,GAAciB,SAAA,KAAc,SAAYA,SAAA,GAAYA,SAAA,GAAY;EAEpElB,MAAA,GAASmB,cAAA,GAAiBnB,MAAA,GAASD,kBAAA,CAAmBC,MAAA,EAAQC,WAAW;EACzED,MAAA,GAASgB,sBAAA,CAAuBhB,MAAA,EAAQC,WAAW;EAEnD,OAAOD,MAAA;AACT;;;AD1DA,SAASoB,UACPC,OAAA,EACAC,OAAA,GAII,CAAC,GACF;EAvDL,IAAAC,EAAA,EAAAC,EAAA,EAAAC,EAAA;EAyDEH,OAAA,GAAUA,OAAA,WAAAA,OAAA,GAAW,CAAC;EACtB,IAAI,CAAClC,QAAA,CAASkC,OAAO,GAAG,MAAM,IAAII,KAAA,CAAM,oBAAoB;EAC5D,MAAMR,SAAA,IAAYK,EAAA,GAAAD,OAAA,CAAQJ,SAAA,KAAR,OAAAK,EAAA,GAAqB;EACvC,MAAMI,WAAA,IAAcH,EAAA,GAAAF,OAAA,CAAQK,WAAA,KAAR,OAAAH,EAAA,GAAuB;EAC3C,MAAMI,MAAA,IAASH,EAAA,GAAAH,OAAA,CAAQM,MAAA,KAAR,OAAAH,EAAA,GAAkB;EAEjC,IAAI,CAACJ,OAAA,EAAS,MAAM,IAAIK,KAAA,CAAM,qBAAqB;EACnD,IAAIR,SAAA,IAAaA,SAAA,GAAY,GAAG,MAAM,IAAIQ,KAAA,CAAM,mBAAmB;EAGnE,IAAIE,MAAA,KAAW,MAAMP,OAAA,GAAUnC,KAAA,CAAMmC,OAAO;EAE5ClC,QAAA,CAASkC,OAAA,EAAS,UAAUQ,IAAA,EAAM;IAChCC,YAAA,CAAaD,IAAA,EAAMX,SAAA,EAAWS,WAAW;EAC3C,CAAC;EACD,OAAON,OAAA;AACT;AAWA,SAASS,aACPC,QAAA,EACAb,SAAA,EACAS,WAAA,EACA;EACA,MAAMK,IAAA,GAAOD,QAAA,CAASC,IAAA;EAGtB,IAAIA,IAAA,KAAS,WAAWA,IAAA,KAAS,cAAc,OAAOD,QAAA;EAGtD9C,WAAA,CAAY8C,QAAA,EAAU;IAAEH,MAAA,EAAQ;EAAK,CAAC;EAEtC,IAAII,IAAA,KAAS,sBAAsB;IAEjC,QAAQA,IAAA;MACN,KAAK;QACHD,QAAA,CAASE,WAAA,GAAchB,QAAA,CACrBc,QAAA,CAASE,WAAA,EACTf,SAAA,EACAS,WACF;QACA;MACF,KAAK;QACHI,QAAA,CAASE,WAAA,GAAcF,QAAA,CAASE,WAAA,CAAYC,GAAA,CAAKC,KAAA,IAC/ClB,QAAA,CAAWkB,KAAA,EAAOjB,SAAA,EAAWS,WAAW,CAC1C;QACA;MACF,KAAK;QACHI,QAAA,CAASE,WAAA,GAAcG,eAAA,CACrBL,QAAA,CAASE,WAAA,EACTf,SAAA,EACAS,WACF;QACA;MACF,KAAK;QACHI,QAAA,CAASE,WAAA,GAAcF,QAAA,CAASE,WAAA,CAAYC,GAAA,CAAKG,KAAA,IAC/CD,eAAA,CAAgBC,KAAA,EAAOnB,SAAA,EAAWS,WAAW,CAC/C;IACJ;EACF;EAEA,OAAOI,QAAA;AACT;AAWA,SAASK,gBACPH,WAAA,EACAf,SAAA,EACAS,WAAA,EACA;EACA,OAAOM,WAAA,CAAYC,GAAA,CAAI,UAAUI,IAAA,EAAM;IACrC,IAAIA,IAAA,CAAK/B,MAAA,GAAS,GAAG;MACnB,MAAM,IAAImB,KAAA,CAAM,iBAAiB;IACnC;IACA,IAAIa,aAAA,GAAgBrB,SAAA;IACpB,IAAIsB,UAAA,GAAavB,QAAA,CAAWqB,IAAA,EAAMC,aAAA,EAAeZ,WAAW;IAE5D,OAAO,CAACc,aAAA,CAAcD,UAAU,GAAG;MACjCD,aAAA,IAAiBA,aAAA,GAAgB;MACjCC,UAAA,GAAavB,QAAA,CAAWqB,IAAA,EAAMC,aAAA,EAAeZ,WAAW;IAC1D;IACA,IACEa,UAAA,CAAWA,UAAA,CAAWjC,MAAA,GAAS,CAAC,EAAE,CAAC,MAAMiC,UAAA,CAAW,CAAC,EAAE,CAAC,KACxDA,UAAA,CAAWA,UAAA,CAAWjC,MAAA,GAAS,CAAC,EAAE,CAAC,MAAMiC,UAAA,CAAW,CAAC,EAAE,CAAC,GACxD;MACAA,UAAA,CAAWhC,IAAA,CAAKgC,UAAA,CAAW,CAAC,CAAC;IAC/B;IACA,OAAOA,UAAA;EACT,CAAC;AACH;AASA,SAASC,cAAcH,IAAA,EAAkB;EACvC,IAAIA,IAAA,CAAK/B,MAAA,GAAS,GAAG,OAAO;EAE5B,OAAO,EACL+B,IAAA,CAAK/B,MAAA,KAAW,KAChB+B,IAAA,CAAK,CAAC,EAAE,CAAC,MAAMA,IAAA,CAAK,CAAC,EAAE,CAAC,KACxBA,IAAA,CAAK,CAAC,EAAE,CAAC,MAAMA,IAAA,CAAK,CAAC,EAAE,CAAC;AAE5B;AAGA,IAAOI,qBAAA,GAAQtB,SAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}