{"ast":null,"code":"// index.js\nimport { geojsonRbush as rbush } from \"@turf/geojson-rbush\";\nimport { square } from \"@turf/square\";\nimport { bbox } from \"@turf/bbox\";\nimport { truncate } from \"@turf/truncate\";\nimport { lineSegment } from \"@turf/line-segment\";\nimport { lineIntersect } from \"@turf/line-intersect\";\nimport { nearestPointOnLine } from \"@turf/nearest-point-on-line\";\nimport { getCoords, getCoord, getType } from \"@turf/invariant\";\nimport { featureEach, featureReduce, flattenEach } from \"@turf/meta\";\nimport { lineString, featureCollection } from \"@turf/helpers\";\nfunction lineSplit(line, splitter) {\n  if (!line) throw new Error(\"line is required\");\n  if (!splitter) throw new Error(\"splitter is required\");\n  var lineType = getType(line);\n  var splitterType = getType(splitter);\n  if (lineType !== \"LineString\") throw new Error(\"line must be LineString\");\n  if (splitterType === \"FeatureCollection\") throw new Error(\"splitter cannot be a FeatureCollection\");\n  if (splitterType === \"GeometryCollection\") throw new Error(\"splitter cannot be a GeometryCollection\");\n  var truncatedSplitter = truncate(splitter, {\n    precision: 7\n  });\n  switch (splitterType) {\n    case \"Point\":\n      return splitLineWithPoint(line, truncatedSplitter);\n    case \"MultiPoint\":\n      return splitLineWithPoints(line, truncatedSplitter);\n    case \"LineString\":\n    case \"MultiLineString\":\n    case \"Polygon\":\n    case \"MultiPolygon\":\n      return splitLineWithPoints(line, lineIntersect(line, truncatedSplitter, {\n        ignoreSelfIntersections: true\n      }));\n  }\n}\nfunction splitLineWithPoints(line, splitter) {\n  var results = [];\n  var tree = rbush();\n  flattenEach(splitter, function (point) {\n    results.forEach(function (feature, index) {\n      feature.id = index;\n    });\n    if (!results.length) {\n      results = splitLineWithPoint(line, point).features;\n      results.forEach(function (feature) {\n        if (!feature.bbox) feature.bbox = square(bbox(feature));\n      });\n      tree.load(featureCollection(results));\n    } else {\n      var search = tree.search(point);\n      if (search.features.length) {\n        var closestLine = findClosestFeature(point, search);\n        results = results.filter(function (feature) {\n          return feature.id !== closestLine.id;\n        });\n        tree.remove(closestLine);\n        featureEach(splitLineWithPoint(closestLine, point), function (line2) {\n          results.push(line2);\n          tree.insert(line2);\n        });\n      }\n    }\n  });\n  return featureCollection(results);\n}\nfunction splitLineWithPoint(line, splitter) {\n  var results = [];\n  var startPoint = getCoords(line)[0];\n  var endPoint = getCoords(line)[line.geometry.coordinates.length - 1];\n  if (pointsEquals(startPoint, getCoord(splitter)) || pointsEquals(endPoint, getCoord(splitter))) return featureCollection([line]);\n  var tree = rbush();\n  var segments = lineSegment(line);\n  tree.load(segments);\n  var search = tree.search(splitter);\n  if (!search.features.length) return featureCollection([line]);\n  var closestSegment = findClosestFeature(splitter, search);\n  var initialValue = [startPoint];\n  var lastCoords = featureReduce(segments, function (previous, current, index) {\n    var currentCoords = getCoords(current)[1];\n    var splitterCoords = getCoord(splitter);\n    if (index === closestSegment.id) {\n      previous.push(splitterCoords);\n      results.push(lineString(previous));\n      if (pointsEquals(splitterCoords, currentCoords)) return [splitterCoords];\n      return [splitterCoords, currentCoords];\n    } else {\n      previous.push(currentCoords);\n      return previous;\n    }\n  }, initialValue);\n  if (lastCoords.length > 1) {\n    results.push(lineString(lastCoords));\n  }\n  return featureCollection(results);\n}\nfunction findClosestFeature(point, lines) {\n  if (!lines.features.length) throw new Error(\"lines must contain features\");\n  if (lines.features.length === 1) return lines.features[0];\n  var closestFeature;\n  var closestDistance = Infinity;\n  featureEach(lines, function (segment) {\n    var pt = nearestPointOnLine(segment, point);\n    var dist = pt.properties.dist;\n    if (dist < closestDistance) {\n      closestFeature = segment;\n      closestDistance = dist;\n    }\n  });\n  return closestFeature;\n}\nfunction pointsEquals(pt1, pt2) {\n  return pt1[0] === pt2[0] && pt1[1] === pt2[1];\n}\nvar turf_line_split_default = lineSplit;\nexport { turf_line_split_default as default, lineSplit };","map":{"version":3,"names":["geojsonRbush","rbush","square","bbox","truncate","lineSegment","lineIntersect","nearestPointOnLine","getCoords","getCoord","getType","featureEach","featureReduce","flattenEach","lineString","featureCollection","lineSplit","line","splitter","Error","lineType","splitterType","truncatedSplitter","precision","splitLineWithPoint","splitLineWithPoints","ignoreSelfIntersections","results","tree","point","forEach","feature","index","id","length","features","load","search","closestLine","findClosestFeature","filter","remove","line2","push","insert","startPoint","endPoint","geometry","coordinates","pointsEquals","segments","closestSegment","initialValue","lastCoords","previous","current","currentCoords","splitterCoords","lines","closestFeature","closestDistance","Infinity","segment","pt","dist","properties","pt1","pt2","turf_line_split_default"],"sources":["/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/line-split/index.js"],"sourcesContent":["import { geojsonRbush as rbush } from \"@turf/geojson-rbush\";\nimport { square } from \"@turf/square\";\nimport { bbox } from \"@turf/bbox\";\nimport { truncate } from \"@turf/truncate\";\nimport { lineSegment } from \"@turf/line-segment\";\nimport { lineIntersect } from \"@turf/line-intersect\";\nimport { nearestPointOnLine } from \"@turf/nearest-point-on-line\";\nimport { getCoords, getCoord, getType } from \"@turf/invariant\";\nimport { featureEach, featureReduce, flattenEach } from \"@turf/meta\";\nimport { lineString, featureCollection } from \"@turf/helpers\";\n\n/**\n * Split a LineString by another GeoJSON Feature.\n *\n * @function\n * @param {Feature<LineString>} line LineString Feature to split\n * @param {Feature<any>} splitter Feature used to split line\n * @returns {FeatureCollection<LineString>} Split LineStrings\n * @example\n * var line = turf.lineString([[120, -25], [145, -25]]);\n * var splitter = turf.lineString([[130, -15], [130, -35]]);\n *\n * var split = turf.lineSplit(line, splitter);\n *\n * //addToMap\n * var addToMap = [line, splitter]\n */\nfunction lineSplit(line, splitter) {\n  if (!line) throw new Error(\"line is required\");\n  if (!splitter) throw new Error(\"splitter is required\");\n\n  var lineType = getType(line);\n  var splitterType = getType(splitter);\n\n  if (lineType !== \"LineString\") throw new Error(\"line must be LineString\");\n  if (splitterType === \"FeatureCollection\")\n    throw new Error(\"splitter cannot be a FeatureCollection\");\n  if (splitterType === \"GeometryCollection\")\n    throw new Error(\"splitter cannot be a GeometryCollection\");\n\n  // remove excessive decimals from splitter\n  // to avoid possible approximation issues in rbush\n  var truncatedSplitter = truncate(splitter, { precision: 7 });\n\n  switch (splitterType) {\n    case \"Point\":\n      return splitLineWithPoint(line, truncatedSplitter);\n    case \"MultiPoint\":\n      return splitLineWithPoints(line, truncatedSplitter);\n    case \"LineString\":\n    case \"MultiLineString\":\n    case \"Polygon\":\n    case \"MultiPolygon\":\n      return splitLineWithPoints(\n        line,\n        lineIntersect(line, truncatedSplitter, {\n          ignoreSelfIntersections: true,\n        })\n      );\n  }\n}\n\n/**\n * Split LineString with MultiPoint\n *\n * @private\n * @param {Feature<LineString>} line LineString\n * @param {FeatureCollection<Point>} splitter Point\n * @returns {FeatureCollection<LineString>} split LineStrings\n */\nfunction splitLineWithPoints(line, splitter) {\n  var results = [];\n  var tree = rbush();\n\n  flattenEach(splitter, function (point) {\n    // Add index/id to features (needed for filter)\n    results.forEach(function (feature, index) {\n      feature.id = index;\n    });\n    // First Point - doesn't need to handle any previous line results\n    if (!results.length) {\n      results = splitLineWithPoint(line, point).features;\n\n      // Add Square BBox to each feature for GeoJSON-RBush\n      results.forEach(function (feature) {\n        if (!feature.bbox) feature.bbox = square(bbox(feature));\n      });\n      tree.load(featureCollection(results));\n      // Split with remaining points - lines might needed to be split multiple times\n    } else {\n      // Find all lines that are within the splitter's bbox\n      var search = tree.search(point);\n\n      if (search.features.length) {\n        // RBush might return multiple lines - only process the closest line to splitter\n        var closestLine = findClosestFeature(point, search);\n\n        // Remove closest line from results since this will be split into two lines\n        // This removes any duplicates inside the results & index\n        results = results.filter(function (feature) {\n          return feature.id !== closestLine.id;\n        });\n        tree.remove(closestLine);\n\n        // Append the two newly split lines into the results\n        featureEach(splitLineWithPoint(closestLine, point), function (line) {\n          results.push(line);\n          tree.insert(line);\n        });\n      }\n    }\n  });\n  return featureCollection(results);\n}\n\n/**\n * Split LineString with Point\n *\n * @private\n * @param {Feature<LineString>} line LineString\n * @param {Feature<Point>} splitter Point\n * @returns {FeatureCollection<LineString>} split LineStrings\n */\nfunction splitLineWithPoint(line, splitter) {\n  var results = [];\n\n  // handle endpoints\n  var startPoint = getCoords(line)[0];\n  var endPoint = getCoords(line)[line.geometry.coordinates.length - 1];\n  if (\n    pointsEquals(startPoint, getCoord(splitter)) ||\n    pointsEquals(endPoint, getCoord(splitter))\n  )\n    return featureCollection([line]);\n\n  // Create spatial index\n  var tree = rbush();\n  var segments = lineSegment(line);\n  tree.load(segments);\n\n  // Find all segments that are within bbox of splitter\n  var search = tree.search(splitter);\n\n  // Return itself if point is not within spatial index\n  if (!search.features.length) return featureCollection([line]);\n\n  // RBush might return multiple lines - only process the closest line to splitter\n  var closestSegment = findClosestFeature(splitter, search);\n\n  // Initial value is the first point of the first segments (beginning of line)\n  var initialValue = [startPoint];\n  var lastCoords = featureReduce(\n    segments,\n    function (previous, current, index) {\n      var currentCoords = getCoords(current)[1];\n      var splitterCoords = getCoord(splitter);\n\n      // Location where segment intersects with line\n      if (index === closestSegment.id) {\n        previous.push(splitterCoords);\n        results.push(lineString(previous));\n        // Don't duplicate splitter coordinate (Issue #688)\n        if (pointsEquals(splitterCoords, currentCoords))\n          return [splitterCoords];\n        return [splitterCoords, currentCoords];\n\n        // Keep iterating over coords until finished or intersection is found\n      } else {\n        previous.push(currentCoords);\n        return previous;\n      }\n    },\n    initialValue\n  );\n  // Append last line to final split results\n  if (lastCoords.length > 1) {\n    results.push(lineString(lastCoords));\n  }\n  return featureCollection(results);\n}\n\n/**\n * Find Closest Feature\n *\n * @private\n * @param {Feature<Point>} point Feature must be closest to this point\n * @param {FeatureCollection<LineString>} lines Collection of Features\n * @returns {Feature<LineString>} closest LineString\n */\nfunction findClosestFeature(point, lines) {\n  if (!lines.features.length) throw new Error(\"lines must contain features\");\n  // Filter to one segment that is the closest to the line\n  if (lines.features.length === 1) return lines.features[0];\n\n  var closestFeature;\n  var closestDistance = Infinity;\n  featureEach(lines, function (segment) {\n    var pt = nearestPointOnLine(segment, point);\n    var dist = pt.properties.dist;\n    if (dist < closestDistance) {\n      closestFeature = segment;\n      closestDistance = dist;\n    }\n  });\n  return closestFeature;\n}\n\n/**\n * Compares two points and returns if they are equals\n *\n * @private\n * @param {Array<number>} pt1 point\n * @param {Array<number>} pt2 point\n * @returns {boolean} true if they are equals\n */\nfunction pointsEquals(pt1, pt2) {\n  return pt1[0] === pt2[0] && pt1[1] === pt2[1];\n}\n\nexport { lineSplit };\nexport default lineSplit;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}