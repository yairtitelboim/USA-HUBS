{"ast":null,"code":"// index.ts\nimport { featureCollection, lineString } from \"@turf/helpers\";\nimport { getCoords } from \"@turf/invariant\";\nimport { flattenEach } from \"@turf/meta\";\nfunction lineSegment(geojson) {\n  if (!geojson) {\n    throw new Error(\"geojson is required\");\n  }\n  const results = [];\n  flattenEach(geojson, feature => {\n    lineSegmentFeature(feature, results);\n  });\n  return featureCollection(results);\n}\nfunction lineSegmentFeature(geojson, results) {\n  let coords = [];\n  const geometry = geojson.geometry;\n  if (geometry !== null) {\n    switch (geometry.type) {\n      case \"Polygon\":\n        coords = getCoords(geometry);\n        break;\n      case \"LineString\":\n        coords = [getCoords(geometry)];\n    }\n    coords.forEach(coord => {\n      const segments = createSegments(coord, geojson.properties);\n      segments.forEach(segment => {\n        segment.id = results.length;\n        results.push(segment);\n      });\n    });\n  }\n}\nfunction createSegments(coords, properties) {\n  const segments = [];\n  coords.reduce((previousCoords, currentCoords) => {\n    const segment = lineString([previousCoords, currentCoords], properties);\n    segment.bbox = bbox(previousCoords, currentCoords);\n    segments.push(segment);\n    return currentCoords;\n  });\n  return segments;\n}\nfunction bbox(coords1, coords2) {\n  const x1 = coords1[0];\n  const y1 = coords1[1];\n  const x2 = coords2[0];\n  const y2 = coords2[1];\n  const west = x1 < x2 ? x1 : x2;\n  const south = y1 < y2 ? y1 : y2;\n  const east = x1 > x2 ? x1 : x2;\n  const north = y1 > y2 ? y1 : y2;\n  return [west, south, east, north];\n}\nvar turf_line_segment_default = lineSegment;\nexport { turf_line_segment_default as default, lineSegment };","map":{"version":3,"names":["featureCollection","lineString","getCoords","flattenEach","lineSegment","geojson","Error","results","feature","lineSegmentFeature","coords","geometry","type","forEach","coord","segments","createSegments","properties","segment","id","length","push","reduce","previousCoords","currentCoords","bbox","coords1","coords2","x1","y1","x2","y2","west","south","east","north","turf_line_segment_default"],"sources":["/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/line-segment/index.ts"],"sourcesContent":["import {\n  BBox,\n  Feature,\n  FeatureCollection,\n  LineString,\n  MultiLineString,\n  MultiPolygon,\n  Polygon,\n} from \"geojson\";\nimport { featureCollection, lineString } from \"@turf/helpers\";\nimport { getCoords } from \"@turf/invariant\";\nimport { flattenEach } from \"@turf/meta\";\n\n/**\n * Creates a {@link FeatureCollection} of 2-vertex {@link LineString} segments from a\n * {@link LineString|(Multi)LineString} or {@link Polygon|(Multi)Polygon}.\n *\n * @function\n * @param {GeoJSON} geojson GeoJSON Polygon or LineString\n * @returns {FeatureCollection<LineString>} 2-vertex line segments\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n * var segments = turf.lineSegment(polygon);\n *\n * //addToMap\n * var addToMap = [polygon, segments]\n */\nfunction lineSegment<\n  G extends LineString | MultiLineString | Polygon | MultiPolygon,\n>(\n  geojson: Feature<G> | FeatureCollection<G> | G\n): FeatureCollection<LineString> {\n  if (!geojson) {\n    throw new Error(\"geojson is required\");\n  }\n\n  const results: Array<Feature<LineString>> = [];\n  flattenEach(geojson, (feature: Feature<any>) => {\n    lineSegmentFeature(feature, results);\n  });\n  return featureCollection(results);\n}\n\n/**\n * Line Segment\n *\n * @private\n * @param {Feature<LineString|Polygon>} geojson Line or polygon feature\n * @param {Array} results push to results\n * @returns {void}\n */\nfunction lineSegmentFeature(\n  geojson: Feature<LineString | Polygon>,\n  results: Array<Feature<LineString>>\n) {\n  let coords: number[][][] = [];\n  const geometry = geojson.geometry;\n  if (geometry !== null) {\n    switch (geometry.type) {\n      case \"Polygon\":\n        coords = getCoords(geometry);\n        break;\n      case \"LineString\":\n        coords = [getCoords(geometry)];\n    }\n    coords.forEach((coord) => {\n      const segments = createSegments(coord, geojson.properties);\n      segments.forEach((segment) => {\n        segment.id = results.length;\n        results.push(segment);\n      });\n    });\n  }\n}\n\n/**\n * Create Segments from LineString coordinates\n *\n * @private\n * @param {Array<Array<number>>} coords LineString coordinates\n * @param {*} properties GeoJSON properties\n * @returns {Array<Feature<LineString>>} line segments\n */\nfunction createSegments(coords: number[][], properties: any) {\n  const segments: Array<Feature<LineString>> = [];\n  coords.reduce((previousCoords, currentCoords) => {\n    const segment = lineString([previousCoords, currentCoords], properties);\n    segment.bbox = bbox(previousCoords, currentCoords);\n    segments.push(segment);\n    return currentCoords;\n  });\n  return segments;\n}\n\n/**\n * Create BBox between two coordinates (faster than @turf/bbox)\n *\n * @private\n * @param {Array<number>} coords1 Point coordinate\n * @param {Array<number>} coords2 Point coordinate\n * @returns {BBox} [west, south, east, north]\n */\nfunction bbox(coords1: number[], coords2: number[]): BBox {\n  const x1 = coords1[0];\n  const y1 = coords1[1];\n  const x2 = coords2[0];\n  const y2 = coords2[1];\n  const west = x1 < x2 ? x1 : x2;\n  const south = y1 < y2 ? y1 : y2;\n  const east = x1 > x2 ? x1 : x2;\n  const north = y1 > y2 ? y1 : y2;\n  return [west, south, east, north];\n}\n\nexport { lineSegment };\nexport default lineSegment;\n"],"mappings":";AASA,SAASA,iBAAA,EAAmBC,UAAA,QAAkB;AAC9C,SAASC,SAAA,QAAiB;AAC1B,SAASC,WAAA,QAAmB;AAgB5B,SAASC,YAGPC,OAAA,EAC+B;EAC/B,IAAI,CAACA,OAAA,EAAS;IACZ,MAAM,IAAIC,KAAA,CAAM,qBAAqB;EACvC;EAEA,MAAMC,OAAA,GAAsC,EAAC;EAC7CJ,WAAA,CAAYE,OAAA,EAAUG,OAAA,IAA0B;IAC9CC,kBAAA,CAAmBD,OAAA,EAASD,OAAO;EACrC,CAAC;EACD,OAAOP,iBAAA,CAAkBO,OAAO;AAClC;AAUA,SAASE,mBACPJ,OAAA,EACAE,OAAA,EACA;EACA,IAAIG,MAAA,GAAuB,EAAC;EAC5B,MAAMC,QAAA,GAAWN,OAAA,CAAQM,QAAA;EACzB,IAAIA,QAAA,KAAa,MAAM;IACrB,QAAQA,QAAA,CAASC,IAAA;MACf,KAAK;QACHF,MAAA,GAASR,SAAA,CAAUS,QAAQ;QAC3B;MACF,KAAK;QACHD,MAAA,GAAS,CAACR,SAAA,CAAUS,QAAQ,CAAC;IACjC;IACAD,MAAA,CAAOG,OAAA,CAASC,KAAA,IAAU;MACxB,MAAMC,QAAA,GAAWC,cAAA,CAAeF,KAAA,EAAOT,OAAA,CAAQY,UAAU;MACzDF,QAAA,CAASF,OAAA,CAASK,OAAA,IAAY;QAC5BA,OAAA,CAAQC,EAAA,GAAKZ,OAAA,CAAQa,MAAA;QACrBb,OAAA,CAAQc,IAAA,CAAKH,OAAO;MACtB,CAAC;IACH,CAAC;EACH;AACF;AAUA,SAASF,eAAeN,MAAA,EAAoBO,UAAA,EAAiB;EAC3D,MAAMF,QAAA,GAAuC,EAAC;EAC9CL,MAAA,CAAOY,MAAA,CAAO,CAACC,cAAA,EAAgBC,aAAA,KAAkB;IAC/C,MAAMN,OAAA,GAAUjB,UAAA,CAAW,CAACsB,cAAA,EAAgBC,aAAa,GAAGP,UAAU;IACtEC,OAAA,CAAQO,IAAA,GAAOA,IAAA,CAAKF,cAAA,EAAgBC,aAAa;IACjDT,QAAA,CAASM,IAAA,CAAKH,OAAO;IACrB,OAAOM,aAAA;EACT,CAAC;EACD,OAAOT,QAAA;AACT;AAUA,SAASU,KAAKC,OAAA,EAAmBC,OAAA,EAAyB;EACxD,MAAMC,EAAA,GAAKF,OAAA,CAAQ,CAAC;EACpB,MAAMG,EAAA,GAAKH,OAAA,CAAQ,CAAC;EACpB,MAAMI,EAAA,GAAKH,OAAA,CAAQ,CAAC;EACpB,MAAMI,EAAA,GAAKJ,OAAA,CAAQ,CAAC;EACpB,MAAMK,IAAA,GAAOJ,EAAA,GAAKE,EAAA,GAAKF,EAAA,GAAKE,EAAA;EAC5B,MAAMG,KAAA,GAAQJ,EAAA,GAAKE,EAAA,GAAKF,EAAA,GAAKE,EAAA;EAC7B,MAAMG,IAAA,GAAON,EAAA,GAAKE,EAAA,GAAKF,EAAA,GAAKE,EAAA;EAC5B,MAAMK,KAAA,GAAQN,EAAA,GAAKE,EAAA,GAAKF,EAAA,GAAKE,EAAA;EAC7B,OAAO,CAACC,IAAA,EAAMC,KAAA,EAAOC,IAAA,EAAMC,KAAK;AAClC;AAGA,IAAOC,yBAAA,GAAQhC,WAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}