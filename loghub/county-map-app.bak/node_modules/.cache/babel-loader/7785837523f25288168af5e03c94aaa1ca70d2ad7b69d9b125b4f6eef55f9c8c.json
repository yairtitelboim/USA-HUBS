{"ast":null,"code":"// index.ts\nvar earthRadius = 63710088e-1;\nvar factors = {\n  centimeters: earthRadius * 100,\n  centimetres: earthRadius * 100,\n  degrees: 360 / (2 * Math.PI),\n  feet: earthRadius * 3.28084,\n  inches: earthRadius * 39.37,\n  kilometers: earthRadius / 1e3,\n  kilometres: earthRadius / 1e3,\n  meters: earthRadius,\n  metres: earthRadius,\n  miles: earthRadius / 1609.344,\n  millimeters: earthRadius * 1e3,\n  millimetres: earthRadius * 1e3,\n  nauticalmiles: earthRadius / 1852,\n  radians: 1,\n  yards: earthRadius * 1.0936\n};\nvar areaFactors = {\n  acres: 247105e-9,\n  centimeters: 1e4,\n  centimetres: 1e4,\n  feet: 10.763910417,\n  hectares: 1e-4,\n  inches: 1550.003100006,\n  kilometers: 1e-6,\n  kilometres: 1e-6,\n  meters: 1,\n  metres: 1,\n  miles: 386e-9,\n  nauticalmiles: 29155334959812285e-23,\n  millimeters: 1e6,\n  millimetres: 1e6,\n  yards: 1.195990046\n};\nfunction feature(geom, properties, options = {}) {\n  const feat = {\n    type: \"Feature\"\n  };\n  if (options.id === 0 || options.id) {\n    feat.id = options.id;\n  }\n  if (options.bbox) {\n    feat.bbox = options.bbox;\n  }\n  feat.properties = properties || {};\n  feat.geometry = geom;\n  return feat;\n}\nfunction geometry(type, coordinates, _options = {}) {\n  switch (type) {\n    case \"Point\":\n      return point(coordinates).geometry;\n    case \"LineString\":\n      return lineString(coordinates).geometry;\n    case \"Polygon\":\n      return polygon(coordinates).geometry;\n    case \"MultiPoint\":\n      return multiPoint(coordinates).geometry;\n    case \"MultiLineString\":\n      return multiLineString(coordinates).geometry;\n    case \"MultiPolygon\":\n      return multiPolygon(coordinates).geometry;\n    default:\n      throw new Error(type + \" is invalid\");\n  }\n}\nfunction point(coordinates, properties, options = {}) {\n  if (!coordinates) {\n    throw new Error(\"coordinates is required\");\n  }\n  if (!Array.isArray(coordinates)) {\n    throw new Error(\"coordinates must be an Array\");\n  }\n  if (coordinates.length < 2) {\n    throw new Error(\"coordinates must be at least 2 numbers long\");\n  }\n  if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {\n    throw new Error(\"coordinates must contain numbers\");\n  }\n  const geom = {\n    type: \"Point\",\n    coordinates\n  };\n  return feature(geom, properties, options);\n}\nfunction points(coordinates, properties, options = {}) {\n  return featureCollection(coordinates.map(coords => {\n    return point(coords, properties);\n  }), options);\n}\nfunction polygon(coordinates, properties, options = {}) {\n  for (const ring of coordinates) {\n    if (ring.length < 4) {\n      throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\n    }\n    if (ring[ring.length - 1].length !== ring[0].length) {\n      throw new Error(\"First and last Position are not equivalent.\");\n    }\n    for (let j = 0; j < ring[ring.length - 1].length; j++) {\n      if (ring[ring.length - 1][j] !== ring[0][j]) {\n        throw new Error(\"First and last Position are not equivalent.\");\n      }\n    }\n  }\n  const geom = {\n    type: \"Polygon\",\n    coordinates\n  };\n  return feature(geom, properties, options);\n}\nfunction polygons(coordinates, properties, options = {}) {\n  return featureCollection(coordinates.map(coords => {\n    return polygon(coords, properties);\n  }), options);\n}\nfunction lineString(coordinates, properties, options = {}) {\n  if (coordinates.length < 2) {\n    throw new Error(\"coordinates must be an array of two or more positions\");\n  }\n  const geom = {\n    type: \"LineString\",\n    coordinates\n  };\n  return feature(geom, properties, options);\n}\nfunction lineStrings(coordinates, properties, options = {}) {\n  return featureCollection(coordinates.map(coords => {\n    return lineString(coords, properties);\n  }), options);\n}\nfunction featureCollection(features, options = {}) {\n  const fc = {\n    type: \"FeatureCollection\"\n  };\n  if (options.id) {\n    fc.id = options.id;\n  }\n  if (options.bbox) {\n    fc.bbox = options.bbox;\n  }\n  fc.features = features;\n  return fc;\n}\nfunction multiLineString(coordinates, properties, options = {}) {\n  const geom = {\n    type: \"MultiLineString\",\n    coordinates\n  };\n  return feature(geom, properties, options);\n}\nfunction multiPoint(coordinates, properties, options = {}) {\n  const geom = {\n    type: \"MultiPoint\",\n    coordinates\n  };\n  return feature(geom, properties, options);\n}\nfunction multiPolygon(coordinates, properties, options = {}) {\n  const geom = {\n    type: \"MultiPolygon\",\n    coordinates\n  };\n  return feature(geom, properties, options);\n}\nfunction geometryCollection(geometries, properties, options = {}) {\n  const geom = {\n    type: \"GeometryCollection\",\n    geometries\n  };\n  return feature(geom, properties, options);\n}\nfunction round(num, precision = 0) {\n  if (precision && !(precision >= 0)) {\n    throw new Error(\"precision must be a positive number\");\n  }\n  const multiplier = Math.pow(10, precision || 0);\n  return Math.round(num * multiplier) / multiplier;\n}\nfunction radiansToLength(radians, units = \"kilometers\") {\n  const factor = factors[units];\n  if (!factor) {\n    throw new Error(units + \" units is invalid\");\n  }\n  return radians * factor;\n}\nfunction lengthToRadians(distance, units = \"kilometers\") {\n  const factor = factors[units];\n  if (!factor) {\n    throw new Error(units + \" units is invalid\");\n  }\n  return distance / factor;\n}\nfunction lengthToDegrees(distance, units) {\n  return radiansToDegrees(lengthToRadians(distance, units));\n}\nfunction bearingToAzimuth(bearing) {\n  let angle = bearing % 360;\n  if (angle < 0) {\n    angle += 360;\n  }\n  return angle;\n}\nfunction azimuthToBearing(angle) {\n  angle = angle % 360;\n  if (angle > 180) {\n    return angle - 360;\n  } else if (angle < -180) {\n    return angle + 360;\n  }\n  return angle;\n}\nfunction radiansToDegrees(radians) {\n  const normalisedRadians = radians % (2 * Math.PI);\n  return normalisedRadians * 180 / Math.PI;\n}\nfunction degreesToRadians(degrees) {\n  const normalisedDegrees = degrees % 360;\n  return normalisedDegrees * Math.PI / 180;\n}\nfunction convertLength(length, originalUnit = \"kilometers\", finalUnit = \"kilometers\") {\n  if (!(length >= 0)) {\n    throw new Error(\"length must be a positive number\");\n  }\n  return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\nfunction convertArea(area, originalUnit = \"meters\", finalUnit = \"kilometers\") {\n  if (!(area >= 0)) {\n    throw new Error(\"area must be a positive number\");\n  }\n  const startFactor = areaFactors[originalUnit];\n  if (!startFactor) {\n    throw new Error(\"invalid original units\");\n  }\n  const finalFactor = areaFactors[finalUnit];\n  if (!finalFactor) {\n    throw new Error(\"invalid final units\");\n  }\n  return area / startFactor * finalFactor;\n}\nfunction isNumber(num) {\n  return !isNaN(num) && num !== null && !Array.isArray(num);\n}\nfunction isObject(input) {\n  return input !== null && typeof input === \"object\" && !Array.isArray(input);\n}\nfunction validateBBox(bbox) {\n  if (!bbox) {\n    throw new Error(\"bbox is required\");\n  }\n  if (!Array.isArray(bbox)) {\n    throw new Error(\"bbox must be an Array\");\n  }\n  if (bbox.length !== 4 && bbox.length !== 6) {\n    throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n  }\n  bbox.forEach(num => {\n    if (!isNumber(num)) {\n      throw new Error(\"bbox must only contain numbers\");\n    }\n  });\n}\nfunction validateId(id) {\n  if (!id) {\n    throw new Error(\"id is required\");\n  }\n  if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n    throw new Error(\"id must be a number or a string\");\n  }\n}\nexport { areaFactors, azimuthToBearing, bearingToAzimuth, convertArea, convertLength, degreesToRadians, earthRadius, factors, feature, featureCollection, geometry, geometryCollection, isNumber, isObject, lengthToDegrees, lengthToRadians, lineString, lineStrings, multiLineString, multiPoint, multiPolygon, point, points, polygon, polygons, radiansToDegrees, radiansToLength, round, validateBBox, validateId };","map":{"version":3,"names":["earthRadius","factors","centimeters","centimetres","degrees","Math","PI","feet","inches","kilometers","kilometres","meters","metres","miles","millimeters","millimetres","nauticalmiles","radians","yards","areaFactors","acres","hectares","feature","geom","properties","options","feat","type","id","bbox","geometry","coordinates","_options","point","lineString","polygon","multiPoint","multiLineString","multiPolygon","Error","Array","isArray","length","isNumber","points","featureCollection","map","coords","ring","j","polygons","lineStrings","features","fc","geometryCollection","geometries","round","num","precision","multiplier","pow","radiansToLength","units","factor","lengthToRadians","distance","lengthToDegrees","radiansToDegrees","bearingToAzimuth","bearing","angle","azimuthToBearing","normalisedRadians","degreesToRadians","normalisedDegrees","convertLength","originalUnit","finalUnit","convertArea","area","startFactor","finalFactor","isNaN","isObject","input","validateBBox","forEach","validateId","indexOf"],"sources":["/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/helpers/index.ts"],"sourcesContent":["import {\n  BBox,\n  Feature,\n  FeatureCollection,\n  Geometry,\n  GeometryCollection,\n  GeometryObject,\n  LineString,\n  MultiLineString,\n  MultiPoint,\n  MultiPolygon,\n  Point,\n  Polygon,\n  Position,\n  GeoJsonProperties,\n} from \"geojson\";\n\nimport { Id } from \"./lib/geojson.js\";\nexport * from \"./lib/geojson.js\";\n\n/**\n * @module helpers\n */\n\n// TurfJS Combined Types\nexport type Coord = Feature<Point> | Point | Position;\n\n/**\n * Linear measurement units.\n *\n * ⚠️ Warning. Be aware of the implications of using radian or degree units to\n * measure distance. The distance represented by a degree of longitude *varies*\n * depending on latitude.\n *\n * See https://www.thoughtco.com/degree-of-latitude-and-longitude-distance-4070616\n * for an illustration of this behaviour.\n *\n * @typedef\n */\nexport type Units =\n  | \"meters\"\n  | \"metres\"\n  | \"millimeters\"\n  | \"millimetres\"\n  | \"centimeters\"\n  | \"centimetres\"\n  | \"kilometers\"\n  | \"kilometres\"\n  | \"miles\"\n  | \"nauticalmiles\"\n  | \"inches\"\n  | \"yards\"\n  | \"feet\"\n  | \"radians\"\n  | \"degrees\";\n\n/**\n * Area measurement units.\n *\n * @typedef\n */\nexport type AreaUnits =\n  | Exclude<Units, \"radians\" | \"degrees\">\n  | \"acres\"\n  | \"hectares\";\n\n/**\n * Grid types.\n *\n * @typedef\n */\nexport type Grid = \"point\" | \"square\" | \"hex\" | \"triangle\";\n\n/**\n * Shorthand corner identifiers.\n *\n * @typedef\n */\nexport type Corners = \"sw\" | \"se\" | \"nw\" | \"ne\" | \"center\" | \"centroid\";\n\n/**\n * Geometries made up of lines i.e. lines and polygons.\n *\n * @typedef\n */\nexport type Lines = LineString | MultiLineString | Polygon | MultiPolygon;\n\n/**\n * Convenience type for all possible GeoJSON.\n *\n * @typedef\n */\nexport type AllGeoJSON =\n  | Feature\n  | FeatureCollection\n  | Geometry\n  | GeometryCollection;\n\n/**\n * The Earth radius in kilometers. Used by Turf modules that model the Earth as a sphere. The {@link https://en.wikipedia.org/wiki/Earth_radius#Arithmetic_mean_radius mean radius} was selected because it is {@link https://rosettacode.org/wiki/Haversine_formula#:~:text=This%20value%20is%20recommended recommended } by the Haversine formula (used by turf/distance) to reduce error.\n *\n * @constant\n */\nexport const earthRadius = 6371008.8;\n\n/**\n * Unit of measurement factors based on earthRadius.\n *\n * Keys are the name of the unit, values are the number of that unit in a single radian\n *\n * @constant\n */\nexport const factors: Record<Units, number> = {\n  centimeters: earthRadius * 100,\n  centimetres: earthRadius * 100,\n  degrees: 360 / (2 * Math.PI),\n  feet: earthRadius * 3.28084,\n  inches: earthRadius * 39.37,\n  kilometers: earthRadius / 1000,\n  kilometres: earthRadius / 1000,\n  meters: earthRadius,\n  metres: earthRadius,\n  miles: earthRadius / 1609.344,\n  millimeters: earthRadius * 1000,\n  millimetres: earthRadius * 1000,\n  nauticalmiles: earthRadius / 1852,\n  radians: 1,\n  yards: earthRadius * 1.0936,\n};\n\n/**\n\n * Area of measurement factors based on 1 square meter.\n *\n * @constant\n */\nexport const areaFactors: Record<AreaUnits, number> = {\n  acres: 0.000247105,\n  centimeters: 10000,\n  centimetres: 10000,\n  feet: 10.763910417,\n  hectares: 0.0001,\n  inches: 1550.003100006,\n  kilometers: 0.000001,\n  kilometres: 0.000001,\n  meters: 1,\n  metres: 1,\n  miles: 3.86e-7,\n  nauticalmiles: 2.9155334959812285e-7,\n  millimeters: 1000000,\n  millimetres: 1000000,\n  yards: 1.195990046,\n};\n\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @function\n * @param {GeometryObject} geometry input geometry\n * @param {GeoJsonProperties} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {BBox} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {Id} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryObject, GeoJsonProperties>} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nexport function feature<\n  G extends GeometryObject = Geometry,\n  P extends GeoJsonProperties = GeoJsonProperties,\n>(\n  geom: G | null,\n  properties?: P,\n  options: { bbox?: BBox; id?: Id } = {}\n): Feature<G, P> {\n  const feat: any = { type: \"Feature\" };\n  if (options.id === 0 || options.id) {\n    feat.id = options.id;\n  }\n  if (options.bbox) {\n    feat.bbox = options.bbox;\n  }\n  feat.properties = properties || {};\n  feat.geometry = geom;\n  return feat;\n}\n\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @function\n * @param {(\"Point\" | \"LineString\" | \"Polygon\" | \"MultiPoint\" | \"MultiLineString\" | \"MultiPolygon\")} type Geometry Type\n * @param {Array<any>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = \"Point\";\n * var coordinates = [110, 50];\n * var geometry = turf.geometry(type, coordinates);\n * // => geometry\n */\nexport function geometry(\n  type:\n    | \"Point\"\n    | \"LineString\"\n    | \"Polygon\"\n    | \"MultiPoint\"\n    | \"MultiLineString\"\n    | \"MultiPolygon\",\n  coordinates: any[],\n  _options: Record<string, never> = {}\n) {\n  switch (type) {\n    case \"Point\":\n      return point(coordinates).geometry;\n    case \"LineString\":\n      return lineString(coordinates).geometry;\n    case \"Polygon\":\n      return polygon(coordinates).geometry;\n    case \"MultiPoint\":\n      return multiPoint(coordinates).geometry;\n    case \"MultiLineString\":\n      return multiLineString(coordinates).geometry;\n    case \"MultiPolygon\":\n      return multiPolygon(coordinates).geometry;\n    default:\n      throw new Error(type + \" is invalid\");\n  }\n}\n\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @function\n * @param {Position} coordinates longitude, latitude position (each in decimal degrees)\n * @param {GeoJsonProperties} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {BBox} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {Id} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point, GeoJsonProperties>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nexport function point<P extends GeoJsonProperties = GeoJsonProperties>(\n  coordinates: Position,\n  properties?: P,\n  options: { bbox?: BBox; id?: Id } = {}\n): Feature<Point, P> {\n  if (!coordinates) {\n    throw new Error(\"coordinates is required\");\n  }\n  if (!Array.isArray(coordinates)) {\n    throw new Error(\"coordinates must be an Array\");\n  }\n  if (coordinates.length < 2) {\n    throw new Error(\"coordinates must be at least 2 numbers long\");\n  }\n  if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {\n    throw new Error(\"coordinates must contain numbers\");\n  }\n\n  const geom: Point = {\n    type: \"Point\",\n    coordinates,\n  };\n  return feature(geom, properties, options);\n}\n\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @function\n * @param {Position[]} coordinates an array of Points\n * @param {GeoJsonProperties} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {BBox} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {Id} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nexport function points<P extends GeoJsonProperties = GeoJsonProperties>(\n  coordinates: Position[],\n  properties?: P,\n  options: { bbox?: BBox; id?: Id } = {}\n): FeatureCollection<Point, P> {\n  return featureCollection(\n    coordinates.map((coords) => {\n      return point(coords, properties);\n    }),\n    options\n  );\n}\n\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @function\n * @param {Position[][]} coordinates an array of LinearRings\n * @param {GeoJsonProperties} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {BBox} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {Id} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon, GeoJsonProperties>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nexport function polygon<P extends GeoJsonProperties = GeoJsonProperties>(\n  coordinates: Position[][],\n  properties?: P,\n  options: { bbox?: BBox; id?: Id } = {}\n): Feature<Polygon, P> {\n  for (const ring of coordinates) {\n    if (ring.length < 4) {\n      throw new Error(\n        \"Each LinearRing of a Polygon must have 4 or more Positions.\"\n      );\n    }\n\n    if (ring[ring.length - 1].length !== ring[0].length) {\n      throw new Error(\"First and last Position are not equivalent.\");\n    }\n\n    for (let j = 0; j < ring[ring.length - 1].length; j++) {\n      // Check if first point of Polygon contains two numbers\n      if (ring[ring.length - 1][j] !== ring[0][j]) {\n        throw new Error(\"First and last Position are not equivalent.\");\n      }\n    }\n  }\n  const geom: Polygon = {\n    type: \"Polygon\",\n    coordinates,\n  };\n  return feature(geom, properties, options);\n}\n\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @function\n * @param {Position[][][]} coordinates an array of Polygon coordinates\n * @param {GeoJsonProperties} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {BBox} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {Id} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon, GeoJsonProperties>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nexport function polygons<P extends GeoJsonProperties = GeoJsonProperties>(\n  coordinates: Position[][][],\n  properties?: P,\n  options: { bbox?: BBox; id?: Id } = {}\n): FeatureCollection<Polygon, P> {\n  return featureCollection(\n    coordinates.map((coords) => {\n      return polygon(coords, properties);\n    }),\n    options\n  );\n}\n\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @function\n * @param {Position[]} coordinates an array of Positions\n * @param {GeoJsonProperties} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {BBox} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {Id} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString, GeoJsonProperties>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nexport function lineString<P extends GeoJsonProperties = GeoJsonProperties>(\n  coordinates: Position[],\n  properties?: P,\n  options: { bbox?: BBox; id?: Id } = {}\n): Feature<LineString, P> {\n  if (coordinates.length < 2) {\n    throw new Error(\"coordinates must be an array of two or more positions\");\n  }\n  const geom: LineString = {\n    type: \"LineString\",\n    coordinates,\n  };\n  return feature(geom, properties, options);\n}\n\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @function\n * @param {Position[][]} coordinates an array of LinearRings\n * @param {GeoJsonProperties} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {BBox} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {Id} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString, GeoJsonProperties>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nexport function lineStrings<P extends GeoJsonProperties = GeoJsonProperties>(\n  coordinates: Position[][],\n  properties?: P,\n  options: { bbox?: BBox; id?: Id } = {}\n): FeatureCollection<LineString, P> {\n  return featureCollection(\n    coordinates.map((coords) => {\n      return lineString(coords, properties);\n    }),\n    options\n  );\n}\n\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @function\n * @param {Array<Feature<GeometryObject, GeoJsonProperties>>} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {BBox} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {Id} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection<GeometryObject, GeoJsonProperties>} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nexport function featureCollection<\n  G extends GeometryObject = Geometry,\n  P extends GeoJsonProperties = GeoJsonProperties,\n>(\n  features: Array<Feature<G, P>>,\n  options: { bbox?: BBox; id?: Id } = {}\n): FeatureCollection<G, P> {\n  const fc: any = { type: \"FeatureCollection\" };\n  if (options.id) {\n    fc.id = options.id;\n  }\n  if (options.bbox) {\n    fc.bbox = options.bbox;\n  }\n  fc.features = features;\n  return fc;\n}\n\n/**\n * Creates a {@link Feature}<{@link MultiLineString}> based on a\n * coordinate array. Properties can be added optionally.\n *\n * @function\n * @param {Position[][]} coordinates an array of LineStrings\n * @param {GeoJsonProperties} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {BBox} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {Id} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString, GeoJsonProperties>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nexport function multiLineString<\n  P extends GeoJsonProperties = GeoJsonProperties,\n>(\n  coordinates: Position[][],\n  properties?: P,\n  options: { bbox?: BBox; id?: Id } = {}\n): Feature<MultiLineString, P> {\n  const geom: MultiLineString = {\n    type: \"MultiLineString\",\n    coordinates,\n  };\n  return feature(geom, properties, options);\n}\n\n/**\n * Creates a {@link Feature}<{@link MultiPoint}> based on a\n * coordinate array. Properties can be added optionally.\n *\n * @function\n * @param {Position[]} coordinates an array of Positions\n * @param {GeoJsonProperties} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {BBox} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {Id} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint, GeoJsonProperties>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nexport function multiPoint<P extends GeoJsonProperties = GeoJsonProperties>(\n  coordinates: Position[],\n  properties?: P,\n  options: { bbox?: BBox; id?: Id } = {}\n): Feature<MultiPoint, P> {\n  const geom: MultiPoint = {\n    type: \"MultiPoint\",\n    coordinates,\n  };\n  return feature(geom, properties, options);\n}\n\n/**\n * Creates a {@link Feature}<{@link MultiPolygon}> based on a\n * coordinate array. Properties can be added optionally.\n *\n * @function\n * @param {Position[][][]} coordinates an array of Polygons\n * @param {GeoJsonProperties} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {BBox} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {Id} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon, GeoJsonProperties>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nexport function multiPolygon<P extends GeoJsonProperties = GeoJsonProperties>(\n  coordinates: Position[][][],\n  properties?: P,\n  options: { bbox?: BBox; id?: Id } = {}\n): Feature<MultiPolygon, P> {\n  const geom: MultiPolygon = {\n    type: \"MultiPolygon\",\n    coordinates,\n  };\n  return feature(geom, properties, options);\n}\n\n/**\n * Creates a Feature<GeometryCollection> based on a\n * coordinate array. Properties can be added optionally.\n *\n * @function\n * @param {Array<Point | LineString | Polygon | MultiPoint | MultiLineString | MultiPolygon>} geometries an array of GeoJSON Geometries\n * @param {GeoJsonProperties} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {BBox} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {Id} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection, GeoJsonProperties>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = turf.geometry(\"Point\", [100, 0]);\n * var line = turf.geometry(\"LineString\", [[101, 0], [102, 1]]);\n * var collection = turf.geometryCollection([pt, line]);\n *\n * // => collection\n */\nexport function geometryCollection<\n  P extends GeoJsonProperties = GeoJsonProperties,\n>(\n  geometries: Array<\n    Point | LineString | Polygon | MultiPoint | MultiLineString | MultiPolygon\n  >,\n  properties?: P,\n  options: { bbox?: BBox; id?: Id } = {}\n): Feature<GeometryCollection, P> {\n  const geom: GeometryCollection = {\n    type: \"GeometryCollection\",\n    geometries,\n  };\n  return feature(geom, properties, options);\n}\n\n/**\n * Round number to precision\n *\n * @function\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nexport function round(num: number, precision = 0): number {\n  if (precision && !(precision >= 0)) {\n    throw new Error(\"precision must be a positive number\");\n  }\n  const multiplier = Math.pow(10, precision || 0);\n  return Math.round(num * multiplier) / multiplier;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @function\n * @param {number} radians in radians across the sphere\n * @param {Units} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} distance\n */\nexport function radiansToLength(\n  radians: number,\n  units: Units = \"kilometers\"\n): number {\n  const factor = factors[units];\n  if (!factor) {\n    throw new Error(units + \" units is invalid\");\n  }\n  return radians * factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @function\n * @param {number} distance in real units\n * @param {Units} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} radians\n */\nexport function lengthToRadians(\n  distance: number,\n  units: Units = \"kilometers\"\n): number {\n  const factor = factors[units];\n  if (!factor) {\n    throw new Error(units + \" units is invalid\");\n  }\n  return distance / factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @function\n * @param {number} distance in real units\n * @param {Units} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nexport function lengthToDegrees(distance: number, units?: Units): number {\n  return radiansToDegrees(lengthToRadians(distance, units));\n}\n\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @function\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nexport function bearingToAzimuth(bearing: number): number {\n  let angle = bearing % 360;\n  if (angle < 0) {\n    angle += 360;\n  }\n  return angle;\n}\n\n/**\n * Converts any azimuth angle from the north line direction (positive clockwise)\n * and returns an angle between -180 and +180 degrees (positive clockwise), 0 being the north line\n *\n * @function\n * @param {number} angle between 0 and 360 degrees\n * @returns {number} bearing between -180 and +180 degrees\n */\nexport function azimuthToBearing(angle: number): number {\n  // Ignore full revolutions (multiples of 360)\n  angle = angle % 360;\n\n  if (angle > 180) {\n    return angle - 360;\n  } else if (angle < -180) {\n    return angle + 360;\n  }\n\n  return angle;\n}\n\n/**\n * Converts an angle in radians to degrees\n *\n * @function\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nexport function radiansToDegrees(radians: number): number {\n  // % (2 * Math.PI) radians in case someone passes value > 2π\n  const normalisedRadians = radians % (2 * Math.PI);\n  return (normalisedRadians * 180) / Math.PI;\n}\n\n/**\n * Converts an angle in degrees to radians\n *\n * @function\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nexport function degreesToRadians(degrees: number): number {\n  // % 360 degrees in case someone passes value > 360\n  const normalisedDegrees = degrees % 360;\n  return (normalisedDegrees * Math.PI) / 180;\n}\n\n/**\n * Converts a length from one unit to another.\n *\n * @function\n * @param {number} length Length to be converted\n * @param {Units} [originalUnit=\"kilometers\"] Input length unit\n * @param {Units} [finalUnit=\"kilometers\"] Returned length unit\n * @returns {number} The converted length\n */\nexport function convertLength(\n  length: number,\n  originalUnit: Units = \"kilometers\",\n  finalUnit: Units = \"kilometers\"\n): number {\n  if (!(length >= 0)) {\n    throw new Error(\"length must be a positive number\");\n  }\n  return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\n\n/**\n * Converts an area from one unit to another.\n *\n * @function\n * @param {number} area Area to be converted\n * @param {AreaUnits} [originalUnit=\"meters\"] Input area unit\n * @param {AreaUnits} [finalUnit=\"kilometers\"] Returned area unit\n * @returns {number} The converted length\n */\nexport function convertArea(\n  area: number,\n  originalUnit: AreaUnits = \"meters\",\n  finalUnit: AreaUnits = \"kilometers\"\n): number {\n  if (!(area >= 0)) {\n    throw new Error(\"area must be a positive number\");\n  }\n\n  const startFactor = areaFactors[originalUnit];\n  if (!startFactor) {\n    throw new Error(\"invalid original units\");\n  }\n\n  const finalFactor = areaFactors[finalUnit];\n  if (!finalFactor) {\n    throw new Error(\"invalid final units\");\n  }\n\n  return (area / startFactor) * finalFactor;\n}\n\n/**\n * isNumber\n *\n * @function\n * @param {any} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nexport function isNumber(num: any): boolean {\n  return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n\n/**\n * isObject\n *\n * @function\n * @param {any} input variable to validate\n * @returns {boolean} true/false, including false for Arrays and Functions\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nexport function isObject(input: any): boolean {\n  return input !== null && typeof input === \"object\" && !Array.isArray(input);\n}\n\n/**\n * Validate BBox\n *\n * @private\n * @param {any} bbox BBox to validate\n * @returns {void}\n * @throws {Error} if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nexport function validateBBox(bbox: any): void {\n  if (!bbox) {\n    throw new Error(\"bbox is required\");\n  }\n  if (!Array.isArray(bbox)) {\n    throw new Error(\"bbox must be an Array\");\n  }\n  if (bbox.length !== 4 && bbox.length !== 6) {\n    throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n  }\n  bbox.forEach((num) => {\n    if (!isNumber(num)) {\n      throw new Error(\"bbox must only contain numbers\");\n    }\n  });\n}\n\n/**\n * Validate Id\n *\n * @private\n * @param {any} id Id to validate\n * @returns {void}\n * @throws {Error} if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nexport function validateId(id: any): void {\n  if (!id) {\n    throw new Error(\"id is required\");\n  }\n  if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n    throw new Error(\"id must be a number or a string\");\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}