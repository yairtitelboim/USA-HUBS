{"ast":null,"code":"// index.ts\nimport { booleanPointInPolygon as pointInPolygon } from \"@turf/boolean-point-in-polygon\";\nimport { featureCollection, multiPoint } from \"@turf/helpers\";\nimport { geomEach, featureEach, coordEach } from \"@turf/meta\";\nfunction pointsWithinPolygon(points, polygons) {\n  const results = [];\n  featureEach(points, function (point) {\n    let contained = false;\n    if (point.geometry.type === \"Point\") {\n      geomEach(polygons, function (polygon) {\n        if (pointInPolygon(point, polygon)) {\n          contained = true;\n        }\n      });\n      if (contained) {\n        results.push(point);\n      }\n    } else if (point.geometry.type === \"MultiPoint\") {\n      var pointsWithin = [];\n      geomEach(polygons, function (polygon) {\n        coordEach(point, function (pointCoord) {\n          if (pointInPolygon(pointCoord, polygon)) {\n            contained = true;\n            pointsWithin.push(pointCoord);\n          }\n        });\n      });\n      if (contained) {\n        results.push(multiPoint(pointsWithin, point.properties));\n      }\n    } else {\n      throw new Error(\"Input geometry must be a Point or MultiPoint\");\n    }\n  });\n  return featureCollection(results);\n}\nvar turf_points_within_polygon_default = pointsWithinPolygon;\nexport { turf_points_within_polygon_default as default, pointsWithinPolygon };","map":{"version":3,"names":["booleanPointInPolygon","pointInPolygon","featureCollection","multiPoint","geomEach","featureEach","coordEach","pointsWithinPolygon","points","polygons","results","point","contained","geometry","type","polygon","push","pointsWithin","pointCoord","properties","Error","turf_points_within_polygon_default"],"sources":["/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/points-within-polygon/index.ts"],"sourcesContent":["import type {\n  Feature,\n  FeatureCollection,\n  Polygon,\n  MultiPolygon,\n  MultiPoint,\n  Point,\n  GeoJsonProperties,\n  Position,\n} from \"geojson\";\nimport { booleanPointInPolygon as pointInPolygon } from \"@turf/boolean-point-in-polygon\";\nimport { featureCollection, multiPoint } from \"@turf/helpers\";\nimport { geomEach, featureEach, coordEach } from \"@turf/meta\";\n\n/**\n * Finds {@link Points} or {@link MultiPoint} coordinate positions that fall within {@link (Multi)Polygon(s)}.\n *\n * @function\n * @param {Feature|FeatureCollection<Point|MultiPoint>} points Point(s) or MultiPoint(s) as input search\n * @param {FeatureCollection|Geometry|Feature<Polygon|MultiPolygon>} polygons (Multi)Polygon(s) to check if points are within\n * @returns {FeatureCollection<Point|MultiPoint>} Point(s) or MultiPoint(s) with positions that land within at least one polygon.  The geometry type will match what was passsed in\n * @example\n * var points = turf.points([\n *     [-46.6318, -23.5523],\n *     [-46.6246, -23.5325],\n *     [-46.6062, -23.5513],\n *     [-46.663, -23.554],\n *     [-46.643, -23.557]\n * ]);\n *\n * var searchWithin = turf.polygon([[\n *     [-46.653,-23.543],\n *     [-46.634,-23.5346],\n *     [-46.613,-23.543],\n *     [-46.614,-23.559],\n *     [-46.631,-23.567],\n *     [-46.653,-23.560],\n *     [-46.653,-23.543]\n * ]]);\n *\n * var ptsWithin = turf.pointsWithinPolygon(points, searchWithin);\n *\n * //addToMap\n * var addToMap = [points, searchWithin, ptsWithin]\n * turf.featureEach(ptsWithin, function (currentFeature) {\n *   currentFeature.properties['marker-size'] = 'large';\n *   currentFeature.properties['marker-color'] = '#000';\n * });\n */\nfunction pointsWithinPolygon<\n  G extends Polygon | MultiPolygon,\n  P extends GeoJsonProperties,\n>(\n  points:\n    | Feature<Point | MultiPoint, P>\n    | FeatureCollection<Point | MultiPoint, P>,\n  polygons: Feature<G> | FeatureCollection<G> | G\n): FeatureCollection<Point | MultiPoint, P> {\n  const results: Feature<Point | MultiPoint, P>[] = [];\n  featureEach(points, function (point) {\n    let contained = false;\n    if (point.geometry.type === \"Point\") {\n      geomEach(polygons, function (polygon) {\n        if (pointInPolygon(point as Feature<Point, P>, polygon)) {\n          contained = true;\n        }\n      });\n      if (contained) {\n        results.push(point);\n      }\n    } else if (point.geometry.type === \"MultiPoint\") {\n      var pointsWithin: Position[] = [];\n      geomEach(polygons, function (polygon) {\n        coordEach(point as Feature<MultiPoint>, function (pointCoord) {\n          if (pointInPolygon(pointCoord, polygon)) {\n            contained = true;\n            pointsWithin.push(pointCoord);\n          }\n        });\n      });\n      if (contained) {\n        results.push(\n          multiPoint(pointsWithin, point.properties) as Feature<MultiPoint, P>\n        );\n      }\n    } else {\n      throw new Error(\"Input geometry must be a Point or MultiPoint\");\n    }\n  });\n  return featureCollection(results);\n}\n\nexport { pointsWithinPolygon };\nexport default pointsWithinPolygon;\n"],"mappings":";AAUA,SAASA,qBAAA,IAAyBC,cAAA,QAAsB;AACxD,SAASC,iBAAA,EAAmBC,UAAA,QAAkB;AAC9C,SAASC,QAAA,EAAUC,WAAA,EAAaC,SAAA,QAAiB;AAqCjD,SAASC,oBAIPC,MAAA,EAGAC,QAAA,EAC0C;EAC1C,MAAMC,OAAA,GAA4C,EAAC;EACnDL,WAAA,CAAYG,MAAA,EAAQ,UAAUG,KAAA,EAAO;IACnC,IAAIC,SAAA,GAAY;IAChB,IAAID,KAAA,CAAME,QAAA,CAASC,IAAA,KAAS,SAAS;MACnCV,QAAA,CAASK,QAAA,EAAU,UAAUM,OAAA,EAAS;QACpC,IAAId,cAAA,CAAeU,KAAA,EAA4BI,OAAO,GAAG;UACvDH,SAAA,GAAY;QACd;MACF,CAAC;MACD,IAAIA,SAAA,EAAW;QACbF,OAAA,CAAQM,IAAA,CAAKL,KAAK;MACpB;IACF,WAAWA,KAAA,CAAME,QAAA,CAASC,IAAA,KAAS,cAAc;MAC/C,IAAIG,YAAA,GAA2B,EAAC;MAChCb,QAAA,CAASK,QAAA,EAAU,UAAUM,OAAA,EAAS;QACpCT,SAAA,CAAUK,KAAA,EAA8B,UAAUO,UAAA,EAAY;UAC5D,IAAIjB,cAAA,CAAeiB,UAAA,EAAYH,OAAO,GAAG;YACvCH,SAAA,GAAY;YACZK,YAAA,CAAaD,IAAA,CAAKE,UAAU;UAC9B;QACF,CAAC;MACH,CAAC;MACD,IAAIN,SAAA,EAAW;QACbF,OAAA,CAAQM,IAAA,CACNb,UAAA,CAAWc,YAAA,EAAcN,KAAA,CAAMQ,UAAU,CAC3C;MACF;IACF,OAAO;MACL,MAAM,IAAIC,KAAA,CAAM,8CAA8C;IAChE;EACF,CAAC;EACD,OAAOlB,iBAAA,CAAkBQ,OAAO;AAClC;AAGA,IAAOW,kCAAA,GAAQd,mBAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}