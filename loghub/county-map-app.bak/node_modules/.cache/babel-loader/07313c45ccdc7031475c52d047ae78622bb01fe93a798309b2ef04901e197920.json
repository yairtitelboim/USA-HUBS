{"ast":null,"code":"// index.ts\nimport { booleanIntersects as intersect } from \"@turf/boolean-intersects\";\nimport { convertLength, featureCollection, polygon } from \"@turf/helpers\";\nfunction rectangleGrid(bbox, cellWidth, cellHeight, options = {}) {\n  const results = [];\n  const west = bbox[0];\n  const south = bbox[1];\n  const east = bbox[2];\n  const north = bbox[3];\n  const bboxWidth = east - west;\n  const cellWidthDeg = convertLength(cellWidth, options.units, \"degrees\");\n  const bboxHeight = north - south;\n  const cellHeightDeg = convertLength(cellHeight, options.units, \"degrees\");\n  const columns = Math.floor(Math.abs(bboxWidth) / cellWidthDeg);\n  const rows = Math.floor(Math.abs(bboxHeight) / cellHeightDeg);\n  const deltaX = (bboxWidth - columns * cellWidthDeg) / 2;\n  const deltaY = (bboxHeight - rows * cellHeightDeg) / 2;\n  let currentX = west + deltaX;\n  for (let column = 0; column < columns; column++) {\n    let currentY = south + deltaY;\n    for (let row = 0; row < rows; row++) {\n      const cellPoly = polygon([[[currentX, currentY], [currentX, currentY + cellHeightDeg], [currentX + cellWidthDeg, currentY + cellHeightDeg], [currentX + cellWidthDeg, currentY], [currentX, currentY]]], options.properties);\n      if (options.mask) {\n        if (intersect(options.mask, cellPoly)) {\n          results.push(cellPoly);\n        }\n      } else {\n        results.push(cellPoly);\n      }\n      currentY += cellHeightDeg;\n    }\n    currentX += cellWidthDeg;\n  }\n  return featureCollection(results);\n}\nvar turf_rectangle_grid_default = rectangleGrid;\nexport { turf_rectangle_grid_default as default, rectangleGrid };","map":{"version":3,"names":["booleanIntersects","intersect","convertLength","featureCollection","polygon","rectangleGrid","bbox","cellWidth","cellHeight","options","results","west","south","east","north","bboxWidth","cellWidthDeg","units","bboxHeight","cellHeightDeg","columns","Math","floor","abs","rows","deltaX","deltaY","currentX","column","currentY","row","cellPoly","properties","mask","push","turf_rectangle_grid_default"],"sources":["/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/rectangle-grid/index.ts"],"sourcesContent":["import { booleanIntersects as intersect } from \"@turf/boolean-intersects\";\nimport {\n  BBox,\n  Feature,\n  FeatureCollection,\n  MultiPolygon,\n  Polygon,\n  GeoJsonProperties,\n} from \"geojson\";\nimport {\n  convertLength,\n  featureCollection,\n  polygon,\n  Units,\n} from \"@turf/helpers\";\n/**\n * Creates a grid of rectangular polygons with width and height consistent in degrees\n *\n * @function\n * @param {BBox} bbox extent of grid in [minX, minY, maxX, maxY] order.  If the grid does not fill the bbox perfectly, it is centered.\n * @param {number} cellWidth width of each cell, in units\n * @param {number} cellHeight height of each cell, in units\n * @param {Object} [options={}] Optional parameters\n * @param {Units} [options.units='kilometers'] the units of the cell width and height value.\n * Supports all valid Turf {@link https://github.com/Turfjs/turf/blob/master/packages/turf-helpers/README_UNITS.md Units}.\n * If you are looking for rectangles with equal width and height in linear units (e.g. kilometers) this is not the module for you.\n * The cellWidth and cellHeight is converted from units provided to degrees internally, so the width and height of resulting polygons will be consistent only in degrees.\n * @param {Feature<Polygon|MultiPolygon>} [options.mask] if passed a Polygon or MultiPolygon,\n * the grid Points will be created only inside it\n * @param {Object} [options.properties={}] passed to each point of the grid\n * @returns {FeatureCollection<Polygon>} a grid of polygons\n * @example\n * var bbox = [-95, 30 ,-85, 40];\n * var cellWidth = 50;\n * var cellHeight = 20;\n * var options = {units: 'miles'};\n *\n * var rectangleGrid = turf.rectangleGrid(bbox, cellWidth, cellHeight, options);\n *\n * //addToMap\n * var addToMap = [rectangleGrid]\n */\nfunction rectangleGrid<P extends GeoJsonProperties = GeoJsonProperties>(\n  bbox: BBox,\n  cellWidth: number,\n  cellHeight: number,\n  options: {\n    units?: Units;\n    properties?: P;\n    mask?: Feature<Polygon | MultiPolygon> | Polygon | MultiPolygon;\n  } = {}\n): FeatureCollection<Polygon, P> {\n  // Containers\n  const results = [];\n  const west = bbox[0];\n  const south = bbox[1];\n  const east = bbox[2];\n  const north = bbox[3];\n\n  const bboxWidth = east - west;\n  const cellWidthDeg = convertLength(cellWidth, options.units, \"degrees\");\n\n  const bboxHeight = north - south;\n  const cellHeightDeg = convertLength(cellHeight, options.units, \"degrees\");\n\n  const columns = Math.floor(Math.abs(bboxWidth) / cellWidthDeg);\n  const rows = Math.floor(Math.abs(bboxHeight) / cellHeightDeg);\n\n  // if the grid does not fill the bbox perfectly, center it.\n  const deltaX = (bboxWidth - columns * cellWidthDeg) / 2;\n  const deltaY = (bboxHeight - rows * cellHeightDeg) / 2;\n\n  // iterate over columns & rows\n  let currentX = west + deltaX;\n  for (let column = 0; column < columns; column++) {\n    let currentY = south + deltaY;\n    for (let row = 0; row < rows; row++) {\n      const cellPoly = polygon(\n        [\n          [\n            [currentX, currentY],\n            [currentX, currentY + cellHeightDeg],\n            [currentX + cellWidthDeg, currentY + cellHeightDeg],\n            [currentX + cellWidthDeg, currentY],\n            [currentX, currentY],\n          ],\n        ],\n        options.properties\n      );\n      if (options.mask) {\n        if (intersect(options.mask, cellPoly)) {\n          results.push(cellPoly);\n        }\n      } else {\n        results.push(cellPoly);\n      }\n\n      currentY += cellHeightDeg;\n    }\n    currentX += cellWidthDeg;\n  }\n  return featureCollection(results);\n}\n\nexport { rectangleGrid };\nexport default rectangleGrid;\n"],"mappings":";AAAA,SAASA,iBAAA,IAAqBC,SAAA,QAAiB;AAS/C,SACEC,aAAA,EACAC,iBAAA,EACAC,OAAA,QAEK;AA4BP,SAASC,cACPC,IAAA,EACAC,SAAA,EACAC,UAAA,EACAC,OAAA,GAII,CAAC,GAC0B;EAE/B,MAAMC,OAAA,GAAU,EAAC;EACjB,MAAMC,IAAA,GAAOL,IAAA,CAAK,CAAC;EACnB,MAAMM,KAAA,GAAQN,IAAA,CAAK,CAAC;EACpB,MAAMO,IAAA,GAAOP,IAAA,CAAK,CAAC;EACnB,MAAMQ,KAAA,GAAQR,IAAA,CAAK,CAAC;EAEpB,MAAMS,SAAA,GAAYF,IAAA,GAAOF,IAAA;EACzB,MAAMK,YAAA,GAAed,aAAA,CAAcK,SAAA,EAAWE,OAAA,CAAQQ,KAAA,EAAO,SAAS;EAEtE,MAAMC,UAAA,GAAaJ,KAAA,GAAQF,KAAA;EAC3B,MAAMO,aAAA,GAAgBjB,aAAA,CAAcM,UAAA,EAAYC,OAAA,CAAQQ,KAAA,EAAO,SAAS;EAExE,MAAMG,OAAA,GAAUC,IAAA,CAAKC,KAAA,CAAMD,IAAA,CAAKE,GAAA,CAAIR,SAAS,IAAIC,YAAY;EAC7D,MAAMQ,IAAA,GAAOH,IAAA,CAAKC,KAAA,CAAMD,IAAA,CAAKE,GAAA,CAAIL,UAAU,IAAIC,aAAa;EAG5D,MAAMM,MAAA,IAAUV,SAAA,GAAYK,OAAA,GAAUJ,YAAA,IAAgB;EACtD,MAAMU,MAAA,IAAUR,UAAA,GAAaM,IAAA,GAAOL,aAAA,IAAiB;EAGrD,IAAIQ,QAAA,GAAWhB,IAAA,GAAOc,MAAA;EACtB,SAASG,MAAA,GAAS,GAAGA,MAAA,GAASR,OAAA,EAASQ,MAAA,IAAU;IAC/C,IAAIC,QAAA,GAAWjB,KAAA,GAAQc,MAAA;IACvB,SAASI,GAAA,GAAM,GAAGA,GAAA,GAAMN,IAAA,EAAMM,GAAA,IAAO;MACnC,MAAMC,QAAA,GAAW3B,OAAA,CACf,CACE,CACE,CAACuB,QAAA,EAAUE,QAAQ,GACnB,CAACF,QAAA,EAAUE,QAAA,GAAWV,aAAa,GACnC,CAACQ,QAAA,GAAWX,YAAA,EAAca,QAAA,GAAWV,aAAa,GAClD,CAACQ,QAAA,GAAWX,YAAA,EAAca,QAAQ,GAClC,CAACF,QAAA,EAAUE,QAAQ,EACrB,CACF,EACApB,OAAA,CAAQuB,UACV;MACA,IAAIvB,OAAA,CAAQwB,IAAA,EAAM;QAChB,IAAIhC,SAAA,CAAUQ,OAAA,CAAQwB,IAAA,EAAMF,QAAQ,GAAG;UACrCrB,OAAA,CAAQwB,IAAA,CAAKH,QAAQ;QACvB;MACF,OAAO;QACLrB,OAAA,CAAQwB,IAAA,CAAKH,QAAQ;MACvB;MAEAF,QAAA,IAAYV,aAAA;IACd;IACAQ,QAAA,IAAYX,YAAA;EACd;EACA,OAAOb,iBAAA,CAAkBO,OAAO;AAClC;AAGA,IAAOyB,2BAAA,GAAQ9B,aAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}