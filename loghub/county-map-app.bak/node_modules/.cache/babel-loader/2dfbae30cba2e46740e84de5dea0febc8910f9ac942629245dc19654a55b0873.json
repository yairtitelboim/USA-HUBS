{"ast":null,"code":"// index.ts\nimport { degreesToRadians, radiansToDegrees } from \"@turf/helpers\";\nimport { getCoord } from \"@turf/invariant\";\nfunction rhumbBearing(start, end, options = {}) {\n  let bear360;\n  if (options.final) {\n    bear360 = calculateRhumbBearing(getCoord(end), getCoord(start));\n  } else {\n    bear360 = calculateRhumbBearing(getCoord(start), getCoord(end));\n  }\n  const bear180 = bear360 > 180 ? -(360 - bear360) : bear360;\n  return bear180;\n}\nfunction calculateRhumbBearing(from, to) {\n  const phi1 = degreesToRadians(from[1]);\n  const phi2 = degreesToRadians(to[1]);\n  let deltaLambda = degreesToRadians(to[0] - from[0]);\n  if (deltaLambda > Math.PI) {\n    deltaLambda -= 2 * Math.PI;\n  }\n  if (deltaLambda < -Math.PI) {\n    deltaLambda += 2 * Math.PI;\n  }\n  const deltaPsi = Math.log(Math.tan(phi2 / 2 + Math.PI / 4) / Math.tan(phi1 / 2 + Math.PI / 4));\n  const theta = Math.atan2(deltaLambda, deltaPsi);\n  return (radiansToDegrees(theta) + 360) % 360;\n}\nvar turf_rhumb_bearing_default = rhumbBearing;\nexport { turf_rhumb_bearing_default as default, rhumbBearing };","map":{"version":3,"names":["degreesToRadians","radiansToDegrees","getCoord","rhumbBearing","start","end","options","bear360","final","calculateRhumbBearing","bear180","from","to","phi1","phi2","deltaLambda","Math","PI","deltaPsi","log","tan","theta","atan2","turf_rhumb_bearing_default"],"sources":["/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/rhumb-bearing/index.ts"],"sourcesContent":["// https://en.wikipedia.org/wiki/Rhumb_line\nimport { Coord, degreesToRadians, radiansToDegrees } from \"@turf/helpers\";\nimport { getCoord } from \"@turf/invariant\";\n\n/**\n * Takes two {@link Point|points} and finds the bearing angle between them along a Rhumb line\n * i.e. the angle measured in degrees start the north line (0 degrees)\n *\n * @function\n * @param {Coord} start starting Point\n * @param {Coord} end ending Point\n * @param {Object} [options] Optional parameters\n * @param {boolean} [options.final=false] calculates the final bearing if true\n * @returns {number} bearing from north in decimal degrees, between -180 and 180 degrees (positive clockwise)\n * @example\n * var point1 = turf.point([-75.343, 39.984], {\"marker-color\": \"#F00\"});\n * var point2 = turf.point([-75.534, 39.123], {\"marker-color\": \"#00F\"});\n *\n * var bearing = turf.rhumbBearing(point1, point2);\n *\n * //addToMap\n * var addToMap = [point1, point2];\n * point1.properties.bearing = bearing;\n * point2.properties.bearing = bearing;\n */\nfunction rhumbBearing(\n  start: Coord,\n  end: Coord,\n  options: { final?: boolean } = {}\n): number {\n  let bear360;\n  if (options.final) {\n    bear360 = calculateRhumbBearing(getCoord(end), getCoord(start));\n  } else {\n    bear360 = calculateRhumbBearing(getCoord(start), getCoord(end));\n  }\n\n  const bear180 = bear360 > 180 ? -(360 - bear360) : bear360;\n\n  return bear180;\n}\n\n/**\n * Returns the bearing from ‘this’ point to destination point along a rhumb line.\n * Adapted from Geodesy: https://github.com/chrisveness/geodesy/blob/master/latlon-spherical.js\n *\n * @private\n * @param   {Array<number>} from - origin point.\n * @param   {Array<number>} to - destination point.\n * @returns {number} Bearing in degrees from north.\n * @example\n * var p1 = new LatLon(51.127, 1.338);\n * var p2 = new LatLon(50.964, 1.853);\n * var d = p1.rhumbBearingTo(p2); // 116.7 m\n */\nfunction calculateRhumbBearing(from: number[], to: number[]) {\n  // φ => phi\n  // Δλ => deltaLambda\n  // Δψ => deltaPsi\n  // θ => theta\n  const phi1 = degreesToRadians(from[1]);\n  const phi2 = degreesToRadians(to[1]);\n  let deltaLambda = degreesToRadians(to[0] - from[0]);\n  // if deltaLambdaon over 180° take shorter rhumb line across the anti-meridian:\n  if (deltaLambda > Math.PI) {\n    deltaLambda -= 2 * Math.PI;\n  }\n  if (deltaLambda < -Math.PI) {\n    deltaLambda += 2 * Math.PI;\n  }\n\n  const deltaPsi = Math.log(\n    Math.tan(phi2 / 2 + Math.PI / 4) / Math.tan(phi1 / 2 + Math.PI / 4)\n  );\n\n  const theta = Math.atan2(deltaLambda, deltaPsi);\n\n  return (radiansToDegrees(theta) + 360) % 360;\n}\n\nexport { rhumbBearing };\nexport default rhumbBearing;\n"],"mappings":";AACA,SAAgBA,gBAAA,EAAkBC,gBAAA,QAAwB;AAC1D,SAASC,QAAA,QAAgB;AAuBzB,SAASC,aACPC,KAAA,EACAC,GAAA,EACAC,OAAA,GAA+B,CAAC,GACxB;EACR,IAAIC,OAAA;EACJ,IAAID,OAAA,CAAQE,KAAA,EAAO;IACjBD,OAAA,GAAUE,qBAAA,CAAsBP,QAAA,CAASG,GAAG,GAAGH,QAAA,CAASE,KAAK,CAAC;EAChE,OAAO;IACLG,OAAA,GAAUE,qBAAA,CAAsBP,QAAA,CAASE,KAAK,GAAGF,QAAA,CAASG,GAAG,CAAC;EAChE;EAEA,MAAMK,OAAA,GAAUH,OAAA,GAAU,MAAM,EAAE,MAAMA,OAAA,IAAWA,OAAA;EAEnD,OAAOG,OAAA;AACT;AAeA,SAASD,sBAAsBE,IAAA,EAAgBC,EAAA,EAAc;EAK3D,MAAMC,IAAA,GAAOb,gBAAA,CAAiBW,IAAA,CAAK,CAAC,CAAC;EACrC,MAAMG,IAAA,GAAOd,gBAAA,CAAiBY,EAAA,CAAG,CAAC,CAAC;EACnC,IAAIG,WAAA,GAAcf,gBAAA,CAAiBY,EAAA,CAAG,CAAC,IAAID,IAAA,CAAK,CAAC,CAAC;EAElD,IAAII,WAAA,GAAcC,IAAA,CAAKC,EAAA,EAAI;IACzBF,WAAA,IAAe,IAAIC,IAAA,CAAKC,EAAA;EAC1B;EACA,IAAIF,WAAA,GAAc,CAACC,IAAA,CAAKC,EAAA,EAAI;IAC1BF,WAAA,IAAe,IAAIC,IAAA,CAAKC,EAAA;EAC1B;EAEA,MAAMC,QAAA,GAAWF,IAAA,CAAKG,GAAA,CACpBH,IAAA,CAAKI,GAAA,CAAIN,IAAA,GAAO,IAAIE,IAAA,CAAKC,EAAA,GAAK,CAAC,IAAID,IAAA,CAAKI,GAAA,CAAIP,IAAA,GAAO,IAAIG,IAAA,CAAKC,EAAA,GAAK,CAAC,CACpE;EAEA,MAAMI,KAAA,GAAQL,IAAA,CAAKM,KAAA,CAAMP,WAAA,EAAaG,QAAQ;EAE9C,QAAQjB,gBAAA,CAAiBoB,KAAK,IAAI,OAAO;AAC3C;AAGA,IAAOE,0BAAA,GAAQpB,YAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}