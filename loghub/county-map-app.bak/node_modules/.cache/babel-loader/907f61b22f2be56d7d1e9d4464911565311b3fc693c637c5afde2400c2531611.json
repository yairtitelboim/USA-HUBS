{"ast":null,"code":"// index.js\nimport { getCoords, getType } from \"@turf/invariant\";\nimport { lineString as linestring } from \"@turf/helpers\";\nimport { nearestPointOnLine } from \"@turf/nearest-point-on-line\";\nfunction lineSlice(startPt, stopPt, line) {\n  var coords = getCoords(line);\n  if (getType(line) !== \"LineString\") throw new Error(\"line must be a LineString\");\n  var startVertex = nearestPointOnLine(line, startPt);\n  var stopVertex = nearestPointOnLine(line, stopPt);\n  var ends;\n  if (startVertex.properties.index <= stopVertex.properties.index) {\n    ends = [startVertex, stopVertex];\n  } else {\n    ends = [stopVertex, startVertex];\n  }\n  var clipCoords = [ends[0].geometry.coordinates];\n  for (var i = ends[0].properties.index + 1; i < ends[1].properties.index + 1; i++) {\n    clipCoords.push(coords[i]);\n  }\n  clipCoords.push(ends[1].geometry.coordinates);\n  return linestring(clipCoords, line.properties);\n}\nvar turf_line_slice_default = lineSlice;\nexport { turf_line_slice_default as default, lineSlice };","map":{"version":3,"names":["getCoords","getType","lineString","linestring","nearestPointOnLine","lineSlice","startPt","stopPt","line","coords","Error","startVertex","stopVertex","ends","properties","index","clipCoords","geometry","coordinates","i","push","turf_line_slice_default"],"sources":["/Users/yairtitelboim/Documents/Kernel/ALLAPPS/LOGhub/loghub/county-map-app/node_modules/@turf/line-slice/index.js"],"sourcesContent":["import { getCoords, getType } from \"@turf/invariant\";\nimport { lineString as linestring } from \"@turf/helpers\";\nimport { nearestPointOnLine } from \"@turf/nearest-point-on-line\";\n\n/**\n * Takes a {@link LineString|line}, a start {@link Point}, and a stop point\n * and returns a subsection of the line in-between those points.\n * The start & stop points don't need to fall exactly on the line.\n *\n * This can be useful for extracting only the part of a route between waypoints.\n *\n * @function\n * @param {Coord} startPt starting point\n * @param {Coord} stopPt stopping point\n * @param {Feature<LineString>|LineString} line line to slice\n * @returns {Feature<LineString>} sliced line\n * @example\n * var line = turf.lineString([\n *     [-77.031669, 38.878605],\n *     [-77.029609, 38.881946],\n *     [-77.020339, 38.884084],\n *     [-77.025661, 38.885821],\n *     [-77.021884, 38.889563],\n *     [-77.019824, 38.892368]\n * ]);\n * var start = turf.point([-77.029609, 38.881946]);\n * var stop = turf.point([-77.021884, 38.889563]);\n *\n * var sliced = turf.lineSlice(start, stop, line);\n *\n * //addToMap\n * var addToMap = [start, stop, line]\n */\nfunction lineSlice(startPt, stopPt, line) {\n  // Validation\n  var coords = getCoords(line);\n  if (getType(line) !== \"LineString\")\n    throw new Error(\"line must be a LineString\");\n\n  var startVertex = nearestPointOnLine(line, startPt);\n  var stopVertex = nearestPointOnLine(line, stopPt);\n  var ends;\n  if (startVertex.properties.index <= stopVertex.properties.index) {\n    ends = [startVertex, stopVertex];\n  } else {\n    ends = [stopVertex, startVertex];\n  }\n  var clipCoords = [ends[0].geometry.coordinates];\n  for (\n    var i = ends[0].properties.index + 1;\n    i < ends[1].properties.index + 1;\n    i++\n  ) {\n    clipCoords.push(coords[i]);\n  }\n  clipCoords.push(ends[1].geometry.coordinates);\n  return linestring(clipCoords, line.properties);\n}\n\nexport { lineSlice };\nexport default lineSlice;\n"],"mappings":";AAAA,SAASA,SAAA,EAAWC,OAAA,QAAe;AACnC,SAASC,UAAA,IAAcC,UAAA,QAAkB;AACzC,SAASC,kBAAA,QAA0B;AA+BnC,SAASC,UAAUC,OAAA,EAASC,MAAA,EAAQC,IAAA,EAAM;EAExC,IAAIC,MAAA,GAAST,SAAA,CAAUQ,IAAI;EAC3B,IAAIP,OAAA,CAAQO,IAAI,MAAM,cACpB,MAAM,IAAIE,KAAA,CAAM,2BAA2B;EAE7C,IAAIC,WAAA,GAAcP,kBAAA,CAAmBI,IAAA,EAAMF,OAAO;EAClD,IAAIM,UAAA,GAAaR,kBAAA,CAAmBI,IAAA,EAAMD,MAAM;EAChD,IAAIM,IAAA;EACJ,IAAIF,WAAA,CAAYG,UAAA,CAAWC,KAAA,IAASH,UAAA,CAAWE,UAAA,CAAWC,KAAA,EAAO;IAC/DF,IAAA,GAAO,CAACF,WAAA,EAAaC,UAAU;EACjC,OAAO;IACLC,IAAA,GAAO,CAACD,UAAA,EAAYD,WAAW;EACjC;EACA,IAAIK,UAAA,GAAa,CAACH,IAAA,CAAK,CAAC,EAAEI,QAAA,CAASC,WAAW;EAC9C,SACMC,CAAA,GAAIN,IAAA,CAAK,CAAC,EAAEC,UAAA,CAAWC,KAAA,GAAQ,GACnCI,CAAA,GAAIN,IAAA,CAAK,CAAC,EAAEC,UAAA,CAAWC,KAAA,GAAQ,GAC/BI,CAAA,IACA;IACAH,UAAA,CAAWI,IAAA,CAAKX,MAAA,CAAOU,CAAC,CAAC;EAC3B;EACAH,UAAA,CAAWI,IAAA,CAAKP,IAAA,CAAK,CAAC,EAAEI,QAAA,CAASC,WAAW;EAC5C,OAAOf,UAAA,CAAWa,UAAA,EAAYR,IAAA,CAAKM,UAAU;AAC/C;AAGA,IAAOO,uBAAA,GAAQhB,SAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}